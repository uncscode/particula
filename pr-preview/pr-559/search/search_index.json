{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Particula","text":"<p>Particula is a Python-based aerosol particle simulator.</p> <p>Our goal is to provide a robust aerosol simulation (including both gas and particle phases) that can be used to answer scientific questions arising from experiments and research ideas.</p>"},{"location":"#pypi-installation","title":"PyPI Installation","text":"<p>If your Python environment is already set up, you can install <code>Particula</code> via pip using the following command:</p> <pre><code>pip install particula\n</code></pre> <p>Setup Particula How to Guides Tutorials API Reference</p>"},{"location":"#contributing-to-particula","title":"Contributing to <code>Particula</code>","text":"<p>We are open to and we welcome contributions from anyone who wants to contribute to this project. We have a short contributing document in the root of the repository, which you can read. However, feel free to reach out with any questions or comments!</p>"},{"location":"#citation","title":"Citation","text":"<p>Particula [Computer software]. https://doi.org/10.5281/zenodo.6634653</p>"},{"location":"API/","title":"Particula Index","text":"<p>Auto-generated documentation index.</p> <p>A full list of Particula project modules.</p> <ul> <li>Particula<ul> <li>Abc Builder</li> <li>Abc Factory</li> <li>Activity<ul> <li>Activity Coefficients</li> <li>Bat Blending</li> <li>Bat Coefficients</li> <li>Convert Functional Group</li> <li>Gibbs</li> <li>Gibbs Mixing</li> <li>Phase Separation</li> <li>Ratio</li> <li>Species Density</li> <li>Water Activity</li> </ul> </li> <li>Aerosol</li> <li>Builder Mixin</li> <li>Dynamics<ul> <li>Coagulation<ul> <li>Brownian Kernel</li> <li>Kernel</li> <li>Particle Resolved Method</li> <li>Rate</li> <li>Strategy</li> <li>Super Droplet Method</li> <li>Transition Regime</li> </ul> </li> <li>Condensation<ul> <li>Condensation Strategies</li> <li>Mass Transfer</li> </ul> </li> <li>Dilution</li> <li>Particle Process</li> <li>Properties<ul> <li>Wall Loss Coefficient</li> </ul> </li> <li>Wall Loss</li> </ul> </li> <li>Equilibria<ul> <li>Partitioning</li> </ul> </li> <li>Gas<ul> <li>Atmosphere</li> <li>Atmosphere Builders</li> <li>Properties<ul> <li>Concentration Function</li> <li>Dynamic Viscosity</li> <li>Mean Free Path</li> <li>Pressure Function</li> <li>Thermal Conductivity</li> <li>Vapor Pressure Module</li> </ul> </li> <li>Species</li> <li>Species Builders</li> <li>Species Factories</li> <li>Vapor Pressure Builders</li> <li>Vapor Pressure Factories</li> <li>Vapor Pressure Strategies</li> </ul> </li> <li>Logger Setup</li> <li>Particles<ul> <li>Activity Builders</li> <li>Activity Factories</li> <li>Activity Strategies</li> <li>Distribution Builders</li> <li>Distribution Factories</li> <li>Distribution Strategies</li> <li>Properties<ul> <li>Activity Module</li> <li>Aerodynamic Mobility Module</li> <li>Aerodynamic Size</li> <li>Collision Radius Module</li> <li>Coulomb Enhancement</li> <li>Diffusion Coefficient</li> <li>Diffusive Knudsen Module</li> <li>Friction Factor Module</li> <li>Kelvin Effect Module</li> <li>Knudsen Number Module</li> <li>Lognormal Size Distribution</li> <li>Mean Thermal Speed Module</li> <li>Partial Pressure Module</li> <li>Settling Velocity</li> <li>Slip Correction Module</li> <li>Special Functions</li> <li>Vapor Correction Module</li> </ul> </li> <li>Representation</li> <li>Representation Builders</li> <li>Representation Factories</li> <li>Surface Builders</li> <li>Surface Factories</li> <li>Surface Strategies</li> </ul> </li> <li>Runnable</li> <li>Util<ul> <li>Colors</li> <li>Constants</li> <li>Convert</li> <li>Converting<ul> <li>Convert Mass Concentration</li> </ul> </li> <li>Lf2013 Coagulation<ul> <li>Src Lf2013 Coagulation</li> </ul> </li> <li>Machine Limit</li> <li>Reduced Quantity</li> <li>Size Distribution Convert</li> <li>Surface Tension</li> <li>Validate Inputs</li> </ul> </li> </ul> </li> </ul>"},{"location":"API/particula/","title":"Particula","text":"<p>Particula Index / Particula</p> <p>Auto-generated documentation for particula module.</p>"},{"location":"API/particula/#attributes","title":"Attributes","text":"<ul> <li><code>logger</code> - setup the logger: setup()</li> </ul>"},{"location":"API/particula/#modules","title":"Modules","text":"<ul> <li>Abc Builder</li> <li>Abc Factory</li> <li>Activity</li> <li>Aerosol</li> <li>Builder Mixin</li> <li>Dynamics</li> <li>Equilibria</li> <li>Gas</li> <li>Logger Setup</li> <li>Particles</li> <li>Runnable</li> <li>Util</li> </ul>"},{"location":"API/particula/abc_builder/","title":"Abc Builder","text":"<p>Particula Index / Particula / Abc Builder</p> <p>Auto-generated documentation for particula.abc_builder module.</p>"},{"location":"API/particula/abc_builder/#builderabc","title":"BuilderABC","text":"<p>Show source in abc_builder.py:15</p> <p>Abstract base class for builders with common methods to check keys and set parameters from a dictionary.</p>"},{"location":"API/particula/abc_builder/#arguments","title":"Arguments","text":"<ul> <li>required_parameters : List of required parameters for the builder.</li> </ul>"},{"location":"API/particula/abc_builder/#raises","title":"Raises","text":"<ul> <li>ValueError : If any required key is missing during check_keys or     pre_build_check, or if trying to set an invalid parameter.</li> <li>Warning : If using default units for any parameter.</li> </ul>"},{"location":"API/particula/abc_builder/#references","title":"References","text":"<ul> <li>Builder Pattern : https://refactoring.guru/design-patterns/builder</li> </ul>"},{"location":"API/particula/abc_builder/#signature","title":"Signature","text":"<pre><code>class BuilderABC(ABC):\n    def __init__(self, required_parameters: Optional[list[str]] = None): ...\n</code></pre>"},{"location":"API/particula/abc_builder/#builderabcbuild","title":"BuilderABC().build","text":"<p>Show source in abc_builder.py:138</p> <p>Build and return the strategy object with the set parameters.</p>"},{"location":"API/particula/abc_builder/#returns","title":"Returns","text":"<ul> <li>strategy : The built strategy object.</li> </ul>"},{"location":"API/particula/abc_builder/#examples","title":"Examples","text":"<pre><code>builder = Builder()\nstrategy = builder.build()\n</code></pre>"},{"location":"API/particula/abc_builder/#signature_1","title":"Signature","text":"<pre><code>@abstractmethod\ndef build(self) -&gt; Any: ...\n</code></pre>"},{"location":"API/particula/abc_builder/#builderabccheck_keys","title":"BuilderABC().check_keys","text":"<p>Show source in abc_builder.py:34</p> <p>Check if the keys are present and valid.</p>"},{"location":"API/particula/abc_builder/#arguments_1","title":"Arguments","text":"<ul> <li>parameters : The parameters dictionary to check.</li> </ul>"},{"location":"API/particula/abc_builder/#raises_1","title":"Raises","text":"<ul> <li>ValueError : If any required key is missing or if trying to set     an invalid parameter.</li> </ul>"},{"location":"API/particula/abc_builder/#examples_1","title":"Examples","text":"<pre><code>builder = Builder()\nbuilder.check_keys({\n    \"parameter1\": 1,\n    \"parameter2\": 2,\n})\n</code></pre>"},{"location":"API/particula/abc_builder/#signature_2","title":"Signature","text":"<pre><code>def check_keys(self, parameters: dict[str, Any]): ...\n</code></pre>"},{"location":"API/particula/abc_builder/#builderabcpre_build_check","title":"BuilderABC().pre_build_check","text":"<p>Show source in abc_builder.py:117</p> <p>Check if all required attribute parameters are set before building.</p>"},{"location":"API/particula/abc_builder/#raises_2","title":"Raises","text":"<ul> <li>ValueError : If any required parameter is missing.</li> </ul>"},{"location":"API/particula/abc_builder/#examples_2","title":"Examples","text":"<pre><code>builder = Builder()\nbuilder.pre_build_check()\n</code></pre>"},{"location":"API/particula/abc_builder/#signature_3","title":"Signature","text":"<pre><code>def pre_build_check(self): ...\n</code></pre>"},{"location":"API/particula/abc_builder/#builderabcset_parameters","title":"BuilderABC().set_parameters","text":"<p>Show source in abc_builder.py:80</p> <p>Set parameters from a dictionary including optional suffix for units as '_units'.</p>"},{"location":"API/particula/abc_builder/#arguments_2","title":"Arguments","text":"<ul> <li>parameters : The parameters dictionary to set.</li> </ul>"},{"location":"API/particula/abc_builder/#returns_1","title":"Returns","text":"<ul> <li>The builder object with the set parameters.</li> </ul>"},{"location":"API/particula/abc_builder/#raises_3","title":"Raises","text":"<ul> <li>ValueError : If any required key is missing.</li> <li>Warning : If using default units for any parameter.</li> </ul>"},{"location":"API/particula/abc_builder/#examples_3","title":"Examples","text":"<pre><code>builder = Builder().set_parameters({\n    \"parameter1\": 1,\n    \"parameter2\": 2,\n    \"parameter2_units\": \"K\",\n})\n</code></pre>"},{"location":"API/particula/abc_builder/#signature_4","title":"Signature","text":"<pre><code>def set_parameters(self, parameters: dict[str, Any]): ...\n</code></pre>"},{"location":"API/particula/abc_factory/","title":"Abc Factory","text":"<p>Particula Index / Particula / Abc Factory</p> <p>Auto-generated documentation for particula.abc_factory module.</p>"},{"location":"API/particula/abc_factory/#attributes","title":"Attributes","text":"<ul> <li><code>BuilderT</code> - Define a generic type variable for the strategy type, to get good type hints: TypeVar('BuilderT')</li> </ul>"},{"location":"API/particula/abc_factory/#strategyfactory","title":"StrategyFactory","text":"<p>Show source in abc_factory.py:16</p> <p>Abstract base class for strategy factories.</p>"},{"location":"API/particula/abc_factory/#signature","title":"Signature","text":"<pre><code>class StrategyFactory(ABC, Generic[BuilderT, StrategyT]): ...\n</code></pre>"},{"location":"API/particula/abc_factory/#see-also","title":"See also","text":"<ul> <li>BuilderT</li> <li>StrategyT</li> </ul>"},{"location":"API/particula/abc_factory/#strategyfactoryget_builders","title":"StrategyFactory().get_builders","text":"<p>Show source in abc_factory.py:21</p> <p>Returns the mapping of key names to builders.</p>"},{"location":"API/particula/abc_factory/#signature_1","title":"Signature","text":"<pre><code>@abstractmethod\ndef get_builders(self) -&gt; Dict[str, BuilderT]: ...\n</code></pre>"},{"location":"API/particula/abc_factory/#see-also_1","title":"See also","text":"<ul> <li>BuilderT</li> </ul>"},{"location":"API/particula/abc_factory/#strategyfactoryget_strategy","title":"StrategyFactory().get_strategy","text":"<p>Show source in abc_factory.py:27</p> <p>Generic factory method to create objects instances.</p>"},{"location":"API/particula/abc_factory/#returns","title":"Returns","text":"<p>An object, built from selected builder with parameters.</p>"},{"location":"API/particula/abc_factory/#raises","title":"Raises","text":"<ul> <li>ValueError : If an unknown key is provided.</li> <li>ValueError : If any required parameter is missing during     check_keys or pre_build_check, or if trying to set an     invalid parameter.</li> </ul>"},{"location":"API/particula/abc_factory/#signature_2","title":"Signature","text":"<pre><code>def get_strategy(\n    self, strategy_type: str, parameters: Optional[Dict[str, Any]] = None\n) -&gt; StrategyT: ...\n</code></pre>"},{"location":"API/particula/abc_factory/#see-also_2","title":"See also","text":"<ul> <li>StrategyT</li> </ul>"},{"location":"API/particula/aerosol/","title":"Aerosol","text":"<p>Particula Index / Particula / Aerosol</p> <p>Auto-generated documentation for particula.aerosol module.</p>"},{"location":"API/particula/aerosol/#aerosol_1","title":"Aerosol","text":"<p>Show source in aerosol.py:14</p> <p>Collection of Gas and Particle objects.</p> <p>A class for interacting with collections of Gas and Particle objects. Allows for the representation and manipulation of an aerosol, which is composed of various gases and particles.</p>"},{"location":"API/particula/aerosol/#attributes","title":"Attributes","text":"<ul> <li>atmosphere : The atmosphere containing the gases.</li> <li>particles : A list of particles in the aerosol.</li> </ul>"},{"location":"API/particula/aerosol/#methods","title":"Methods","text":"<ul> <li>iterate_gas : Returns an iterator for atmosphere species.</li> <li>iterate_particle : Returns an iterator for particle.</li> <li>replace_atmosphere : Replaces the current Atmosphere instance     with a new one.</li> <li>add_particle : Adds a Particle instance to the aerosol.</li> </ul>"},{"location":"API/particula/aerosol/#examples","title":"Examples","text":"Creating an Aerosol<pre><code>aerosol_instance = Aerosol(atmosphere, particles)\nprint(aerosol_instance)\n</code></pre> Iterating over the Aerosol<pre><code>aerosol_instance = Aerosol(atmosphere, particles)\nfor gas in aerosol_instance.iterate_gas():\n    print(gas)\nfor particle in aerosol_instance.iterate_particle():\n    print(particle)\n</code></pre>"},{"location":"API/particula/aerosol/#signature","title":"Signature","text":"<pre><code>class Aerosol:\n    def __init__(\n        self,\n        atmosphere: Atmosphere,\n        particles: Union[ParticleRepresentation, List[ParticleRepresentation]],\n    ): ...\n</code></pre>"},{"location":"API/particula/aerosol/#see-also","title":"See also","text":"<ul> <li>Atmosphere</li> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/aerosol/#aerosolstr","title":"Aerosol().str","text":"<p>Show source in aerosol.py:64</p> <p>Returns a string representation of the aerosol.</p>"},{"location":"API/particula/aerosol/#returns","title":"Returns","text":"<ul> <li>str : A string representation of the aerosol.</li> </ul>"},{"location":"API/particula/aerosol/#examples_1","title":"Examples","text":"<pre><code>aerosol_instance = Aerosol(atmosphere, particles)\nprint(aerosol_instance)\n</code></pre>"},{"location":"API/particula/aerosol/#signature_1","title":"Signature","text":"<pre><code>def __str__(self) -&gt; str: ...\n</code></pre>"},{"location":"API/particula/aerosol/#aerosoladd_particle","title":"Aerosol().add_particle","text":"<p>Show source in aerosol.py:127</p> <p>Adds a Particle instance to the aerosol.</p>"},{"location":"API/particula/aerosol/#arguments","title":"Arguments","text":"<ul> <li>particle : The Particle instance to add.</li> </ul>"},{"location":"API/particula/aerosol/#examples_2","title":"Examples","text":"Adding a Particle to the Aerosol<pre><code>aerosol_instance = Aerosol(atmosphere, particles)\nnew_particle = ParticleRepresentation()\naerosol_instance.add_particle(new_particle)\n</code></pre>"},{"location":"API/particula/aerosol/#signature_2","title":"Signature","text":"<pre><code>def add_particle(self, particle: ParticleRepresentation): ...\n</code></pre>"},{"location":"API/particula/aerosol/#see-also_1","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/aerosol/#aerosoliterate_gas","title":"Aerosol().iterate_gas","text":"<p>Show source in aerosol.py:82</p> <p>Returns an iterator for atmosphere species.</p>"},{"location":"API/particula/aerosol/#returns_1","title":"Returns","text":"<ul> <li>Iterator : An iterator over the gas species type.</li> </ul>"},{"location":"API/particula/aerosol/#examples_3","title":"Examples","text":"Iterating over the Aerosol gas<pre><code>aerosol_instance = Aerosol(atmosphere, particles)\nfor gas in aerosol_instance.iterate_gas():\n    print(gas)\n</code></pre>"},{"location":"API/particula/aerosol/#signature_3","title":"Signature","text":"<pre><code>def iterate_gas(self) -&gt; Iterator[GasSpecies]: ...\n</code></pre>"},{"location":"API/particula/aerosol/#see-also_2","title":"See also","text":"<ul> <li>GasSpecies</li> </ul>"},{"location":"API/particula/aerosol/#aerosoliterate_particle","title":"Aerosol().iterate_particle","text":"<p>Show source in aerosol.py:97</p> <p>Returns an iterator for particle.</p>"},{"location":"API/particula/aerosol/#returns_2","title":"Returns","text":"<ul> <li>Iterator : An iterator over the particle type.</li> </ul>"},{"location":"API/particula/aerosol/#examples_4","title":"Examples","text":"Iterating over the Aerosol particle<pre><code>aerosol_instance = Aerosol(atmosphere, particles)\nfor particle in aerosol_instance.iterate_particle():\n    print(particle)\n</code></pre>"},{"location":"API/particula/aerosol/#signature_4","title":"Signature","text":"<pre><code>def iterate_particle(self) -&gt; Iterator[ParticleRepresentation]: ...\n</code></pre>"},{"location":"API/particula/aerosol/#see-also_3","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/aerosol/#aerosolreplace_atmosphere","title":"Aerosol().replace_atmosphere","text":"<p>Show source in aerosol.py:112</p> <p>Replaces the current Atmosphere instance with a new one.</p>"},{"location":"API/particula/aerosol/#arguments_1","title":"Arguments","text":"<ul> <li>atmosphere : The instance to replace the current one.</li> </ul>"},{"location":"API/particula/aerosol/#examples_5","title":"Examples","text":"Replacing the Atmosphere in the Aerosol<pre><code>aerosol_instance = Aerosol(atmosphere, particles)\nnew_atmosphere = Atmosphere()\naerosol_instance.replace_atmosphere(new_atmosphere)\n</code></pre>"},{"location":"API/particula/aerosol/#signature_5","title":"Signature","text":"<pre><code>def replace_atmosphere(self, atmosphere: Atmosphere): ...\n</code></pre>"},{"location":"API/particula/aerosol/#see-also_4","title":"See also","text":"<ul> <li>Atmosphere</li> </ul>"},{"location":"API/particula/builder_mixin/","title":"Builder Mixin","text":"<p>Particula Index / Particula / Builder Mixin</p> <p>Auto-generated documentation for particula.builder_mixin module.</p>"},{"location":"API/particula/builder_mixin/#builderchargemixin","title":"BuilderChargeMixin","text":"<p>Show source in builder_mixin.py:141</p> <p>Mixin class for Builder classes to set charge and charge_units.</p>"},{"location":"API/particula/builder_mixin/#methods","title":"Methods","text":"<ul> <li><code>set_charge</code> - Set the charge attribute and units.</li> </ul>"},{"location":"API/particula/builder_mixin/#signature","title":"Signature","text":"<pre><code>class BuilderChargeMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/builder_mixin/#builderchargemixinset_charge","title":"BuilderChargeMixin().set_charge","text":"<p>Show source in builder_mixin.py:151</p> <p>Set the number of elemental charges on the particle.</p>"},{"location":"API/particula/builder_mixin/#arguments","title":"Arguments","text":"<ul> <li><code>charge</code> - Charge of the particle [C].</li> <li><code>charge_units</code> - Not used. (for interface consistency)</li> </ul>"},{"location":"API/particula/builder_mixin/#signature_1","title":"Signature","text":"<pre><code>def set_charge(\n    self, charge: Union[float, NDArray[np.float64]], charge_units: Optional[str] = None\n): ...\n</code></pre>"},{"location":"API/particula/builder_mixin/#builderconcentrationmixin","title":"BuilderConcentrationMixin","text":"<p>Show source in builder_mixin.py:103</p> <p>Mixin class for Builder classes to set concentration and concentration_units.</p>"},{"location":"API/particula/builder_mixin/#arguments_1","title":"Arguments","text":"<ul> <li><code>default_units</code> - Default units of concentration. Default is kg/m^3.</li> </ul>"},{"location":"API/particula/builder_mixin/#methods_1","title":"Methods","text":"<ul> <li><code>set_concentration</code> - Set the concentration attribute and units.</li> </ul>"},{"location":"API/particula/builder_mixin/#signature_2","title":"Signature","text":"<pre><code>class BuilderConcentrationMixin:\n    def __init__(self, default_units: Optional[str] = \"kg/m^3\"): ...\n</code></pre>"},{"location":"API/particula/builder_mixin/#builderconcentrationmixinset_concentration","title":"BuilderConcentrationMixin().set_concentration","text":"<p>Show source in builder_mixin.py:118</p> <p>Set the concentration.</p>"},{"location":"API/particula/builder_mixin/#arguments_2","title":"Arguments","text":"<ul> <li><code>concentration</code> - Concentration in the mixture.</li> <li><code>concentration_units</code> - Units of the concentration. Default is kg/m^3.</li> </ul>"},{"location":"API/particula/builder_mixin/#signature_3","title":"Signature","text":"<pre><code>@validate_inputs({\"concentration\": \"positive\"})\ndef set_concentration(\n    self,\n    concentration: Union[float, NDArray[np.float64]],\n    concentration_units: Optional[str] = None,\n): ...\n</code></pre>"},{"location":"API/particula/builder_mixin/#builderdensitymixin","title":"BuilderDensityMixin","text":"<p>Show source in builder_mixin.py:17</p> <p>Mixin class for Builder classes to set density and density_units.</p>"},{"location":"API/particula/builder_mixin/#methods_2","title":"Methods","text":"<ul> <li><code>set_density</code> - Set the density attribute and units.</li> </ul>"},{"location":"API/particula/builder_mixin/#signature_4","title":"Signature","text":"<pre><code>class BuilderDensityMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/builder_mixin/#builderdensitymixinset_density","title":"BuilderDensityMixin().set_density","text":"<p>Show source in builder_mixin.py:27</p> <p>Set the density of the particle in kg/m^3.</p>"},{"location":"API/particula/builder_mixin/#arguments_3","title":"Arguments","text":"<ul> <li><code>density</code> - Density of the particle.</li> <li><code>density_units</code> - Units of the density. Default is kg/m^3</li> </ul>"},{"location":"API/particula/builder_mixin/#signature_5","title":"Signature","text":"<pre><code>@validate_inputs({\"density\": \"positive\"})\ndef set_density(\n    self,\n    density: Union[float, NDArray[np.float64]],\n    density_units: Optional[str] = \"kg/m^3\",\n): ...\n</code></pre>"},{"location":"API/particula/builder_mixin/#builderlognormalmixin","title":"BuilderLognormalMixin","text":"<p>Show source in builder_mixin.py:330</p> <p>Mixin class for Builder classes to set lognormal distributions.</p>"},{"location":"API/particula/builder_mixin/#methods_3","title":"Methods","text":"<ul> <li><code>set_mode</code> - Set the mode attribute and units.</li> <li><code>set_geometric_standard_deviation</code> - Set the geometric standard deviation     attribute and units.</li> <li><code>set_number_concentration</code> - Set the number concentration attribute and     units.</li> </ul>"},{"location":"API/particula/builder_mixin/#signature_6","title":"Signature","text":"<pre><code>class BuilderLognormalMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/builder_mixin/#builderlognormalmixinset_geometric_standard_deviation","title":"BuilderLognormalMixin().set_geometric_standard_deviation","text":"<p>Show source in builder_mixin.py:366</p> <p>Set the geometric standard deviation for the distribution.</p>"},{"location":"API/particula/builder_mixin/#arguments_4","title":"Arguments","text":"<ul> <li><code>geometric_standard_deviation</code> - The geometric standard deviation for     the radius.</li> <li><code>geometric_standard_deviation_units</code> - Optional, ignored units for     geometric standard deviation [dimensionless].</li> </ul>"},{"location":"API/particula/builder_mixin/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code> - If geometric standard deviation is negative.</li> </ul>"},{"location":"API/particula/builder_mixin/#signature_7","title":"Signature","text":"<pre><code>@validate_inputs({\"geometric_standard_deviation\": \"positive\"})\ndef set_geometric_standard_deviation(\n    self,\n    geometric_standard_deviation: NDArray[np.float64],\n    geometric_standard_deviation_units: Optional[str] = None,\n): ...\n</code></pre>"},{"location":"API/particula/builder_mixin/#builderlognormalmixinset_mode","title":"BuilderLognormalMixin().set_mode","text":"<p>Show source in builder_mixin.py:346</p> <p>Set the mode for distribution.</p>"},{"location":"API/particula/builder_mixin/#arguments_5","title":"Arguments","text":"<ul> <li><code>mode</code> - The modes for the radius.</li> <li><code>mode_units</code> - The units for the modes, default is 'm'.</li> </ul>"},{"location":"API/particula/builder_mixin/#raises_1","title":"Raises","text":"<ul> <li><code>ValueError</code> - If mode is negative.</li> </ul>"},{"location":"API/particula/builder_mixin/#signature_8","title":"Signature","text":"<pre><code>@validate_inputs({\"mode\": \"positive\"})\ndef set_mode(self, mode: NDArray[np.float64], mode_units: str = \"m\"): ...\n</code></pre>"},{"location":"API/particula/builder_mixin/#builderlognormalmixinset_number_concentration","title":"BuilderLognormalMixin().set_number_concentration","text":"<p>Show source in builder_mixin.py:388</p> <p>Set the number concentration for the distribution.</p>"},{"location":"API/particula/builder_mixin/#arguments_6","title":"Arguments","text":"<ul> <li><code>number_concentration</code> - The number concentration for the radius.</li> <li><code>number_concentration_units</code> - The units for the number concentration,     default is '1/m^3'.</li> </ul>"},{"location":"API/particula/builder_mixin/#raises_2","title":"Raises","text":"<ul> <li><code>ValueError</code> - If number concentration is negative.</li> </ul>"},{"location":"API/particula/builder_mixin/#signature_9","title":"Signature","text":"<pre><code>@validate_inputs({\"number_concentration\": \"positive\"})\ndef set_number_concentration(\n    self,\n    number_concentration: NDArray[np.float64],\n    number_concentration_units: str = \"1/m^3\",\n): ...\n</code></pre>"},{"location":"API/particula/builder_mixin/#buildermassmixin","title":"BuilderMassMixin","text":"<p>Show source in builder_mixin.py:168</p> <p>Mixin class for Builder classes to set mass and mass_units.</p>"},{"location":"API/particula/builder_mixin/#methods_4","title":"Methods","text":"<ul> <li><code>set_mass</code> - Set the mass attribute and units.</li> </ul>"},{"location":"API/particula/builder_mixin/#signature_10","title":"Signature","text":"<pre><code>class BuilderMassMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/builder_mixin/#buildermassmixinset_mass","title":"BuilderMassMixin().set_mass","text":"<p>Show source in builder_mixin.py:178</p> <p>Set the mass of the particle in kg.</p>"},{"location":"API/particula/builder_mixin/#arguments_7","title":"Arguments","text":"<ul> <li><code>mass</code> - Mass of the particle.</li> <li><code>mass_units</code> - Units of the mass. Default is kg.</li> </ul>"},{"location":"API/particula/builder_mixin/#raises_3","title":"Raises","text":"<ul> <li><code>ValueError</code> - If mass is negative</li> </ul>"},{"location":"API/particula/builder_mixin/#signature_11","title":"Signature","text":"<pre><code>@validate_inputs({\"mass\": \"positive\"})\ndef set_mass(\n    self, mass: Union[float, NDArray[np.float64]], mass_units: Optional[str] = \"kg\"\n): ...\n</code></pre>"},{"location":"API/particula/builder_mixin/#buildermolarmassmixin","title":"BuilderMolarMassMixin","text":"<p>Show source in builder_mixin.py:74</p> <p>Mixin class for Builder classes to set molar_mass and molar_mass_units.</p>"},{"location":"API/particula/builder_mixin/#methods_5","title":"Methods","text":"<ul> <li><code>set_molar_mass</code> - Set the molar_mass attribute and units.</li> </ul>"},{"location":"API/particula/builder_mixin/#signature_12","title":"Signature","text":"<pre><code>class BuilderMolarMassMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/builder_mixin/#buildermolarmassmixinset_molar_mass","title":"BuilderMolarMassMixin().set_molar_mass","text":"<p>Show source in builder_mixin.py:84</p> <p>Set the molar mass of the particle in kg/mol.</p>"},{"location":"API/particula/builder_mixin/#arguments_8","title":"Arguments","text":"<ul> <li><code>-</code> molar_mass - Molar mass of the particle.</li> <li><code>-</code> molar_mass_units - Units of the molar mass. Default is kg/mol.</li> </ul>"},{"location":"API/particula/builder_mixin/#signature_13","title":"Signature","text":"<pre><code>@validate_inputs({\"molar_mass\": \"positive\"})\ndef set_molar_mass(\n    self,\n    molar_mass: Union[float, NDArray[np.float64]],\n    molar_mass_units: Optional[str] = \"kg/mol\",\n): ...\n</code></pre>"},{"location":"API/particula/builder_mixin/#builderparticleresolvedcountmixin","title":"BuilderParticleResolvedCountMixin","text":"<p>Show source in builder_mixin.py:410</p> <p>Mixin class for Builder classes to set particle_resolved_count.</p>"},{"location":"API/particula/builder_mixin/#methods_6","title":"Methods","text":"<ul> <li><code>set_particle_resolved_count</code> - Set the number of particles to resolve.</li> </ul>"},{"location":"API/particula/builder_mixin/#signature_14","title":"Signature","text":"<pre><code>class BuilderParticleResolvedCountMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/builder_mixin/#builderparticleresolvedcountmixinset_particle_resolved_count","title":"BuilderParticleResolvedCountMixin().set_particle_resolved_count","text":"<p>Show source in builder_mixin.py:420</p> <p>Set the number of particles to resolve.</p>"},{"location":"API/particula/builder_mixin/#arguments_9","title":"Arguments","text":"<ul> <li><code>particle_resolved_count</code> - The number of particles to resolve.</li> <li><code>particle_resolved_count_units</code> - Ignored units for particle resolved.</li> </ul>"},{"location":"API/particula/builder_mixin/#raises_4","title":"Raises","text":"<ul> <li><code>ValueError</code> - If particle_resolved_count is negative.</li> </ul>"},{"location":"API/particula/builder_mixin/#signature_15","title":"Signature","text":"<pre><code>@validate_inputs({\"particle_resolved_count\": \"positive\"})\ndef set_particle_resolved_count(\n    self,\n    particle_resolved_count: int,\n    particle_resolved_count_units: Optional[str] = None,\n): ...\n</code></pre>"},{"location":"API/particula/builder_mixin/#builderpressuremixin","title":"BuilderPressureMixin","text":"<p>Show source in builder_mixin.py:295</p> <p>Mixin class for AtmosphereBuilder to set total pressure.</p>"},{"location":"API/particula/builder_mixin/#methods_7","title":"Methods","text":"<ul> <li><code>set_pressure</code> - Set the total pressure attribute and units.</li> </ul>"},{"location":"API/particula/builder_mixin/#signature_16","title":"Signature","text":"<pre><code>class BuilderPressureMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/builder_mixin/#builderpressuremixinset_pressure","title":"BuilderPressureMixin().set_pressure","text":"<p>Show source in builder_mixin.py:305</p> <p>Set the total pressure of the atmosphere.</p>"},{"location":"API/particula/builder_mixin/#arguments_10","title":"Arguments","text":"<ul> <li><code>total_pressure</code> - Total pressure of the gas mixture.</li> <li><code>pressure_units</code> - Units of the pressure. Options include     'Pa', 'kPa', 'MPa', 'psi', 'bar', 'atm'. Default is 'Pa'.</li> </ul>"},{"location":"API/particula/builder_mixin/#returns","title":"Returns","text":"<ul> <li><code>AtmosphereBuilderMixin</code> - This object instance with updated pressure.</li> </ul>"},{"location":"API/particula/builder_mixin/#raises_5","title":"Raises","text":"<ul> <li><code>ValueError</code> - If the total pressure is below zero.</li> </ul>"},{"location":"API/particula/builder_mixin/#signature_17","title":"Signature","text":"<pre><code>@validate_inputs({\"pressure\": \"positive\"})\ndef set_pressure(\n    self, pressure: Union[float, NDArray[np.float64]], pressure_units: str = \"Pa\"\n): ...\n</code></pre>"},{"location":"API/particula/builder_mixin/#builderradiusmixin","title":"BuilderRadiusMixin","text":"<p>Show source in builder_mixin.py:230</p> <p>Mixin class for Builder classes to set radius and radius_units.</p>"},{"location":"API/particula/builder_mixin/#methods_8","title":"Methods","text":"<ul> <li><code>set_radius</code> - Set the radius attribute and units.</li> </ul>"},{"location":"API/particula/builder_mixin/#signature_18","title":"Signature","text":"<pre><code>class BuilderRadiusMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/builder_mixin/#builderradiusmixinset_radius","title":"BuilderRadiusMixin().set_radius","text":"<p>Show source in builder_mixin.py:240</p> <p>Set the radius of the particle in meters.</p>"},{"location":"API/particula/builder_mixin/#arguments_11","title":"Arguments","text":"<ul> <li><code>radius</code> - Radius of the particle.</li> <li><code>radius_units</code> - Units of the radius. Default is m.</li> </ul>"},{"location":"API/particula/builder_mixin/#raises_6","title":"Raises","text":"<ul> <li><code>ValueError</code> - If radius is negative</li> </ul>"},{"location":"API/particula/builder_mixin/#signature_19","title":"Signature","text":"<pre><code>@validate_inputs({\"radius\": \"positive\"})\ndef set_radius(\n    self, radius: Union[float, NDArray[np.float64]], radius_units: Optional[str] = \"m\"\n): ...\n</code></pre>"},{"location":"API/particula/builder_mixin/#buildersurfacetensionmixin","title":"BuilderSurfaceTensionMixin","text":"<p>Show source in builder_mixin.py:45</p> <p>Mixin class for Builder classes to set surface_tension.</p>"},{"location":"API/particula/builder_mixin/#methods_9","title":"Methods","text":"<pre><code>- `set_surface_tension` - Set the surface_tension attribute and units.\n</code></pre>"},{"location":"API/particula/builder_mixin/#signature_20","title":"Signature","text":"<pre><code>class BuilderSurfaceTensionMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/builder_mixin/#buildersurfacetensionmixinset_surface_tension","title":"BuilderSurfaceTensionMixin().set_surface_tension","text":"<p>Show source in builder_mixin.py:56</p> <p>Set the surface tension of the particle in N/m.</p>"},{"location":"API/particula/builder_mixin/#arguments_12","title":"Arguments","text":"<ul> <li><code>surface_tension</code> - Surface tension of the particle.</li> <li><code>surface_tension_units</code> - Surface tension units. Default is N/m.</li> </ul>"},{"location":"API/particula/builder_mixin/#signature_21","title":"Signature","text":"<pre><code>@validate_inputs({\"surface_tension\": \"positive\"})\ndef set_surface_tension(\n    self,\n    surface_tension: Union[float, NDArray[np.float64]],\n    surface_tension_units: Optional[str] = \"N/m\",\n): ...\n</code></pre>"},{"location":"API/particula/builder_mixin/#buildertemperaturemixin","title":"BuilderTemperatureMixin","text":"<p>Show source in builder_mixin.py:261</p> <p>Mixin class for AtmosphereBuilder to set temperature.</p>"},{"location":"API/particula/builder_mixin/#methods_10","title":"Methods","text":"<ul> <li><code>set_temperature</code> - Set the temperature attribute and units.</li> </ul>"},{"location":"API/particula/builder_mixin/#signature_22","title":"Signature","text":"<pre><code>class BuilderTemperatureMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/builder_mixin/#buildertemperaturemixinset_temperature","title":"BuilderTemperatureMixin().set_temperature","text":"<p>Show source in builder_mixin.py:271</p> <p>Set the temperature of the atmosphere.</p>"},{"location":"API/particula/builder_mixin/#arguments_13","title":"Arguments","text":"<ul> <li><code>temperature</code> float - Temperature of the gas mixture.</li> <li><code>temperature_units</code> str - Units of the temperature.     Options include 'degC', 'degF', 'degR', 'K'. Default is 'K'.</li> </ul>"},{"location":"API/particula/builder_mixin/#returns_1","title":"Returns","text":"<ul> <li><code>AtmosphereBuilderMixin</code> - This object instance with updated     temperature.</li> </ul>"},{"location":"API/particula/builder_mixin/#raises_7","title":"Raises","text":"<ul> <li><code>ValueError</code> - If the converted temperature is below absolute zero.</li> </ul>"},{"location":"API/particula/builder_mixin/#signature_23","title":"Signature","text":"<pre><code>@validate_inputs({\"temperature\": \"positive\"})\ndef set_temperature(self, temperature: float, temperature_units: str = \"K\"): ...\n</code></pre>"},{"location":"API/particula/builder_mixin/#buildervolumemixin","title":"BuilderVolumeMixin","text":"<p>Show source in builder_mixin.py:199</p> <p>Mixin class for Builder classes to set volume and volume_units.</p>"},{"location":"API/particula/builder_mixin/#methods_11","title":"Methods","text":"<ul> <li><code>set_volume</code> - Set the volume attribute and units.</li> </ul>"},{"location":"API/particula/builder_mixin/#signature_24","title":"Signature","text":"<pre><code>class BuilderVolumeMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/builder_mixin/#buildervolumemixinset_volume","title":"BuilderVolumeMixin().set_volume","text":"<p>Show source in builder_mixin.py:209</p> <p>Set the volume in m^3.</p>"},{"location":"API/particula/builder_mixin/#arguments_14","title":"Arguments","text":"<ul> <li><code>volume</code> - Volume.</li> <li><code>volume_units</code> - Units of the volume. Default is m^3.</li> </ul>"},{"location":"API/particula/builder_mixin/#raises_8","title":"Raises","text":"<ul> <li><code>ValueError</code> - If volume is negative</li> </ul>"},{"location":"API/particula/builder_mixin/#signature_25","title":"Signature","text":"<pre><code>@validate_inputs({\"volume\": \"positive\"})\ndef set_volume(\n    self, volume: Union[float, NDArray[np.float64]], volume_units: Optional[str] = \"m^3\"\n): ...\n</code></pre>"},{"location":"API/particula/logger_setup/","title":"Logger Setup","text":"<p>Particula Index / Particula / Logger Setup</p> <p>Auto-generated documentation for particula.logger_setup module.</p>"},{"location":"API/particula/logger_setup/#attributes","title":"Attributes","text":"<ul> <li> <p><code>current_dir</code> - get path of the current directory: os.path.dirname(os.path.abspath(file))</p> </li> <li> <p><code>log_dir</code> - add the logging directory to the path: os.path.join(current_dir, 'logging')</p> </li> </ul>"},{"location":"API/particula/logger_setup/#setup","title":"setup","text":"<p>Show source in logger_setup.py:65</p> <p>Setup for logging in the particula package.</p>"},{"location":"API/particula/logger_setup/#signature","title":"Signature","text":"<pre><code>def setup(): ...\n</code></pre>"},{"location":"API/particula/runnable/","title":"Runnable","text":"<p>Particula Index / Particula / Runnable</p> <p>Auto-generated documentation for particula.runnable module.</p>"},{"location":"API/particula/runnable/#runnable_1","title":"Runnable","text":"<p>Show source in runnable.py:10</p> <p>Runnable process that can modify an aerosol instance.</p> <p>Parameters: None</p>"},{"location":"API/particula/runnable/#methods","title":"Methods","text":"<ul> <li><code>-</code> rate - Return the rate of the process.</li> <li><code>-</code> execute - Execute the process and modify the aerosol instance.</li> <li><code>-</code> or - Chain this process with another process using the | operator.</li> </ul>"},{"location":"API/particula/runnable/#signature","title":"Signature","text":"<pre><code>class Runnable(ABC): ...\n</code></pre>"},{"location":"API/particula/runnable/#runnableor","title":"Runnable().or","text":"<p>Show source in runnable.py:45</p> <p>Chain this process with another process using the | operator.</p>"},{"location":"API/particula/runnable/#signature_1","title":"Signature","text":"<pre><code>def __or__(self, other: \"Runnable\"): ...\n</code></pre>"},{"location":"API/particula/runnable/#runnableexecute","title":"Runnable().execute","text":"<p>Show source in runnable.py:28</p> <p>Execute the process and modify the aerosol instance.</p>"},{"location":"API/particula/runnable/#arguments","title":"Arguments","text":"<ul> <li><code>aerosol</code> Aerosol - The aerosol instance to modify.</li> <li><code>time_step</code> float - The time step for the process in seconds.</li> <li><code>sub_steps</code> int - The number of sub-steps to use for the process,     default is 1. Which means the full time step is used. A value     of 2 would mean the time step is divided into two sub-steps.</li> </ul>"},{"location":"API/particula/runnable/#signature_2","title":"Signature","text":"<pre><code>@abstractmethod\ndef execute(self, aerosol: Aerosol, time_step: float, sub_steps: int = 1) -&gt; Aerosol: ...\n</code></pre>"},{"location":"API/particula/runnable/#see-also","title":"See also","text":"<ul> <li>Aerosol</li> </ul>"},{"location":"API/particula/runnable/#runnablerate","title":"Runnable().rate","text":"<p>Show source in runnable.py:21</p> <p>Return the rate of the process.</p>"},{"location":"API/particula/runnable/#arguments_1","title":"Arguments","text":"<ul> <li>aerosol (Aerosol): The aerosol instance to modify.</li> </ul>"},{"location":"API/particula/runnable/#signature_3","title":"Signature","text":"<pre><code>@abstractmethod\ndef rate(self, aerosol: Aerosol) -&gt; Any: ...\n</code></pre>"},{"location":"API/particula/runnable/#see-also_1","title":"See also","text":"<ul> <li>Aerosol</li> </ul>"},{"location":"API/particula/runnable/#runnablesequence","title":"RunnableSequence","text":"<p>Show source in runnable.py:54</p> <p>A sequence of processes to be executed in order.</p>"},{"location":"API/particula/runnable/#attributes","title":"Attributes","text":"<ul> <li>processes (List[Runnable]): A list of RunnableProcess objects.</li> </ul>"},{"location":"API/particula/runnable/#methods_1","title":"Methods","text":"<ul> <li><code>-</code> add_process - Add a process to the sequence.</li> <li><code>-</code> execute - Execute the sequence of processes on an aerosol instance.</li> <li><code>-</code> or - Add a process to the sequence using the | operator.</li> </ul>"},{"location":"API/particula/runnable/#signature_4","title":"Signature","text":"<pre><code>class RunnableSequence:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/runnable/#runnablesequenceor","title":"RunnableSequence().or","text":"<p>Show source in runnable.py:80</p> <p>Add a runnable to the sequence using the | operator.</p>"},{"location":"API/particula/runnable/#signature_5","title":"Signature","text":"<pre><code>def __or__(self, process: Runnable): ...\n</code></pre>"},{"location":"API/particula/runnable/#see-also_2","title":"See also","text":"<ul> <li>Runnable</li> </ul>"},{"location":"API/particula/runnable/#runnablesequenceadd_process","title":"RunnableSequence().add_process","text":"<p>Show source in runnable.py:69</p> <p>Add a process to the sequence.</p>"},{"location":"API/particula/runnable/#signature_6","title":"Signature","text":"<pre><code>def add_process(self, process: Runnable): ...\n</code></pre>"},{"location":"API/particula/runnable/#see-also_3","title":"See also","text":"<ul> <li>Runnable</li> </ul>"},{"location":"API/particula/runnable/#runnablesequenceexecute","title":"RunnableSequence().execute","text":"<p>Show source in runnable.py:73</p> <p>Execute the sequence of runnables on an aerosol instance.</p>"},{"location":"API/particula/runnable/#signature_7","title":"Signature","text":"<pre><code>def execute(self, aerosol: Aerosol, time_step: float) -&gt; Aerosol: ...\n</code></pre>"},{"location":"API/particula/runnable/#see-also_4","title":"See also","text":"<ul> <li>Aerosol</li> </ul>"},{"location":"API/particula/activity/","title":"Activity","text":"<p>Particula Index / Particula / Activity</p> <p>Auto-generated documentation for particula.activity module.</p>"},{"location":"API/particula/activity/#modules","title":"Modules","text":"<ul> <li>Activity Coefficients</li> <li>Bat Blending</li> <li>Bat Coefficients</li> <li>Convert Functional Group</li> <li>Gibbs</li> <li>Gibbs Mixing</li> <li>Phase Separation</li> <li>Ratio</li> <li>Species Density</li> <li>Water Activity</li> </ul>"},{"location":"API/particula/activity/activity_coefficients/","title":"Activity Coefficients","text":"<p>Particula Index / Particula / Activity / Activity Coefficients</p> <p>Auto-generated documentation for particula.activity.activity_coefficients module.</p>"},{"location":"API/particula/activity/activity_coefficients/#bat_activity_coefficients","title":"bat_activity_coefficients","text":"<p>Show source in activity_coefficients.py:23</p> <p>Calculate the activity coefficients for water and organic matter in organic-water mixtures.</p>"},{"location":"API/particula/activity/activity_coefficients/#arguments","title":"Arguments","text":"<ul> <li>molar_mass_ratio : Ratio of the molecular weight of water to the   molecular weight of organic matter.</li> <li>organic_mole_fraction : Molar fraction of organic matter in the   mixture.</li> <li>oxygen2carbon : Oxygen to carbon ratio in the organic compound.</li> <li>density : Density of the mixture, in kg/m^3.</li> <li>functional_group : Optional functional group(s) of the organic   compound, if applicable.</li> </ul>"},{"location":"API/particula/activity/activity_coefficients/#returns","title":"Returns","text":"<ul> <li>A tuple containing the activity of water, activity   of organic matter, mass fraction of water, and mass   fraction of organic matter, gamma_water (activity coefficient),   and gamma_organic (activity coefficient).</li> </ul>"},{"location":"API/particula/activity/activity_coefficients/#signature","title":"Signature","text":"<pre><code>@validate_inputs(\n    {\n        \"molar_mass_ratio\": \"positive\",\n        \"organic_mole_fraction\": \"nonnegative\",\n        \"oxygen2carbon\": \"nonnegative\",\n        \"density\": \"positive\",\n    }\n)\ndef bat_activity_coefficients(\n    molar_mass_ratio: Union[float, NDArray[np.float64]],\n    organic_mole_fraction: Union[float, NDArray[np.float64]],\n    oxygen2carbon: Union[float, NDArray[np.float64]],\n    density: Union[float, NDArray[np.float64]],\n    functional_group: Optional[Union[str, List[str]]] = None,\n) -&gt; Tuple[\n    Union[float, NDArray[np.float64]],\n    Union[float, NDArray[np.float64]],\n    Union[float, NDArray[np.float64]],\n    Union[float, NDArray[np.float64]],\n    Union[float, NDArray[np.float64]],\n    Union[float, NDArray[np.float64]],\n]: ...\n</code></pre>"},{"location":"API/particula/activity/bat_blending/","title":"Bat Blending","text":"<p>Particula Index / Particula / Activity / Bat Blending</p> <p>Auto-generated documentation for particula.activity.bat_blending module.</p>"},{"location":"API/particula/activity/bat_blending/#_calculate_blending_weights","title":"_calculate_blending_weights","text":"<p>Show source in bat_blending.py:62</p> <p>Helper function to calculate blending weights for a single value of oxygen2carbon.</p>"},{"location":"API/particula/activity/bat_blending/#arguments","title":"Arguments","text":"<ul> <li>oxygen2carbon : The oxygen to carbon ratio.</li> <li>oxygen2carbon_ml : The single-phase oxygen to carbon ratio.</li> </ul>"},{"location":"API/particula/activity/bat_blending/#returns","title":"Returns","text":"<ul> <li>blending_weights : List of blending weights for the BAT model     in the low, mid, and high oxygen2carbon regions.</li> </ul>"},{"location":"API/particula/activity/bat_blending/#signature","title":"Signature","text":"<pre><code>def _calculate_blending_weights(\n    oxygen2carbon: float, oxygen2carbon_ml: float\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/activity/bat_blending/#bat_blending_weights","title":"bat_blending_weights","text":"<p>Show source in bat_blending.py:20</p> <p>Function to estimate the blending weights for the BAT model.</p>"},{"location":"API/particula/activity/bat_blending/#arguments_1","title":"Arguments","text":"<ul> <li>molar_mass_ratio : The molar mass ratio of water to organic     matter.</li> <li>oxygen2carbon : The oxygen to carbon ratio.</li> </ul>"},{"location":"API/particula/activity/bat_blending/#returns_1","title":"Returns","text":"<ul> <li>blending_weights : Array of blending weights for the BAT model     in the low, mid, and high oxygen2carbon regions. The weights     size is (3,) if oxygen2carbon is a single value, or (n, 3)     if oxygen2carbon is an array of size n.</li> </ul>"},{"location":"API/particula/activity/bat_blending/#signature_1","title":"Signature","text":"<pre><code>@validate_inputs({\"molar_mass_ratio\": \"positive\", \"oxygen2carbon\": \"nonnegative\"})\ndef bat_blending_weights(\n    molar_mass_ratio: Union[float, NDArray[np.float64]],\n    oxygen2carbon: Union[float, NDArray[np.float64]],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/activity/bat_coefficients/","title":"Bat Coefficients","text":"<p>Particula Index / Particula / Activity / Bat Coefficients</p> <p>Auto-generated documentation for particula.activity.bat_coefficients module.</p>"},{"location":"API/particula/activity/bat_coefficients/#fitvalues","title":"FitValues","text":"<p>Show source in bat_coefficients.py:17</p> <p>Named tuple for the fit values for the activity model.</p>"},{"location":"API/particula/activity/bat_coefficients/#signature","title":"Signature","text":"<pre><code>class FitValues(NamedTuple): ...\n</code></pre>"},{"location":"API/particula/activity/bat_coefficients/#coefficients_c","title":"coefficients_c","text":"<p>Show source in bat_coefficients.py:45</p> <p>Coefficients for activity model, see Gorkowski (2019). equation S1 S2.</p>"},{"location":"API/particula/activity/bat_coefficients/#arguments","title":"Arguments","text":"<ul> <li>molar_mass_ratio : The molar mass ratio of water to organic   matter.</li> <li>oxygen2carbon : The oxygen to carbon ratio.</li> <li>fit_values : The fit values for the activity model.</li> </ul>"},{"location":"API/particula/activity/bat_coefficients/#returns","title":"Returns","text":"<ul> <li>The coefficients for the activity model.</li> </ul>"},{"location":"API/particula/activity/bat_coefficients/#signature_1","title":"Signature","text":"<pre><code>def coefficients_c(\n    molar_mass_ratio: Union[float, NDArray[np.float64]],\n    oxygen2carbon: Union[float, NDArray[np.float64]],\n    fit_values: List[float],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/activity/convert_functional_group/","title":"Convert Functional Group","text":"<p>Particula Index / Particula / Activity / Convert Functional Group</p> <p>Auto-generated documentation for particula.activity.convert_functional_group module.</p>"},{"location":"API/particula/activity/convert_functional_group/#convert_to_oh_equivalent","title":"convert_to_oh_equivalent","text":"<p>Show source in convert_functional_group.py:17</p> <p>Just a pass through now, but will add the oh equivalent conversion.</p>"},{"location":"API/particula/activity/convert_functional_group/#arguments","title":"Arguments","text":"<ul> <li>oxygen2carbon : The oxygen to carbon ratio.</li> <li>molar_mass_ratio : The molar mass ratio of water to organic   matter.</li> <li>functional_group : Optional functional group(s) of the organic   compound, if applicable.</li> </ul>"},{"location":"API/particula/activity/convert_functional_group/#returns","title":"Returns","text":"<ul> <li>A tuple containing the converted oxygen to carbon ratio and   molar mass ratio.</li> </ul>"},{"location":"API/particula/activity/convert_functional_group/#signature","title":"Signature","text":"<pre><code>def convert_to_oh_equivalent(\n    oxygen2carbon: Union[float, NDArray[np.float64]],\n    molar_mass_ratio: Union[float, NDArray[np.float64]],\n    functional_group: Optional[Union[list[str], str]] = None,\n) -&gt; Tuple[np.ndarray, np.ndarray]: ...\n</code></pre>"},{"location":"API/particula/activity/gibbs/","title":"Gibbs","text":"<p>Particula Index / Particula / Activity / Gibbs</p> <p>Auto-generated documentation for particula.activity.gibbs module.</p>"},{"location":"API/particula/activity/gibbs/#gibbs_free_engery","title":"gibbs_free_engery","text":"<p>Show source in gibbs.py:13</p> <p>Calculate the gibbs free energy of the mixture. Ideal and non-ideal.</p>"},{"location":"API/particula/activity/gibbs/#arguments","title":"Arguments","text":"<ul> <li>organic_mole_fraction : A numpy array of organic mole     fractions.</li> <li>gibbs_mix : A numpy array of gibbs free energy of mixing.</li> </ul>"},{"location":"API/particula/activity/gibbs/#returns","title":"Returns","text":"<ul> <li>gibbs_ideal : The ideal gibbs free energy of mixing.</li> <li>gibbs_real : The real gibbs free energy of mixing.</li> </ul>"},{"location":"API/particula/activity/gibbs/#signature","title":"Signature","text":"<pre><code>def gibbs_free_engery(\n    organic_mole_fraction: NDArray[np.float64], gibbs_mix: NDArray[np.float64]\n) -&gt; Tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/activity/gibbs_mixing/","title":"Gibbs Mixing","text":"<p>Particula Index / Particula / Activity / Gibbs Mixing</p> <p>Auto-generated documentation for particula.activity.gibbs_mixing module.</p>"},{"location":"API/particula/activity/gibbs_mixing/#_calculate_gibbs_mix_single","title":"_calculate_gibbs_mix_single","text":"<p>Show source in gibbs_mixing.py:157</p> <p>Calculate Gibbs free energy of mixing for a single set of inputs.</p>"},{"location":"API/particula/activity/gibbs_mixing/#arguments","title":"Arguments","text":"<ul> <li>molar_mass_ratio : The molar mass ratio of water to organic   matter.</li> <li>organic_mole_fraction : The fraction of organic matter.</li> <li>oxygen2carbon : The oxygen to carbon ratio.</li> <li>density : The density of the mixture, in kg/m^3.</li> <li>weights : Blending weights for the BAT model.</li> </ul>"},{"location":"API/particula/activity/gibbs_mixing/#returns","title":"Returns","text":"<ul> <li>gibbs_mix : Gibbs energy of mixing (including 1/RT)</li> <li>derivative_gibbs : derivative of Gibbs energy with respect to   mole fraction of organics (includes 1/RT)</li> </ul>"},{"location":"API/particula/activity/gibbs_mixing/#signature","title":"Signature","text":"<pre><code>def _calculate_gibbs_mix_single(\n    molar_mass_ratio: float,\n    organic_mole_fraction: float,\n    oxygen2carbon: float,\n    density: float,\n    weights: NDArray[np.float64],\n) -&gt; Tuple[np.ndarray, np.ndarray]: ...\n</code></pre>"},{"location":"API/particula/activity/gibbs_mixing/#gibbs_mix_weight","title":"gibbs_mix_weight","text":"<p>Show source in gibbs_mixing.py:96</p> <p>Gibbs free energy of mixing, see Gorkowski (2019), with weighted oxygen2carbon regions. Only can run one compound at a time.</p>"},{"location":"API/particula/activity/gibbs_mixing/#arguments_1","title":"Arguments","text":"<ul> <li>molar_mass_ratio : The molar mass ratio of water to organic   matter.</li> <li>organic_mole_fraction : The fraction of organic matter.</li> <li>oxygen2carbon : The oxygen to carbon ratio.</li> <li>density : The density of the mixture, in kg/m^3.</li> <li>functional_group : Optional functional group(s) of the organic   compound, if applicable.</li> </ul>"},{"location":"API/particula/activity/gibbs_mixing/#returns_1","title":"Returns","text":"<ul> <li>gibbs_mix : Gibbs energy of mixing (including 1/RT)</li> <li>derivative_gibbs : derivative of Gibbs energy with respect to   mole fraction of organics (includes 1/RT)</li> </ul>"},{"location":"API/particula/activity/gibbs_mixing/#signature_1","title":"Signature","text":"<pre><code>def gibbs_mix_weight(\n    molar_mass_ratio: Union[float, NDArray[np.float64]],\n    organic_mole_fraction: Union[float, NDArray[np.float64]],\n    oxygen2carbon: Union[float, NDArray[np.float64]],\n    density: Union[float, NDArray[np.float64]],\n    functional_group: Optional[str] = None,\n) -&gt; Tuple[np.ndarray, np.ndarray]: ...\n</code></pre>"},{"location":"API/particula/activity/gibbs_mixing/#gibbs_of_mixing","title":"gibbs_of_mixing","text":"<p>Show source in gibbs_mixing.py:27</p> <p>Calculate the Gibbs free energy of mixing for a binary mixture.</p>"},{"location":"API/particula/activity/gibbs_mixing/#arguments_2","title":"Arguments","text":"<ul> <li>molar_mass_ratio : The molar mass ratio of water to organic   matter.</li> <li>organic_mole_fraction : The fraction of organic matter.</li> <li>oxygen2carbon : The oxygen to carbon ratio.</li> <li>density : The density of the mixture, in kg/m^3.</li> <li>fit_dict : A dictionary of fit values for the low oxygen2carbon     region</li> </ul>"},{"location":"API/particula/activity/gibbs_mixing/#returns_2","title":"Returns","text":"<ul> <li>A tuple containing the Gibbs free energy of mixing and its   derivative.</li> </ul>"},{"location":"API/particula/activity/gibbs_mixing/#signature_2","title":"Signature","text":"<pre><code>@validate_inputs(\n    {\n        \"molar_mass_ratio\": \"positive\",\n        \"organic_mole_fraction\": \"nonnegative\",\n        \"oxygen2carbon\": \"nonnegative\",\n        \"density\": \"positive\",\n    }\n)\ndef gibbs_of_mixing(\n    molar_mass_ratio: Union[float, NDArray[np.float64]],\n    organic_mole_fraction: Union[float, NDArray[np.float64]],\n    oxygen2carbon: Union[float, NDArray[np.float64]],\n    density: Union[float, NDArray[np.float64]],\n    fit_dict: Tuple[str, List[float]],\n) -&gt; Tuple[Union[float, NDArray[np.float64]], Union[float, NDArray[np.float64]]]: ...\n</code></pre>"},{"location":"API/particula/activity/phase_separation/","title":"Phase Separation","text":"<p>Particula Index / Particula / Activity / Phase Separation</p> <p>Auto-generated documentation for particula.activity.phase_separation module.</p>"},{"location":"API/particula/activity/phase_separation/#find_phase_sep_index","title":"find_phase_sep_index","text":"<p>Show source in phase_separation.py:53</p> <p>This function finds phase separation using activity&gt;1 and inflections in the activity curve data. In physical systems activity can not be above one and curve should be monotonic. Or else there will be phase separation.</p>"},{"location":"API/particula/activity/phase_separation/#arguments","title":"Arguments","text":"<ul> <li><code>-</code> activity_data - A array of activity data.</li> </ul>"},{"location":"API/particula/activity/phase_separation/#returns","title":"Returns","text":"<ul> <li><code>dict</code> - A dictionary containing the following keys:<ul> <li><code>-</code> 'phase_sep_activity' - Phase separation via activity     (1 if there is phase separation, 0 otherwise)</li> <li><code>-</code> 'phase_sep_curve' - Phase separation via activity curvature     (1 if there is phase separation, 0 otherwise)</li> <li><code>-</code> 'index_phase_sep_starts' - Index where phase separation starts</li> <li><code>-</code> 'index_phase_sep_end' - Index where phase separation ends</li> </ul> </li> </ul>"},{"location":"API/particula/activity/phase_separation/#signature","title":"Signature","text":"<pre><code>def find_phase_sep_index(activity_data: NDArray[np.float64]) -&gt; dict: ...\n</code></pre>"},{"location":"API/particula/activity/phase_separation/#find_phase_separation","title":"find_phase_separation","text":"<p>Show source in phase_separation.py:143</p> <p>This function checks for phase separation in each activity curve.</p>"},{"location":"API/particula/activity/phase_separation/#arguments_1","title":"Arguments","text":"<ul> <li>activity_water (np.array): A numpy array of water activity values.</li> <li>activity_org (np.array): A numpy array of organic activity values.</li> </ul>"},{"location":"API/particula/activity/phase_separation/#returns_1","title":"Returns","text":"<ul> <li><code>dict</code> - A dictionary containing the following keys:<ul> <li><code>-</code> 'phase_sep_check' - An integer indicating whether phase separation         is present (1) or not (0).</li> <li><code>-</code> 'lower_seperation_index' - The index of the lower separation point         in the activity curve.</li> <li><code>-</code> 'upper_seperation_index' - The index of the upper separation point in         the activity curve.</li> <li><code>-</code> 'matching_upper_seperation_index' - The index where the difference         between activity_water_beta and match_a_w is greater than 0.</li> <li><code>-</code> 'lower_seperation' - The value of water activity at the lower         separation point.</li> <li><code>-</code> 'upper_seperation' - The value of water activity at the upper         separation point.</li> <li><code>-</code> 'matching_upper_seperation' - The value of water activity at the         matching upper separation point.</li> </ul> </li> </ul>"},{"location":"API/particula/activity/phase_separation/#signature_1","title":"Signature","text":"<pre><code>def find_phase_separation(\n    activity_water: NDArray[np.float64], activity_org: NDArray[np.float64]\n) -&gt; dict: ...\n</code></pre>"},{"location":"API/particula/activity/phase_separation/#organic_water_single_phase","title":"organic_water_single_phase","text":"<p>Show source in phase_separation.py:22</p> <p>Convert the given molar mass ratio (MW water / MW organic) to a and oxygen2carbon value were above is a single phase with water and below phase separation is possible.</p>"},{"location":"API/particula/activity/phase_separation/#arguments_2","title":"Arguments","text":"<ul> <li><code>-</code> molar_mass_ratio - The molar mass ratio with respect to water.</li> </ul>"},{"location":"API/particula/activity/phase_separation/#returns_2","title":"Returns","text":"<ul> <li>The single phase cross point.</li> </ul>"},{"location":"API/particula/activity/phase_separation/#references","title":"References","text":"<ul> <li>Gorkowski, K., Preston, T. C., &amp; Zuend, A. (2019).   Relative-humidity-dependent organic aerosol thermodynamics   Via an efficient reduced-complexity model.   Atmospheric Chemistry and Physics   https://doi.org/10.5194/acp-19-13383-2019</li> </ul>"},{"location":"API/particula/activity/phase_separation/#signature_2","title":"Signature","text":"<pre><code>def organic_water_single_phase(\n    molar_mass_ratio: Union[int, float, list, np.ndarray],\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/activity/phase_separation/#q_alpha","title":"q_alpha","text":"<p>Show source in phase_separation.py:240</p> <p>This function calculates the q_alpha value using a squeezed logistic     function.</p>"},{"location":"API/particula/activity/phase_separation/#arguments_3","title":"Arguments","text":"<ul> <li>seperation_activity (np.array): A numpy array of values representing     the separation activity.</li> <li>activities (np.array): A numpy array of activity values.</li> </ul>"},{"location":"API/particula/activity/phase_separation/#returns_3","title":"Returns","text":"<ul> <li><code>np.array</code> - The q_alpha value.</li> </ul>"},{"location":"API/particula/activity/phase_separation/#notes","title":"Notes","text":"<ul> <li>The q_alpha value represents the transfer from     q_alpha ~0 to q_alpha ~1.</li> <li>The function uses a sigmoid curve parameter to calculate the     q_alpha value.</li> </ul>"},{"location":"API/particula/activity/phase_separation/#signature_3","title":"Signature","text":"<pre><code>def q_alpha(\n    seperation_activity: NDArray[np.float64], activities: NDArray[np.float64]\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/activity/ratio/","title":"Ratio","text":"<p>Particula Index / Particula / Activity / Ratio</p> <p>Auto-generated documentation for particula.activity.ratio module.</p>"},{"location":"API/particula/activity/ratio/#from_molar_mass_ratio","title":"from_molar_mass_ratio","text":"<p>Show source in ratio.py:22</p> <p>Convert the given molar mass ratio (MW water / MW organic) to a molar mass with respect to the other compound.</p>"},{"location":"API/particula/activity/ratio/#arguments","title":"Arguments","text":"<ul> <li><code>molar_mass_ratio</code> np.array - The molar mass ratio with respect to water.</li> <li><code>other_molar_mass</code> float, optional - The molar mass of the other compound.     Defaults to 18.01528.</li> </ul>"},{"location":"API/particula/activity/ratio/#returns","title":"Returns","text":"<ul> <li><code>np.array</code> - The molar mass of the organic compound.</li> </ul>"},{"location":"API/particula/activity/ratio/#signature","title":"Signature","text":"<pre><code>def from_molar_mass_ratio(molar_mass_ratio, other_molar_mass=18.01528): ...\n</code></pre>"},{"location":"API/particula/activity/ratio/#to_molar_mass_ratio","title":"to_molar_mass_ratio","text":"<p>Show source in ratio.py:4</p> <p>Convert the given molar mass to a molar mass ratio with respect to water. (MW water / MW organic)</p>"},{"location":"API/particula/activity/ratio/#arguments_1","title":"Arguments","text":"<ul> <li><code>molar_mass</code> np.array - The molar mass of the organic compound.</li> <li><code>other_molar_mass</code> float, optional - The molar mass of the other compound.     Defaults to 18.01528.</li> </ul>"},{"location":"API/particula/activity/ratio/#returns_1","title":"Returns","text":"<ul> <li><code>np.array</code> - The molar mass ratio with respect to water.</li> </ul>"},{"location":"API/particula/activity/ratio/#signature_1","title":"Signature","text":"<pre><code>def to_molar_mass_ratio(molar_mass, other_molar_mass=18.01528): ...\n</code></pre>"},{"location":"API/particula/activity/species_density/","title":"Species Density","text":"<p>Particula Index / Particula / Activity / Species Density</p> <p>Auto-generated documentation for particula.activity.species_density module.</p>"},{"location":"API/particula/activity/species_density/#organic_array","title":"organic_array","text":"<p>Show source in species_density.py:93</p> <p>Get densities for an array.</p>"},{"location":"API/particula/activity/species_density/#signature","title":"Signature","text":"<pre><code>def organic_array(\n    molar_mass,\n    oxygen2carbon,\n    hydrogen2carbon=None,\n    nitrogen2carbon=None,\n    mass_ratio_convert=False,\n): ...\n</code></pre>"},{"location":"API/particula/activity/species_density/#organic_density_estimate","title":"organic_density_estimate","text":"<p>Show source in species_density.py:12</p> <p>Function to estimate the density of organic compounds based on the simple model by Girolami (1994). The input parameters include molar mass, O:C and H:C ratios. If the H:C ratio is unknown at input, enter a negative value. The actual H:C will then be estimated based on an initial assumption of H:C = 2. The model also estimates the number of carbon atoms per molecular structure based on molar mass, O:C, and H:C. The density is then approximated by the formula of Girolami.</p> <p>Reference: Girolami, G. S.: A Simple 'Back of the Envelope' Method for Estimating the Densities and Molecular Volumes of Liquids and Solids, J. Chem. Educ., 71(11), 962, doi:10.1021/ed071p962, 1994.</p>"},{"location":"API/particula/activity/species_density/#arguments","title":"Arguments","text":"<ul> <li><code>molar_mass(float)</code> - Molar mass.</li> <li><code>oxygen2carbon</code> float - O:C ratio.</li> <li><code>hydrogen2carbon</code> float - H:C ratio. If unknown, provide a negative     value.</li> <li><code>nitrogen2carbon</code> float, optional - N:C ratio. Defaults to None.</li> </ul>"},{"location":"API/particula/activity/species_density/#returns","title":"Returns","text":"<ul> <li><code>densityEst</code> float - Estimated density in g/cm^3.</li> </ul>"},{"location":"API/particula/activity/species_density/#signature_1","title":"Signature","text":"<pre><code>def organic_density_estimate(\n    molar_mass,\n    oxygen2carbon,\n    hydrogen2carbon=None,\n    nitrogen2carbon=None,\n    mass_ratio_convert=False,\n): ...\n</code></pre>"},{"location":"API/particula/activity/water_activity/","title":"Water Activity","text":"<p>Particula Index / Particula / Activity / Water Activity</p> <p>Auto-generated documentation for particula.activity.water_activity module.</p>"},{"location":"API/particula/activity/water_activity/#biphasic_water_activity_point","title":"biphasic_water_activity_point","text":"<p>Show source in water_activity.py:24</p> <p>This function computes the biphasic to single phase water activity (RH*100).</p>"},{"location":"API/particula/activity/water_activity/#arguments","title":"Arguments","text":"<ul> <li>oxygen2carbon : The oxygen to carbon ratio.</li> <li>hydrogen2carbon : The hydrogen to carbon ratio.</li> <li>molar_mass_ratio : The molar mass ratio of water to organic   matter.</li> <li>functional_group : Optional functional group(s) of the organic   compound, if applicable.</li> </ul>"},{"location":"API/particula/activity/water_activity/#returns","title":"Returns","text":"<ul> <li>The RH cross point array.</li> </ul>"},{"location":"API/particula/activity/water_activity/#signature","title":"Signature","text":"<pre><code>def biphasic_water_activity_point(\n    oxygen2carbon: Union[float, NDArray[np.float64]],\n    hydrogen2carbon: Union[float, NDArray[np.float64]],\n    molar_mass_ratio: Union[float, NDArray[np.float64]],\n    functional_group: Optional[Union[list[str], str]] = None,\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/activity/water_activity/#fixed_water_activity","title":"fixed_water_activity","text":"<p>Show source in water_activity.py:93</p> <p>Calculate the activity coefficients of water and organic matter in organic-water mixtures.</p> <p>This function assumes a fixed water activity value (e.g., RH = 75% corresponds to 0.75 water activity in equilibrium). It calculates the activity coefficients for different phases and determines phase separations if they occur.</p>"},{"location":"API/particula/activity/water_activity/#arguments_1","title":"Arguments","text":"<ul> <li>water_activity : An array of water activity values.</li> <li>molar_mass_ratio : Array of molar mass ratios of the components.</li> <li>oxygen2carbon : Array of oxygen-to-carbon ratios.</li> <li>density : Array of densities of the mixture, in kg/m^3.</li> </ul>"},{"location":"API/particula/activity/water_activity/#returns_1","title":"Returns","text":"<ul> <li>A tuple containing the activity coefficients for alpha and beta   phases, and the q_alpha (phase separation) value.   If no phase separation occurs, the beta phase values are None.</li> </ul>"},{"location":"API/particula/activity/water_activity/#signature_1","title":"Signature","text":"<pre><code>def fixed_water_activity(\n    water_activity: Union[float, NDArray[np.float64]],\n    molar_mass_ratio: Union[float, NDArray[np.float64]],\n    oxygen2carbon: Union[float, NDArray[np.float64]],\n    density: Union[float, NDArray[np.float64]],\n) -&gt; Tuple[\n    Union[float, NDArray[np.float64]],\n    Union[float, NDArray[np.float64]],\n    Union[float, NDArray[np.float64]],\n]: ...\n</code></pre>"},{"location":"API/particula/dynamics/","title":"Dynamics","text":"<p>Particula Index / Particula / Dynamics</p> <p>Auto-generated documentation for particula.dynamics module.</p>"},{"location":"API/particula/dynamics/#modules","title":"Modules","text":"<ul> <li>Coagulation</li> <li>Condensation</li> <li>Dilution</li> <li>Particle Process</li> <li>Properties</li> <li>Wall Loss</li> </ul>"},{"location":"API/particula/dynamics/dilution/","title":"Dilution","text":"<p>Particula Index / Particula / Dynamics / Dilution</p> <p>Auto-generated documentation for particula.dynamics.dilution module.</p>"},{"location":"API/particula/dynamics/dilution/#dilution_rate","title":"dilution_rate","text":"<p>Show source in dilution.py:49</p> <p>Calculate the dilution rate of a substance.</p> <p>The dilution rate quantifies the rate at which the concentration of a substance decreases due to dilution, based on the volume dilution coefficient and the current concentration of the substance.</p>"},{"location":"API/particula/dynamics/dilution/#arguments","title":"Arguments","text":"<ul> <li><code>coefficient</code> - The volume dilution coefficient in inverse seconds (s\u207b\u00b9).</li> <li><code>concentration</code> - The concentration of the substance in the system     in particles per cubic meter (#/m\u00b3) or any other relevant units.</li> </ul>"},{"location":"API/particula/dynamics/dilution/#returns","title":"Returns","text":"<p>The dilution rate, which is the rate of decrease in concentration in inverse seconds (s\u207b\u00b9). The value is returned as negative, indicating a reduction in concentration over time.</p>"},{"location":"API/particula/dynamics/dilution/#examples","title":"Examples","text":"float input<pre><code>dilution_rate(\n    coefficient=0.01,\n    concentration=100,\n)\n# Returns -1.0\n</code></pre> array input<pre><code>dilution_rate(\n    coefficient=0.01,\n    concentration=np.array([100, 200, 300]),\n)\n# Returns array([-1., -2., -3.])\n</code></pre>"},{"location":"API/particula/dynamics/dilution/#signature","title":"Signature","text":"<pre><code>def dilution_rate(\n    coefficient: Union[float, NDArray[np.float64]],\n    concentration: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/dilution/#volume_dilution_coefficient","title":"volume_dilution_coefficient","text":"<p>Show source in dilution.py:10</p> <p>Calculate the volume dilution coefficient.</p> <p>The volume dilution coefficient is a measure of how quickly a substance is diluted within a given volume due to an incoming flow. It is defined as the ratio of the flow rate to the volume.</p>"},{"location":"API/particula/dynamics/dilution/#arguments_1","title":"Arguments","text":"<ul> <li><code>volume</code> - The volume of the system in cubic meters (m\u00b3).</li> <li><code>input_flow_rate</code> - The flow rate of the substance entering the system     in cubic meters per second (m\u00b3/s).</li> </ul>"},{"location":"API/particula/dynamics/dilution/#returns_1","title":"Returns","text":"<p>The volume dilution coefficient in inverse seconds (s\u207b\u00b9).</p>"},{"location":"API/particula/dynamics/dilution/#examples_1","title":"Examples","text":"float input<pre><code>volume_dilution_coefficient(\n    volume=10,\n    input_flow_rate=0.1,\n)\n# Returns 0.01\n</code></pre> array input<pre><code>volume_dilution_coefficient(\n    volume=np.array([10, 20, 30]),\n    input_flow_rate=np.array([0.1, 0.2, 0.3]),\n)\n# Returns array([0.01, 0.01, 0.01])\n</code></pre>"},{"location":"API/particula/dynamics/dilution/#signature_1","title":"Signature","text":"<pre><code>def volume_dilution_coefficient(\n    volume: Union[float, NDArray[np.float64]],\n    input_flow_rate: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/particle_process/","title":"Particle Process","text":"<p>Particula Index / Particula / Dynamics / Particle Process</p> <p>Auto-generated documentation for particula.dynamics.particle_process module.</p>"},{"location":"API/particula/dynamics/particle_process/#coagulation","title":"Coagulation","text":"<p>Show source in particle_process.py:92</p> <p>A class for running a coagulation strategy.</p>"},{"location":"API/particula/dynamics/particle_process/#arguments","title":"Arguments","text":"<ul> <li><code>coagulation_strategy</code> CoagulationStrategy - The coagulation strategy to     use.</li> </ul>"},{"location":"API/particula/dynamics/particle_process/#methods","title":"Methods","text":"<ul> <li><code>execute</code> - Execute the coagulation process.</li> <li><code>rate</code> - Calculate the rate of coagulation for each particle.</li> </ul>"},{"location":"API/particula/dynamics/particle_process/#signature","title":"Signature","text":"<pre><code>class Coagulation(Runnable):\n    def __init__(self, coagulation_strategy: CoagulationStrategy): ...\n</code></pre>"},{"location":"API/particula/dynamics/particle_process/#see-also","title":"See also","text":"<ul> <li>CoagulationStrategy</li> <li>Runnable</li> </ul>"},{"location":"API/particula/dynamics/particle_process/#coagulationexecute","title":"Coagulation().execute","text":"<p>Show source in particle_process.py:108</p> <p>Execute the coagulation process.</p>"},{"location":"API/particula/dynamics/particle_process/#arguments_1","title":"Arguments","text":"<ul> <li><code>aerosol</code> Aerosol - The aerosol instance to modify.</li> </ul>"},{"location":"API/particula/dynamics/particle_process/#signature_1","title":"Signature","text":"<pre><code>def execute(self, aerosol: Aerosol, time_step: float, sub_steps: int = 1) -&gt; Aerosol: ...\n</code></pre>"},{"location":"API/particula/dynamics/particle_process/#see-also_1","title":"See also","text":"<ul> <li>Aerosol</li> </ul>"},{"location":"API/particula/dynamics/particle_process/#coagulationrate","title":"Coagulation().rate","text":"<p>Show source in particle_process.py:129</p> <p>Calculate the rate of coagulation for each particle.</p>"},{"location":"API/particula/dynamics/particle_process/#arguments_2","title":"Arguments","text":"<ul> <li><code>aerosol</code> Aerosol - The aerosol instance to modify.</li> </ul>"},{"location":"API/particula/dynamics/particle_process/#returns","title":"Returns","text":"<ul> <li><code>np.ndarray</code> - An array of coagulation rates for each particle.</li> </ul>"},{"location":"API/particula/dynamics/particle_process/#signature_2","title":"Signature","text":"<pre><code>def rate(self, aerosol: Aerosol) -&gt; Any: ...\n</code></pre>"},{"location":"API/particula/dynamics/particle_process/#see-also_2","title":"See also","text":"<ul> <li>Aerosol</li> </ul>"},{"location":"API/particula/dynamics/particle_process/#masscondensation","title":"MassCondensation","text":"<p>Show source in particle_process.py:17</p> <p>A class for running a mass condensation process.</p>"},{"location":"API/particula/dynamics/particle_process/#arguments_3","title":"Arguments","text":"<ul> <li><code>condensation_strategy</code> CondensationStrategy - The condensation strategy     to use.</li> </ul>"},{"location":"API/particula/dynamics/particle_process/#methods_1","title":"Methods","text":"<ul> <li><code>execute</code> - Execute the mass condensation process.</li> <li><code>rate</code> - Calculate the rate of mass condensation for each particle due to     each condensable gas species.</li> </ul>"},{"location":"API/particula/dynamics/particle_process/#signature_3","title":"Signature","text":"<pre><code>class MassCondensation(Runnable):\n    def __init__(self, condensation_strategy: CondensationStrategy): ...\n</code></pre>"},{"location":"API/particula/dynamics/particle_process/#see-also_3","title":"See also","text":"<ul> <li>CondensationStrategy</li> <li>Runnable</li> </ul>"},{"location":"API/particula/dynamics/particle_process/#masscondensationexecute","title":"MassCondensation().execute","text":"<p>Show source in particle_process.py:34</p> <p>Execute the mass condensation process.</p>"},{"location":"API/particula/dynamics/particle_process/#arguments_4","title":"Arguments","text":"<ul> <li><code>aerosol</code> Aerosol - The aerosol instance to modify.</li> </ul>"},{"location":"API/particula/dynamics/particle_process/#signature_4","title":"Signature","text":"<pre><code>def execute(self, aerosol: Aerosol, time_step: float, sub_steps: int = 1) -&gt; Aerosol: ...\n</code></pre>"},{"location":"API/particula/dynamics/particle_process/#see-also_4","title":"See also","text":"<ul> <li>Aerosol</li> </ul>"},{"location":"API/particula/dynamics/particle_process/#masscondensationrate","title":"MassCondensation().rate","text":"<p>Show source in particle_process.py:61</p> <p>Calculate the rate of mass condensation for each particle due to each condensable gas species.</p>"},{"location":"API/particula/dynamics/particle_process/#arguments_5","title":"Arguments","text":"<ul> <li><code>aerosol</code> Aerosol - The aerosol instance to modify.</li> </ul>"},{"location":"API/particula/dynamics/particle_process/#returns_1","title":"Returns","text":"<ul> <li><code>np.ndarray</code> - An array of condensation rates for each particle.</li> </ul>"},{"location":"API/particula/dynamics/particle_process/#signature_5","title":"Signature","text":"<pre><code>def rate(self, aerosol: Aerosol) -&gt; Any: ...\n</code></pre>"},{"location":"API/particula/dynamics/particle_process/#see-also_5","title":"See also","text":"<ul> <li>Aerosol</li> </ul>"},{"location":"API/particula/dynamics/wall_loss/","title":"Wall Loss","text":"<p>Particula Index / Particula / Dynamics / Wall Loss</p> <p>Auto-generated documentation for particula.dynamics.wall_loss module.</p>"},{"location":"API/particula/dynamics/wall_loss/#rectangle_wall_loss_rate","title":"rectangle_wall_loss_rate","text":"<p>Show source in wall_loss.py:65</p> <p>Calculate the wall loss rate of particles in a rectangular chamber.</p> <p>This function computes the rate at which particles are lost to the walls of a rectangular chamber, based on the system state. It uses the wall eddy diffusivity, particle properties (radius, density, concentration), and environmental conditions (temperature, pressure) to determine the loss rate. The chamber dimensions (length, width, height) are also taken into account.</p>"},{"location":"API/particula/dynamics/wall_loss/#arguments","title":"Arguments","text":"<ul> <li><code>wall_eddy_diffusivity</code> - The rate of wall eddy diffusivity in inverse     seconds (s\u207b\u00b9).</li> <li><code>particle_radius</code> - The radius of the particle in meters (m).</li> <li><code>particle_density</code> - The density of the particle in kilograms per cubic     meter (kg/m\u00b3).</li> <li><code>particle_concentration</code> - The concentration of particles in the chamber     in particles per cubic meter (#/m\u00b3).</li> <li><code>temperature</code> - The temperature of the system in Kelvin (K).</li> <li><code>pressure</code> - The pressure of the system in Pascals (Pa).</li> <li><code>chamber_dimensions</code> - A tuple containing the length, width, and height     of the rectangular chamber in meters (m).</li> </ul>"},{"location":"API/particula/dynamics/wall_loss/#returns","title":"Returns","text":"<p>The wall loss rate of the particles in the chamber.</p>"},{"location":"API/particula/dynamics/wall_loss/#signature","title":"Signature","text":"<pre><code>def rectangle_wall_loss_rate(\n    wall_eddy_diffusivity: float,\n    particle_radius: Union[float, NDArray[np.float64]],\n    particle_density: Union[float, NDArray[np.float64]],\n    particle_concentration: Union[float, NDArray[np.float64]],\n    temperature: float,\n    pressure: float,\n    chamber_dimensions: Tuple[float, float, float],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/wall_loss/#spherical_wall_loss_rate","title":"spherical_wall_loss_rate","text":"<p>Show source in wall_loss.py:16</p> <p>Calculate the wall loss rate of particles in a spherical chamber.</p> <p>This function computes the rate at which particles are lost to the walls of a spherical chamber, based on the system state. It uses the wall eddy diffusivity, particle properties (radius, density, concentration), and environmental conditions (temperature, pressure) to determine the loss rate.</p>"},{"location":"API/particula/dynamics/wall_loss/#arguments_1","title":"Arguments","text":"<ul> <li><code>wall_eddy_diffusivity</code> - The rate of wall eddy diffusivity in inverse     seconds (s\u207b\u00b9).</li> <li><code>particle_radius</code> - The radius of the particle in meters (m).</li> <li><code>particle_density</code> - The density of the particle in kilograms per cubic     meter (kg/m\u00b3).</li> <li><code>particle_concentration</code> - The concentration of particles in the chamber     in particles per cubic meter (#/m\u00b3).</li> <li><code>temperature</code> - The temperature of the system in Kelvin (K).</li> <li><code>pressure</code> - The pressure of the system in Pascals (Pa).</li> <li><code>chamber_radius</code> - The radius of the spherical chamber in meters (m).</li> </ul>"},{"location":"API/particula/dynamics/wall_loss/#returns_1","title":"Returns","text":"<p>The wall loss rate of the particles in the chamber.</p>"},{"location":"API/particula/dynamics/wall_loss/#signature_1","title":"Signature","text":"<pre><code>def spherical_wall_loss_rate(\n    wall_eddy_diffusivity: float,\n    particle_radius: Union[float, NDArray[np.float64]],\n    particle_density: Union[float, NDArray[np.float64]],\n    particle_concentration: Union[float, NDArray[np.float64]],\n    temperature: float,\n    pressure: float,\n    chamber_radius: float,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/","title":"Coagulation","text":"<p>Particula Index / Particula / Dynamics / Coagulation</p> <p>Auto-generated documentation for particula.dynamics.coagulation module.</p>"},{"location":"API/particula/dynamics/coagulation/#modules","title":"Modules","text":"<ul> <li>Brownian Kernel</li> <li>Kernel</li> <li>Particle Resolved Method</li> <li>Rate</li> <li>Strategy</li> <li>Super Droplet Method</li> <li>Transition Regime</li> </ul>"},{"location":"API/particula/dynamics/coagulation/brownian_kernel/","title":"Brownian Kernel","text":"<p>Particula Index / Particula / Dynamics / Coagulation / Brownian Kernel</p> <p>Auto-generated documentation for particula.dynamics.coagulation.brownian_kernel module.</p>"},{"location":"API/particula/dynamics/coagulation/brownian_kernel/#brownian_coagulation_kernel","title":"brownian_coagulation_kernel","text":"<p>Show source in brownian_kernel.py:109</p> <p>Returns the Brownian coagulation kernel for aerosol particles. Defined as the product of the diffusivity of the particles, the collection term <code>g</code>, and the radius of the particles.</p>"},{"location":"API/particula/dynamics/coagulation/brownian_kernel/#args","title":"Args","text":"<p>radius_particle : The radius of the particles [m]. diffusivity_particle : The diffusivity of the particles [m^2/s]. g_collection_term_particle : The collection term for Brownian coagulation [dimensionless]. alpha_collision_efficiency : The collision efficiency of the particles [dimensionless].</p>"},{"location":"API/particula/dynamics/coagulation/brownian_kernel/#returns","title":"Returns","text":"<p>Square matrix of Brownian coagulation kernel for aerosol particles [m^3/s].</p>"},{"location":"API/particula/dynamics/coagulation/brownian_kernel/#references","title":"References","text":"<p>Seinfeld, J. H., &amp; Pandis, S. N. (2016). Atmospheric chemistry and physics, Section 13 TABLE 13.1 Fuchs Form of the Brownian Coagulation Coefficient K12 (with alpha collision efficiency term 13.56)</p>"},{"location":"API/particula/dynamics/coagulation/brownian_kernel/#signature","title":"Signature","text":"<pre><code>def brownian_coagulation_kernel(\n    radius_particle: Union[float, NDArray[np.float64]],\n    diffusivity_particle: Union[float, NDArray[np.float64]],\n    g_collection_term_particle: Union[float, NDArray[np.float64]],\n    mean_thermal_speed_particle: Union[float, NDArray[np.float64]],\n    alpha_collision_efficiency: Union[float, NDArray[np.float64]] = 1.0,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/brownian_kernel/#brownian_coagulation_kernel_via_system_state","title":"brownian_coagulation_kernel_via_system_state","text":"<p>Show source in brownian_kernel.py:178</p> <p>Returns the Brownian coagulation kernel for aerosol particles, calculating the intermediate properties needed.</p>"},{"location":"API/particula/dynamics/coagulation/brownian_kernel/#arguments","title":"Arguments","text":"<p>radius_particle : The radius of the particles [m]. mass_particle : The mass of the particles [kg]. temperature : The temperature of the air [K]. pressure : The pressure of the air [Pa]. alpha_collision_efficiency : The collision efficiency of the particles     [dimensionless].</p>"},{"location":"API/particula/dynamics/coagulation/brownian_kernel/#returns_1","title":"Returns","text":"<p>Square matrix of Brownian coagulation kernel for aerosol particles     [m^3/s].</p>"},{"location":"API/particula/dynamics/coagulation/brownian_kernel/#references_1","title":"References","text":"<p>Seinfeld, J. H., &amp; Pandis, S. N. (2016). Atmospheric chemistry and physics, Section 13 TABLE 13.1 Fuchs Form of the Brownian Coagulation Coefficient K12.</p>"},{"location":"API/particula/dynamics/coagulation/brownian_kernel/#signature_1","title":"Signature","text":"<pre><code>def brownian_coagulation_kernel_via_system_state(\n    radius_particle: Union[float, NDArray[np.float64]],\n    mass_particle: Union[float, NDArray[np.float64]],\n    temperature: float,\n    pressure: float,\n    alpha_collision_efficiency: Union[float, NDArray[np.float64]] = 1.0,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/brownian_kernel/#brownian_diffusivity","title":"brownian_diffusivity","text":"<p>Show source in brownian_kernel.py:83</p> <p>Returns the diffusivity of the particles due to Brownian motion</p> <p>THis is just the scaled aerodynamic mobility of the particles.</p>"},{"location":"API/particula/dynamics/coagulation/brownian_kernel/#args_1","title":"Args","text":"<ul> <li>temperature : The temperature of the air [K].</li> <li>aerodynamic_mobility : The aerodynamic mobility of the particles [m^2/s].</li> </ul>"},{"location":"API/particula/dynamics/coagulation/brownian_kernel/#returns_2","title":"Returns","text":"<p>The diffusivity of the particles due to Brownian motion [m^2/s].</p>"},{"location":"API/particula/dynamics/coagulation/brownian_kernel/#references_2","title":"References","text":"<p>Seinfeld, J. H., &amp; Pandis, S. N. (2016). Atmospheric chemistry and physics, Section 13 TABLE 13.1 Fuchs Form of the Brownian Coagulation Coefficient K12</p>"},{"location":"API/particula/dynamics/coagulation/brownian_kernel/#signature_2","title":"Signature","text":"<pre><code>def brownian_diffusivity(\n    temperature: Union[float, NDArray[np.float64]],\n    aerodynamic_mobility: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/brownian_kernel/#g_collection_term","title":"g_collection_term","text":"<p>Show source in brownian_kernel.py:49</p> <p>Returns the <code>g</code> collection term for Brownian coagulation.</p> <p>Defined as the ratio of the mean free path of the particles to the radius of the particles.</p>"},{"location":"API/particula/dynamics/coagulation/brownian_kernel/#args_2","title":"Args","text":"<p>mean_free_path_particle : The mean free path of the particles [m]. radius_particle : The radius of the particles [m].</p>"},{"location":"API/particula/dynamics/coagulation/brownian_kernel/#returns_3","title":"Returns","text":"<p>The collection term for Brownian coagulation [dimensionless].</p>"},{"location":"API/particula/dynamics/coagulation/brownian_kernel/#references_3","title":"References","text":"<p>Seinfeld, J. H., &amp; Pandis, S. N. (2016). Atmospheric chemistry and physics, Section 13 TABLE 13.1 Fuchs Form of the Brownian Coagulation Coefficient K12</p> <p>The np.sqrt(2) term appears to be an error in the text, as the term is not used in the second edition of the book. And when it it is used, the values are too small, by about 2x.</p>"},{"location":"API/particula/dynamics/coagulation/brownian_kernel/#signature_3","title":"Signature","text":"<pre><code>def g_collection_term(\n    mean_free_path_particle: Union[float, NDArray[np.float64]],\n    radius_particle: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/brownian_kernel/#mean_free_path_l","title":"mean_free_path_l","text":"<p>Show source in brownian_kernel.py:18</p> <p>Calculate the mean free path of particles for coagulation.</p> <p>Calculate the mean free path of particles, defined for Brownian coagulation as the ratio of the diffusivity of the particles to their mean thermal speed. This parameter is crucial for understanding particle dynamics in a fluid.</p>"},{"location":"API/particula/dynamics/coagulation/brownian_kernel/#arguments_1","title":"Arguments","text":"<ul> <li>diffusivity_particle : The diffusivity of the particles [m^2/s].</li> <li>mean_thermal_speed_particle : The mean thermal speed of the particles [m/s].</li> </ul>"},{"location":"API/particula/dynamics/coagulation/brownian_kernel/#returns_4","title":"Returns","text":"<p>The mean free path of the particles [m].</p>"},{"location":"API/particula/dynamics/coagulation/brownian_kernel/#references_4","title":"References","text":"<p>Seinfeld, J. H., &amp; Pandis, S. N. (2016). Atmospheric chemistry and physics, Section 13 TABLE 13.1 Fuchs Form of the Brownian Coagulation Coefficient K12.</p>"},{"location":"API/particula/dynamics/coagulation/brownian_kernel/#signature_4","title":"Signature","text":"<pre><code>def mean_free_path_l(\n    diffusivity_particle: Union[float, NDArray[np.float64]],\n    mean_thermal_speed_particle: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/kernel/","title":"Kernel","text":"<p>Particula Index / Particula / Dynamics / Coagulation / Kernel</p> <p>Auto-generated documentation for particula.dynamics.coagulation.kernel module.</p>"},{"location":"API/particula/dynamics/coagulation/kernel/#coulombdyachkov2007","title":"CoulombDyachkov2007","text":"<p>Show source in kernel.py:130</p> <p>Dyachkov et al. (2007) approximation for the dimensionless coagulation kernel. Accounts for the Coulomb potential between particles.</p>"},{"location":"API/particula/dynamics/coagulation/kernel/#references","title":"References","text":"<ul> <li>Dyachkov, S. A., Kustova, E. V., &amp; Kustov, A. V. (2007). Coagulation of particles in the transition regime: The effect of the Coulomb potential. Journal of Chemical Physics, 126(12). https://doi.org/10.1063/1.2713719</li> </ul>"},{"location":"API/particula/dynamics/coagulation/kernel/#signature","title":"Signature","text":"<pre><code>class CoulombDyachkov2007(KernelStrategy): ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/kernel/#see-also","title":"See also","text":"<ul> <li>KernelStrategy</li> </ul>"},{"location":"API/particula/dynamics/coagulation/kernel/#coulombdyachkov2007dimensionless","title":"CoulombDyachkov2007().dimensionless","text":"<p>Show source in kernel.py:143</p>"},{"location":"API/particula/dynamics/coagulation/kernel/#signature_1","title":"Signature","text":"<pre><code>def dimensionless(\n    self,\n    diffusive_knudsen: NDArray[np.float64],\n    coulomb_potential_ratio: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/kernel/#coulombgatti2008","title":"CoulombGatti2008","text":"<p>Show source in kernel.py:153</p> <p>Gatti and Kortshagen (2008) approximation for the dimensionless coagulation kernel. Accounts for the Coulomb potential between particles.</p>"},{"location":"API/particula/dynamics/coagulation/kernel/#references_1","title":"References","text":"<ul> <li>Gatti, M., &amp; Kortshagen, U. (2008). Analytical model of particle charging in plasmas over a wide range of collisionality. Physical Review E - Statistical, Nonlinear, and Soft Matter Physics, 78(4). https://doi.org/10.1103/PhysRevE.78.046402</li> </ul>"},{"location":"API/particula/dynamics/coagulation/kernel/#signature_2","title":"Signature","text":"<pre><code>class CoulombGatti2008(KernelStrategy): ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/kernel/#see-also_1","title":"See also","text":"<ul> <li>KernelStrategy</li> </ul>"},{"location":"API/particula/dynamics/coagulation/kernel/#coulombgatti2008dimensionless","title":"CoulombGatti2008().dimensionless","text":"<p>Show source in kernel.py:166</p>"},{"location":"API/particula/dynamics/coagulation/kernel/#signature_3","title":"Signature","text":"<pre><code>def dimensionless(\n    self,\n    diffusive_knudsen: NDArray[np.float64],\n    coulomb_potential_ratio: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/kernel/#coulombgopalakrishnan2012","title":"CoulombGopalakrishnan2012","text":"<p>Show source in kernel.py:176</p> <p>Gopalakrishnan and Hogan (2012) approximation for the dimensionless coagulation kernel. Accounts for the Coulomb potential between particles.</p>"},{"location":"API/particula/dynamics/coagulation/kernel/#references_2","title":"References","text":"<ul> <li>Gopalakrishnan, R., &amp; Hogan, C. J. (2012). Coulomb-influenced collisions in aerosols and dusty plasmas. Physical Review E - Statistical, Nonlinear, and Soft Matter Physics, 85(2). https://doi.org/10.1103/PhysRevE.85.026410</li> </ul>"},{"location":"API/particula/dynamics/coagulation/kernel/#signature_4","title":"Signature","text":"<pre><code>class CoulombGopalakrishnan2012(KernelStrategy): ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/kernel/#see-also_2","title":"See also","text":"<ul> <li>KernelStrategy</li> </ul>"},{"location":"API/particula/dynamics/coagulation/kernel/#coulombgopalakrishnan2012dimensionless","title":"CoulombGopalakrishnan2012().dimensionless","text":"<p>Show source in kernel.py:189</p>"},{"location":"API/particula/dynamics/coagulation/kernel/#signature_5","title":"Signature","text":"<pre><code>def dimensionless(\n    self,\n    diffusive_knudsen: NDArray[np.float64],\n    coulomb_potential_ratio: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/kernel/#coulumbchahl2019","title":"CoulumbChahl2019","text":"<p>Show source in kernel.py:199</p> <p>Chahl and Gopalakrishnan (2019) approximation for the dimensionless coagulation kernel. Accounts for the Coulomb potential between particles.</p>"},{"location":"API/particula/dynamics/coagulation/kernel/#references_3","title":"References","text":"<ul> <li>Chahl, H. S., &amp; Gopalakrishnan, R. (2019). High potential, near free molecular regime Coulombic collisions in aerosols and dusty plasmas. Aerosol Science and Technology, 53(8), 933-957. https://doi.org/10.1080/02786826.2019.1614522</li> </ul>"},{"location":"API/particula/dynamics/coagulation/kernel/#signature_6","title":"Signature","text":"<pre><code>class CoulumbChahl2019(KernelStrategy): ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/kernel/#see-also_3","title":"See also","text":"<ul> <li>KernelStrategy</li> </ul>"},{"location":"API/particula/dynamics/coagulation/kernel/#coulumbchahl2019dimensionless","title":"CoulumbChahl2019().dimensionless","text":"<p>Show source in kernel.py:212</p>"},{"location":"API/particula/dynamics/coagulation/kernel/#signature_7","title":"Signature","text":"<pre><code>def dimensionless(\n    self,\n    diffusive_knudsen: NDArray[np.float64],\n    coulomb_potential_ratio: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/kernel/#hardsphere","title":"HardSphere","text":"<p>Show source in kernel.py:117</p> <p>Hard sphere dimensionless coagulation strategy.</p>"},{"location":"API/particula/dynamics/coagulation/kernel/#signature_8","title":"Signature","text":"<pre><code>class HardSphere(KernelStrategy): ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/kernel/#see-also_4","title":"See also","text":"<ul> <li>KernelStrategy</li> </ul>"},{"location":"API/particula/dynamics/coagulation/kernel/#hardspheredimensionless","title":"HardSphere().dimensionless","text":"<p>Show source in kernel.py:122</p>"},{"location":"API/particula/dynamics/coagulation/kernel/#signature_9","title":"Signature","text":"<pre><code>def dimensionless(\n    self, diffusive_knudsen: NDArray[np.float64], coulomb_potential_ratio: ignore\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/kernel/#kernelstrategy","title":"KernelStrategy","text":"<p>Show source in kernel.py:12</p> <p>Abstract class for dimensionless coagulation strategies. This class defines the dimensionless kernel (H) method that must be implemented by any dimensionless coagulation strategy.</p>"},{"location":"API/particula/dynamics/coagulation/kernel/#methods","title":"Methods","text":"<ul> <li>dimensionless (abstractmethod): Calculate the dimensionless coagulation kernel.</li> <li><code>-</code> kernel - Calculate the dimensioned coagulation kernel.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/kernel/#signature_10","title":"Signature","text":"<pre><code>class KernelStrategy(ABC): ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/kernel/#kernelstrategydimensionless","title":"KernelStrategy().dimensionless","text":"<p>Show source in kernel.py:25</p> <p>Return the dimensionless coagulation kernel (H)</p>"},{"location":"API/particula/dynamics/coagulation/kernel/#arguments","title":"Arguments","text":"<ul> <li><code>-</code> diffusive_knudsen - The diffusive Knudsen number (K_nD) [dimensionless].</li> <li><code>-</code> coulomb_potential_ratio - The Coulomb potential ratio (phi_E) [dimensionless].</li> </ul>"},{"location":"API/particula/dynamics/coagulation/kernel/#returns","title":"Returns","text":"<p>The dimensionless coagulation kernel (H) [dimensionless].</p>"},{"location":"API/particula/dynamics/coagulation/kernel/#references_4","title":"References","text":"<ul> <li>Dyachkov, S. A., Kustova, E. V., &amp; Kustov, A. V. (2007). Coagulation of particles in the transition regime: The effect of the Coulomb potential. Journal of Chemical Physics, 126(12). https://doi.org/10.1063/1.2713719</li> <li>Gatti, M., &amp; Kortshagen, U. (2008). Analytical model of particle charging in plasmas over a wide range of collisionality. Physical Review E - Statistical, Nonlinear, and Soft Matter Physics, 78(4). https://doi.org/10.1103/PhysRevE.78.046402</li> <li>Gopalakrishnan, R., &amp; Hogan, C. J. (2011). Determination of the transition regime collision kernel from mean first passage times. Aerosol Science and Technology, 45(12), 1499-1509. https://doi.org/10.1080/02786826.2011.601775</li> <li>Gopalakrishnan, R., &amp; Hogan, C. J. (2012). Coulomb-influenced collisions in aerosols and dusty plasmas. Physical Review E - Statistical, Nonlinear, and Soft Matter Physics, 85(2). https://doi.org/10.1103/PhysRevE.85.026410</li> <li>Chahl, H. S., &amp; Gopalakrishnan, R. (2019). High potential, near free molecular regime Coulombic collisions in aerosols and dusty plasmas. Aerosol Science and Technology, 53(8), 933-957. https://doi.org/10.1080/02786826.2019.1614522</li> </ul>"},{"location":"API/particula/dynamics/coagulation/kernel/#signature_11","title":"Signature","text":"<pre><code>@abstractmethod\ndef dimensionless(\n    self,\n    diffusive_knudsen: NDArray[np.float64],\n    coulomb_potential_ratio: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/kernel/#kernelstrategykernel","title":"KernelStrategy().kernel","text":"<p>Show source in kernel.py:68</p> <p>The dimensioned coagulation kernel for each particle pair, calculated from the dimensionless coagulation kernel and the reduced quantities. All inputs are square matrices, for all particle-particle interactions.</p>"},{"location":"API/particula/dynamics/coagulation/kernel/#arguments_1","title":"Arguments","text":"<ul> <li><code>-</code> dimensionless_kernel - The dimensionless coagulation kernel [dimensionless].</li> <li><code>-</code> coulomb_potential_ratio - The Coulomb potential ratio [dimensionless].</li> <li><code>-</code> sum_of_radii - The sum of the radii of the particles [m].</li> <li><code>-</code> reduced_mass - The reduced mass of the particles [kg].</li> <li><code>-</code> reduced_friction_factor - The reduced friction factor of the particles [dimensionless].</li> </ul>"},{"location":"API/particula/dynamics/coagulation/kernel/#returns_1","title":"Returns","text":"<p>The dimensioned coagulation kernel, as a square matrix, of all particle-particle interactions [m^3/s].</p> <p>Check, were the /s comes from.</p>"},{"location":"API/particula/dynamics/coagulation/kernel/#references_5","title":"References","text":""},{"location":"API/particula/dynamics/coagulation/kernel/#signature_12","title":"Signature","text":"<pre><code>def kernel(\n    self,\n    dimensionless_kernel: NDArray[np.float64],\n    coulomb_potential_ratio: NDArray[np.float64],\n    sum_of_radii: NDArray[np.float64],\n    reduced_mass: NDArray[np.float64],\n    reduced_friction_factor: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/particle_resolved_method/","title":"Particle Resolved Method","text":"<p>Particula Index / Particula / Dynamics / Coagulation / Particle Resolved Method</p> <p>Auto-generated documentation for particula.dynamics.coagulation.particle_resolved_method module.</p>"},{"location":"API/particula/dynamics/coagulation/particle_resolved_method/#calculate_probabilities","title":"calculate_probabilities","text":"<p>Show source in particle_resolved_method.py:33</p> <p>Calculate coagulation probabilities based on kernel values and system parameters.</p>"},{"location":"API/particula/dynamics/coagulation/particle_resolved_method/#arguments","title":"Arguments","text":"<ul> <li><code>kernel_values</code> float - Interpolated kernel value for a particle pair.</li> <li><code>time_step</code> float - The time step over which coagulation occurs.</li> <li><code>events</code> int - Number of possible coagulation events.</li> <li><code>tests</code> int - Number of tests (or trials) for coagulation.</li> <li><code>volume</code> float - Volume of the system.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/particle_resolved_method/#returns","title":"Returns","text":"<ul> <li><code>float</code> - Coagulation probability.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/particle_resolved_method/#signature","title":"Signature","text":"<pre><code>def calculate_probabilities(\n    kernel_values: Union[float, NDArray[np.float64]],\n    time_step: float,\n    events: int,\n    tests: int,\n    volume: float,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/particle_resolved_method/#interpolate_kernel","title":"interpolate_kernel","text":"<p>Show source in particle_resolved_method.py:15</p> <p>Create a 2D interpolation function for the coagulation kernel.</p>"},{"location":"API/particula/dynamics/coagulation/particle_resolved_method/#arguments_1","title":"Arguments","text":"<ul> <li><code>kernel</code> NDArray[np.float64] - Coagulation kernel.</li> <li><code>kernel_radius</code> NDArray[np.float64] - Radii corresponding to kernel     bins.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/particle_resolved_method/#returns_1","title":"Returns","text":"<ul> <li><code>RectBivariateSpline</code> - Interpolated kernel function.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/particle_resolved_method/#signature_1","title":"Signature","text":"<pre><code>def interpolate_kernel(\n    kernel: NDArray[np.float64], kernel_radius: NDArray[np.float64]\n) -&gt; RectBivariateSpline: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/particle_resolved_method/#particle_resolved_coagulation_step","title":"particle_resolved_coagulation_step","text":"<p>Show source in particle_resolved_method.py:141</p> <p>Perform a single step of particle coagulation, updating particle radii based on coagulation events.</p>"},{"location":"API/particula/dynamics/coagulation/particle_resolved_method/#arguments_2","title":"Arguments","text":"<ul> <li><code>particle_radius</code> NDArray[np.float64] - Array of particle radii.</li> <li><code>kernel</code> NDArray[np.float64] - Coagulation kernel as a 2D array where     each element represents the probability of coagulation between     particles of corresponding sizes.</li> <li><code>kernel_radius</code> NDArray[np.float64] - Array of radii corresponding to     the kernel bins.</li> <li><code>volume</code> float - Volume of the system in which coagulation occurs.</li> <li><code>time_step</code> float - Time step over which coagulation is calculated.</li> <li><code>random_generator</code> np.random.Generator - Random number generator for     stochastic processes.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/particle_resolved_method/#returns_2","title":"Returns","text":"<ul> <li><code>NDArray[np.int64]</code> - Array of indices corresponding to the coagulation     events, where each element is a pair of indices corresponding to     the coagulating particles [loss, gain].</li> </ul>"},{"location":"API/particula/dynamics/coagulation/particle_resolved_method/#signature_2","title":"Signature","text":"<pre><code>def particle_resolved_coagulation_step(\n    particle_radius: NDArray[np.float64],\n    kernel: NDArray[np.float64],\n    kernel_radius: NDArray[np.float64],\n    volume: float,\n    time_step: float,\n    random_generator: np.random.Generator,\n) -&gt; NDArray[np.int64]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/particle_resolved_method/#particle_resolved_update_step","title":"particle_resolved_update_step","text":"<p>Show source in particle_resolved_method.py:94</p> <p>Update the particle radii and concentrations after coagulation events.</p>"},{"location":"API/particula/dynamics/coagulation/particle_resolved_method/#arguments_3","title":"Arguments","text":"<ul> <li><code>particle_radius</code> NDArray[float64] - Array of particle radii.</li> <li><code>small_index</code> NDArray[int64] - Indices corresponding to smaller     particles.</li> <li><code>large_index</code> NDArray[int64] - Indices corresponding to larger     particles.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/particle_resolved_method/#returns_3","title":"Returns","text":"<ul> <li>Updated array of particle radii.</li> <li>Updated array for the radii of particles that were lost.</li> <li>Updated array for the radii of particles that were gained.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/particle_resolved_method/#signature_3","title":"Signature","text":"<pre><code>def particle_resolved_update_step(\n    particle_radius: NDArray[np.float64],\n    loss: NDArray[np.float64],\n    gain: NDArray[np.float64],\n    small_index: NDArray[np.int64],\n    large_index: NDArray[np.int64],\n) -&gt; Tuple[NDArray[np.float64], NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/particle_resolved_method/#resolve_final_coagulation_state","title":"resolve_final_coagulation_state","text":"<p>Show source in particle_resolved_method.py:57</p> <p>Resolve the final state of particles that have undergone multiple coagulation events.</p>"},{"location":"API/particula/dynamics/coagulation/particle_resolved_method/#arguments_4","title":"Arguments","text":"<ul> <li><code>small_indices</code> NDArray[np.int64] - Indices of smaller particles.</li> <li><code>large_indices</code> NDArray[np.int64] - Indices of larger particles.</li> <li><code>particle_radius</code> NDArray[np.float64] - Radii of particles.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/particle_resolved_method/#returns_4","title":"Returns","text":"<ul> <li><code>Tuple[NDArray[np.int64],</code> NDArray[np.int64]] - Updated small and large indices.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/particle_resolved_method/#signature_4","title":"Signature","text":"<pre><code>def resolve_final_coagulation_state(\n    small_indices: NDArray[np.int64],\n    large_indices: NDArray[np.int64],\n    particle_radius: NDArray[np.float64],\n) -&gt; Tuple[NDArray[np.int64], NDArray[np.int64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/rate/","title":"Rate","text":"<p>Particula Index / Particula / Dynamics / Coagulation / Rate</p> <p>Auto-generated documentation for particula.dynamics.coagulation.rate module.</p>"},{"location":"API/particula/dynamics/coagulation/rate/#continuous_gain","title":"continuous_gain","text":"<p>Show source in rate.py:120</p> <p>Calculate the coagulation gain rate, via the integration method.</p>"},{"location":"API/particula/dynamics/coagulation/rate/#arguments","title":"Arguments","text":"<p>radius : The radius of the particles. concentration : The distribution of particles. kernel : The coagulation kernel.</p>"},{"location":"API/particula/dynamics/coagulation/rate/#returns","title":"Returns","text":"<p>The coagulation gain rate.</p>"},{"location":"API/particula/dynamics/coagulation/rate/#references","title":"References","text":"<ul> <li>This equation necessitates the use of a for-loop due to the convoluted use of different radii at different stages. This is the most expensive step of all coagulation calculations. Using <code>RectBivariateSpline</code> accelerates this significantly.</li> <li>Note, to estimate the kernel and distribution at (other_radius**3 - some_radius**3)*(\u2153) we use interporlation techniques.</li> <li>Seinfeld, J. H., &amp; Pandis, S. (2016). Atmospheric chemistry and physics, Chapter 13 Equations 13.61</li> </ul>"},{"location":"API/particula/dynamics/coagulation/rate/#signature","title":"Signature","text":"<pre><code>def continuous_gain(\n    radius: Union[float, NDArray[np.float64]],\n    concentration: Union[float, NDArray[np.float64]],\n    kernel: NDArray[np.float64],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/rate/#continuous_loss","title":"continuous_loss","text":"<p>Show source in rate.py:96</p> <p>Calculate the coagulation loss rate, via the integration method.</p>"},{"location":"API/particula/dynamics/coagulation/rate/#arguments_1","title":"Arguments","text":"<p>radius : The radius of the particles. concentration : The distribution of particles. kernel : The coagulation kernel.</p>"},{"location":"API/particula/dynamics/coagulation/rate/#returns_1","title":"Returns","text":"<p>The coagulation loss rate.</p>"},{"location":"API/particula/dynamics/coagulation/rate/#references_1","title":"References","text":"<ul> <li>Seinfeld, J. H., &amp; Pandis, S. N. (2016). Atmospheric chemistry and     physics, Chapter 13 Equations 13.61</li> </ul>"},{"location":"API/particula/dynamics/coagulation/rate/#signature_1","title":"Signature","text":"<pre><code>def continuous_loss(\n    radius: Union[float, NDArray[np.float64]],\n    concentration: Union[float, NDArray[np.float64]],\n    kernel: NDArray[np.float64],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/rate/#discrete_gain","title":"discrete_gain","text":"<p>Show source in rate.py:40</p> <p>Calculate the coagulation gain rate, via the integration method, by converting to a continuous distribution.</p>"},{"location":"API/particula/dynamics/coagulation/rate/#arguments_2","title":"Arguments","text":"<p>radius : The radius of the particles. concentration : The distribution of particles. kernel : The coagulation kernel.</p>"},{"location":"API/particula/dynamics/coagulation/rate/#returns_2","title":"Returns","text":"<p>The coagulation gain rate.</p>"},{"location":"API/particula/dynamics/coagulation/rate/#references_2","title":"References","text":"<ul> <li>This equation necessitates the use of a for-loop due to the convoluted use of different radii at different stages. This is the most expensive step of all coagulation calculations. Using <code>RectBivariateSpline</code> accelerates this significantly.</li> <li>Note, to estimate the kernel and distribution at (other_radius**3 - some_radius**3)*(\u2153) we use interporlation techniques.</li> <li>Seinfeld, J. H., &amp; Pandis, S. (2016). Atmospheric chemistry and physics, Chapter 13 Equations 13.61</li> </ul>"},{"location":"API/particula/dynamics/coagulation/rate/#signature_2","title":"Signature","text":"<pre><code>def discrete_gain(\n    radius: Union[float, NDArray[np.float64]],\n    concentration: Union[float, NDArray[np.float64]],\n    kernel: NDArray[np.float64],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/rate/#discrete_loss","title":"discrete_loss","text":"<p>Show source in rate.py:19</p> <p>Calculate the coagulation loss rate, via the summation method.</p>"},{"location":"API/particula/dynamics/coagulation/rate/#arguments_3","title":"Arguments","text":"<p>concentraiton : The distribution of particles. kernel : The coagulation kernel.</p>"},{"location":"API/particula/dynamics/coagulation/rate/#returns_3","title":"Returns","text":"<p>The coagulation loss rate.</p>"},{"location":"API/particula/dynamics/coagulation/rate/#references_3","title":"References","text":"<p>Seinfeld, J. H., &amp; Pandis, S. N. (2016). Atmospheric chemistry and physics, Chapter 13 Equations 13.61</p>"},{"location":"API/particula/dynamics/coagulation/rate/#signature_3","title":"Signature","text":"<pre><code>def discrete_loss(\n    concentration: Union[float, NDArray[np.float64]], kernel: NDArray[np.float64]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/","title":"Strategy","text":"<p>Particula Index / Particula / Dynamics / Coagulation / Strategy</p> <p>Auto-generated documentation for particula.dynamics.coagulation.strategy module.</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#coagulationstrategy","title":"CoagulationStrategy","text":"<p>Show source in strategy.py:26</p> <p>Abstract class for defining a coagulation strategy. This class defines the methods that must be implemented by any coagulation strategy.</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#methods","title":"Methods","text":"<ul> <li><code>kernel</code> - Calculate the coagulation kernel.</li> <li><code>loss_rate</code> - Calculate the coagulation loss rate.</li> <li><code>gain_rate</code> - Calculate the coagulation gain rate.</li> <li><code>net_rate</code> - Calculate the net coagulation rate.</li> <li><code>diffusive_knudsen</code> - Calculate the diffusive Knudsen number.</li> <li><code>coulomb_potential_ratio</code> - Calculate the Coulomb potential ratio.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature","title":"Signature","text":"<pre><code>class CoagulationStrategy(ABC): ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#coagulationstrategycoulomb_potential_ratio","title":"CoagulationStrategy().coulomb_potential_ratio","text":"<p>Show source in strategy.py:205</p> <p>Calculate the Coulomb potential ratio based on the particle properties and temperature.</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#arguments","title":"Arguments","text":"<ul> <li><code>particle</code> - The particles for which the Coulomb     potential ratio is to be calculated.</li> <li><code>temperature</code> - The temperature of the gas phase [K].</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#returns","title":"Returns","text":"<p>The Coulomb potential ratio for the particle     [dimensionless].</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_1","title":"Signature","text":"<pre><code>def coulomb_potential_ratio(\n    self, particle: ParticleRepresentation, temperature: float\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#coagulationstrategydiffusive_knudsen","title":"CoagulationStrategy().diffusive_knudsen","text":"<p>Show source in strategy.py:169</p> <p>Calculate the diffusive Knudsen number based on the particle properties, temperature, and pressure.</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#arguments_1","title":"Arguments","text":"<ul> <li><code>particle</code> - The particle for which the diffusive     Knudsen number is to be calculated.</li> <li><code>temperature</code> - The temperature of the gas phase [K].</li> <li><code>pressure</code> - The pressure of the gas phase [Pa].</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#returns_1","title":"Returns","text":"<ul> <li><code>NDArray[np.float64]</code> - The diffusive Knudsen number for the particle     [dimensionless].</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_2","title":"Signature","text":"<pre><code>def diffusive_knudsen(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_1","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#coagulationstrategydimensionless_kernel","title":"CoagulationStrategy().dimensionless_kernel","text":"<p>Show source in strategy.py:40</p> <p>Calculate the dimensionless coagulation kernel based on the particle properties interactions, diffusive Knudsen number and Coulomb potential</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#arguments_2","title":"Arguments","text":"<ul> <li>CoagulationStrategy().diffusive_knudsen - The diffusive Knudsen number     for the particle [dimensionless].</li> <li>CoagulationStrategy().coulomb_potential_ratio - The Coulomb potential     ratio for the particle [dimensionless].</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#returns_2","title":"Returns","text":"<p>The dimensionless coagulation kernel for the particle     [dimensionless].</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_3","title":"Signature","text":"<pre><code>@abstractmethod\ndef dimensionless_kernel(\n    self,\n    diffusive_knudsen: NDArray[np.float64],\n    coulomb_potential_ratio: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#coagulationstrategyfriction_factor","title":"CoagulationStrategy().friction_factor","text":"<p>Show source in strategy.py:227</p> <p>Calculate the friction factor based on the particle properties, temperature, and pressure.</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#arguments_3","title":"Arguments","text":"<ul> <li><code>particle</code> - The particle for which the friction factor     is to be calculated.</li> <li><code>temperature</code> - The temperature of the gas phase [K].</li> <li><code>pressure</code> - The pressure of the gas phase [Pa].</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#returns_3","title":"Returns","text":"<p>The friction factor for the particle [dimensionless].</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_4","title":"Signature","text":"<pre><code>def friction_factor(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_2","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#coagulationstrategygain_rate","title":"CoagulationStrategy().gain_rate","text":"<p>Show source in strategy.py:102</p> <p>Calculate the coagulation gain rate based on the particle radius, distribution, and the coagulation kernel.</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#arguments_4","title":"Arguments","text":"<ul> <li><code>particle</code> - The particle for which the coagulation     gain rate is to be calculated.</li> <li>CoagulationStrategy().kernel - The coagulation kernel.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#returns_4","title":"Returns","text":"<p>The coagulation gain rate for the particle [kg/s].</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#notes","title":"Notes","text":"<p>May be abstracted to a separate module when different coagulation     strategies are implemented (super droplet).</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_5","title":"Signature","text":"<pre><code>@abstractmethod\ndef gain_rate(\n    self, particle: ParticleRepresentation, kernel: NDArray[np.float64]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_3","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#coagulationstrategykernel","title":"CoagulationStrategy().kernel","text":"<p>Show source in strategy.py:62</p> <p>Calculate the coagulation kernel based on the particle properties, temperature, and pressure.</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#arguments_5","title":"Arguments","text":"<ul> <li><code>particle</code> - The particle for which the coagulation     kernel is to be calculated.</li> <li><code>temperature</code> - The temperature of the gas phase [K].</li> <li><code>pressure</code> - The pressure of the gas phase [Pa].</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#returns_5","title":"Returns","text":"<p>The coagulation kernel for the particle [m^3/s].</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_6","title":"Signature","text":"<pre><code>@abstractmethod\ndef kernel(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_4","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#coagulationstrategyloss_rate","title":"CoagulationStrategy().loss_rate","text":"<p>Show source in strategy.py:83</p> <p>Calculate the coagulation loss rate based on the particle radius, distribution, and the coagulation kernel.</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#arguments_6","title":"Arguments","text":"<ul> <li><code>particle</code> - The particle for which the coagulation     loss rate is to be calculated.</li> <li>CoagulationStrategy().kernel - The coagulation kernel.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#returns_6","title":"Returns","text":"<p>The coagulation loss rate for the particle [kg/s].</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_7","title":"Signature","text":"<pre><code>@abstractmethod\ndef loss_rate(\n    self, particle: ParticleRepresentation, kernel: NDArray[np.float64]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_5","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#coagulationstrategynet_rate","title":"CoagulationStrategy().net_rate","text":"<p>Show source in strategy.py:125</p> <p>Calculate the net coagulation rate based on the particle radius, distribution, and the coagulation kernel.</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#arguments_7","title":"Arguments","text":"<ul> <li><code>particle</code> - The particle class for which the     coagulation net rate is to be calculated.</li> <li><code>temperature</code> - The temperature of the gas phase [K].</li> <li><code>pressure</code> - The pressure of the gas phase [Pa].</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#returns_7","title":"Returns","text":"<ul> <li><code>Union[float,</code> NDArray[np.float64]] - The net coagulation rate for the     particle [kg/s].</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_8","title":"Signature","text":"<pre><code>@abstractmethod\ndef net_rate(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_6","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#coagulationstrategystep","title":"CoagulationStrategy().step","text":"<p>Show source in strategy.py:147</p> <p>Perform a single step of the coagulation process.</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#arguments_8","title":"Arguments","text":"<ul> <li><code>particle</code> - The particle for which the coagulation step     is to be performed.</li> <li><code>temperature</code> - The temperature of the gas phase [K].</li> <li><code>pressure</code> - The pressure of the gas phase [Pa].</li> <li><code>time_step</code> - The time step for the coagulation process [s].</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#returns_8","title":"Returns","text":"<ul> <li><code>ParticleRepresentation</code> - The particle after the coagulation step.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_9","title":"Signature","text":"<pre><code>@abstractmethod\ndef step(\n    self,\n    particle: ParticleRepresentation,\n    temperature: float,\n    pressure: float,\n    time_step: float,\n) -&gt; ParticleRepresentation: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_7","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#continuousgeneralpdf","title":"ContinuousGeneralPDF","text":"<p>Show source in strategy.py:492</p> <p>Continuous PDF coagulation strategy class. This class implements the methods defined in the CoagulationStrategy abstract class. The kernel strategy is passed as an argument to the class, should use a dimensionless kernel representation.</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#methods_1","title":"Methods","text":"<ul> <li><code>kernel</code> - Calculate the coagulation kernel.</li> <li><code>loss_rate</code> - Calculate the coagulation loss rate.</li> <li><code>gain_rate</code> - Calculate the coagulation gain rate.</li> <li><code>net_rate</code> - Calculate the net coagulation rate.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_10","title":"Signature","text":"<pre><code>class ContinuousGeneralPDF(CoagulationStrategy):\n    def __init__(self, kernel_strategy: KernelStrategy): ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_8","title":"See also","text":"<ul> <li>CoagulationStrategy</li> <li>KernelStrategy</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#continuousgeneralpdfdimensionless_kernel","title":"ContinuousGeneralPDF().dimensionless_kernel","text":"<p>Show source in strategy.py:509</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_11","title":"Signature","text":"<pre><code>def dimensionless_kernel(\n    self,\n    diffusive_knudsen: NDArray[np.float64],\n    coulomb_potential_ratio: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#continuousgeneralpdfgain_rate","title":"ContinuousGeneralPDF().gain_rate","text":"<p>Show source in strategy.py:566</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_12","title":"Signature","text":"<pre><code>def gain_rate(\n    self, particle: ParticleRepresentation, kernel: NDArray[np.float64]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_9","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#continuousgeneralpdfkernel","title":"ContinuousGeneralPDF().kernel","text":"<p>Show source in strategy.py:519</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_13","title":"Signature","text":"<pre><code>def kernel(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_10","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#continuousgeneralpdfloss_rate","title":"ContinuousGeneralPDF().loss_rate","text":"<p>Show source in strategy.py:554</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_14","title":"Signature","text":"<pre><code>def loss_rate(\n    self, particle: ParticleRepresentation, kernel: NDArray[np.float64]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_11","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#continuousgeneralpdfnet_rate","title":"ContinuousGeneralPDF().net_rate","text":"<p>Show source in strategy.py:578</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_15","title":"Signature","text":"<pre><code>def net_rate(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_12","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#continuousgeneralpdfstep","title":"ContinuousGeneralPDF().step","text":"<p>Show source in strategy.py:596</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_16","title":"Signature","text":"<pre><code>def step(\n    self,\n    particle: ParticleRepresentation,\n    temperature: float,\n    pressure: float,\n    time_step: float,\n) -&gt; ParticleRepresentation: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_13","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#discretegeneral","title":"DiscreteGeneral","text":"<p>Show source in strategy.py:366</p> <p>Discrete general coagulation strategy class. This class implements the methods defined in the CoagulationStrategy abstract class. The kernel strategy is passed as an argument to the class, to use a dimensionless kernel representation.</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#attributes","title":"Attributes","text":"<ul> <li><code>-</code> kernel_strategy - The kernel strategy to be used for the coagulation, from the KernelStrategy class.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#methods_2","title":"Methods","text":"<ul> <li><code>-</code> kernel - Calculate the coagulation kernel.</li> <li><code>-</code> loss_rate - Calculate the coagulation loss rate.</li> <li><code>-</code> gain_rate - Calculate the coagulation gain rate.</li> <li><code>-</code> net_rate - Calculate the net coagulation rate.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_17","title":"Signature","text":"<pre><code>class DiscreteGeneral(CoagulationStrategy):\n    def __init__(self, kernel_strategy: KernelStrategy): ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_14","title":"See also","text":"<ul> <li>CoagulationStrategy</li> <li>KernelStrategy</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#discretegeneraldimensionless_kernel","title":"DiscreteGeneral().dimensionless_kernel","text":"<p>Show source in strategy.py:389</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_18","title":"Signature","text":"<pre><code>def dimensionless_kernel(\n    self,\n    diffusive_knudsen: NDArray[np.float64],\n    coulomb_potential_ratio: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#discretegeneralgain_rate","title":"DiscreteGeneral().gain_rate","text":"<p>Show source in strategy.py:445</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_19","title":"Signature","text":"<pre><code>def gain_rate(\n    self, particle: ParticleRepresentation, kernel: NDArray[np.float64]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_15","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#discretegeneralkernel","title":"DiscreteGeneral().kernel","text":"<p>Show source in strategy.py:399</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_20","title":"Signature","text":"<pre><code>def kernel(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_16","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#discretegeneralloss_rate","title":"DiscreteGeneral().loss_rate","text":"<p>Show source in strategy.py:434</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_21","title":"Signature","text":"<pre><code>def loss_rate(\n    self, particle: ParticleRepresentation, kernel: NDArray[np.float64]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_17","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#discretegeneralnet_rate","title":"DiscreteGeneral().net_rate","text":"<p>Show source in strategy.py:457</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_22","title":"Signature","text":"<pre><code>def net_rate(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_18","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#discretegeneralstep","title":"DiscreteGeneral().step","text":"<p>Show source in strategy.py:475</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_23","title":"Signature","text":"<pre><code>def step(\n    self,\n    particle: ParticleRepresentation,\n    temperature: float,\n    pressure: float,\n    time_step: float,\n) -&gt; ParticleRepresentation: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_19","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#discretesimple","title":"DiscreteSimple","text":"<p>Show source in strategy.py:269</p> <p>Discrete Brownian coagulation strategy class. This class implements the methods defined in the CoagulationStrategy abstract class.</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#methods_3","title":"Methods","text":"<ul> <li><code>-</code> kernel - Calculate the coagulation kernel.</li> <li><code>-</code> loss_rate - Calculate the coagulation loss rate.</li> <li><code>-</code> gain_rate - Calculate the coagulation gain rate.</li> <li><code>-</code> net_rate - Calculate the net coagulation rate.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_24","title":"Signature","text":"<pre><code>class DiscreteSimple(CoagulationStrategy): ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_20","title":"See also","text":"<ul> <li>CoagulationStrategy</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#discretesimpledimensionless_kernel","title":"DiscreteSimple().dimensionless_kernel","text":"<p>Show source in strategy.py:282</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_25","title":"Signature","text":"<pre><code>def dimensionless_kernel(\n    self,\n    diffusive_knudsen: NDArray[np.float64],\n    coulomb_potential_ratio: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#discretesimplegain_rate","title":"DiscreteSimple().gain_rate","text":"<p>Show source in strategy.py:319</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_26","title":"Signature","text":"<pre><code>def gain_rate(\n    self, particle: ParticleRepresentation, kernel: NDArray[np.float64]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_21","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#discretesimplekernel","title":"DiscreteSimple().kernel","text":"<p>Show source in strategy.py:294</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_27","title":"Signature","text":"<pre><code>def kernel(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_22","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#discretesimpleloss_rate","title":"DiscreteSimple().loss_rate","text":"<p>Show source in strategy.py:308</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_28","title":"Signature","text":"<pre><code>def loss_rate(\n    self, particle: ParticleRepresentation, kernel: NDArray[np.float64]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_23","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#discretesimplenet_rate","title":"DiscreteSimple().net_rate","text":"<p>Show source in strategy.py:331</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_29","title":"Signature","text":"<pre><code>def net_rate(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_24","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#discretesimplestep","title":"DiscreteSimple().step","text":"<p>Show source in strategy.py:349</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_30","title":"Signature","text":"<pre><code>def step(\n    self,\n    particle: ParticleRepresentation,\n    temperature: float,\n    pressure: float,\n    time_step: float,\n) -&gt; ParticleRepresentation: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_25","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#particleresolved","title":"ParticleResolved","text":"<p>Show source in strategy.py:613</p> <p>Particle-resolved coagulation strategy class. This class implements the methods defined in the CoagulationStrategy abstract class. The kernel strategy is passed as an argument to the class, should use a dimensionless kernel representation.</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#methods_4","title":"Methods","text":"<ul> <li><code>kernel</code> - Calculate the coagulation kernel.</li> <li><code>loss_rate</code> - Not implemented.</li> <li><code>gain_rate</code> - Not implemented.</li> <li><code>net_rate</code> - Not implemented.</li> <li><code>step</code> - Perform a single step of the coagulation process.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_31","title":"Signature","text":"<pre><code>class ParticleResolved(CoagulationStrategy):\n    def __init__(\n        self,\n        kernel_radius: Optional[NDArray[np.float64]] = None,\n        kernel_bins_number: Optional[int] = None,\n        kernel_bins_per_decade: int = 10,\n    ): ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_26","title":"See also","text":"<ul> <li>CoagulationStrategy</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#particleresolveddimensionless_kernel","title":"ParticleResolved().dimensionless_kernel","text":"<p>Show source in strategy.py:678</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_32","title":"Signature","text":"<pre><code>def dimensionless_kernel(\n    self,\n    diffusive_knudsen: NDArray[np.float64],\n    coulomb_potential_ratio: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#particleresolvedgain_rate","title":"ParticleResolved().gain_rate","text":"<p>Show source in strategy.py:719</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_33","title":"Signature","text":"<pre><code>def gain_rate(\n    self, particle: ParticleRepresentation, kernel: NDArray[np.float64]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_27","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#particleresolvedget_kernel_radius","title":"ParticleResolved().get_kernel_radius","text":"<p>Show source in strategy.py:638</p> <p>Get the binning for the kernel radius.</p> <p>If the kernel radius is not set, it will be calculated based on the particle radius.</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#arguments_9","title":"Arguments","text":"<ul> <li><code>particle</code> - The particle for which the kernel radius is to be     calculated.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#returns_9","title":"Returns","text":"<p>The kernel radius for the particle [m].</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_34","title":"Signature","text":"<pre><code>def get_kernel_radius(self, particle: ParticleRepresentation) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_28","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#particleresolvedkernel","title":"ParticleResolved().kernel","text":"<p>Show source in strategy.py:691</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_35","title":"Signature","text":"<pre><code>def kernel(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_29","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#particleresolvedloss_rate","title":"ParticleResolved().loss_rate","text":"<p>Show source in strategy.py:709</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_36","title":"Signature","text":"<pre><code>def loss_rate(\n    self, particle: ParticleRepresentation, kernel: NDArray[np.float64]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_30","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#particleresolvednet_rate","title":"ParticleResolved().net_rate","text":"<p>Show source in strategy.py:729</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_37","title":"Signature","text":"<pre><code>def net_rate(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_31","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/coagulation/strategy/#particleresolvedstep","title":"ParticleResolved().step","text":"<p>Show source in strategy.py:740</p>"},{"location":"API/particula/dynamics/coagulation/strategy/#signature_38","title":"Signature","text":"<pre><code>def step(\n    self,\n    particle: ParticleRepresentation,\n    temperature: float,\n    pressure: float,\n    time_step: float,\n) -&gt; ParticleRepresentation: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/strategy/#see-also_32","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/","title":"Super Droplet Method","text":"<p>Particula Index / Particula / Dynamics / Coagulation / Super Droplet Method</p> <p>Auto-generated documentation for particula.dynamics.coagulation.super_droplet_method module.</p>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#bin_particles","title":"bin_particles","text":"<p>Show source in super_droplet_method.py:449</p> <p>Bin particles by size and return the number of particles in each bin.</p>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#arguments","title":"Arguments","text":"<ul> <li><code>particle_radius</code> - Array of sorted particle radii.</li> <li><code>radius_bins</code> - Array defining the bin edges for particle radii.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#returns","title":"Returns","text":"<p>Tuple:     - Array of the number of particles in each bin.     - Array of bin indices for each particle.</p>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#signature","title":"Signature","text":"<pre><code>def bin_particles(\n    particle_radius: NDArray[np.float64], radius_bins: NDArray[np.float64]\n) -&gt; Tuple[NDArray[np.int64], NDArray[np.int64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#bin_to_particle_indices","title":"bin_to_particle_indices","text":"<p>Show source in super_droplet_method.py:275</p> <p>Convert bin indices to actual particle indices in the particle array.</p> <p>This function calculates the actual indices in the particle array corresponding to the bins specified by <code>lower_bin</code> and <code>upper_bin</code>. The function adjusts the provided bin-relative indices to reflect their position in the full particle array.</p>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#arguments_1","title":"Arguments","text":"<ul> <li><code>lower_indices</code> - Array of indices relative to the start of     the <code>lower_bin</code>.</li> <li><code>upper_indices</code> - Array of indices relative to the start of     the <code>upper_bin</code>.</li> <li><code>lower_bin</code> - Index of the bin containing smaller particles.</li> <li><code>upper_bin</code> - Index of the bin containing larger particles.</li> <li><code>bin_indices</code> - Array containing the start indices of each bin in the     particle array.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#returns_1","title":"Returns","text":"<p>Tuple:     - <code>-</code> <code>small_index</code> - Indices of particles from the <code>lower_bin</code>.     - <code>-</code> <code>large_index</code> - Indices of particles from the <code>upper_bin</code>.</p>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#signature_1","title":"Signature","text":"<pre><code>def bin_to_particle_indices(\n    lower_indices: NDArray[np.int64],\n    upper_indices: NDArray[np.int64],\n    lower_bin: int,\n    upper_bin: int,\n    bin_indices: NDArray[np.int64],\n) -&gt; Tuple[NDArray[np.int64], NDArray[np.int64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#calculate_concentration_in_bins","title":"calculate_concentration_in_bins","text":"<p>Show source in super_droplet_method.py:492</p> <p>Calculate the concentration of particles in each bin.</p>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#arguments_2","title":"Arguments","text":"<ul> <li><code>bin_indices</code> - Array of bin indices for each particle.</li> <li><code>particle_concentration</code> - Array of sorted particle concentrations. number_in_bins : Array of the number of particles in each bin.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#returns_2","title":"Returns","text":"<p>The total concentration in each bin.</p>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#signature_2","title":"Signature","text":"<pre><code>def calculate_concentration_in_bins(\n    bin_indices: NDArray[np.int64],\n    particle_concentration: NDArray[np.float64],\n    number_in_bins: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#coagulation_events","title":"coagulation_events","text":"<p>Show source in super_droplet_method.py:363</p> <p>Calculate coagulation probabilities and filter events based on them.</p> <p>This function calculates the probability of coagulation events occurring between pairs of particles, based on the ratio of the kernel value for each pair to the maximum kernel value for the bins. The function then randomly determines which events occur using these probabilities.</p>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#arguments_3","title":"Arguments","text":"<ul> <li><code>small_index</code> - Array of indices for the first set of particles     (smaller particles) involved in the events.</li> <li><code>large_index</code> - Array of indices for the second set of particles     (larger particles) involved in the events.</li> <li><code>kernel_values</code> - Array of kernel values corresponding to the     particle pairs.</li> <li><code>kernel_max</code> - The maximum kernel value used for normalization     of probabilities.</li> <li><code>generator</code> - A NumPy random generator used to sample random numbers.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#returns_3","title":"Returns","text":"<p>Tuple:     - Filtered <code>small_index</code> array containing indices where         coagulation events occurred.     - Filtered <code>large_index</code> array containing indices where         coagulation events occurred.</p>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#signature_3","title":"Signature","text":"<pre><code>def coagulation_events(\n    small_index: NDArray[np.int64],\n    large_index: NDArray[np.int64],\n    kernel_values: NDArray[np.float64],\n    kernel_max: float,\n    generator: np.random.Generator,\n) -&gt; Tuple[NDArray[np.int64], NDArray[np.int64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#event_pairs","title":"event_pairs","text":"<p>Show source in super_droplet_method.py:102</p> <p>Calculate the number of particle pairs based on kernel value.</p>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#arguments_4","title":"Arguments","text":"<ul> <li><code>lower_bin</code> - Lower bin index.</li> <li><code>upper_bin</code> - Upper bin index.</li> <li><code>kernel_max</code> - Maximum value of the kernel.</li> <li><code>number_in_bins</code> - Number of particles in each bin.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#returns_4","title":"Returns","text":"<p>The number of particle pairs events based on the kernel and number of particles in the bins.</p>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#signature_4","title":"Signature","text":"<pre><code>def event_pairs(\n    lower_bin: int,\n    upper_bin: int,\n    kernel_max: Union[float, NDArray[np.float64]],\n    number_in_bins: Union[NDArray[np.float64], NDArray[np.int64]],\n) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#filter_valid_indices","title":"filter_valid_indices","text":"<p>Show source in super_droplet_method.py:317</p> <p>Filter particles indices based on particle radius and event counters.</p> <p>This function filters out particle indices that are considered invalid based on two criteria: 1. The particle radius must be greater than zero. 2. If provided, the single event counter must be less than one.</p>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#arguments_5","title":"Arguments","text":"<ul> <li><code>small_index</code> - Array of indices for particles in the smaller bin.</li> <li><code>large_index</code> - Array of indices for particles in the larger bin.</li> <li><code>particle_radius</code> - Array containing the radii of particles.</li> <li><code>single_event_counter</code> Optional - Optional array tracking the     number of events for each particle. If provided, only particles     with a counter value less than one are valid.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#returns_5","title":"Returns","text":"<p>Tuple:     - Filtered <code>small_index</code> array containing only valid indices.     - Filtered <code>large_index</code> array containing only valid indices.</p>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#signature_5","title":"Signature","text":"<pre><code>def filter_valid_indices(\n    small_index: NDArray[np.int64],\n    large_index: NDArray[np.int64],\n    particle_radius: NDArray[np.float64],\n    single_event_counter: Optional[NDArray[np.int64]] = None,\n) -&gt; Tuple[NDArray[np.int64], NDArray[np.int64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#get_bin_pairs","title":"get_bin_pairs","text":"<p>Show source in super_droplet_method.py:476</p> <p>Pre-compute the unique bin pairs for vectorized operations.</p>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#arguments_6","title":"Arguments","text":"<ul> <li><code>bin_indices</code> - Array of bin indices.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#returns_6","title":"Returns","text":"<p>Unique bin pairs for vectorized operations.</p>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#signature_6","title":"Signature","text":"<pre><code>def get_bin_pairs(bin_indices: NDArray[np.int64]) -&gt; list[Tuple[int, int]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#random_choice_indices","title":"random_choice_indices","text":"<p>Show source in super_droplet_method.py:165</p> <p>Filter valid indices and select random indices for coagulation events.</p> <p>This function filters particle indices based on bin indices and ensures the selected particles have a positive radius. It then randomly selects indices from both a lower bin and an upper bin for a given number of events.</p>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#arguments_7","title":"Arguments","text":"<ul> <li><code>lower_bin</code> - The index of the lower bin to filter particles from.</li> <li><code>upper_bin</code> - The index of the upper bin to filter particles from.</li> <li><code>events</code> - Number of events (indices) to sample for each bin.</li> <li><code>particle_radius</code> - A NumPy array of particle radii. Only particles with     radius &gt; 0 are considered.</li> <li><code>bin_indices</code> - A NumPy array of bin indices corresponding to each     particle.</li> <li><code>generator</code> - A NumPy random generator used to sample indices.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#returns_7","title":"Returns","text":"<p>Tuple:     - Indices of particles from the lower bin.     - Indices of particles from the upper bin.</p>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#examples","title":"Examples","text":"Example choice indices (update)<pre><code>rng = np.random.default_rng()\nparticle_radius = np.array([0.5, 0.0, 1.2, 0.3, 0.9])\nbin_indices = np.array([1, 1, 1, 2, 2])\nlower_bin = 1\nupper_bin = 2\nevents = 2\nlower_indices, upper_indices = random_choice_indices(\n    lower_bin, upper_bin, events, particle_radius, bin_indices, rng)\n# lower_indices: array([0, 4])\n# upper_indices: array([0, 1])\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#signature_7","title":"Signature","text":"<pre><code>def random_choice_indices(\n    lower_bin: int,\n    upper_bin: int,\n    events: int,\n    particle_radius: NDArray[np.float64],\n    bin_indices: NDArray[np.int64],\n    generator: np.random.Generator,\n) -&gt; Tuple[NDArray[np.int64], NDArray[np.int64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#sample_events","title":"sample_events","text":"<p>Show source in super_droplet_method.py:133</p> <p>Sample the number of coagulation events from a Poisson distribution.</p> <p>This function calculates the expected number of coagulation events based on the number of particle pairs, the simulation volume, and the time step. It then samples the actual number of events using a Poisson distribution.</p>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#arguments_8","title":"Arguments","text":"<ul> <li><code>events</code> - The calculated number of particle pairs that could     interact.</li> <li><code>volume</code> - The volume of the simulation space.</li> <li><code>time_step</code> - The time step over which the events are being simulated.</li> <li><code>generator</code> - A NumPy random generator used to sample from the Poisson     distribution.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#returns_8","title":"Returns","text":"<p>The sampled number of coagulation events as an integer.</p>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#signature_8","title":"Signature","text":"<pre><code>def sample_events(\n    events: float, volume: float, time_step: float, generator: np.random.Generator\n) -&gt; int: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#select_random_indices","title":"select_random_indices","text":"<p>Show source in super_droplet_method.py:228</p> <p>Select random indices for particles involved in coagulation events.</p> <p>This function generates random indices for particles in the specified bins (<code>lower_bin</code> and <code>upper_bin</code>) that are involved in a specified number of events. The indices are selected based on the number of particles in each bin.</p>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#arguments_9","title":"Arguments","text":"<ul> <li><code>lower_bin</code> - Index of the bin containing smaller particles.</li> <li><code>upper_bin</code> - Index of the bin containing larger particles.</li> <li><code>events</code> - The number of events to sample indices for.</li> <li><code>number_in_bins</code> - Array representing the number of particles in     each bin.</li> <li><code>generator</code> - A NumPy random generator used to sample indices.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#returns_9","title":"Returns","text":"<p>Tuple:     - Indices of particles from <code>lower_bin</code>.     - Indices of particles from <code>upper_bin</code>.</p>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#signature_9","title":"Signature","text":"<pre><code>def select_random_indices(\n    lower_bin: int,\n    upper_bin: int,\n    events: int,\n    number_in_bins: NDArray[np.int64],\n    generator: np.random.Generator,\n) -&gt; Tuple[NDArray[np.int64], NDArray[np.int64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#sort_particles","title":"sort_particles","text":"<p>Show source in super_droplet_method.py:411</p> <p>Sort particles by size and optionally sort their concentrations.</p>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#arguments_10","title":"Arguments","text":"<ul> <li><code>particle_radius</code> - Array of particle radii.</li> <li><code>particle_concentration</code> - Optional array of particle concentrations     corresponding to each radius. If provided, it will be sorted to     match the sorted radii.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#returns_10","title":"Returns","text":"<p>Tuple:     - <code>-</code> <code>unsort_indices</code> - Array of indices to revert the sorting.     - <code>-</code> <code>sorted_radius</code> - Array of sorted particle radii.     - <code>-</code> <code>sorted_concentration</code> - Optional array of sorted particle         concentrations (or <code>None</code> if not provided).</p>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#signature_10","title":"Signature","text":"<pre><code>def sort_particles(\n    particle_radius: NDArray[np.float64],\n    particle_concentration: Optional[NDArray[np.float64]] = None,\n) -&gt; Tuple[NDArray[np.int64], NDArray[np.float64], Optional[NDArray[np.float64]]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#super_droplet_coagulation_step","title":"super_droplet_coagulation_step","text":"<p>Show source in super_droplet_method.py:520</p> <p>Perform a single step of the Super Droplet coagulation process.</p> <p>This function processes particles by sorting them, binning by size, computing coagulation events based on the coagulation kernel, and updating particle properties accordingly.</p>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#arguments_11","title":"Arguments","text":"<ul> <li><code>particle_radius</code> - Array of particle radii.</li> <li><code>particle_concentration</code> - Array of particle concentrations     corresponding to each radius.</li> <li><code>kernel</code> - 2D array representing the coagulation kernel values between     different bins.</li> <li><code>kernel_radius</code> - Array defining the radii corresponding to the     kernel bins.</li> <li><code>volume</code> - Volume of the system or relevant scaling factor.</li> <li><code>time_step</code> - Duration of the current time step. random_generator : A NumPy random number generator for     stochastic processes.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#returns_11","title":"Returns","text":"<p>Tuple:     - Updated array of particle radii after coagulation.     - Updated array of particle concentrations after coagulation.</p>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#signature_11","title":"Signature","text":"<pre><code>def super_droplet_coagulation_step(\n    particle_radius: NDArray[np.float64],\n    particle_concentration: NDArray[np.float64],\n    kernel: NDArray[np.float64],\n    kernel_radius: NDArray[np.float64],\n    volume: float,\n    time_step: float,\n    random_generator: np.random.Generator,\n) -&gt; Tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#super_droplet_update_step","title":"super_droplet_update_step","text":"<p>Show source in super_droplet_method.py:14</p> <p>Update the particle radii and concentrations after coagulation events.</p>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#arguments_12","title":"Arguments","text":"<ul> <li><code>particle_radius</code> NDArray[float64] - Array of particle radii.</li> <li><code>concentration</code> NDArray[float64] - Array representing the concentration     of particles.</li> <li><code>single_event_counter</code> NDArray[int64] - Tracks the number of     coagulation events for each particle.</li> <li><code>small_index</code> NDArray[int64] - Indices corresponding to smaller     particles.</li> <li><code>large_index</code> NDArray[int64] - Indices corresponding to larger     particles.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#returns_12","title":"Returns","text":"<ul> <li>Updated array of particle radii.</li> <li>Updated array representing the concentration of particles.</li> <li>Updated array tracking the number of coagulation events.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/super_droplet_method/#signature_12","title":"Signature","text":"<pre><code>def super_droplet_update_step(\n    particle_radius: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    single_event_counter: NDArray[np.int64],\n    small_index: NDArray[np.int64],\n    large_index: NDArray[np.int64],\n) -&gt; Tuple[NDArray[np.float64], NDArray[np.float64], NDArray[np.int64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/transition_regime/","title":"Transition Regime","text":"<p>Particula Index / Particula / Dynamics / Coagulation / Transition Regime</p> <p>Auto-generated documentation for particula.dynamics.coagulation.transition_regime module.</p>"},{"location":"API/particula/dynamics/coagulation/transition_regime/#coulomb_chahl2019","title":"coulomb_chahl2019","text":"<p>Show source in transition_regime.py:220</p> <p>Chahl and Gopalakrishnan (2019) approximation for the dimensionless coagulation kernel. Accounts for the Coulomb potential between particles.</p>"},{"location":"API/particula/dynamics/coagulation/transition_regime/#arguments","title":"Arguments","text":"<ul> <li><code>-</code> diffusive_knudsen - The diffusive Knudsen number (K_nD) [dimensionless].</li> <li><code>-</code> coulomb_potential_ratio - The Coulomb potential ratio (phi_E) [dimensionless].</li> </ul>"},{"location":"API/particula/dynamics/coagulation/transition_regime/#returns","title":"Returns","text":"<p>The dimensionless coagulation kernel (H) [dimensionless].</p>"},{"location":"API/particula/dynamics/coagulation/transition_regime/#references","title":"References","text":"<ul> <li>Equations X in: Chahl, H. S., &amp; Gopalakrishnan, R. (2019). High potential, near free molecular regime Coulombic collisions in aerosols and dusty plasmas. Aerosol Science and Technology, 53(8), 933-957. https://doi.org/10.1080/02786826.2019.1614522</li> </ul>"},{"location":"API/particula/dynamics/coagulation/transition_regime/#signature","title":"Signature","text":"<pre><code>def coulomb_chahl2019(\n    diffusive_knudsen: Union[float, NDArray[np.float64]],\n    coulomb_potential_ratio: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/transition_regime/#coulomb_dyachkov2007","title":"coulomb_dyachkov2007","text":"<p>Show source in transition_regime.py:62</p> <p>Dyachkov et al. (2007) approximation for the dimensionless coagulation kernel. Accounts for the Coulomb potential between particles.</p>"},{"location":"API/particula/dynamics/coagulation/transition_regime/#arguments_1","title":"Arguments","text":"<ul> <li><code>-</code> diffusive_knudsen - The diffusive Knudsen number (K_nD) [dimensionless].</li> <li><code>-</code> coulomb_potential_ratio - The Coulomb potential ratio (phi_E) [dimensionless].</li> </ul>"},{"location":"API/particula/dynamics/coagulation/transition_regime/#returns_1","title":"Returns","text":"<p>The dimensionless coagulation kernel (H) [dimensionless].</p>"},{"location":"API/particula/dynamics/coagulation/transition_regime/#references_1","title":"References","text":"<p>Equations X in: - Dyachkov, S. A., Kustova, E. V., &amp; Kustov, A. V. (2007). Coagulation of particles in the transition regime: The effect of the Coulomb potential. Journal of Chemical Physics, 126(12). https://doi.org/10.1063/1.2713719</p>"},{"location":"API/particula/dynamics/coagulation/transition_regime/#signature_1","title":"Signature","text":"<pre><code>def coulomb_dyachkov2007(\n    diffusive_knudsen: Union[float, NDArray[np.float64]],\n    coulomb_potential_ratio: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/transition_regime/#coulomb_gatti2008","title":"coulomb_gatti2008","text":"<p>Show source in transition_regime.py:117</p> <p>Gatti et al. (2008) approximation for the dimensionless coagulation kernel. Accounts for the Coulomb potential between particles.</p>"},{"location":"API/particula/dynamics/coagulation/transition_regime/#arguments_2","title":"Arguments","text":"<ul> <li><code>-</code> diffusive_knudsen - The diffusive Knudsen number (K_nD) [dimensionless].</li> <li><code>-</code> coulomb_potential_ratio - The Coulomb potential ratio (phi_E) [dimensionless].</li> </ul>"},{"location":"API/particula/dynamics/coagulation/transition_regime/#returns_2","title":"Returns","text":"<p>The dimensionless coagulation kernel (H) [dimensionless].</p>"},{"location":"API/particula/dynamics/coagulation/transition_regime/#references_2","title":"References","text":"<ul> <li>Equations X in: Gatti, M., &amp; Kortshagen, U. (2008). Analytical model of particle charging in plasmas over a wide range of collisionality. Physical Review E - Statistical, Nonlinear, and Soft Matter Physics, 78(4). https://doi.org/10.1103/PhysRevE.78.046402</li> </ul>"},{"location":"API/particula/dynamics/coagulation/transition_regime/#signature_2","title":"Signature","text":"<pre><code>def coulomb_gatti2008(\n    diffusive_knudsen: Union[float, NDArray[np.float64]],\n    coulomb_potential_ratio: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/transition_regime/#coulomb_gopalakrishnan2012","title":"coulomb_gopalakrishnan2012","text":"<p>Show source in transition_regime.py:181</p> <p>Gopalakrishnan and Hogan (2012) approximation for the dimensionless coagulation kernel. Accounts for the Coulomb potential between particles.</p>"},{"location":"API/particula/dynamics/coagulation/transition_regime/#arguments_3","title":"Arguments","text":"<ul> <li><code>-</code> diffusive_knudsen - The diffusive Knudsen number (K_nD) [dimensionless].</li> <li><code>-</code> coulomb_potential_ratio - The Coulomb potential ratio (phi_E) [dimensionless].</li> </ul>"},{"location":"API/particula/dynamics/coagulation/transition_regime/#returns_3","title":"Returns","text":"<p>The dimensionless coagulation kernel (H) [dimensionless].</p>"},{"location":"API/particula/dynamics/coagulation/transition_regime/#references_3","title":"References","text":"<ul> <li>Equations X in: Gopalakrishnan, R., &amp; Hogan, C. J. (2012). Coulomb-influenced collisions in aerosols and dusty plasmas. Physical Review E - Statistical, Nonlinear, and Soft Matter Physics, 85(2). https://doi.org/10.1103/PhysRevE.85.026410</li> </ul>"},{"location":"API/particula/dynamics/coagulation/transition_regime/#signature_3","title":"Signature","text":"<pre><code>def coulomb_gopalakrishnan2012(\n    diffusive_knudsen: Union[float, NDArray[np.float64]],\n    coulomb_potential_ratio: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/coagulation/transition_regime/#hard_sphere","title":"hard_sphere","text":"<p>Show source in transition_regime.py:12</p> <p>Hard sphere approximation for the dimensionless coagulation kernel.</p>"},{"location":"API/particula/dynamics/coagulation/transition_regime/#arguments_4","title":"Arguments","text":"<ul> <li><code>-</code> diffusive_knudsen - The diffusive Knudsen number (K_nD) [dimensionless].</li> </ul>"},{"location":"API/particula/dynamics/coagulation/transition_regime/#returns_4","title":"Returns","text":"<p>The dimensionless coagulation kernel (H) [dimensionless].</p>"},{"location":"API/particula/dynamics/coagulation/transition_regime/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code> - If diffusive_knudsen contains negative values, NaN, or infinity.</li> </ul>"},{"location":"API/particula/dynamics/coagulation/transition_regime/#references_4","title":"References","text":"<p>Equations X in: - Dyachkov, S. A., Kustova, E. V., &amp; Kustov, A. V. (2007). Coagulation of particles in the transition regime: The effect of the Coulomb potential. Journal of Chemical Physics, 126(12). https://doi.org/10.1063/1.2713719</p>"},{"location":"API/particula/dynamics/coagulation/transition_regime/#signature_4","title":"Signature","text":"<pre><code>def hard_sphere(\n    diffusive_knudsen: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/condensation/","title":"Condensation","text":"<p>Particula Index / Particula / Dynamics / Condensation</p> <p>Auto-generated documentation for particula.dynamics.condensation module.</p>"},{"location":"API/particula/dynamics/condensation/#modules","title":"Modules","text":"<ul> <li>Condensation Strategies</li> <li>Mass Transfer</li> </ul>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/","title":"Condensation Strategies","text":"<p>Particula Index / Particula / Dynamics / Condensation / Condensation Strategies</p> <p>Auto-generated documentation for particula.dynamics.condensation.condensation_strategies module.</p>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#condensationisothermal","title":"CondensationIsothermal","text":"<p>Show source in condensation_strategies.py:362</p> <p>Condensation strategy for isothermal conditions.</p> <p>Condensation strategy for isothermal conditions, where the temperature remains constant. This class implements the mass transfer rate calculation for condensation of particles based on partial pressures. No Latent heat of vaporization effect is considered.</p>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#signature","title":"Signature","text":"<pre><code>class CondensationIsothermal(CondensationStrategy):\n    def __init__(\n        self,\n        molar_mass: Union[float, NDArray[np.float64]],\n        diffusion_coefficient: Union[float, NDArray[np.float64]] = 2e-05,\n        accommodation_coefficient: Union[float, NDArray[np.float64]] = 1.0,\n        update_gases: bool = True,\n    ): ...\n</code></pre>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#see-also","title":"See also","text":"<ul> <li>CondensationStrategy</li> </ul>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#condensationisothermalmass_transfer_rate","title":"CondensationIsothermal().mass_transfer_rate","text":"<p>Show source in condensation_strategies.py:385</p>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#signature_1","title":"Signature","text":"<pre><code>def mass_transfer_rate(\n    self,\n    particle: ParticleRepresentation,\n    gas_species: GasSpecies,\n    temperature: float,\n    pressure: float,\n    dynamic_viscosity: Optional[float] = None,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#see-also_1","title":"See also","text":"<ul> <li>GasSpecies</li> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#condensationisothermalrate","title":"CondensationIsothermal().rate","text":"<p>Show source in condensation_strategies.py:412</p>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#signature_2","title":"Signature","text":"<pre><code>def rate(\n    self,\n    particle: ParticleRepresentation,\n    gas_species: GasSpecies,\n    temperature: float,\n    pressure: float,\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#see-also_2","title":"See also","text":"<ul> <li>GasSpecies</li> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#condensationisothermalstep","title":"CondensationIsothermal().step","text":"<p>Show source in condensation_strategies.py:441</p>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#signature_3","title":"Signature","text":"<pre><code>def step(\n    self,\n    particle: ParticleRepresentation,\n    gas_species: GasSpecies,\n    temperature: float,\n    pressure: float,\n    time_step: float,\n) -&gt; Tuple[ParticleRepresentation, GasSpecies]: ...\n</code></pre>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#see-also_3","title":"See also","text":"<ul> <li>GasSpecies</li> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#condensationstrategy","title":"CondensationStrategy","text":"<p>Show source in condensation_strategies.py:63</p> <p>Abstract base class for condensation strategies.</p> <p>This class defines the interface for various condensation models used in atmospheric physics. Subclasses should implement specific condensation algorithms based on different physical models and equations.</p>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#arguments","title":"Arguments","text":"<ul> <li>molar_mass : The molar mass of the species [kg/mol]. If a single     value is provided, it will be used for all species.</li> <li>diffusion_coefficient : The diffusion coefficient of the species     [m^2/s]. If a single value is provided, it will be used for all     species. Default is 2e-5 m^2/s for air.</li> <li>accommodation_coefficient : The mass accommodation coefficient of the     species. If a single value is provided, it will be used for all     species. Default is 1.0.</li> </ul>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#signature_4","title":"Signature","text":"<pre><code>class CondensationStrategy(ABC):\n    def __init__(\n        self,\n        molar_mass: Union[float, NDArray[np.float64]],\n        diffusion_coefficient: Union[float, NDArray[np.float64]] = 2e-05,\n        accommodation_coefficient: Union[float, NDArray[np.float64]] = 1.0,\n        update_gases: bool = True,\n    ): ...\n</code></pre>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#condensationstrategy_fill_zero_radius","title":"CondensationStrategy()._fill_zero_radius","text":"<p>Show source in condensation_strategies.py:202</p> <p>Fill zero radius values with the maximum radius. The concentration value of zero will ensure that the rate of condensation is zero. The fill is necessary to avoid division by zero in the array operations.</p>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#arguments_1","title":"Arguments","text":"<ul> <li>radius : The radius of the particles.</li> </ul>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#returns","title":"Returns","text":"<ul> <li>radius : The radius of the particles with zero values filled.</li> </ul>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#raises","title":"Raises","text":"<ul> <li>Warning : If all radius values are zero.</li> </ul>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#signature_5","title":"Signature","text":"<pre><code>def _fill_zero_radius(self, radius: NDArray[np.float64]) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#condensationstrategycalculate_pressure_delta","title":"CondensationStrategy().calculate_pressure_delta","text":"<p>Show source in condensation_strategies.py:228</p> <p>Calculate the difference in partial pressure between the gas and particle phases.</p>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#arguments_2","title":"Arguments","text":"<ul> <li>particle : The particle for which the partial pressure difference     is to be calculated.</li> <li>gas_species : The gas species with which the particle is in     contact.</li> <li>temperature : The temperature at which the partial pressure     difference is to be calculated.</li> <li>radius : The radius of the particles.</li> </ul>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#returns_1","title":"Returns","text":"<ul> <li>partial_pressure_delta : The difference in partial pressure     between the gas and particle phases.</li> </ul>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#signature_6","title":"Signature","text":"<pre><code>def calculate_pressure_delta(\n    self,\n    particle: ParticleRepresentation,\n    gas_species: GasSpecies,\n    temperature: float,\n    radius: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#see-also_4","title":"See also","text":"<ul> <li>GasSpecies</li> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#condensationstrategyfirst_order_mass_transport","title":"CondensationStrategy().first_order_mass_transport","text":"<p>Show source in condensation_strategies.py:159</p> <p>First-order mass transport coefficient per particle.</p> <p>Calculate the first-order mass transport coefficient, K, for a given particle based on the diffusion coefficient, radius, and vapor transition correction factor.</p>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#arguments_3","title":"Arguments","text":"<ul> <li>radius : The radius of the particle [m].</li> <li>temperature : The temperature at which the first-order mass     transport coefficient is to be calculated.</li> <li>pressure : The pressure of the gas phase.</li> <li>dynamic_viscosity : The dynamic viscosity of the gas [Pa*s]. If     not provided, it will be calculated based on the temperature</li> </ul>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#returns_2","title":"Returns","text":"<p>The first-order mass transport coefficient per particle (m^3/s).</p>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#references","title":"References","text":"<ul> <li>Aerosol Modeling, Chapter 2, Equation 2.49 (excluding particle     number)</li> </ul>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#signature_7","title":"Signature","text":"<pre><code>def first_order_mass_transport(\n    self,\n    radius: Union[float, NDArray[np.float64]],\n    temperature: float,\n    pressure: float,\n    dynamic_viscosity: Optional[float] = None,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#condensationstrategyknudsen_number","title":"CondensationStrategy().knudsen_number","text":"<p>Show source in condensation_strategies.py:124</p> <p>The Knudsen number for a particle.</p> <p>Calculate the Knudsen number based on the mean free path of the gas molecules and the radius of the particle.</p>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#arguments_4","title":"Arguments","text":"<ul> <li>radius : The radius of the particle [m].</li> <li>temperature : The temperature of the gas [K].</li> <li>pressure : The pressure of the gas [Pa].</li> <li>dynamic_viscosity : The dynamic viscosity of the gas [Pa*s]. If     not provided, it will be calculated based on the temperature</li> </ul>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#returns_3","title":"Returns","text":"<p>The Knudsen number, which is the ratio of the mean free path to     the particle radius.</p>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#references_1","title":"References","text":"<p>Knudsen Number</p>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#signature_8","title":"Signature","text":"<pre><code>def knudsen_number(\n    self,\n    radius: Union[float, NDArray[np.float64]],\n    temperature: float,\n    pressure: float,\n    dynamic_viscosity: Optional[float] = None,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#condensationstrategymass_transfer_rate","title":"CondensationStrategy().mass_transfer_rate","text":"<p>Show source in condensation_strategies.py:274</p> <p>Mass transfer rate for a particle.</p> <p>Calculate the mass transfer rate based on the difference in partial pressure and the first-order mass transport coefficient.</p>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#arguments_5","title":"Arguments","text":"<ul> <li>particle : The particle for which the mass transfer rate is to be     calculated.</li> <li>gas_species : The gas species with which the particle is in     contact.</li> <li>temperature : The temperature at which the mass transfer rate     is to be calculated.</li> <li>pressure : The pressure of the gas phase.</li> <li>dynamic_viscosity : The dynamic viscosity of the gas [Pa*s]. If     not provided, it will be calculated based on the temperature</li> </ul>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#returns_4","title":"Returns","text":"<p>The mass transfer rate for the particle [kg/s].</p>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#signature_9","title":"Signature","text":"<pre><code>@abstractmethod\ndef mass_transfer_rate(\n    self,\n    particle: ParticleRepresentation,\n    gas_species: GasSpecies,\n    temperature: float,\n    pressure: float,\n    dynamic_viscosity: Optional[float] = None,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#see-also_5","title":"See also","text":"<ul> <li>GasSpecies</li> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#condensationstrategymean_free_path","title":"CondensationStrategy().mean_free_path","text":"<p>Show source in condensation_strategies.py:94</p> <p>Calculate the mean free path of the gas molecules based on the temperature, pressure, and dynamic viscosity of the gas.</p>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#arguments_6","title":"Arguments","text":"<ul> <li>temperature : The temperature of the gas [K].</li> <li>pressure : The pressure of the gas [Pa].</li> <li>dynamic_viscosity : The dynamic viscosity of the gas [Pa*s]. If     not provided, it will be calculated based on the temperature</li> </ul>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#returns_5","title":"Returns","text":"<p>The mean free path of the gas molecules in meters (m).</p>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#references_2","title":"References","text":"<p>Mean Free Path Wikipedia</p>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#signature_10","title":"Signature","text":"<pre><code>def mean_free_path(\n    self, temperature: float, pressure: float, dynamic_viscosity: Optional[float] = None\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#condensationstrategyrate","title":"CondensationStrategy().rate","text":"<p>Show source in condensation_strategies.py:304</p> <p>Calculate the rate of mass condensation for each particle due to each condensable gas species.</p> <p>The rate of condensation is determined based on the mass transfer rate, which is a function of particle properties, gas species properties, temperature, and pressure. This rate is then scaled by the concentration of particles in the system to get the overall condensation rate for each particle or bin.</p>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#arguments_7","title":"Arguments","text":"<ul> <li>particle : Representation of the particles, including properties     such as size, concentration, and mass.</li> <li>gas_species : The species of gas condensing onto the particles.</li> <li>temperature : The temperature of the system in Kelvin.</li> <li>pressure : The pressure of the system in Pascals.</li> </ul>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#returns_6","title":"Returns","text":"<p>An array of condensation rates for each particle, scaled by     particle concentration.</p>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#signature_11","title":"Signature","text":"<pre><code>@abstractmethod\ndef rate(\n    self,\n    particle: ParticleRepresentation,\n    gas_species: GasSpecies,\n    temperature: float,\n    pressure: float,\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#see-also_6","title":"See also","text":"<ul> <li>GasSpecies</li> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#condensationstrategystep","title":"CondensationStrategy().step","text":"<p>Show source in condensation_strategies.py:335</p> <p>Execute the condensation process for a given time step.</p>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#arguments_8","title":"Arguments","text":"<ul> <li>particle : The particle to modify.</li> <li>gas_species : The gas species to condense onto the     particle.</li> <li>temperature : The temperature of the system in Kelvin.</li> <li>pressure : The pressure of the system in Pascals.</li> <li>time_step : The time step for the process in seconds.</li> </ul>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#returns_7","title":"Returns","text":"<p>The modified particle instance and the modified gas species     instance.</p>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#signature_12","title":"Signature","text":"<pre><code>@abstractmethod\ndef step(\n    self,\n    particle: ParticleRepresentation,\n    gas_species: GasSpecies,\n    temperature: float,\n    pressure: float,\n    time_step: float,\n) -&gt; Tuple[ParticleRepresentation, GasSpecies]: ...\n</code></pre>"},{"location":"API/particula/dynamics/condensation/condensation_strategies/#see-also_7","title":"See also","text":"<ul> <li>GasSpecies</li> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/dynamics/condensation/mass_transfer/","title":"Mass Transfer","text":"<p>Particula Index / Particula / Dynamics / Condensation / Mass Transfer</p> <p>Auto-generated documentation for particula.dynamics.condensation.mass_transfer module.</p>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#calculate_mass_transfer","title":"calculate_mass_transfer","text":"<p>Show source in mass_transfer.py:199</p> <p>Helper function that routes the mass transfer calculation to either the single-species or multi-species calculation functions based on the input dimensions of gas_mass.</p>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#arguments","title":"Arguments","text":"<ul> <li>mass_rate : The rate of mass transfer per particle (kg/s).</li> <li>time_step : The time step for the mass transfer calculation (sec).</li> <li>gas_mass : The available mass of gas species (kg).</li> <li>particle_mass : The mass of each particle (kg).</li> <li>particle_concentration : The concentration of particles (number/m^3).</li> </ul>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#returns","title":"Returns","text":"<p>The amount of mass transferred, accounting for gas and particle     limitations.</p>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#examples","title":"Examples","text":"Single species input<pre><code>calculate_mass_transfer(\n    mass_rate=np.array([0.1, 0.5]),\n    time_step=10,\n    gas_mass=np.array([0.5]),\n    particle_mass=np.array([1.0, 50]),\n    particle_concentration=np.array([1, 0.5])\n)\n</code></pre> Multiple species input<pre><code>calculate_mass_transfer(\n    mass_rate=np.array([[0.1, 0.05, 0.03], [0.2, 0.15, 0.07]]),\n    time_step=10,\n    gas_mass=np.array([1.0, 0.8, 0.5]),\n    particle_mass=np.array([[1.0, 0.9, 0.8], [1.2, 1.0, 0.7]]),\n    particle_concentration=np.array([5, 4])\n)\n</code></pre>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#signature","title":"Signature","text":"<pre><code>def calculate_mass_transfer(\n    mass_rate: NDArray[np.float64],\n    time_step: float,\n    gas_mass: NDArray[np.float64],\n    particle_mass: NDArray[np.float64],\n    particle_concentration: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#calculate_mass_transfer_multiple_species","title":"calculate_mass_transfer_multiple_species","text":"<p>Show source in mass_transfer.py:316</p> <p>Calculate mass transfer for multiple gas species.</p>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#arguments_1","title":"Arguments","text":"<ul> <li>mass_rate : The rate of mass transfer per particle for each gas     species (kg/s).</li> <li>time_step : The time step for the mass transfer calculation (sec).</li> <li>gas_mass : The available mass of each gas species (kg).</li> <li>particle_mass : The mass of each particle for each gas species (kg).</li> <li>particle_concentration : The concentration of particles for each gas     species (number/m^3).</li> </ul>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#returns_1","title":"Returns","text":"<p>The amount of mass transferred for multiple gas species.</p>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#examples_1","title":"Examples","text":"Multiple species input<pre><code>calculate_mass_transfer_multiple_species(\n    mass_rate=np.array([[0.1, 0.05, 0.03], [0.2, 0.15, 0.07]]),\n    time_step=10,\n    gas_mass=np.array([1.0, 0.8, 0.5]),\n    particle_mass=np.array([[1.0, 0.9, 0.8], [1.2, 1.0, 0.7]]),\n    particle_concentration=np.array([5, 4])\n)\n</code></pre>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#signature_1","title":"Signature","text":"<pre><code>def calculate_mass_transfer_multiple_species(\n    mass_rate: NDArray[np.float64],\n    time_step: float,\n    gas_mass: NDArray[np.float64],\n    particle_mass: NDArray[np.float64],\n    particle_concentration: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#calculate_mass_transfer_single_species","title":"calculate_mass_transfer_single_species","text":"<p>Show source in mass_transfer.py:261</p> <p>Calculate mass transfer for a single gas species (m=1).</p>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#arguments_2","title":"Arguments","text":"<ul> <li>mass_rate : The rate of mass transfer per particle (number*kg/s).</li> <li>time_step : The time step for the mass transfer calculation (sec).</li> <li>gas_mass : The available mass of gas species (kg).</li> <li>particle_mass : The mass of each particle (kg).</li> <li>particle_concentration : The concentration of particles (number/m^3).</li> </ul>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#returns_2","title":"Returns","text":"<p>The amount of mass transferred for a single gas species.</p>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#examples_2","title":"Examples","text":"Single species input<pre><code>calculate_mass_transfer_single_species(\n    mass_rate=np.array([0.1, 0.5]),\n    time_step=10,\n    gas_mass=np.array([0.5]),\n    particle_mass=np.array([1.0, 50]),\n    particle_concentration=np.array([1, 0.5])\n)\n</code></pre>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#signature_2","title":"Signature","text":"<pre><code>def calculate_mass_transfer_single_species(\n    mass_rate: NDArray[np.float64],\n    time_step: float,\n    gas_mass: NDArray[np.float64],\n    particle_mass: NDArray[np.float64],\n    particle_concentration: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#first_order_mass_transport_k","title":"first_order_mass_transport_k","text":"<p>Show source in mass_transfer.py:46</p> <p>First-order mass transport coefficient per particle.</p> <p>Calculate the first-order mass transport coefficient, K, for a given radius diffusion coefficient, and vapor transition correction factor. For a single particle.</p>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#arguments_3","title":"Arguments","text":"<ul> <li>radius : The radius of the particle [m].</li> <li>diffusion_coefficient : The diffusion coefficient of the vapor     [m^2/s], default to air.</li> <li>vapor_transition : The vapor transition correction factor. [unitless]</li> </ul>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#returns_3","title":"Returns","text":"<p>The first-order mass transport coefficient per particle (m^3/s).</p>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#examples_3","title":"Examples","text":"Float input<pre><code>first_order_mass_transport_k(\n    radius=1e-6,\n    vapor_transition=0.6,\n    diffusion_coefficient=2e-9\n    )\n# Output: 1.5079644737231005e-14\n</code></pre> Array input<pre><code>first_order_mass_transport_k\n    radius=np.array([1e-6, 2e-6]),\n    vapor_transition=np.array([0.6, 0.6]),\n    diffusion_coefficient=2e-9\n    )\n# Output: array([1.50796447e-14, 6.03185789e-14])\n</code></pre>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#references","title":"References","text":"<ul> <li>Aerosol Modeling: Chapter 2, Equation 2.49 (excluding number)</li> <li>Mass Diffusivity:     Wikipedia</li> </ul>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#signature_3","title":"Signature","text":"<pre><code>def first_order_mass_transport_k(\n    radius: Union[float, NDArray[np.float64]],\n    vapor_transition: Union[float, NDArray[np.float64]],\n    diffusion_coefficient: Union[float, NDArray[np.float64]] = 2e-05,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#mass_transfer_rate","title":"mass_transfer_rate","text":"<p>Show source in mass_transfer.py:100</p> <p>Calculate the mass transfer rate for a particle.</p> <p>Calculate the mass transfer rate based on the difference in partial pressure and the first-order mass transport coefficient.</p>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#arguments_4","title":"Arguments","text":"<ul> <li>pressure_delta : The difference in partial pressure between the gas     phase and the particle phase.</li> <li>first_order_mass_transport : The first-order mass transport     coefficient per particle.</li> <li>temperature : The temperature at which the mass transfer rate is to     be calculated.</li> <li>molar_mass : The molar mass of the species [kg/mol].</li> </ul>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#returns_4","title":"Returns","text":"<p>The mass transfer rate for the particle [kg/s].</p>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#examples_4","title":"Examples","text":"Single value input<pre><code>mass_transfer_rate(\n    pressure_delta=10.0,\n    first_order_mass_transport=1e-17,\n    temperature=300.0,\n    molar_mass=0.02897\n)\n# Output: 1.16143004e-21\n</code></pre> Array input<pre><code>mass_transfer_rate(\n    pressure_delta=np.array([10.0, 15.0]),\n    first_order_mass_transport=np.array([1e-17, 2e-17]),\n    temperature=300.0,\n    molar_mass=0.02897\n)\n# Output: array([1.16143004e-21, 3.48429013e-21])\n</code></pre>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#references_1","title":"References","text":"<ul> <li>Aerosol Modeling Chapter 2, Equation 2.41 (excluding particle number)</li> <li>Seinfeld and Pandis: \"Atmospheric Chemistry and Physics\",     Equation 13.3</li> </ul>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#signature_4","title":"Signature","text":"<pre><code>def mass_transfer_rate(\n    pressure_delta: Union[float, NDArray[np.float64]],\n    first_order_mass_transport: Union[float, NDArray[np.float64]],\n    temperature: Union[float, NDArray[np.float64]],\n    molar_mass: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#radius_transfer_rate","title":"radius_transfer_rate","text":"<p>Show source in mass_transfer.py:157</p> <p>Convert mass rate to radius transfer rate.</p> <p>Convert the mass rate to a radius transfer rate based on the volume of the particle.</p>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#arguments_5","title":"Arguments","text":"<ul> <li>mass_rate : The mass transfer rate for the particle [kg/s].</li> <li>radius : The radius of the particle [m].</li> <li>density : The density of the particle [kg/m^3].</li> </ul>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#returns_5","title":"Returns","text":"<p>The radius growth rate for the particle [m/s].</p>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#examples_5","title":"Examples","text":"Single value input<pre><code>radius_transfer_rate(\n    mass_rate=1e-21,\n    radius=1e-6,\n    density=1000\n)\n# Output: 7.95774715e-14\n</code></pre> Array input<pre><code>radius_transfer_rate(\n    mass_rate=np.array([1e-21, 2e-21]),\n    radius=np.array([1e-6, 2e-6]),\n    density=1000\n)\n# Output: array([7.95774715e-14, 1.98943679e-14])\n</code></pre>"},{"location":"API/particula/dynamics/condensation/mass_transfer/#signature_5","title":"Signature","text":"<pre><code>def radius_transfer_rate(\n    mass_rate: Union[float, NDArray[np.float64]],\n    radius: Union[float, NDArray[np.float64]],\n    density: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/properties/","title":"Properties","text":"<p>Particula Index / Particula / Dynamics / Properties</p> <p>Auto-generated documentation for particula.dynamics.properties module.</p>"},{"location":"API/particula/dynamics/properties/#modules","title":"Modules","text":"<ul> <li>Wall Loss Coefficient</li> </ul>"},{"location":"API/particula/dynamics/properties/wall_loss_coefficient/","title":"Wall Loss Coefficient","text":"<p>Particula Index / Particula / Dynamics / Properties / Wall Loss Coefficient</p> <p>Auto-generated documentation for particula.dynamics.properties.wall_loss_coefficient module.</p>"},{"location":"API/particula/dynamics/properties/wall_loss_coefficient/#rectangle_wall_loss_coefficient","title":"rectangle_wall_loss_coefficient","text":"<p>Show source in wall_loss_coefficient.py:65</p> <p>Calculate the wall loss coefficient, \u03b2\u2080, for a rectangular chamber.</p> <p>This function computes the wall loss coefficient for a rectangular-prism chamber, considering the wall eddy diffusivity, particle diffusion coefficient, and terminal settling velocity. The chamber dimensions (length, width, and height) are used to account for the geometry's impact on particle loss.</p>"},{"location":"API/particula/dynamics/properties/wall_loss_coefficient/#arguments","title":"Arguments","text":"<ul> <li><code>wall_eddy_diffusivity</code> - Rate of wall diffusivity parameter in     units of inverse seconds (s^-1).</li> <li><code>diffusion_coefficient</code> - The particle diffusion coefficient     in units of square meters per second (m\u00b2/s).</li> <li><code>settling_velocity</code> - The terminal settling velocity of the     particles, in units of meters per second (m/s).</li> <li><code>chamber_dimensions</code> - A tuple of three floats representing the length     (L), width (W), and height (H) of the rectangular chamber,     in units of meters (m).</li> </ul>"},{"location":"API/particula/dynamics/properties/wall_loss_coefficient/#returns","title":"Returns","text":"<p>The calculated wall loss rate (\u03b2\u2080) for the rectangular chamber.</p>"},{"location":"API/particula/dynamics/properties/wall_loss_coefficient/#references","title":"References","text":"<ul> <li>Crump, J. G., &amp; Seinfeld, J. H. (1981). TURBULENT DEPOSITION AND     GRAVITATIONAL SEDIMENTATION OF AN AEROSOL IN A VESSEL OF ARBITRARY     SHAPE. In J Aerosol Sct (Vol. 12, Issue 5).     https://doi.org/10.1016/0021-8502(81)90036-7</li> </ul>"},{"location":"API/particula/dynamics/properties/wall_loss_coefficient/#signature","title":"Signature","text":"<pre><code>def rectangle_wall_loss_coefficient(\n    wall_eddy_diffusivity: Union[float, NDArray[np.float64]],\n    diffusion_coefficient: Union[float, NDArray[np.float64]],\n    settling_velocity: Union[float, NDArray[np.float64]],\n    chamber_dimensions: Tuple[float, float, float],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/properties/wall_loss_coefficient/#rectangle_wall_loss_coefficient_via_system_state","title":"rectangle_wall_loss_coefficient_via_system_state","text":"<p>Show source in wall_loss_coefficient.py:177</p> <p>Calculate the wall loss coefficient for a rectangular chamber based on the system state.</p> <p>This function computes the wall loss coefficient for a rectangular chamber using the system's physical state, including the wall eddy diffusivity, particle properties (radius, density), and environmental conditions (temperature, pressure). The chamber dimensions (length, width, height) are also considered.</p>"},{"location":"API/particula/dynamics/properties/wall_loss_coefficient/#arguments_1","title":"Arguments","text":"<ul> <li><code>wall_eddy_diffusivity</code> - The rate of wall eddy diffusivity in inverse     seconds (s\u207b\u00b9).</li> <li><code>particle_radius</code> - The radius of the particle in meters (m).</li> <li><code>particle_density</code> - The density of the particle in kilograms per cubic     meter (kg/m\u00b3).</li> <li><code>temperature</code> - The temperature of the system in Kelvin (K).</li> <li><code>pressure</code> - The pressure of the system in Pascals (Pa).</li> <li><code>chamber_dimensions</code> - A tuple containing the length, width, and height     of the rectangular chamber in meters (m).</li> </ul>"},{"location":"API/particula/dynamics/properties/wall_loss_coefficient/#returns_1","title":"Returns","text":"<p>The calculated wall loss coefficient for the rectangular chamber.</p>"},{"location":"API/particula/dynamics/properties/wall_loss_coefficient/#references_1","title":"References","text":"<ul> <li>Crump, J. G., &amp; Seinfeld, J. H. (1981). TURBULENT DEPOSITION AND     GRAVITATIONAL SEDIMENTATION OF AN AEROSOL IN A VESSEL OF ARBITRARY     SHAPE. In J Aerosol Sct (Vol. 12, Issue 5).     https://doi.org/10.1016/0021-8502(81)90036-7</li> </ul>"},{"location":"API/particula/dynamics/properties/wall_loss_coefficient/#signature_1","title":"Signature","text":"<pre><code>def rectangle_wall_loss_coefficient_via_system_state(\n    wall_eddy_diffusivity: float,\n    particle_radius: Union[float, NDArray[np.float64]],\n    particle_density: Union[float, NDArray[np.float64]],\n    temperature: float,\n    pressure: float,\n    chamber_dimensions: Tuple[float, float, float],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/properties/wall_loss_coefficient/#spherical_wall_loss_coefficient","title":"spherical_wall_loss_coefficient","text":"<p>Show source in wall_loss_coefficient.py:28</p> <p>Calculate the wall loss coefficient for a spherical chamber approximation.</p>"},{"location":"API/particula/dynamics/properties/wall_loss_coefficient/#arguments_2","title":"Arguments","text":"<ul> <li><code>wall_eddy_diffusivity</code> - Rate of the wall eddy diffusivity.</li> <li><code>diffusion_coefficient</code> - Diffusion coefficient of the     particle.</li> <li><code>settling_velocity</code> - Settling velocity of the particle.</li> <li><code>chamber_radius</code> - Radius of the chamber.</li> </ul>"},{"location":"API/particula/dynamics/properties/wall_loss_coefficient/#returns_2","title":"Returns","text":"<p>The calculated wall loss rate for a spherical chamber.</p>"},{"location":"API/particula/dynamics/properties/wall_loss_coefficient/#references_2","title":"References","text":"<ul> <li>Crump, J. G., Flagan, R. C., &amp; Seinfeld, J. H. (1982). Particle wall     loss rates in vessels. Aerosol Science and Technology, 2(3),     303-309. https://doi.org/10.1080/02786828308958636</li> </ul>"},{"location":"API/particula/dynamics/properties/wall_loss_coefficient/#signature_2","title":"Signature","text":"<pre><code>def spherical_wall_loss_coefficient(\n    wall_eddy_diffusivity: Union[float, NDArray[np.float64]],\n    diffusion_coefficient: Union[float, NDArray[np.float64]],\n    settling_velocity: Union[float, NDArray[np.float64]],\n    chamber_radius: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/dynamics/properties/wall_loss_coefficient/#spherical_wall_loss_coefficient_via_system_state","title":"spherical_wall_loss_coefficient_via_system_state","text":"<p>Show source in wall_loss_coefficient.py:120</p> <p>Calculate the wall loss coefficient for a spherical chamber based on the system state.</p> <p>This function computes the wall loss coefficient for a spherical chamber using the system's physical state, including the wall eddy diffusivity, particle properties (radius, density), and environmental conditions (temperature, pressure). The chamber radius is also taken into account.</p>"},{"location":"API/particula/dynamics/properties/wall_loss_coefficient/#arguments_3","title":"Arguments","text":"<ul> <li><code>wall_eddy_diffusivity</code> - The rate of wall eddy diffusivity in inverse     seconds (s\u207b\u00b9).</li> <li><code>particle_radius</code> - The radius of the particle in meters (m).</li> <li><code>particle_density</code> - The density of the particle in kilograms per cubic     meter (kg/m\u00b3).</li> <li><code>temperature</code> - The temperature of the system in Kelvin (K).</li> <li><code>pressure</code> - The pressure of the system in Pascals (Pa).</li> <li><code>chamber_radius</code> - The radius of the spherical chamber in meters (m).</li> </ul>"},{"location":"API/particula/dynamics/properties/wall_loss_coefficient/#returns_3","title":"Returns","text":"<p>The calculated wall loss coefficient for the spherical chamber.</p>"},{"location":"API/particula/dynamics/properties/wall_loss_coefficient/#signature_3","title":"Signature","text":"<pre><code>def spherical_wall_loss_coefficient_via_system_state(\n    wall_eddy_diffusivity: float,\n    particle_radius: Union[float, NDArray[np.float64]],\n    particle_density: Union[float, NDArray[np.float64]],\n    temperature: float,\n    pressure: float,\n    chamber_radius: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/equilibria/","title":"Equilibria","text":"<p>Particula Index / Particula / Equilibria</p> <p>Auto-generated documentation for particula.equilibria module.</p>"},{"location":"API/particula/equilibria/#modules","title":"Modules","text":"<ul> <li>Partitioning</li> </ul>"},{"location":"API/particula/equilibria/partitioning/","title":"Partitioning","text":"<p>Particula Index / Particula / Equilibria / Partitioning</p> <p>Auto-generated documentation for particula.equilibria.partitioning module.</p>"},{"location":"API/particula/equilibria/partitioning/#get_properties_for_liquid_vapor_partitioning","title":"get_properties_for_liquid_vapor_partitioning","text":"<p>Show source in partitioning.py:212</p> <p>Get properties for liquid-vapor partitioning.</p>"},{"location":"API/particula/equilibria/partitioning/#signature","title":"Signature","text":"<pre><code>def get_properties_for_liquid_vapor_partitioning(\n    water_activity_desired, molar_mass, oxygen2carbon, density\n): ...\n</code></pre>"},{"location":"API/particula/equilibria/partitioning/#liquid_vapor_obj_function","title":"liquid_vapor_obj_function","text":"<p>Show source in partitioning.py:9</p> <p>Objective function for liquid-vapor partitioning.</p>"},{"location":"API/particula/equilibria/partitioning/#signature_1","title":"Signature","text":"<pre><code>def liquid_vapor_obj_function(\n    e_j_partition_guess,\n    c_star_j_dry,\n    concentration_organic_matter,\n    gamma_organic_ab,\n    mass_fraction_water_ab,\n    q_ab,\n    molar_mass,\n    error_only=True,\n): ...\n</code></pre>"},{"location":"API/particula/equilibria/partitioning/#liquid_vapor_partitioning","title":"liquid_vapor_partitioning","text":"<p>Show source in partitioning.py:158</p> <p>Thermodynamic equilibrium between liquid and vapor phase. with activity coefficients,</p>"},{"location":"API/particula/equilibria/partitioning/#signature_2","title":"Signature","text":"<pre><code>def liquid_vapor_partitioning(\n    c_star_j_dry,\n    concentration_organic_matter,\n    molar_mass,\n    gamma_organic_ab,\n    mass_fraction_water_ab,\n    q_ab,\n    partition_coefficient_guess=None,\n): ...\n</code></pre>"},{"location":"API/particula/gas/","title":"Gas","text":"<p>Particula Index / Particula / Gas</p> <p>Auto-generated documentation for particula.gas module.</p>"},{"location":"API/particula/gas/#modules","title":"Modules","text":"<ul> <li>Atmosphere</li> <li>Atmosphere Builders</li> <li>Properties</li> <li>Species</li> <li>Species Builders</li> <li>Species Factories</li> <li>Vapor Pressure Builders</li> <li>Vapor Pressure Factories</li> <li>Vapor Pressure Strategies</li> </ul>"},{"location":"API/particula/gas/atmosphere/","title":"Atmosphere","text":"<p>Particula Index / Particula / Gas / Atmosphere</p> <p>Auto-generated documentation for particula.gas.atmosphere module.</p>"},{"location":"API/particula/gas/atmosphere/#atmosphere_1","title":"Atmosphere","text":"<p>Show source in atmosphere.py:8</p> <p>Represents a mixture of gas species under specific conditions.</p> <p>This class represents the atmospheric environment by detailing properties such as temperature and pressure, alongside a dynamic list of gas species present.</p>"},{"location":"API/particula/gas/atmosphere/#attributes","title":"Attributes","text":"<ul> <li><code>temperature</code> - Temperature of the gas mixture in Kelvin.</li> <li><code>total_pressure</code> - Total atmospheric pressure of the mixture inPascals.</li> <li><code>species</code> - List of GasSpecies objects representing the     various species within the gas mixture.</li> </ul>"},{"location":"API/particula/gas/atmosphere/#methods","title":"Methods","text":"<ul> <li><code>add_species(self,</code> species - GasSpecies) -&gt; None:     Adds a GasSpecies object to the mixture.</li> <li><code>remove_species(self,</code> index - int) -&gt; None:     Removes a GasSpecies object from the mixture based on its index.</li> </ul>"},{"location":"API/particula/gas/atmosphere/#signature","title":"Signature","text":"<pre><code>class Atmosphere: ...\n</code></pre>"},{"location":"API/particula/gas/atmosphere/#atmospheregetitem","title":"Atmosphere().getitem","text":"<p>Show source in atmosphere.py:64</p> <p>Retrieves a gas species by index.</p>"},{"location":"API/particula/gas/atmosphere/#arguments","title":"Arguments","text":"<ul> <li><code>index</code> - The index of the gas species to retrieve.</li> </ul>"},{"location":"API/particula/gas/atmosphere/#returns","title":"Returns","text":"<ul> <li><code>GasSpecies</code> - The gas species at the specified index.</li> </ul>"},{"location":"API/particula/gas/atmosphere/#signature_1","title":"Signature","text":"<pre><code>def __getitem__(self, index: int) -&gt; GasSpecies: ...\n</code></pre>"},{"location":"API/particula/gas/atmosphere/#see-also","title":"See also","text":"<ul> <li>GasSpecies</li> </ul>"},{"location":"API/particula/gas/atmosphere/#atmosphereiter","title":"Atmosphere().iter","text":"<p>Show source in atmosphere.py:55</p> <p>Allows iteration over the species in the gas mixture.</p>"},{"location":"API/particula/gas/atmosphere/#returns_1","title":"Returns","text":"<ul> <li><code>Iterator[GasSpecies]</code> - An iterator over the gas species objects.</li> </ul>"},{"location":"API/particula/gas/atmosphere/#signature_2","title":"Signature","text":"<pre><code>def __iter__(self): ...\n</code></pre>"},{"location":"API/particula/gas/atmosphere/#atmospherelen","title":"Atmosphere().len","text":"<p>Show source in atmosphere.py:75</p> <p>Returns the number of species in the gas mixture.</p>"},{"location":"API/particula/gas/atmosphere/#returns_2","title":"Returns","text":"<ul> <li><code>int</code> - The number of gas species in the mixture.</li> </ul>"},{"location":"API/particula/gas/atmosphere/#signature_3","title":"Signature","text":"<pre><code>def __len__(self) -&gt; int: ...\n</code></pre>"},{"location":"API/particula/gas/atmosphere/#atmospherestr","title":"Atmosphere().str","text":"<p>Show source in atmosphere.py:83</p> <p>Provides a string representation of the Atmosphere object.</p>"},{"location":"API/particula/gas/atmosphere/#returns_3","title":"Returns","text":"<ul> <li><code>str</code> - A string that includes the temperature, pressure, and a     list of species in the mixture.</li> </ul>"},{"location":"API/particula/gas/atmosphere/#signature_4","title":"Signature","text":"<pre><code>def __str__(self) -&gt; str: ...\n</code></pre>"},{"location":"API/particula/gas/atmosphere/#atmosphereadd_species","title":"Atmosphere().add_species","text":"<p>Show source in atmosphere.py:32</p> <p>Adds a GasSpecies object to the mixture.</p>"},{"location":"API/particula/gas/atmosphere/#arguments_1","title":"Arguments","text":"<ul> <li><code>gas_species</code> - The gas species to be added.</li> </ul>"},{"location":"API/particula/gas/atmosphere/#signature_5","title":"Signature","text":"<pre><code>def add_species(self, gas_species: GasSpecies) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/gas/atmosphere/#see-also_1","title":"See also","text":"<ul> <li>GasSpecies</li> </ul>"},{"location":"API/particula/gas/atmosphere/#atmosphereremove_species","title":"Atmosphere().remove_species","text":"<p>Show source in atmosphere.py:40</p> <p>Removes a gas species from the mixture by its index.</p>"},{"location":"API/particula/gas/atmosphere/#arguments_2","title":"Arguments","text":"<ul> <li><code>index</code> - Index of the gas species to remove. Must be within             the current range of the list.</li> </ul>"},{"location":"API/particula/gas/atmosphere/#raises","title":"Raises","text":"<ul> <li><code>IndexError</code> - If the provided index is out of bounds.</li> </ul>"},{"location":"API/particula/gas/atmosphere/#signature_6","title":"Signature","text":"<pre><code>def remove_species(self, index: int) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/gas/atmosphere_builders/","title":"Atmosphere Builders","text":"<p>Particula Index / Particula / Gas / Atmosphere Builders</p> <p>Auto-generated documentation for particula.gas.atmosphere_builders module.</p>"},{"location":"API/particula/gas/atmosphere_builders/#atmospherebuilder","title":"AtmosphereBuilder","text":"<p>Show source in atmosphere_builders.py:18</p> <p>Builder class for creating Atmosphere objects using a fluent interface.</p> <p>This class provides methods to configure and build an Atmosphere object, allowing for step-by-step setting of atmospheric properties and species composition.</p>"},{"location":"API/particula/gas/atmosphere_builders/#attributes","title":"Attributes","text":"<ul> <li><code>temperature</code> - Temperature of the gas mixture in Kelvin.</li> <li><code>total_pressure</code> float - Total pressure of the gas mixture in Pascals.</li> <li><code>species</code> list[GasSpecies] - List of GasSpecies objects in the mixture.     Starts empty.</li> </ul>"},{"location":"API/particula/gas/atmosphere_builders/#methods","title":"Methods","text":"<ul> <li><code>set_temperature(temperature,temperature_units)</code> - Sets the temperature.</li> <li><code>set_pressure(pressure,pressure_units)</code> - Sets the total pressure.</li> <li><code>add_species(species)</code> - Adds a GasSpecies object to the gas mixture.</li> <li><code>set_parameters(parameters)</code> - Sets multiple parameters from a dictionary.</li> <li><code>build()</code> - Validates the set parameters and returns an Atmosphere object.</li> </ul>"},{"location":"API/particula/gas/atmosphere_builders/#signature","title":"Signature","text":"<pre><code>class AtmosphereBuilder(BuilderABC, BuilderTemperatureMixin, BuilderPressureMixin):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/gas/atmosphere_builders/#see-also","title":"See also","text":"<ul> <li>BuilderABC</li> <li>BuilderPressureMixin</li> <li>BuilderTemperatureMixin</li> </ul>"},{"location":"API/particula/gas/atmosphere_builders/#atmospherebuilderadd_species","title":"AtmosphereBuilder().add_species","text":"<p>Show source in atmosphere_builders.py:50</p> <p>Adds a GasSpecies object to the gas mixture.</p>"},{"location":"API/particula/gas/atmosphere_builders/#arguments","title":"Arguments","text":"<ul> <li><code>species</code> GasSpecies - The GasSpecies object to be added.</li> </ul>"},{"location":"API/particula/gas/atmosphere_builders/#returns","title":"Returns","text":"<ul> <li>AtmosphereBuilder - Instance of this builder for chaining.</li> </ul>"},{"location":"API/particula/gas/atmosphere_builders/#signature_1","title":"Signature","text":"<pre><code>def add_species(self, species: GasSpecies) -&gt; \"AtmosphereBuilder\": ...\n</code></pre>"},{"location":"API/particula/gas/atmosphere_builders/#see-also_1","title":"See also","text":"<ul> <li>GasSpecies</li> </ul>"},{"location":"API/particula/gas/atmosphere_builders/#atmospherebuilderbuild","title":"AtmosphereBuilder().build","text":"<p>Show source in atmosphere_builders.py:62</p> <p>Validates the configuration and constructs the Atmosphere object.</p> <p>This method checks that all necessary conditions are met for a valid Atmosphere instance(e.g., at least one species must be present) and then initializes the Atmosphere.</p>"},{"location":"API/particula/gas/atmosphere_builders/#returns_1","title":"Returns","text":"<ul> <li><code>Atmosphere</code> - The newly created Atmosphere object, configured as specified.</li> </ul>"},{"location":"API/particula/gas/atmosphere_builders/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code> - If no species have been added to the mixture.</li> </ul>"},{"location":"API/particula/gas/atmosphere_builders/#signature_2","title":"Signature","text":"<pre><code>def build(self) -&gt; Atmosphere: ...\n</code></pre>"},{"location":"API/particula/gas/atmosphere_builders/#see-also_2","title":"See also","text":"<ul> <li>Atmosphere</li> </ul>"},{"location":"API/particula/gas/species/","title":"Species","text":"<p>Particula Index / Particula / Gas / Species</p> <p>Auto-generated documentation for particula.gas.species module.</p>"},{"location":"API/particula/gas/species/#gasspecies","title":"GasSpecies","text":"<p>Show source in species.py:21</p> <p>GasSpecies represents an individual or array of gas species with properties like name, molar mass, vapor pressure, and condensability.</p>"},{"location":"API/particula/gas/species/#attributes","title":"Attributes","text":"<ul> <li>name : The name of the gas species.</li> <li>molar_mass : The molar mass of the gas species.</li> <li>pure_vapor_pressure_strategy : The strategy for calculating the pure     vapor pressure of the gas species. Can be a single strategy or a     list of strategies. Default is a constant vapor pressure strategy     with a vapor pressure of 0.0 Pa.</li> <li>condensable : Indicates whether the gas species is condensable.     Default is True.</li> <li>concentration : The concentration of the gas species in the mixture.     Default is 0.0 kg/m^3.</li> </ul>"},{"location":"API/particula/gas/species/#signature","title":"Signature","text":"<pre><code>class GasSpecies:\n    def __init__(\n        self,\n        name: Union[str, NDArray[np.str_]],\n        molar_mass: Union[float, NDArray[np.float64]],\n        vapor_pressure_strategy: Union[\n            VaporPressureStrategy, list[VaporPressureStrategy]\n        ] = ConstantVaporPressureStrategy(0.0),\n        condensable: Union[bool, NDArray[np.bool_]] = True,\n        concentration: Union[float, NDArray[np.float64]] = 0.0,\n    ) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/gas/species/#see-also","title":"See also","text":"<ul> <li>VaporPressureStrategy</li> </ul>"},{"location":"API/particula/gas/species/#gasspecieslen","title":"GasSpecies().len","text":"<p>Show source in species.py:62</p> <p>Return the number of gas species.</p>"},{"location":"API/particula/gas/species/#signature_1","title":"Signature","text":"<pre><code>def __len__(self): ...\n</code></pre>"},{"location":"API/particula/gas/species/#gasspeciesstr","title":"GasSpecies().str","text":"<p>Show source in species.py:58</p> <p>Return a string representation of the GasSpecies object.</p>"},{"location":"API/particula/gas/species/#signature_2","title":"Signature","text":"<pre><code>def __str__(self): ...\n</code></pre>"},{"location":"API/particula/gas/species/#gasspecies_check_if_negative_concentration","title":"GasSpecies()._check_if_negative_concentration","text":"<p>Show source in species.py:316</p> <p>Log a warning if the concentration is negative.</p>"},{"location":"API/particula/gas/species/#signature_3","title":"Signature","text":"<pre><code>def _check_if_negative_concentration(\n    self, values: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/gas/species/#gasspecies_check_non_positive_value","title":"GasSpecies()._check_non_positive_value","text":"<p>Show source in species.py:328</p> <p>Check for non-positive values and raise an error if found.</p>"},{"location":"API/particula/gas/species/#signature_4","title":"Signature","text":"<pre><code>def _check_non_positive_value(\n    self, value: Union[float, NDArray[np.float64]], name: str\n) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/gas/species/#gasspeciesadd_concentration","title":"GasSpecies().add_concentration","text":"<p>Show source in species.py:283</p> <p>Add concentration to the gas species.</p>"},{"location":"API/particula/gas/species/#arguments","title":"Arguments","text":"<ul> <li>added_concentration : The concentration to add to the gas     species.</li> </ul>"},{"location":"API/particula/gas/species/#examples","title":"Examples","text":"Example usage of add_concentration<pre><code>gas_object.add_concentration(added_concentration=1e-10)\n</code></pre>"},{"location":"API/particula/gas/species/#signature_5","title":"Signature","text":"<pre><code>def add_concentration(\n    self, added_concentration: Union[float, NDArray[np.float64]]\n) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/gas/species/#gasspeciesget_concentration","title":"GasSpecies().get_concentration","text":"<p>Show source in species.py:94</p> <p>Get the concentration of the gas species in the mixture, in kg/m^3.</p>"},{"location":"API/particula/gas/species/#returns","title":"Returns","text":"<p>The concentration of the gas species in the mixture.</p>"},{"location":"API/particula/gas/species/#signature_6","title":"Signature","text":"<pre><code>def get_concentration(self) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/gas/species/#gasspeciesget_condensable","title":"GasSpecies().get_condensable","text":"<p>Show source in species.py:86</p> <p>Check if the gas species is condensable or not.</p>"},{"location":"API/particula/gas/species/#returns_1","title":"Returns","text":"<p>True if the gas species is condensable, False otherwise.</p>"},{"location":"API/particula/gas/species/#signature_7","title":"Signature","text":"<pre><code>def get_condensable(self) -&gt; Union[bool, NDArray[np.bool_]]: ...\n</code></pre>"},{"location":"API/particula/gas/species/#gasspeciesget_molar_mass","title":"GasSpecies().get_molar_mass","text":"<p>Show source in species.py:78</p> <p>Get the molar mass of the gas species in kg/mol.</p>"},{"location":"API/particula/gas/species/#returns_2","title":"Returns","text":"<p>The molar mass of the gas species, in kg/mol.</p>"},{"location":"API/particula/gas/species/#signature_8","title":"Signature","text":"<pre><code>def get_molar_mass(self) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/gas/species/#gasspeciesget_name","title":"GasSpecies().get_name","text":"<p>Show source in species.py:70</p> <p>Get the name of the gas species.</p>"},{"location":"API/particula/gas/species/#returns_3","title":"Returns","text":"<p>The name of the gas species.</p>"},{"location":"API/particula/gas/species/#signature_9","title":"Signature","text":"<pre><code>def get_name(self) -&gt; Union[str, NDArray[np.str_]]: ...\n</code></pre>"},{"location":"API/particula/gas/species/#gasspeciesget_partial_pressure","title":"GasSpecies().get_partial_pressure","text":"<p>Show source in species.py:142</p> <p>Calculate the partial pressure of the gas based on the vapor pressure strategy.</p> <p>This method accounts for multiple strategies if assigned and calculates partial pressure for each strategy based on the corresponding concentration and molar mass.</p>"},{"location":"API/particula/gas/species/#arguments_1","title":"Arguments","text":"<ul> <li>temperature : The temperature in Kelvin at which to calculate     the partial pressure.</li> </ul>"},{"location":"API/particula/gas/species/#returns_4","title":"Returns","text":"<p>Partial pressure of the gas in Pascals.</p>"},{"location":"API/particula/gas/species/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code> - If the vapor pressure strategy is not set.</li> </ul>"},{"location":"API/particula/gas/species/#examples_1","title":"Examples","text":"Example usage of get_partial_pressure<pre><code>gas_object.get_partial_pressure(temperature=298)\n</code></pre>"},{"location":"API/particula/gas/species/#signature_10","title":"Signature","text":"<pre><code>def get_partial_pressure(\n    self, temperature: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/gas/species/#gasspeciesget_pure_vapor_pressure","title":"GasSpecies().get_pure_vapor_pressure","text":"<p>Show source in species.py:102</p> <p>Calculate the pure vapor pressure of the gas species at a given temperature in Kelvin.</p> <p>This method supports both a single strategy or a list of strategies for calculating vapor pressure.</p>"},{"location":"API/particula/gas/species/#arguments_2","title":"Arguments","text":"<ul> <li>temperature : The temperature in Kelvin at which to calculate     vapor pressure.</li> </ul>"},{"location":"API/particula/gas/species/#returns_5","title":"Returns","text":"<p>The calculated pure vapor pressure in Pascals.</p>"},{"location":"API/particula/gas/species/#raises_1","title":"Raises","text":"<ul> <li><code>ValueError</code> - If no vapor pressure strategy is set.</li> </ul>"},{"location":"API/particula/gas/species/#examples_2","title":"Examples","text":"Example usage of get_pure_vapor_pressure<pre><code>gas_object.get_pure_vapor_pressure(temperature=298)\n</code></pre>"},{"location":"API/particula/gas/species/#signature_11","title":"Signature","text":"<pre><code>def get_pure_vapor_pressure(\n    self, temperature: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/gas/species/#gasspeciesget_saturation_concentration","title":"GasSpecies().get_saturation_concentration","text":"<p>Show source in species.py:238</p> <p>Calculate the saturation concentration of the gas based on the vapor pressure strategy.</p> <p>This method accounts for multiple strategies if assigned and calculates saturation concentration for each strategy based on the molar mass.</p>"},{"location":"API/particula/gas/species/#arguments_3","title":"Arguments","text":"<ul> <li>temperature : The temperature in Kelvin at which to calculate     the partial pressure.</li> </ul>"},{"location":"API/particula/gas/species/#returns_6","title":"Returns","text":"<p>The saturation concentration of the gas.</p>"},{"location":"API/particula/gas/species/#raises_2","title":"Raises","text":"<ul> <li><code>ValueError</code> - If the vapor pressure strategy is not set.</li> </ul>"},{"location":"API/particula/gas/species/#examples_3","title":"Examples","text":"Example usage of get_saturation_concentration<pre><code>gas_object.get_saturation_concentration(temperature=298)\n</code></pre>"},{"location":"API/particula/gas/species/#signature_12","title":"Signature","text":"<pre><code>def get_saturation_concentration(\n    self, temperature: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/gas/species/#gasspeciesget_saturation_ratio","title":"GasSpecies().get_saturation_ratio","text":"<p>Show source in species.py:190</p> <p>Calculate the saturation ratio of the gas based on the vapor pressure strategy.</p> <p>This method accounts for multiple strategies if assigned and calculates saturation ratio for each strategy based on the corresponding concentration and molar mass.</p>"},{"location":"API/particula/gas/species/#arguments_4","title":"Arguments","text":"<ul> <li>temperature : The temperature in Kelvin at which to calculate     the partial pressure.</li> </ul>"},{"location":"API/particula/gas/species/#returns_7","title":"Returns","text":"<p>The saturation ratio of the gas.</p>"},{"location":"API/particula/gas/species/#raises_3","title":"Raises","text":"<p>ValueError : If the vapor pressure strategy is not set.</p>"},{"location":"API/particula/gas/species/#examples_4","title":"Examples","text":"Example usage of get_saturation_ratio<pre><code>gas_object.get_saturation_ratio(temperature=298)\n</code></pre>"},{"location":"API/particula/gas/species/#signature_13","title":"Signature","text":"<pre><code>def get_saturation_ratio(\n    self, temperature: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/gas/species/#gasspeciesset_concentration","title":"GasSpecies().set_concentration","text":"<p>Show source in species.py:299</p> <p>Set the concentration of the gas species.</p>"},{"location":"API/particula/gas/species/#arguments_5","title":"Arguments","text":"<ul> <li>new_concentration : The new concentration of the gas species.</li> </ul>"},{"location":"API/particula/gas/species/#examples_5","title":"Examples","text":"Example usage of set_concentration<pre><code>gas_object.set_concentration(new_concentration=1e-10)\n</code></pre>"},{"location":"API/particula/gas/species/#signature_14","title":"Signature","text":"<pre><code>def set_concentration(\n    self, new_concentration: Union[float, NDArray[np.float64]]\n) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/gas/species_builders/","title":"Species Builders","text":"<p>Particula Index / Particula / Gas / Species Builders</p> <p>Auto-generated documentation for particula.gas.species_builders module.</p>"},{"location":"API/particula/gas/species_builders/#gasspeciesbuilder","title":"GasSpeciesBuilder","text":"<p>Show source in species_builders.py:27</p> <p>Builder class for GasSpecies objects, allowing for a more fluent and readable creation of GasSpecies instances with optional parameters.</p>"},{"location":"API/particula/gas/species_builders/#attributes","title":"Attributes","text":"<ul> <li>name : The name of the gas species.</li> <li>molar_mass : The molar mass of the gas species in kg/mol.</li> <li>vapor_pressure_strategy : The vapor pressure strategy for the     gas species.</li> <li>condensable : Whether the gas species is condensable.</li> <li>concentration : The concentration of the gas species in the     mixture, in kg/m^3.</li> </ul>"},{"location":"API/particula/gas/species_builders/#raises","title":"Raises","text":"<ul> <li>ValueError : If any required key is missing. During check_keys and     pre_build_check. Or if trying to set an invalid parameter.</li> <li>Warning : If using default units for any parameter.</li> </ul>"},{"location":"API/particula/gas/species_builders/#signature","title":"Signature","text":"<pre><code>class GasSpeciesBuilder(BuilderABC, BuilderMolarMassMixin, BuilderConcentrationMixin):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/gas/species_builders/#see-also","title":"See also","text":"<ul> <li>BuilderABC</li> <li>BuilderConcentrationMixin</li> <li>BuilderMolarMassMixin</li> </ul>"},{"location":"API/particula/gas/species_builders/#gasspeciesbuilderbuild","title":"GasSpeciesBuilder().build","text":"<p>Show source in species_builders.py:125</p>"},{"location":"API/particula/gas/species_builders/#signature_1","title":"Signature","text":"<pre><code>def build(self) -&gt; GasSpecies: ...\n</code></pre>"},{"location":"API/particula/gas/species_builders/#see-also_1","title":"See also","text":"<ul> <li>GasSpecies</li> </ul>"},{"location":"API/particula/gas/species_builders/#gasspeciesbuilderset_condensable","title":"GasSpeciesBuilder().set_condensable","text":"<p>Show source in species_builders.py:104</p> <p>Set the condensable bool of the gas species.</p>"},{"location":"API/particula/gas/species_builders/#arguments","title":"Arguments","text":"<p>condensable : Whether the gas species is condensable.</p>"},{"location":"API/particula/gas/species_builders/#returns","title":"Returns","text":"<p>self : The GasSpeciesBuilder object.</p>"},{"location":"API/particula/gas/species_builders/#examples","title":"Examples","text":"Set a single condensable bool<pre><code>builder = GasSpeciesBuilder()\nbuilder.set_condensable(False)\n</code></pre>"},{"location":"API/particula/gas/species_builders/#signature_2","title":"Signature","text":"<pre><code>def set_condensable(self, condensable: Union[bool, NDArray[np.bool_]]): ...\n</code></pre>"},{"location":"API/particula/gas/species_builders/#gasspeciesbuilderset_name","title":"GasSpeciesBuilder().set_name","text":"<p>Show source in species_builders.py:63</p> <p>Set the name of the gas species.</p>"},{"location":"API/particula/gas/species_builders/#arguments_1","title":"Arguments","text":"<p>name : The name of the gas species.</p>"},{"location":"API/particula/gas/species_builders/#returns_1","title":"Returns","text":"<p>self : The GasSpeciesBuilder object.</p>"},{"location":"API/particula/gas/species_builders/#examples_1","title":"Examples","text":"Set a single name<pre><code>builder = GasSpeciesBuilder()\nbuilder.set_name(\"Oxygen\")\n</code></pre>"},{"location":"API/particula/gas/species_builders/#signature_3","title":"Signature","text":"<pre><code>def set_name(self, name: Union[str, NDArray[np.str_]]): ...\n</code></pre>"},{"location":"API/particula/gas/species_builders/#gasspeciesbuilderset_vapor_pressure_strategy","title":"GasSpeciesBuilder().set_vapor_pressure_strategy","text":"<p>Show source in species_builders.py:81</p> <p>Set the vapor pressure strategy for the gas species.</p>"},{"location":"API/particula/gas/species_builders/#arguments_2","title":"Arguments","text":"<p>strategy : The vapor pressure strategy for the gas species.</p>"},{"location":"API/particula/gas/species_builders/#returns_2","title":"Returns","text":"<p>self : The GasSpeciesBuilder object.</p>"},{"location":"API/particula/gas/species_builders/#examples_2","title":"Examples","text":"Set a single vapor pressure strategy<pre><code>builder = GasSpeciesBuilder()\nbuilder.set_vapor_pressure_strategy(\n    ConstantVaporPressureStrategy(vapor_pressure=1.0)\n)\n</code></pre>"},{"location":"API/particula/gas/species_builders/#signature_4","title":"Signature","text":"<pre><code>def set_vapor_pressure_strategy(\n    self, strategy: Union[VaporPressureStrategy, list[VaporPressureStrategy]]\n): ...\n</code></pre>"},{"location":"API/particula/gas/species_builders/#see-also_2","title":"See also","text":"<ul> <li>VaporPressureStrategy</li> </ul>"},{"location":"API/particula/gas/species_builders/#presetgasspeciesbuilder","title":"PresetGasSpeciesBuilder","text":"<p>Show source in species_builders.py:138</p> <p>Builder class for GasSpecies objects, allowing for a more fluent and readable creation of GasSpecies instances with optional parameters.</p>"},{"location":"API/particula/gas/species_builders/#signature_5","title":"Signature","text":"<pre><code>class PresetGasSpeciesBuilder(GasSpeciesBuilder):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/gas/species_builders/#see-also_3","title":"See also","text":"<ul> <li>GasSpeciesBuilder</li> </ul>"},{"location":"API/particula/gas/species_builders/#presetgasspeciesbuilderbuild","title":"PresetGasSpeciesBuilder().build","text":"<p>Show source in species_builders.py:155</p>"},{"location":"API/particula/gas/species_builders/#signature_6","title":"Signature","text":"<pre><code>def build(self) -&gt; GasSpecies: ...\n</code></pre>"},{"location":"API/particula/gas/species_builders/#see-also_4","title":"See also","text":"<ul> <li>GasSpecies</li> </ul>"},{"location":"API/particula/gas/species_factories/","title":"Species Factories","text":"<p>Particula Index / Particula / Gas / Species Factories</p> <p>Auto-generated documentation for particula.gas.species_factories module.</p>"},{"location":"API/particula/gas/species_factories/#gasspeciesfactory","title":"GasSpeciesFactory","text":"<p>Show source in species_factories.py:12</p> <p>Factory class to create species builders</p> <p>Factory class to create species builders for creating gas species.</p>"},{"location":"API/particula/gas/species_factories/#methods","title":"Methods","text":"<ul> <li>get_builders : Returns the mapping of strategy types to builder instances.</li> <li>get_strategy : Gets the strategy instance<ul> <li>strategy_type : Type of species builder to use, can be     'gas_species' or 'preset_gas_species'.</li> <li>parameters : Parameters required for the     builder, dependent on the chosen strategy type.</li> </ul> </li> </ul>"},{"location":"API/particula/gas/species_factories/#returns","title":"Returns","text":"<p>GasSpecies : An instance of the specified GasSpecies.</p>"},{"location":"API/particula/gas/species_factories/#raises","title":"Raises","text":"<p>ValueError : If an unknown strategy type is provided.</p>"},{"location":"API/particula/gas/species_factories/#examples","title":"Examples","text":"Create a preset gas species using the factory<pre><code>factory = GasSpeciesFactory()\ngas_object = factory.get_strategy(\"preset_gas_species\", parameters)\n</code></pre> Create a gas species using the factory<pre><code>factory = GasSpeciesFactory()\nparameters = {\n    \"name\": \"Oxygen\",\n    \"molar_mass\": 0.032,\n    \"vapor_pressure_strategy\": ConstantVaporPressureStrategy(\n        vapor_pressure=101325\n    ),\n    \"condensable\": False,\n    \"concentration\": 1.2,\n}\ngas_object = factory.get_strategy(\"gas_species\", parameters)\n</code></pre>"},{"location":"API/particula/gas/species_factories/#signature","title":"Signature","text":"<pre><code>class GasSpeciesFactory(\n    StrategyFactory[Union[GasSpeciesBuilder, PresetGasSpeciesBuilder], GasSpecies]\n): ...\n</code></pre>"},{"location":"API/particula/gas/species_factories/#see-also","title":"See also","text":"<ul> <li>GasSpeciesBuilder</li> <li>GasSpecies</li> <li>PresetGasSpeciesBuilder</li> </ul>"},{"location":"API/particula/gas/species_factories/#gasspeciesfactoryget_builders","title":"GasSpeciesFactory().get_builders","text":"<p>Show source in species_factories.py:62</p> <p>Returns the mapping of strategy types to builder instances.</p>"},{"location":"API/particula/gas/species_factories/#returns_1","title":"Returns","text":"<p>A dictionary mapping strategy types to builder instances.     - gas_species : GasSpeciesBuilder     - preset_gas_species : PresetGasSpeciesBuilder</p>"},{"location":"API/particula/gas/species_factories/#signature_1","title":"Signature","text":"<pre><code>def get_builders(self): ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_builders/","title":"Vapor Pressure Builders","text":"<p>Particula Index / Particula / Gas / Vapor Pressure Builders</p> <p>Auto-generated documentation for particula.gas.vapor_pressure_builders module.</p>"},{"location":"API/particula/gas/vapor_pressure_builders/#antoinebuilder","title":"AntoineBuilder","text":"<p>Show source in vapor_pressure_builders.py:18</p> <p>Builder class for AntoineVaporPressureStrategy. It allows setting the coefficients 'a', 'b', and 'c' separately and then building the strategy object.</p>"},{"location":"API/particula/gas/vapor_pressure_builders/#examples","title":"Examples","text":"AntoineBuilder<pre><code>strategy = (\n    AntoineBuilder()\n    .set_a(8.07131)\n    .set_b(1730.63)\n    .set_c(233.426)\n    .build()\n)\n</code></pre> AntoineBuilder with units<pre><code>strategy = (\n    AntoineBuilder()\n    .set_a(8.07131)\n    .set_b(1730.63, \"K\")\n    .set_c(233.426, \"K\")\n    .build()\n)\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_builders/#references","title":"References","text":"<ul> <li><code>-</code> Equation - log10(P_mmHG) = a - b / (Temperature_K - c)</li> <li><code>(Reference</code> - https://en.wikipedia.org/wiki/Antoine_equation)</li> </ul>"},{"location":"API/particula/gas/vapor_pressure_builders/#signature","title":"Signature","text":"<pre><code>class AntoineBuilder(BuilderABC):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_builders/#see-also","title":"See also","text":"<ul> <li>BuilderABC</li> </ul>"},{"location":"API/particula/gas/vapor_pressure_builders/#antoinebuilderbuild","title":"AntoineBuilder().build","text":"<p>Show source in vapor_pressure_builders.py:85</p> <p>Build the AntoineVaporPressureStrategy object with the set coefficients.</p>"},{"location":"API/particula/gas/vapor_pressure_builders/#signature_1","title":"Signature","text":"<pre><code>def build(self) -&gt; AntoineVaporPressureStrategy: ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_builders/#see-also_1","title":"See also","text":"<ul> <li>AntoineVaporPressureStrategy</li> </ul>"},{"location":"API/particula/gas/vapor_pressure_builders/#antoinebuilderset_a","title":"AntoineBuilder().set_a","text":"<p>Show source in vapor_pressure_builders.py:57</p> <p>Set the coefficient 'a' of the Antoine equation.</p>"},{"location":"API/particula/gas/vapor_pressure_builders/#signature_2","title":"Signature","text":"<pre><code>def set_a(self, a: float, a_units: Optional[str] = None) -&gt; \"AntoineBuilder\": ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_builders/#antoinebuilderset_b","title":"AntoineBuilder().set_b","text":"<p>Show source in vapor_pressure_builders.py:69</p> <p>Set the coefficient 'b' of the Antoine equation.</p>"},{"location":"API/particula/gas/vapor_pressure_builders/#signature_3","title":"Signature","text":"<pre><code>@validate_inputs({\"b\": \"positive\"})\ndef set_b(self, b: float, b_units: str = \"K\") -&gt; \"AntoineBuilder\": ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_builders/#antoinebuilderset_c","title":"AntoineBuilder().set_c","text":"<p>Show source in vapor_pressure_builders.py:77</p> <p>Set the coefficient 'c' of the Antoine equation.</p>"},{"location":"API/particula/gas/vapor_pressure_builders/#signature_4","title":"Signature","text":"<pre><code>@validate_inputs({\"c\": \"positive\"})\ndef set_c(self, c: float, c_units: str = \"K\") -&gt; \"AntoineBuilder\": ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_builders/#clausiusclapeyronbuilder","title":"ClausiusClapeyronBuilder","text":"<p>Show source in vapor_pressure_builders.py:94</p> <p>Builder class for ClausiusClapeyronStrategy. This class facilitates setting the latent heat of vaporization, initial temperature, and initial pressure with unit handling and then builds the strategy object.</p>"},{"location":"API/particula/gas/vapor_pressure_builders/#examples_1","title":"Examples","text":"ClausiusClapeyronBuilder<pre><code>strategy = (\n    ClausiusClapeyronBuilder()\n    .set_latent_heat(2260)\n    .set_temperature_initial(373.15)\n    .set_pressure_initial(101325)\n    .build()\n)\n</code></pre> ClausiusClapeyronBuilder with units<pre><code>strategy = (\n    ClausiusClapeyronBuilder()\n    .set_latent_heat(2260, \"J/kg\")\n    .set_temperature_initial(373.15, \"K\")\n    .set_pressure_initial(101325, \"Pa\")\n    .build()\n)\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_builders/#references_1","title":"References","text":"<ul> <li><code>-</code> Equation - dP/dT = L / (R * T^2)   https://en.wikipedia.org/wiki/Clausius%E2%80%93Clapeyron_relation</li> </ul>"},{"location":"API/particula/gas/vapor_pressure_builders/#signature_5","title":"Signature","text":"<pre><code>class ClausiusClapeyronBuilder(BuilderABC):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_builders/#see-also_2","title":"See also","text":"<ul> <li>BuilderABC</li> </ul>"},{"location":"API/particula/gas/vapor_pressure_builders/#clausiusclapeyronbuilderbuild","title":"ClausiusClapeyronBuilder().build","text":"<p>Show source in vapor_pressure_builders.py:166</p> <p>Build and return a ClausiusClapeyronStrategy object with the set parameters.</p>"},{"location":"API/particula/gas/vapor_pressure_builders/#signature_6","title":"Signature","text":"<pre><code>def build(self) -&gt; ClausiusClapeyronStrategy: ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_builders/#see-also_3","title":"See also","text":"<ul> <li>ClausiusClapeyronStrategy</li> </ul>"},{"location":"API/particula/gas/vapor_pressure_builders/#clausiusclapeyronbuilderset_latent_heat","title":"ClausiusClapeyronBuilder().set_latent_heat","text":"<p>Show source in vapor_pressure_builders.py:136</p> <p>Set the latent heat of vaporization: Default units J/kg.</p>"},{"location":"API/particula/gas/vapor_pressure_builders/#signature_7","title":"Signature","text":"<pre><code>@validate_inputs({\"latent_heat\": \"positive\"})\ndef set_latent_heat(\n    self, latent_heat: float, latent_heat_units: str = \"J/kg\"\n) -&gt; \"ClausiusClapeyronBuilder\": ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_builders/#clausiusclapeyronbuilderset_pressure_initial","title":"ClausiusClapeyronBuilder().set_pressure_initial","text":"<p>Show source in vapor_pressure_builders.py:156</p> <p>Set the initial pressure. Default units: Pa.</p>"},{"location":"API/particula/gas/vapor_pressure_builders/#signature_8","title":"Signature","text":"<pre><code>@validate_inputs({\"pressure_initial\": \"positive\"})\ndef set_pressure_initial(\n    self, pressure_initial: float, pressure_initial_units: str = \"Pa\"\n) -&gt; \"ClausiusClapeyronBuilder\": ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_builders/#clausiusclapeyronbuilderset_temperature_initial","title":"ClausiusClapeyronBuilder().set_temperature_initial","text":"<p>Show source in vapor_pressure_builders.py:146</p> <p>Set the initial temperature. Default units: K.</p>"},{"location":"API/particula/gas/vapor_pressure_builders/#signature_9","title":"Signature","text":"<pre><code>@validate_inputs({\"temperature_initial\": \"positive\"})\ndef set_temperature_initial(\n    self, temperature_initial: float, temperature_initial_units: str = \"K\"\n) -&gt; \"ClausiusClapeyronBuilder\": ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_builders/#constantbuilder","title":"ConstantBuilder","text":"<p>Show source in vapor_pressure_builders.py:177</p> <p>Builder class for ConstantVaporPressureStrategy. This class facilitates setting the constant vapor pressure and then building the strategy object.</p>"},{"location":"API/particula/gas/vapor_pressure_builders/#examples_2","title":"Examples","text":"ConstantBuilder<pre><code>strategy = (\n    ConstantBuilder()\n    .set_vapor_pressure(101325)\n    .build()\n)\n</code></pre> ConstantBuilder with units<pre><code>strategy = (\n    ConstantBuilder()\n    .set_vapor_pressure(1, \"atm\")\n    .build()\n)\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_builders/#references_2","title":"References","text":"<ul> <li><code>-</code> Equation - P = vapor_pressure   https://en.wikipedia.org/wiki/Vapor_pressure</li> </ul>"},{"location":"API/particula/gas/vapor_pressure_builders/#signature_10","title":"Signature","text":"<pre><code>class ConstantBuilder(BuilderABC):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_builders/#see-also_4","title":"See also","text":"<ul> <li>BuilderABC</li> </ul>"},{"location":"API/particula/gas/vapor_pressure_builders/#constantbuilderbuild","title":"ConstantBuilder().build","text":"<p>Show source in vapor_pressure_builders.py:218</p> <p>Build and return a ConstantVaporPressureStrategy object with the set parameters.</p>"},{"location":"API/particula/gas/vapor_pressure_builders/#signature_11","title":"Signature","text":"<pre><code>def build(self) -&gt; ConstantVaporPressureStrategy: ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_builders/#see-also_5","title":"See also","text":"<ul> <li>ConstantVaporPressureStrategy</li> </ul>"},{"location":"API/particula/gas/vapor_pressure_builders/#constantbuilderset_vapor_pressure","title":"ConstantBuilder().set_vapor_pressure","text":"<p>Show source in vapor_pressure_builders.py:208</p> <p>Set the constant vapor pressure.</p>"},{"location":"API/particula/gas/vapor_pressure_builders/#signature_12","title":"Signature","text":"<pre><code>@validate_inputs({\"vapor_pressure\": \"positive\"})\ndef set_vapor_pressure(\n    self, vapor_pressure: float, vapor_pressure_units: str = \"Pa\"\n) -&gt; \"ConstantBuilder\": ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_builders/#waterbuckbuilder","title":"WaterBuckBuilder","text":"<p>Show source in vapor_pressure_builders.py:225</p> <p>Builder class for WaterBuckStrategy. This class facilitates the building of the WaterBuckStrategy object. Which as of now has no additional parameters to set. But could be extended in the future for ice only calculations.</p>"},{"location":"API/particula/gas/vapor_pressure_builders/#examples_3","title":"Examples","text":"WaterBuckBuilder<pre><code>WaterBuckBuilder().build()\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_builders/#signature_13","title":"Signature","text":"<pre><code>class WaterBuckBuilder(BuilderABC):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_builders/#see-also_6","title":"See also","text":"<ul> <li>BuilderABC</li> </ul>"},{"location":"API/particula/gas/vapor_pressure_builders/#waterbuckbuilderbuild","title":"WaterBuckBuilder().build","text":"<p>Show source in vapor_pressure_builders.py:240</p> <p>Build and return a WaterBuckStrategy object.</p>"},{"location":"API/particula/gas/vapor_pressure_builders/#signature_14","title":"Signature","text":"<pre><code>def build(self) -&gt; WaterBuckStrategy: ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_builders/#see-also_7","title":"See also","text":"<ul> <li>WaterBuckStrategy</li> </ul>"},{"location":"API/particula/gas/vapor_pressure_factories/","title":"Vapor Pressure Factories","text":"<p>Particula Index / Particula / Gas / Vapor Pressure Factories</p> <p>Auto-generated documentation for particula.gas.vapor_pressure_factories module.</p>"},{"location":"API/particula/gas/vapor_pressure_factories/#vaporpressurefactory","title":"VaporPressureFactory","text":"<p>Show source in vapor_pressure_factories.py:20</p> <p>Factory class to create vapor pressure strategy builders</p> <p>Factory class to create vapor pressure strategy builders for calculating vapor pressure of gas species.</p>"},{"location":"API/particula/gas/vapor_pressure_factories/#methods","title":"Methods","text":"<ul> <li>get_builders : Returns the mapping of strategy types to builder     instances.</li> <li>get_strategy : Gets the strategy instance     for the specified strategy type.<ul> <li>strategy_type : Type of vapor pressure strategy to use, can be     'constant', 'antoine', 'clausius_clapeyron', or 'water_buck'.</li> <li>parameters : Parameters required for the     builder, dependent on the chosen strategy type.         - <code>-</code> constant - constant_vapor_pressure         - <code>-</code> antoine - A, B, C         - <code>-</code> clausius_clapeyron - A, B, C         - <code>-</code> water_buck - No parameters are required.</li> </ul> </li> </ul>"},{"location":"API/particula/gas/vapor_pressure_factories/#returns","title":"Returns","text":"<p>VaporPressureStrategy : An instance of the specified     VaporPressureStrategy.</p>"},{"location":"API/particula/gas/vapor_pressure_factories/#raises","title":"Raises","text":"<p>ValueError : If an unknown strategy type is provided. ValueError : If any required key is missing during check_keys or     pre_build_check, or if trying to set an invalid parameter.</p>"},{"location":"API/particula/gas/vapor_pressure_factories/#examples","title":"Examples","text":"constant vapor pressure strategy<pre><code>strategy_is = VaporPressureFactory().get_strategy(\"constant\")\n# returns ConstantVaporPressureStrategy\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_factories/#signature","title":"Signature","text":"<pre><code>class VaporPressureFactory(\n    StrategyFactory[\n        Union[\n            ConstantBuilder, AntoineBuilder, ClausiusClapeyronBuilder, WaterBuckBuilder\n        ],\n        Union[\n            ConstantVaporPressureStrategy,\n            AntoineVaporPressureStrategy,\n            ClausiusClapeyronStrategy,\n            WaterBuckStrategy,\n        ],\n    ]\n): ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_factories/#see-also","title":"See also","text":"<ul> <li>AntoineBuilder</li> <li>AntoineVaporPressureStrategy</li> <li>ClausiusClapeyronBuilder</li> <li>ClausiusClapeyronStrategy</li> <li>ConstantBuilder</li> <li>ConstantVaporPressureStrategy</li> <li>WaterBuckBuilder</li> <li>WaterBuckStrategy</li> </ul>"},{"location":"API/particula/gas/vapor_pressure_factories/#vaporpressurefactoryget_builders","title":"VaporPressureFactory().get_builders","text":"<p>Show source in vapor_pressure_factories.py:71</p> <p>Returns the mapping of strategy types to builder instances.</p>"},{"location":"API/particula/gas/vapor_pressure_factories/#returns_1","title":"Returns","text":"<p>A dictionary mapping strategy types to builder instances.     - <code>-</code> constant - ConstantBuilder     - <code>-</code> antoine - AntoineBuilder     - <code>-</code> clausius_clapeyron - ClausiusClapeyronBuilder     - <code>-</code> water_buck - WaterBuckBuilder</p>"},{"location":"API/particula/gas/vapor_pressure_factories/#signature_1","title":"Signature","text":"<pre><code>def get_builders(self): ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_strategies/","title":"Vapor Pressure Strategies","text":"<p>Particula Index / Particula / Gas / Vapor Pressure Strategies</p> <p>Auto-generated documentation for particula.gas.vapor_pressure_strategies module.</p>"},{"location":"API/particula/gas/vapor_pressure_strategies/#antoinevaporpressurestrategy","title":"AntoineVaporPressureStrategy","text":"<p>Show source in vapor_pressure_strategies.py:195</p> <p>Concrete implementation of the VaporPressureStrategy using the Antoine equation for vapor pressure calculations.</p>"},{"location":"API/particula/gas/vapor_pressure_strategies/#signature","title":"Signature","text":"<pre><code>class AntoineVaporPressureStrategy(VaporPressureStrategy):\n    def __init__(\n        self,\n        a: Union[float, NDArray[np.float64]] = 0.0,\n        b: Union[float, NDArray[np.float64]] = 0.0,\n        c: Union[float, NDArray[np.float64]] = 0.0,\n    ): ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_strategies/#see-also","title":"See also","text":"<ul> <li>VaporPressureStrategy</li> </ul>"},{"location":"API/particula/gas/vapor_pressure_strategies/#antoinevaporpressurestrategypure_vapor_pressure","title":"AntoineVaporPressureStrategy().pure_vapor_pressure","text":"<p>Show source in vapor_pressure_strategies.py:211</p> <p>Calculate vapor pressure using the Antoine equation.</p>"},{"location":"API/particula/gas/vapor_pressure_strategies/#arguments","title":"Arguments","text":"<ul> <li>temperature : Temperature in Kelvin.</li> </ul>"},{"location":"API/particula/gas/vapor_pressure_strategies/#returns","title":"Returns","text":"<p>Vapor pressure in Pascals.</p>"},{"location":"API/particula/gas/vapor_pressure_strategies/#examples","title":"Examples","text":"Antoine Vapor Pressure Calculation<pre><code>vapor_pressure = strategy.pure_vapor_pressure(\n    temperature=300\n)\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_strategies/#references","title":"References","text":"<ul> <li><code>-</code> Equation - log10(P) = a - b / (T - c)</li> <li>https://en.wikipedia.org/wiki/Antoine_equation (but in Kelvin)</li> <li>Kelvin form:     https://onlinelibrary.wiley.com/doi/pdf/10.1002/9781118135341.app1</li> </ul>"},{"location":"API/particula/gas/vapor_pressure_strategies/#signature_1","title":"Signature","text":"<pre><code>def pure_vapor_pressure(\n    self, temperature: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_strategies/#clausiusclapeyronstrategy","title":"ClausiusClapeyronStrategy","text":"<p>Show source in vapor_pressure_strategies.py:241</p> <p>Concrete implementation of the VaporPressureStrategy using the Clausius-Clapeyron equation for vapor pressure calculations.</p>"},{"location":"API/particula/gas/vapor_pressure_strategies/#signature_2","title":"Signature","text":"<pre><code>class ClausiusClapeyronStrategy(VaporPressureStrategy):\n    def __init__(\n        self,\n        latent_heat: Union[float, NDArray[np.float64]],\n        temperature_initial: Union[float, NDArray[np.float64]],\n        pressure_initial: Union[float, NDArray[np.float64]],\n    ): ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_strategies/#see-also_1","title":"See also","text":"<ul> <li>VaporPressureStrategy</li> </ul>"},{"location":"API/particula/gas/vapor_pressure_strategies/#clausiusclapeyronstrategypure_vapor_pressure","title":"ClausiusClapeyronStrategy().pure_vapor_pressure","text":"<p>Show source in vapor_pressure_strategies.py:264</p> <p>Calculate vapor pressure using Clausius-Clapeyron equation.</p>"},{"location":"API/particula/gas/vapor_pressure_strategies/#arguments_1","title":"Arguments","text":"<ul> <li>temperature : Final temperature in Kelvin.</li> </ul>"},{"location":"API/particula/gas/vapor_pressure_strategies/#returns_1","title":"Returns","text":"<p>Pure vapor pressure in Pascals.</p>"},{"location":"API/particula/gas/vapor_pressure_strategies/#examples_1","title":"Examples","text":"Clausius-Clapeyron Vapor Pressure Calculation<pre><code>vapor_pressure = strategy.pure_vapor_pressure(\n    temperature=300\n)\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_strategies/#references_1","title":"References","text":"<ul> <li>https://en.wikipedia.org/wiki/Clausius%E2%80%93Clapeyron_relation</li> </ul>"},{"location":"API/particula/gas/vapor_pressure_strategies/#signature_3","title":"Signature","text":"<pre><code>def pure_vapor_pressure(\n    self, temperature: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_strategies/#constantvaporpressurestrategy","title":"ConstantVaporPressureStrategy","text":"<p>Show source in vapor_pressure_strategies.py:165</p> <p>Concrete implementation of the VaporPressureStrategy using a constant vapor pressure value.</p>"},{"location":"API/particula/gas/vapor_pressure_strategies/#signature_4","title":"Signature","text":"<pre><code>class ConstantVaporPressureStrategy(VaporPressureStrategy):\n    def __init__(self, vapor_pressure: Union[float, NDArray[np.float64]]): ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_strategies/#see-also_2","title":"See also","text":"<ul> <li>VaporPressureStrategy</li> </ul>"},{"location":"API/particula/gas/vapor_pressure_strategies/#constantvaporpressurestrategypure_vapor_pressure","title":"ConstantVaporPressureStrategy().pure_vapor_pressure","text":"<p>Show source in vapor_pressure_strategies.py:172</p> <p>Return the constant vapor pressure value.</p>"},{"location":"API/particula/gas/vapor_pressure_strategies/#arguments_2","title":"Arguments","text":"<ul> <li>temperature : Not used.</li> </ul>"},{"location":"API/particula/gas/vapor_pressure_strategies/#returns_2","title":"Returns","text":"<p>The constant vapor pressure value in Pascals.</p>"},{"location":"API/particula/gas/vapor_pressure_strategies/#examples_2","title":"Examples","text":"Constant Vapor Pressure Calculation<pre><code>vapor_pressure = strategy.pure_vapor_pressure(\n    temperature=300\n)\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_strategies/#signature_5","title":"Signature","text":"<pre><code>def pure_vapor_pressure(\n    self, temperature: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_strategies/#vaporpressurestrategy","title":"VaporPressureStrategy","text":"<p>Show source in vapor_pressure_strategies.py:28</p> <p>Abstract class for vapor pressure calculations. The methods defined here must be implemented by subclasses below.</p>"},{"location":"API/particula/gas/vapor_pressure_strategies/#signature_6","title":"Signature","text":"<pre><code>class VaporPressureStrategy(ABC): ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_strategies/#vaporpressurestrategyconcentration","title":"VaporPressureStrategy().concentration","text":"<p>Show source in vapor_pressure_strategies.py:63</p> <p>Calculate the concentration of the gas at a given pressure and temperature.</p>"},{"location":"API/particula/gas/vapor_pressure_strategies/#arguments_3","title":"Arguments","text":"<ul> <li><code>-</code> partial_pressure - Pressure in Pascals.</li> <li><code>-</code> molar_mass - Molar mass of the gas in kg/mol.</li> <li><code>-</code> temperature - Temperature in Kelvin.</li> </ul>"},{"location":"API/particula/gas/vapor_pressure_strategies/#returns_3","title":"Returns","text":"<p>The concentration of the gas in kg/m^3.</p>"},{"location":"API/particula/gas/vapor_pressure_strategies/#examples_3","title":"Examples","text":"Concentration Calculation<pre><code>concentration = strategy.concentration(\n    partial_pressure=101325,\n    molar_mass=18.01528,\n    temperature=298.15\n)\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_strategies/#signature_7","title":"Signature","text":"<pre><code>def concentration(\n    self,\n    partial_pressure: Union[float, NDArray[np.float64]],\n    molar_mass: Union[float, NDArray[np.float64]],\n    temperature: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_strategies/#vaporpressurestrategypartial_pressure","title":"VaporPressureStrategy().partial_pressure","text":"<p>Show source in vapor_pressure_strategies.py:32</p> <p>Calculate the partial pressure of the gas from its concentration, molar mass, and temperature.</p>"},{"location":"API/particula/gas/vapor_pressure_strategies/#arguments_4","title":"Arguments","text":"<ul> <li>concentration : Concentration of the gas in kg/m^3.</li> <li>molar_mass : Molar mass of the gas in kg/mol.</li> <li>temperature : Temperature in Kelvin.</li> </ul>"},{"location":"API/particula/gas/vapor_pressure_strategies/#returns_4","title":"Returns","text":"<p>Partial pressure of the gas in Pascals.</p>"},{"location":"API/particula/gas/vapor_pressure_strategies/#examples_4","title":"Examples","text":"Partial Pressure Calculation<pre><code>partial_pressure = strategy.partial_pressure(\n    concentration=5.0,\n    molar_mass=18.01528,\n    temperature=298.15\n)\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_strategies/#signature_8","title":"Signature","text":"<pre><code>def partial_pressure(\n    self,\n    concentration: Union[float, NDArray[np.float64]],\n    molar_mass: Union[float, NDArray[np.float64]],\n    temperature: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_strategies/#vaporpressurestrategypure_vapor_pressure","title":"VaporPressureStrategy().pure_vapor_pressure","text":"<p>Show source in vapor_pressure_strategies.py:153</p> <p>Calculate the pure (saturation) vapor pressure at a given temperature. Units are in Pascals Pa=kg/(m\u00b7s\u00b2).</p>"},{"location":"API/particula/gas/vapor_pressure_strategies/#arguments_5","title":"Arguments","text":"<ul> <li>temperature : Temperature in Kelvin.</li> </ul>"},{"location":"API/particula/gas/vapor_pressure_strategies/#signature_9","title":"Signature","text":"<pre><code>@abstractmethod\ndef pure_vapor_pressure(\n    self, temperature: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_strategies/#vaporpressurestrategysaturation_concentration","title":"VaporPressureStrategy().saturation_concentration","text":"<p>Show source in vapor_pressure_strategies.py:124</p> <p>Calculate the saturation concentration of the gas at a given temperature.</p>"},{"location":"API/particula/gas/vapor_pressure_strategies/#arguments_6","title":"Arguments","text":"<ul> <li>molar_mass : Molar mass of the gas in kg/mol.</li> <li>temperature : Temperature in Kelvin.</li> </ul>"},{"location":"API/particula/gas/vapor_pressure_strategies/#returns_5","title":"Returns","text":"<p>The saturation concentration of the gas in kg/m^3.</p>"},{"location":"API/particula/gas/vapor_pressure_strategies/#examples_5","title":"Examples","text":"Saturation Concentration Calculation<pre><code>saturation_concentration = strategy.saturation_concentration(\n    molar_mass=18.01528,\n    temperature=298.15\n)\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_strategies/#signature_10","title":"Signature","text":"<pre><code>def saturation_concentration(\n    self,\n    molar_mass: Union[float, NDArray[np.float64]],\n    temperature: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_strategies/#vaporpressurestrategysaturation_ratio","title":"VaporPressureStrategy().saturation_ratio","text":"<p>Show source in vapor_pressure_strategies.py:94</p> <p>Calculate the saturation ratio of the gas at a given pressure and temperature.</p>"},{"location":"API/particula/gas/vapor_pressure_strategies/#arguments_7","title":"Arguments","text":"<ul> <li>pressure : Pressure in Pascals.</li> <li>temperature : Temperature in Kelvin.</li> </ul>"},{"location":"API/particula/gas/vapor_pressure_strategies/#returns_6","title":"Returns","text":"<p>The saturation ratio of the gas.</p>"},{"location":"API/particula/gas/vapor_pressure_strategies/#examples_6","title":"Examples","text":"Saturation Ratio Calculation<pre><code>saturation_ratio = strategy.saturation_ratio(\n    concentration=5.0,\n    molar_mass=18.01528,\n    temperature=298.15\n)\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_strategies/#signature_11","title":"Signature","text":"<pre><code>def saturation_ratio(\n    self,\n    concentration: Union[float, NDArray[np.float64]],\n    molar_mass: Union[float, NDArray[np.float64]],\n    temperature: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_strategies/#waterbuckstrategy","title":"WaterBuckStrategy","text":"<p>Show source in vapor_pressure_strategies.py:294</p> <p>Concrete implementation of the VaporPressureStrategy using the Buck equation for water vapor pressure calculations.</p>"},{"location":"API/particula/gas/vapor_pressure_strategies/#signature_12","title":"Signature","text":"<pre><code>class WaterBuckStrategy(VaporPressureStrategy): ...\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_strategies/#see-also_3","title":"See also","text":"<ul> <li>VaporPressureStrategy</li> </ul>"},{"location":"API/particula/gas/vapor_pressure_strategies/#waterbuckstrategypure_vapor_pressure","title":"WaterBuckStrategy().pure_vapor_pressure","text":"<p>Show source in vapor_pressure_strategies.py:298</p> <p>Calculate vapor pressure using the Buck equation for water vapor.</p>"},{"location":"API/particula/gas/vapor_pressure_strategies/#arguments_8","title":"Arguments","text":"<ul> <li><code>-</code> temperature - Temperature in Kelvin.</li> </ul>"},{"location":"API/particula/gas/vapor_pressure_strategies/#returns_7","title":"Returns","text":"<p>Vapor pressure in Pascals.</p>"},{"location":"API/particula/gas/vapor_pressure_strategies/#examples_7","title":"Examples","text":"Water Buck Vapor Pressure Calculation<pre><code>vapor_pressure = strategy.pure_vapor_pressure(\n    temperature=300\n)\n</code></pre>"},{"location":"API/particula/gas/vapor_pressure_strategies/#references_2","title":"References","text":"<ul> <li>Buck, A. L., 1981: New Equations for Computing Vapor Pressure and   Enhancement Factor. J. Appl. Meteor. Climatol., 20, 1527-1532,   https://doi.org/10.1175/1520-0450(1981)020&lt;1527:NEFCVP&gt;2.0.CO;2.</li> <li>https://en.wikipedia.org/wiki/Arden_Buck_equation</li> </ul>"},{"location":"API/particula/gas/vapor_pressure_strategies/#signature_13","title":"Signature","text":"<pre><code>def pure_vapor_pressure(\n    self, temperature: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/gas/properties/","title":"Properties","text":"<p>Particula Index / Particula / Gas / Properties</p> <p>Auto-generated documentation for particula.gas.properties module.</p>"},{"location":"API/particula/gas/properties/#modules","title":"Modules","text":"<ul> <li>Concentration Function</li> <li>Dynamic Viscosity</li> <li>Mean Free Path</li> <li>Pressure Function</li> <li>Thermal Conductivity</li> <li>Vapor Pressure Module</li> </ul>"},{"location":"API/particula/gas/properties/concentration_function/","title":"Concentration Function","text":"<p>Particula Index / Particula / Gas / Properties / Concentration Function</p> <p>Auto-generated documentation for particula.gas.properties.concentration_function module.</p>"},{"location":"API/particula/gas/properties/concentration_function/#calculate_concentration","title":"calculate_concentration","text":"<p>Show source in concentration_function.py:11</p> <p>Calculate the concentration of a gas from its partial pressure, molar mass, and temperature using the ideal gas law.</p>"},{"location":"API/particula/gas/properties/concentration_function/#arguments","title":"Arguments","text":"<ul> <li>pressure (float or NDArray[np.float64]): Partial pressure of the gas in Pascals (Pa).</li> <li>molar_mass (float or NDArray[np.float64]): Molar mass of the gas in kg/mol</li> <li>temperature (float or NDArray[np.float64]): Temperature in Kelvin.</li> </ul>"},{"location":"API/particula/gas/properties/concentration_function/#returns","title":"Returns","text":"<ul> <li>concentration (float or NDArray[np.float64]): Concentration of the gas in kg/m^3.</li> </ul>"},{"location":"API/particula/gas/properties/concentration_function/#signature","title":"Signature","text":"<pre><code>def calculate_concentration(\n    partial_pressure: Union[float, NDArray[np.float64]],\n    molar_mass: Union[float, NDArray[np.float64]],\n    temperature: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/gas/properties/dynamic_viscosity/","title":"Dynamic Viscosity","text":"<p>Particula Index / Particula / Gas / Properties / Dynamic Viscosity</p> <p>Auto-generated documentation for particula.gas.properties.dynamic_viscosity module.</p>"},{"location":"API/particula/gas/properties/dynamic_viscosity/#get_dynamic_viscosity","title":"get_dynamic_viscosity","text":"<p>Show source in dynamic_viscosity.py:24</p> <p>Calculates the dynamic viscosity of air via Sutherland's formula, which is a common method in fluid dynamics for gases that involves temperature adjustments.</p>"},{"location":"API/particula/gas/properties/dynamic_viscosity/#arguments","title":"Arguments","text":"<ul> <li><code>-</code> temperature - Desired air temperature [K]. Must be greater than 0.</li> <li><code>-</code> reference_viscosity - Gas viscosity [Pa*s] at the reference temperature (default is STP).</li> <li><code>-</code> reference_temperature - Gas temperature [K] for the reference viscosity (default is STP).</li> </ul>"},{"location":"API/particula/gas/properties/dynamic_viscosity/#returns","title":"Returns","text":"<ul> <li><code>-</code> float - The dynamic viscosity of air at the given temperature [Pa*s].</li> </ul>"},{"location":"API/particula/gas/properties/dynamic_viscosity/#raises","title":"Raises","text":"<ul> <li><code>-</code> ValueError - If the temperature is less than or equal to 0.</li> </ul>"},{"location":"API/particula/gas/properties/dynamic_viscosity/#references","title":"References","text":"<p>https://resources.wolframcloud.com/FormulaRepository/resources/Sutherlands-Formula</p>"},{"location":"API/particula/gas/properties/dynamic_viscosity/#signature","title":"Signature","text":"<pre><code>def get_dynamic_viscosity(\n    temperature: float,\n    reference_viscosity: float = REF_VISCOSITY_AIR_STP,\n    reference_temperature: float = REF_TEMPERATURE_STP,\n) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/gas/properties/dynamic_viscosity/#see-also","title":"See also","text":"<ul> <li>REF_TEMPERATURE_STP</li> <li>REF_VISCOSITY_AIR_STP</li> </ul>"},{"location":"API/particula/gas/properties/mean_free_path/","title":"Mean Free Path","text":"<p>Particula Index / Particula / Gas / Properties / Mean Free Path</p> <p>Auto-generated documentation for particula.gas.properties.mean_free_path module.</p>"},{"location":"API/particula/gas/properties/mean_free_path/#molecule_mean_free_path","title":"molecule_mean_free_path","text":"<p>Show source in mean_free_path.py:27</p> <p>Calculate the mean free path of a gas molecule in air based on the temperature, pressure, and molar mass of the gas. The mean free path is the average distance traveled by a molecule between collisions with other molecules present in a medium (air).</p>"},{"location":"API/particula/gas/properties/mean_free_path/#arguments","title":"Arguments","text":"<ul> <li>molar_mass (Union[float, NDArray[np.float64]]): The molar mass of the gas molecule [kg/mol]. Default is the molecular weight of air.</li> <li>temperature (float): The temperature of the gas [K]. Default is 298.15 K.</li> <li>pressure (float): The pressure of the gas [Pa]. Default is 101325 Pa.</li> <li>dynamic_viscosity (Optional[float]): The dynamic viscosity of the gas [Pa*s]. If not provided, it will be calculated based on the temperature.</li> </ul>"},{"location":"API/particula/gas/properties/mean_free_path/#returns","title":"Returns","text":"<ul> <li>Union[float, NDArray[np.float64]]: The mean free path of the gas molecule in meters (m).</li> </ul>"},{"location":"API/particula/gas/properties/mean_free_path/#references","title":"References","text":"<ul> <li>https://en.wikipedia.org/wiki/Mean_free_path</li> </ul>"},{"location":"API/particula/gas/properties/mean_free_path/#signature","title":"Signature","text":"<pre><code>def molecule_mean_free_path(\n    molar_mass: ignore = MOLECULAR_WEIGHT_AIR,\n    temperature: float = 298.15,\n    pressure: float = 101325,\n    dynamic_viscosity: Optional[float] = None,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/gas/properties/mean_free_path/#see-also","title":"See also","text":"<ul> <li>MOLECULAR_WEIGHT_AIR</li> </ul>"},{"location":"API/particula/gas/properties/pressure_function/","title":"Pressure Function","text":"<p>Particula Index / Particula / Gas / Properties / Pressure Function</p> <p>Auto-generated documentation for particula.gas.properties.pressure_function module.</p>"},{"location":"API/particula/gas/properties/pressure_function/#calculate_partial_pressure","title":"calculate_partial_pressure","text":"<p>Show source in pressure_function.py:10</p> <p>Calculate the partial pressure of a gas from its concentration, molar mass, and temperature.</p>"},{"location":"API/particula/gas/properties/pressure_function/#arguments","title":"Arguments","text":"<ul> <li>concentration (float): Concentration of the gas in kg/m^3.</li> <li>molar_mass (float): Molar mass of the gas in kg/mol.</li> <li>temperature (float): Temperature in Kelvin.</li> </ul>"},{"location":"API/particula/gas/properties/pressure_function/#returns","title":"Returns","text":"<ul> <li><code>-</code> float - Partial pressure of the gas in Pascals (Pa).</li> </ul>"},{"location":"API/particula/gas/properties/pressure_function/#signature","title":"Signature","text":"<pre><code>def calculate_partial_pressure(\n    concentration: Union[float, NDArray[np.float64]],\n    molar_mass: Union[float, NDArray[np.float64]],\n    temperature: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/gas/properties/pressure_function/#calculate_saturation_ratio","title":"calculate_saturation_ratio","text":"<p>Show source in pressure_function.py:39</p> <p>Calculate the saturation ratio of the gas at a given pressure and temperature.</p>"},{"location":"API/particula/gas/properties/pressure_function/#arguments_1","title":"Arguments","text":"<ul> <li><code>partial_pressure</code> - Pressure in Pascals.</li> <li><code>pure_vapor_pressure</code> - Pure vapor pressure of the gas in Pascals.</li> </ul>"},{"location":"API/particula/gas/properties/pressure_function/#returns_1","title":"Returns","text":"<ul> <li><code>saturation_ratio</code> - The saturation ratio of the gas.</li> </ul>"},{"location":"API/particula/gas/properties/pressure_function/#signature_1","title":"Signature","text":"<pre><code>def calculate_saturation_ratio(\n    partial_pressure: Union[float, NDArray[np.float64]],\n    pure_vapor_pressure: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/gas/properties/thermal_conductivity/","title":"Thermal Conductivity","text":"<p>Particula Index / Particula / Gas / Properties / Thermal Conductivity</p> <p>Auto-generated documentation for particula.gas.properties.thermal_conductivity module.</p>"},{"location":"API/particula/gas/properties/thermal_conductivity/#get_thermal_conductivity","title":"get_thermal_conductivity","text":"<p>Show source in thermal_conductivity.py:11</p> <p>Calculate the thermal conductivity of air as a function of temperature. Based on a simplified linear relation from atmospheric science literature. Only valid for temperatures within the range typically found on Earth's surface.</p>"},{"location":"API/particula/gas/properties/thermal_conductivity/#arguments","title":"Arguments","text":"<ul> <li>temperature (Union[float, NDArray[np.float64]]): The temperature at which the thermal conductivity of air is to be calculated, in Kelvin (K).</li> </ul>"},{"location":"API/particula/gas/properties/thermal_conductivity/#returns","title":"Returns","text":"<ul> <li>Union[float, NDArray[np.float64]]: The thermal conductivity of air at the specified temperature in Watts per meter-Kelvin (W/m\u00b7K) or J/(m s K).</li> </ul>"},{"location":"API/particula/gas/properties/thermal_conductivity/#raises","title":"Raises","text":"<ul> <li><code>-</code> ValueError - If the temperature is below absolute zero (0 K).</li> </ul>"},{"location":"API/particula/gas/properties/thermal_conductivity/#references","title":"References","text":"<ul> <li>Seinfeld and Pandis, \"Atmospheric Chemistry and Physics\", Equation 17.54.</li> </ul>"},{"location":"API/particula/gas/properties/thermal_conductivity/#signature","title":"Signature","text":"<pre><code>def get_thermal_conductivity(\n    temperature: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/gas/properties/vapor_pressure_module/","title":"Vapor Pressure Module","text":"<p>Particula Index / Particula / Gas / Properties / Vapor Pressure Module</p> <p>Auto-generated documentation for particula.gas.properties.vapor_pressure_module module.</p>"},{"location":"API/particula/gas/properties/vapor_pressure_module/#antoine_vapor_pressure","title":"antoine_vapor_pressure","text":"<p>Show source in vapor_pressure_module.py:12</p> <p>Calculate vapor pressure using the Antoine equation.</p>"},{"location":"API/particula/gas/properties/vapor_pressure_module/#arguments","title":"Arguments","text":"<p>a, b, c: Antoine equation parameters. - <code>temperature</code> - Temperature in Kelvin.</p>"},{"location":"API/particula/gas/properties/vapor_pressure_module/#returns","title":"Returns","text":"<p>Vapor pressure in Pascals.</p>"},{"location":"API/particula/gas/properties/vapor_pressure_module/#references","title":"References","text":"<ul> <li><code>-</code> Equation - log10(P) = a - b / (T - c)</li> <li>https://en.wikipedia.org/wiki/Antoine_equation (but in Kelvin)</li> <li>Kelvin form:     https://onlinelibrary.wiley.com/doi/pdf/10.1002/9781118135341.app1</li> </ul>"},{"location":"API/particula/gas/properties/vapor_pressure_module/#signature","title":"Signature","text":"<pre><code>def antoine_vapor_pressure(\n    a: Union[float, NDArray[np.float64]],\n    b: Union[float, NDArray[np.float64]],\n    c: Union[float, NDArray[np.float64]],\n    temperature: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/gas/properties/vapor_pressure_module/#buck_vapor_pressure","title":"buck_vapor_pressure","text":"<p>Show source in vapor_pressure_module.py:70</p> <p>Calculate vapor pressure using the Buck equation for water vapor.</p>"},{"location":"API/particula/gas/properties/vapor_pressure_module/#arguments_1","title":"Arguments","text":"<ul> <li><code>temperature</code> - Temperature in Kelvin.</li> </ul>"},{"location":"API/particula/gas/properties/vapor_pressure_module/#returns_1","title":"Returns","text":"<p>Vapor pressure in Pascals.</p>"},{"location":"API/particula/gas/properties/vapor_pressure_module/#references_1","title":"References","text":"<ul> <li>Buck, A. L., 1981: New Equations for Computing Vapor Pressure and     Enhancement Factor. J. Appl. Meteor. Climatol., 20, 1527-1532,     https://doi.org/10.1175/1520-0450(1981)020&lt;1527:NEFCVP&gt;2.0.CO;2.</li> <li>https://en.wikipedia.org/wiki/Arden_Buck_equation</li> </ul>"},{"location":"API/particula/gas/properties/vapor_pressure_module/#signature_1","title":"Signature","text":"<pre><code>def buck_vapor_pressure(\n    temperature: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/gas/properties/vapor_pressure_module/#clausius_clapeyron_vapor_pressure","title":"clausius_clapeyron_vapor_pressure","text":"<p>Show source in vapor_pressure_module.py:40</p> <p>Calculate vapor pressure using Clausius-Clapeyron equation.</p>"},{"location":"API/particula/gas/properties/vapor_pressure_module/#arguments_2","title":"Arguments","text":"<ul> <li><code>latent_heat</code> - Latent heat of vaporization in J/mol.</li> <li><code>temperature_initial</code> - Initial temperature in Kelvin.</li> <li><code>pressure_initial</code> - Initial vapor pressure in Pascals.</li> <li><code>temperature</code> - Final temperature in Kelvin.</li> <li><code>gas_constant</code> - gas constant (default is 8.314 J/(mol\u00b7K)).</li> </ul>"},{"location":"API/particula/gas/properties/vapor_pressure_module/#returns_2","title":"Returns","text":"<p>Pure vapor pressure in Pascals.</p>"},{"location":"API/particula/gas/properties/vapor_pressure_module/#references_2","title":"References","text":"<ul> <li>https://en.wikipedia.org/wiki/Clausius%E2%80%93Clapeyron_relation</li> </ul>"},{"location":"API/particula/gas/properties/vapor_pressure_module/#signature_2","title":"Signature","text":"<pre><code>def clausius_clapeyron_vapor_pressure(\n    latent_heat: Union[float, NDArray[np.float64]],\n    temperature_initial: Union[float, NDArray[np.float64]],\n    pressure_initial: Union[float, NDArray[np.float64]],\n    temperature: Union[float, NDArray[np.float64]],\n    gas_constant: float = GAS_CONSTANT,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/gas/properties/vapor_pressure_module/#see-also","title":"See also","text":"<ul> <li>GAS_CONSTANT</li> </ul>"},{"location":"API/particula/particles/","title":"Particles","text":"<p>Particula Index / Particula / Particles</p> <p>Auto-generated documentation for particula.particles module.</p>"},{"location":"API/particula/particles/#modules","title":"Modules","text":"<ul> <li>Activity Builders</li> <li>Activity Factories</li> <li>Activity Strategies</li> <li>Distribution Builders</li> <li>Distribution Factories</li> <li>Distribution Strategies</li> <li>Properties</li> <li>Representation</li> <li>Representation Builders</li> <li>Representation Factories</li> <li>Surface Builders</li> <li>Surface Factories</li> <li>Surface Strategies</li> </ul>"},{"location":"API/particula/particles/activity_builders/","title":"Activity Builders","text":"<p>Particula Index / Particula / Particles / Activity Builders</p> <p>Auto-generated documentation for particula.particles.activity_builders module.</p>"},{"location":"API/particula/particles/activity_builders/#activityidealmassbuilder","title":"ActivityIdealMassBuilder","text":"<p>Show source in activity_builders.py:27</p> <p>Builder class for IdealActivityMass objects. No additional parameters.</p>"},{"location":"API/particula/particles/activity_builders/#methods","title":"Methods","text":"<ul> <li><code>build()</code> - Validate and return the IdealActivityMass object.</li> </ul>"},{"location":"API/particula/particles/activity_builders/#signature","title":"Signature","text":"<pre><code>class ActivityIdealMassBuilder(BuilderABC):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/particles/activity_builders/#see-also","title":"See also","text":"<ul> <li>BuilderABC</li> </ul>"},{"location":"API/particula/particles/activity_builders/#activityidealmassbuilderbuild","title":"ActivityIdealMassBuilder().build","text":"<p>Show source in activity_builders.py:38</p> <p>Validate and return the IdealActivityMass object.</p>"},{"location":"API/particula/particles/activity_builders/#returns","title":"Returns","text":"<ul> <li><code>IdealActivityMass</code> - The validated IdealActivityMass object.</li> </ul>"},{"location":"API/particula/particles/activity_builders/#signature_1","title":"Signature","text":"<pre><code>def build(self) -&gt; ActivityStrategy: ...\n</code></pre>"},{"location":"API/particula/particles/activity_builders/#see-also_1","title":"See also","text":"<ul> <li>ActivityStrategy</li> </ul>"},{"location":"API/particula/particles/activity_builders/#activityidealmolarbuilder","title":"ActivityIdealMolarBuilder","text":"<p>Show source in activity_builders.py:47</p> <p>Builder class for IdealActivityMolar objects.</p>"},{"location":"API/particula/particles/activity_builders/#methods_1","title":"Methods","text":"<ul> <li><code>set_molar_mass(molar_mass,</code> molar_mass_units) - Set the molar mass of the     particle in kg/mol. Default units are 'kg/mol'.</li> <li><code>set_parameters(params)</code> - Set the parameters of the IdealActivityMolar     object from a dictionary including optional units.</li> <li><code>build()</code> - Validate and return the IdealActivityMolar object.</li> </ul>"},{"location":"API/particula/particles/activity_builders/#signature_2","title":"Signature","text":"<pre><code>class ActivityIdealMolarBuilder(BuilderABC, BuilderMolarMassMixin):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/particles/activity_builders/#see-also_2","title":"See also","text":"<ul> <li>BuilderABC</li> <li>BuilderMolarMassMixin</li> </ul>"},{"location":"API/particula/particles/activity_builders/#activityidealmolarbuilderbuild","title":"ActivityIdealMolarBuilder().build","text":"<p>Show source in activity_builders.py:63</p> <p>Validate and return the IdealActivityMolar object.</p>"},{"location":"API/particula/particles/activity_builders/#returns_1","title":"Returns","text":"<ul> <li><code>IdealActivityMolar</code> - The validated IdealActivityMolar object.</li> </ul>"},{"location":"API/particula/particles/activity_builders/#signature_3","title":"Signature","text":"<pre><code>def build(self) -&gt; ActivityStrategy: ...\n</code></pre>"},{"location":"API/particula/particles/activity_builders/#see-also_3","title":"See also","text":"<ul> <li>ActivityStrategy</li> </ul>"},{"location":"API/particula/particles/activity_builders/#activitykappaparameterbuilder","title":"ActivityKappaParameterBuilder","text":"<p>Show source in activity_builders.py:73</p> <p>Builder class for KappaParameterActivity objects.</p>"},{"location":"API/particula/particles/activity_builders/#methods_2","title":"Methods","text":"<ul> <li><code>set_kappa(kappa)</code> - Set the kappa parameter for the activity calculation.</li> <li><code>set_density(density,density_units)</code> - Set the density of the species in     kg/m^3. Default units are 'kg/m^3'.</li> <li><code>set_molar_mass(molar_mass,molar_mass_units)</code> - Set the molar mass of the     species in kg/mol. Default units are 'kg/mol'.</li> <li><code>set_water_index(water_index)</code> - Set the array index of the species.</li> <li><code>set_parameters(dict)</code> - Set the parameters of the KappaParameterActivity     object from a dictionary including optional units.</li> <li><code>build()</code> - Validate and return the KappaParameterActivity object.</li> </ul>"},{"location":"API/particula/particles/activity_builders/#signature_4","title":"Signature","text":"<pre><code>class ActivityKappaParameterBuilder(\n    BuilderABC, BuilderDensityMixin, BuilderMolarMassMixin\n):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/particles/activity_builders/#see-also_4","title":"See also","text":"<ul> <li>BuilderABC</li> <li>BuilderDensityMixin</li> <li>BuilderMolarMassMixin</li> </ul>"},{"location":"API/particula/particles/activity_builders/#activitykappaparameterbuilderbuild","title":"ActivityKappaParameterBuilder().build","text":"<p>Show source in activity_builders.py:136</p> <p>Validate and return the KappaParameterActivity object.</p>"},{"location":"API/particula/particles/activity_builders/#returns_2","title":"Returns","text":"<ul> <li><code>KappaParameterActivity</code> - The validated KappaParameterActivity     object.</li> </ul>"},{"location":"API/particula/particles/activity_builders/#signature_5","title":"Signature","text":"<pre><code>def build(self) -&gt; ActivityStrategy: ...\n</code></pre>"},{"location":"API/particula/particles/activity_builders/#see-also_5","title":"See also","text":"<ul> <li>ActivityStrategy</li> </ul>"},{"location":"API/particula/particles/activity_builders/#activitykappaparameterbuilderset_kappa","title":"ActivityKappaParameterBuilder().set_kappa","text":"<p>Show source in activity_builders.py:98</p> <p>Set the kappa parameter for the activity calculation.</p>"},{"location":"API/particula/particles/activity_builders/#arguments","title":"Arguments","text":"<ul> <li><code>kappa</code> - The kappa parameter for the activity calculation.</li> <li><code>kappa_units</code> - Not used. (for interface consistency)</li> </ul>"},{"location":"API/particula/particles/activity_builders/#signature_6","title":"Signature","text":"<pre><code>def set_kappa(\n    self, kappa: Union[float, NDArray[np.float64]], kappa_units: Optional[str] = None\n): ...\n</code></pre>"},{"location":"API/particula/particles/activity_builders/#activitykappaparameterbuilderset_water_index","title":"ActivityKappaParameterBuilder().set_water_index","text":"<p>Show source in activity_builders.py:118</p> <p>Set the array index of the species.</p>"},{"location":"API/particula/particles/activity_builders/#arguments_1","title":"Arguments","text":"<ul> <li><code>water_index</code> - The array index of the species.</li> <li><code>water_index_units</code> - Not used. (for interface consistency)</li> </ul>"},{"location":"API/particula/particles/activity_builders/#signature_7","title":"Signature","text":"<pre><code>def set_water_index(self, water_index: int, water_index_units: Optional[str] = None): ...\n</code></pre>"},{"location":"API/particula/particles/activity_factories/","title":"Activity Factories","text":"<p>Particula Index / Particula / Particles / Activity Factories</p> <p>Auto-generated documentation for particula.particles.activity_factories module.</p>"},{"location":"API/particula/particles/activity_factories/#activityfactory","title":"ActivityFactory","text":"<p>Show source in activity_factories.py:20</p> <p>Factory class to create activity strategy builders</p> <p>Factory class to create activity strategy builders for calculating activity and partial pressure of species in a mixture of liquids.</p>"},{"location":"API/particula/particles/activity_factories/#methods","title":"Methods","text":"<ul> <li><code>get_builders()</code> - Returns the mapping of strategy types to builder instances.</li> <li><code>get_strategy(strategy_type,</code> parameters) - Gets the strategy instance for the specified strategy type.<ul> <li><code>strategy_type</code> - Type of activity strategy to use, can be 'mass_ideal' (default), 'molar_ideal', or 'kappa_parameter'. parameters(Dict[str, Any], optional): Parameters required for the builder, dependent on the chosen strategy type.<ul> <li><code>mass_ideal</code> - No parameters are required.</li> <li><code>molar_ideal</code> - molar_mass kappa | kappa_parameter: kappa, density, molar_mass, water_index</li> </ul> </li> </ul> </li> </ul>"},{"location":"API/particula/particles/activity_factories/#returns","title":"Returns","text":"<ul> <li><code>ActivityStrategy</code> - An instance of the specified ActivityStrategy.</li> </ul>"},{"location":"API/particula/particles/activity_factories/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code> - If an unknown strategy type is provided.</li> <li><code>ValueError</code> - If any required key is missing during check_keys or     pre_build_check, or if trying to set an invalid parameter.</li> </ul>"},{"location":"API/particula/particles/activity_factories/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; strategy_is = ActivityFactory().get_strategy(\"mass_ideal\")\n</code></pre>"},{"location":"API/particula/particles/activity_factories/#signature","title":"Signature","text":"<pre><code>class ActivityFactory(\n    StrategyFactory[\n        Union[\n            ActivityIdealMassBuilder,\n            ActivityIdealMolarBuilder,\n            ActivityKappaParameterBuilder,\n        ],\n        Union[ActivityIdealMass, ActivityIdealMolar, ActivityKappaParameter],\n    ]\n): ...\n</code></pre>"},{"location":"API/particula/particles/activity_factories/#see-also","title":"See also","text":"<ul> <li>ActivityIdealMassBuilder</li> <li>ActivityIdealMass</li> <li>ActivityIdealMolarBuilder</li> <li>ActivityIdealMolar</li> <li>ActivityKappaParameterBuilder</li> <li>ActivityKappaParameter</li> </ul>"},{"location":"API/particula/particles/activity_factories/#activityfactoryget_builders","title":"ActivityFactory().get_builders","text":"<p>Show source in activity_factories.py:61</p> <p>Returns the mapping of strategy types to builder instances.</p>"},{"location":"API/particula/particles/activity_factories/#returns_1","title":"Returns","text":"<ul> <li><code>Dict[str,</code> Any] - A dictionary mapping strategy types to builder instances.<ul> <li><code>mass_ideal</code> - IdealActivityMassBuilder</li> <li><code>molar_ideal</code> - IdealActivityMolarBuilder</li> <li><code>kappa_parameter</code> - KappaParameterActivityBuilder</li> </ul> </li> </ul>"},{"location":"API/particula/particles/activity_factories/#signature_1","title":"Signature","text":"<pre><code>def get_builders(self): ...\n</code></pre>"},{"location":"API/particula/particles/activity_strategies/","title":"Activity Strategies","text":"<p>Particula Index / Particula / Particles / Activity Strategies</p> <p>Auto-generated documentation for particula.particles.activity_strategies module.</p>"},{"location":"API/particula/particles/activity_strategies/#activityidealmass","title":"ActivityIdealMass","text":"<p>Show source in activity_strategies.py:115</p> <p>Calculate ideal activity based on mass fractions.</p> <p>This strategy utilizes mass fractions to determine the activity, consistent with the principles outlined in Raoult's Law.</p>"},{"location":"API/particula/particles/activity_strategies/#references","title":"References","text":"<p>Mass Based Raoult's Law</p>"},{"location":"API/particula/particles/activity_strategies/#signature","title":"Signature","text":"<pre><code>class ActivityIdealMass(ActivityStrategy): ...\n</code></pre>"},{"location":"API/particula/particles/activity_strategies/#see-also","title":"See also","text":"<ul> <li>ActivityStrategy</li> </ul>"},{"location":"API/particula/particles/activity_strategies/#activityidealmassactivity","title":"ActivityIdealMass().activity","text":"<p>Show source in activity_strategies.py:125</p> <p>Calculate the activity of a species based on mass concentration.</p>"},{"location":"API/particula/particles/activity_strategies/#arguments","title":"Arguments","text":"<ul> <li><code>mass_concentration</code> - Concentration of the species in kilograms per cubic meter (kg/m^3).</li> </ul>"},{"location":"API/particula/particles/activity_strategies/#returns","title":"Returns","text":"<ul> <li><code>Union[float,</code> NDArray[np.float64]] - Activity of the particle, unitless.</li> </ul>"},{"location":"API/particula/particles/activity_strategies/#signature_1","title":"Signature","text":"<pre><code>def activity(\n    self, mass_concentration: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/activity_strategies/#activityidealmolar","title":"ActivityIdealMolar","text":"<p>Show source in activity_strategies.py:79</p> <p>Calculate ideal activity based on mole fractions.</p> <p>This strategy uses mole fractions to compute the activity, adhering to the principles of Raoult's Law.</p>"},{"location":"API/particula/particles/activity_strategies/#arguments_1","title":"Arguments","text":"<p>molar_mass (Union[float, NDArray[np.float64]]): Molar mass of the species [kg/mol]. A single value applies to all species if only one is provided.</p>"},{"location":"API/particula/particles/activity_strategies/#references_1","title":"References","text":"<p>Molar Raoult's Law</p>"},{"location":"API/particula/particles/activity_strategies/#signature_2","title":"Signature","text":"<pre><code>class ActivityIdealMolar(ActivityStrategy):\n    def __init__(self, molar_mass: Union[float, NDArray[np.float64]] = 0.0): ...\n</code></pre>"},{"location":"API/particula/particles/activity_strategies/#see-also_1","title":"See also","text":"<ul> <li>ActivityStrategy</li> </ul>"},{"location":"API/particula/particles/activity_strategies/#activityidealmolaractivity","title":"ActivityIdealMolar().activity","text":"<p>Show source in activity_strategies.py:97</p> <p>Calculate the activity of a species based on mass concentration.</p>"},{"location":"API/particula/particles/activity_strategies/#arguments_2","title":"Arguments","text":"<ul> <li><code>mass_concentration</code> - Concentration of the species in kilograms per cubic meter (kg/m^3).</li> </ul>"},{"location":"API/particula/particles/activity_strategies/#returns_1","title":"Returns","text":"<ul> <li><code>Union[float,</code> NDArray[np.float64]] - Activity of the species, unitless.</li> </ul>"},{"location":"API/particula/particles/activity_strategies/#signature_3","title":"Signature","text":"<pre><code>def activity(\n    self, mass_concentration: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/activity_strategies/#activityidealvolume","title":"ActivityIdealVolume","text":"<p>Show source in activity_strategies.py:141</p> <p>Calculate ideal activity based on volume fractions.</p> <p>This strategy uses volume fractions to compute the activity, following the principles of Raoult's Law.</p>"},{"location":"API/particula/particles/activity_strategies/#references_2","title":"References","text":"<p>Volume Based     Raoult's Law</p>"},{"location":"API/particula/particles/activity_strategies/#signature_4","title":"Signature","text":"<pre><code>class ActivityIdealVolume(ActivityStrategy):\n    def __init__(self, density: Union[float, NDArray[np.float64]] = 0.0): ...\n</code></pre>"},{"location":"API/particula/particles/activity_strategies/#see-also_2","title":"See also","text":"<ul> <li>ActivityStrategy</li> </ul>"},{"location":"API/particula/particles/activity_strategies/#activityidealvolumeactivity","title":"ActivityIdealVolume().activity","text":"<p>Show source in activity_strategies.py:155</p> <p>Calculate the activity of a species based on mass concentration.</p>"},{"location":"API/particula/particles/activity_strategies/#arguments_3","title":"Arguments","text":"<ul> <li><code>mass_concentration</code> - Concentration of the species in kilograms per     cubic meter (kg/m^3).</li> <li><code>density</code> - Density of the species in kilograms per cubic meter     (kg/m^3).</li> </ul>"},{"location":"API/particula/particles/activity_strategies/#returns_2","title":"Returns","text":"<ul> <li><code>Union[float,</code> NDArray[np.float64]] - Activity of the particle, unitless.</li> </ul>"},{"location":"API/particula/particles/activity_strategies/#signature_5","title":"Signature","text":"<pre><code>def activity(\n    self, mass_concentration: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/activity_strategies/#activitykappaparameter","title":"ActivityKappaParameter","text":"<p>Show source in activity_strategies.py:176</p> <p>Non-ideal activity strategy based on the kappa hygroscopic parameter.</p> <p>This strategy calculates the activity using the kappa hygroscopic parameter, a measure of hygroscopicity. The activity is determined by the species' mass concentration along with the hygroscopic parameter.</p>"},{"location":"API/particula/particles/activity_strategies/#arguments_4","title":"Arguments","text":"<ul> <li><code>kappa</code> - Kappa hygroscopic parameter, unitless.     Includes a value for water which is excluded in calculations.</li> <li><code>density</code> - Density of the species in kilograms per     cubic meter (kg/m^3).</li> <li><code>molar_mass</code> - Molar mass of the species in kilograms     per mole (kg/mol).</li> <li><code>water_index</code> - Index of water in the mass concentration array.</li> </ul>"},{"location":"API/particula/particles/activity_strategies/#signature_6","title":"Signature","text":"<pre><code>class ActivityKappaParameter(ActivityStrategy):\n    def __init__(\n        self,\n        kappa: NDArray[np.float64] = np.array([0.0], dtype=np.float64),\n        density: NDArray[np.float64] = np.array([0.0], dtype=np.float64),\n        molar_mass: NDArray[np.float64] = np.array([0.0], dtype=np.float64),\n        water_index: int = 0,\n    ): ...\n</code></pre>"},{"location":"API/particula/particles/activity_strategies/#see-also_3","title":"See also","text":"<ul> <li>ActivityStrategy</li> </ul>"},{"location":"API/particula/particles/activity_strategies/#activitykappaparameteractivity","title":"ActivityKappaParameter().activity","text":"<p>Show source in activity_strategies.py:205</p> <p>Calculate the activity of a species based on mass concentration.</p>"},{"location":"API/particula/particles/activity_strategies/#arguments_5","title":"Arguments","text":"<ul> <li><code>mass_concentration</code> - Concentration of the species in kilograms per cubic meter (kg/m^3).</li> </ul>"},{"location":"API/particula/particles/activity_strategies/#returns_3","title":"Returns","text":"<ul> <li><code>Union[float,</code> NDArray[np.float64]] - Activity of the particle, unitless.</li> </ul>"},{"location":"API/particula/particles/activity_strategies/#references_3","title":"References","text":"<p>Petters, M. D., &amp; Kreidenweis, S. M. (2007). A single parameter representation of hygroscopic growth and cloud condensation nucleus activity. Atmospheric Chemistry and Physics, 7(8), 1961-1971. DOI, see EQ 2 and 7.</p>"},{"location":"API/particula/particles/activity_strategies/#signature_7","title":"Signature","text":"<pre><code>def activity(\n    self, mass_concentration: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/activity_strategies/#activitystrategy","title":"ActivityStrategy","text":"<p>Show source in activity_strategies.py:22</p> <p>Abstract base class for vapor pressure strategies.</p> <p>This interface is used for implementing strategies based on particle activity calculations, specifically for calculating vapor pressures.</p>"},{"location":"API/particula/particles/activity_strategies/#methods","title":"Methods","text":"<ul> <li><code>get_name</code> - Return the type of the activity strategy.</li> <li><code>activity</code> - Calculate the activity of a species.</li> <li><code>partial_pressure</code> - Calculate the partial pressure of a species in     the mixture.</li> </ul>"},{"location":"API/particula/particles/activity_strategies/#signature_8","title":"Signature","text":"<pre><code>class ActivityStrategy(ABC): ...\n</code></pre>"},{"location":"API/particula/particles/activity_strategies/#activitystrategyactivity","title":"ActivityStrategy().activity","text":"<p>Show source in activity_strategies.py:35</p> <p>Calculate the activity of a species based on its mass concentration.</p>"},{"location":"API/particula/particles/activity_strategies/#arguments_6","title":"Arguments","text":"<ul> <li><code>mass_concentration</code> - Concentration of the species [kg/m^3]</li> </ul>"},{"location":"API/particula/particles/activity_strategies/#returns_4","title":"Returns","text":"<p>float or NDArray[float]: Activity of the particle, unitless.</p>"},{"location":"API/particula/particles/activity_strategies/#signature_9","title":"Signature","text":"<pre><code>@abstractmethod\ndef activity(\n    self, mass_concentration: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/activity_strategies/#activitystrategyget_name","title":"ActivityStrategy().get_name","text":"<p>Show source in activity_strategies.py:48</p> <p>Return the type of the activity strategy.</p>"},{"location":"API/particula/particles/activity_strategies/#signature_10","title":"Signature","text":"<pre><code>def get_name(self) -&gt; str: ...\n</code></pre>"},{"location":"API/particula/particles/activity_strategies/#activitystrategypartial_pressure","title":"ActivityStrategy().partial_pressure","text":"<p>Show source in activity_strategies.py:52</p> <p>Calculate the vapor pressure of species in the particle phase.</p> <p>This method computes the vapor pressure based on the species' activity considering its pure vapor pressure and mass concentration.</p>"},{"location":"API/particula/particles/activity_strategies/#arguments_7","title":"Arguments","text":"<ul> <li><code>pure_vapor_pressure</code> - Pure vapor pressure of the species in pascals (Pa).</li> <li><code>mass_concentration</code> - Concentration of the species in kilograms per cubic meter (kg/m^3).</li> </ul>"},{"location":"API/particula/particles/activity_strategies/#returns_5","title":"Returns","text":"<ul> <li><code>Union[float,</code> NDArray[np.float64]] - Vapor pressure of the particle in pascals (Pa).</li> </ul>"},{"location":"API/particula/particles/activity_strategies/#signature_11","title":"Signature","text":"<pre><code>def partial_pressure(\n    self,\n    pure_vapor_pressure: Union[float, NDArray[np.float64]],\n    mass_concentration: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_builders/","title":"Distribution Builders","text":"<p>Particula Index / Particula / Particles / Distribution Builders</p> <p>Auto-generated documentation for particula.particles.distribution_builders module.</p>"},{"location":"API/particula/particles/distribution_builders/#massbasedmovingbinbuilder","title":"MassBasedMovingBinBuilder","text":"<p>Show source in distribution_builders.py:16</p> <p>Builds a MassBasedMovingBin instance.</p>"},{"location":"API/particula/particles/distribution_builders/#signature","title":"Signature","text":"<pre><code>class MassBasedMovingBinBuilder(BuilderABC):\n    def __init__(self) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_builders/#see-also","title":"See also","text":"<ul> <li>BuilderABC</li> </ul>"},{"location":"API/particula/particles/distribution_builders/#massbasedmovingbinbuilderbuild","title":"MassBasedMovingBinBuilder().build","text":"<p>Show source in distribution_builders.py:23</p> <p>Builds a MassBasedMovingBin instance.</p>"},{"location":"API/particula/particles/distribution_builders/#signature_1","title":"Signature","text":"<pre><code>def build(self) -&gt; MassBasedMovingBin: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_builders/#see-also_1","title":"See also","text":"<ul> <li>MassBasedMovingBin</li> </ul>"},{"location":"API/particula/particles/distribution_builders/#particleresolvedspeciatedmassbuilder","title":"ParticleResolvedSpeciatedMassBuilder","text":"<p>Show source in distribution_builders.py:52</p> <p>Builds a ParticleResolvedSpeciatedMass instance.</p>"},{"location":"API/particula/particles/distribution_builders/#signature_2","title":"Signature","text":"<pre><code>class ParticleResolvedSpeciatedMassBuilder(BuilderABC):\n    def __init__(self) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_builders/#see-also_2","title":"See also","text":"<ul> <li>BuilderABC</li> </ul>"},{"location":"API/particula/particles/distribution_builders/#particleresolvedspeciatedmassbuilderbuild","title":"ParticleResolvedSpeciatedMassBuilder().build","text":"<p>Show source in distribution_builders.py:59</p>"},{"location":"API/particula/particles/distribution_builders/#signature_3","title":"Signature","text":"<pre><code>def build(self) -&gt; ParticleResolvedSpeciatedMass: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_builders/#see-also_3","title":"See also","text":"<ul> <li>ParticleResolvedSpeciatedMass</li> </ul>"},{"location":"API/particula/particles/distribution_builders/#radiibasedmovingbinbuilder","title":"RadiiBasedMovingBinBuilder","text":"<p>Show source in distribution_builders.py:28</p> <p>Builds a RadiiBasedMovingBin instance.</p>"},{"location":"API/particula/particles/distribution_builders/#signature_4","title":"Signature","text":"<pre><code>class RadiiBasedMovingBinBuilder(BuilderABC):\n    def __init__(self) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_builders/#see-also_4","title":"See also","text":"<ul> <li>BuilderABC</li> </ul>"},{"location":"API/particula/particles/distribution_builders/#radiibasedmovingbinbuilderbuild","title":"RadiiBasedMovingBinBuilder().build","text":"<p>Show source in distribution_builders.py:35</p> <p>Builds a RadiiBasedMovingBin instance.</p>"},{"location":"API/particula/particles/distribution_builders/#signature_5","title":"Signature","text":"<pre><code>def build(self) -&gt; RadiiBasedMovingBin: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_builders/#see-also_5","title":"See also","text":"<ul> <li>RadiiBasedMovingBin</li> </ul>"},{"location":"API/particula/particles/distribution_builders/#speciatedmassmovingbinbuilder","title":"SpeciatedMassMovingBinBuilder","text":"<p>Show source in distribution_builders.py:40</p> <p>Builds a SpeciatedMassMovingBin instance.</p>"},{"location":"API/particula/particles/distribution_builders/#signature_6","title":"Signature","text":"<pre><code>class SpeciatedMassMovingBinBuilder(BuilderABC):\n    def __init__(self) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_builders/#see-also_6","title":"See also","text":"<ul> <li>BuilderABC</li> </ul>"},{"location":"API/particula/particles/distribution_builders/#speciatedmassmovingbinbuilderbuild","title":"SpeciatedMassMovingBinBuilder().build","text":"<p>Show source in distribution_builders.py:47</p> <p>Builds a SpeciatedMassMovingBin instance.</p>"},{"location":"API/particula/particles/distribution_builders/#signature_7","title":"Signature","text":"<pre><code>def build(self) -&gt; SpeciatedMassMovingBin: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_builders/#see-also_7","title":"See also","text":"<ul> <li>SpeciatedMassMovingBin</li> </ul>"},{"location":"API/particula/particles/distribution_factories/","title":"Distribution Factories","text":"<p>Particula Index / Particula / Particles / Distribution Factories</p> <p>Auto-generated documentation for particula.particles.distribution_factories module.</p>"},{"location":"API/particula/particles/distribution_factories/#distributionfactory","title":"DistributionFactory","text":"<p>Show source in distribution_factories.py:20</p> <p>Factory class to create distribution strategy from builders.</p> <p>Used for calculating particle distributions based on the specified representation type.</p>"},{"location":"API/particula/particles/distribution_factories/#methods","title":"Methods","text":"<ul> <li><code>get_builders()</code> - Returns the mapping of strategy types to builder instances.</li> <li><code>get_strategy(strategy_type,</code> parameters) - Gets the strategy instance for the specified strategy type.<ul> <li><code>strategy_type</code> - Type of distribution strategy to use, can be 'mass_based_moving_bin', 'radii_based_moving_bin', 'speciated_mass_moving_bin', 'particle_resolved_speciated_mass'. parameters(Dict[str, Any], optional): Parameters required for the builder, dependent on the chosen strategy type.<ul> <li><code>mass_based_moving_bin</code> - None</li> <li><code>radii_based_moving_bin</code> - None</li> <li><code>speciated_mass_moving_bin</code> - None</li> <li><code>particle_resolved_speciated_mass</code> - None</li> </ul> </li> </ul> </li> </ul>"},{"location":"API/particula/particles/distribution_factories/#returns","title":"Returns","text":"<ul> <li><code>DistributionStrategy</code> - An instance of the specified DistributionStrategy.</li> </ul>"},{"location":"API/particula/particles/distribution_factories/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code> - If an unknown strategy type is provided.</li> <li><code>ValueError</code> - If any required key is missing during check_keys or pre_build_check, or if trying to set an invalid parameter.</li> </ul>"},{"location":"API/particula/particles/distribution_factories/#signature","title":"Signature","text":"<pre><code>class DistributionFactory(\n    StrategyFactory[\n        Union[\n            MassBasedMovingBinBuilder,\n            RadiiBasedMovingBinBuilder,\n            SpeciatedMassMovingBinBuilder,\n            ParticleResolvedSpeciatedMassBuilder,\n        ],\n        Union[\n            MassBasedMovingBin,\n            RadiiBasedMovingBin,\n            SpeciatedMassMovingBin,\n            ParticleResolvedSpeciatedMass,\n        ],\n    ]\n): ...\n</code></pre>"},{"location":"API/particula/particles/distribution_factories/#see-also","title":"See also","text":"<ul> <li>MassBasedMovingBinBuilder</li> <li>MassBasedMovingBin</li> <li>ParticleResolvedSpeciatedMassBuilder</li> <li>ParticleResolvedSpeciatedMass</li> <li>RadiiBasedMovingBinBuilder</li> <li>RadiiBasedMovingBin</li> <li>SpeciatedMassMovingBinBuilder</li> <li>SpeciatedMassMovingBin</li> </ul>"},{"location":"API/particula/particles/distribution_factories/#distributionfactoryget_builders","title":"DistributionFactory().get_builders","text":"<p>Show source in distribution_factories.py:66</p> <p>Returns the mapping of strategy types to builder instances.</p>"},{"location":"API/particula/particles/distribution_factories/#returns_1","title":"Returns","text":"<ul> <li><code>Dict[str,</code> BuilderABC] - Mapping of strategy types to builder instances.<ul> <li><code>'mass_based_moving_bin'</code> - MassBasedMovingBinBuilder</li> <li><code>'radii_based_moving_bin'</code> - RadiiBasedMovingBinBuilder</li> <li><code>'speciated_mass_moving_bin'</code> - SpeciatedMassMovingBinBuilder</li> </ul> </li> </ul>"},{"location":"API/particula/particles/distribution_factories/#signature_1","title":"Signature","text":"<pre><code>def get_builders(self): ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/","title":"Distribution Strategies","text":"<p>Particula Index / Particula / Particles / Distribution Strategies</p> <p>Auto-generated documentation for particula.particles.distribution_strategies module.</p>"},{"location":"API/particula/particles/distribution_strategies/#distributionstrategy","title":"DistributionStrategy","text":"<p>Show source in distribution_strategies.py:13</p> <p>Abstract base class for particle strategy, defining the common interface for mass, radius, and total mass calculations for different particle representations.</p>"},{"location":"API/particula/particles/distribution_strategies/#methods","title":"Methods","text":"<ul> <li><code>get_name</code> - Returns the type of the distribution strategy.</li> <li><code>get_mass</code> - Calculates the mass of particles.</li> <li><code>get_radius</code> - Calculates the radius of particles.</li> <li><code>get_total_mass</code> - Calculates the total mass of particles.</li> <li><code>add_mass</code> - Adds mass to the distribution of particles.</li> </ul>"},{"location":"API/particula/particles/distribution_strategies/#signature","title":"Signature","text":"<pre><code>class DistributionStrategy(ABC): ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#distributionstrategyadd_concentration","title":"DistributionStrategy().add_concentration","text":"<p>Show source in distribution_strategies.py:120</p> <p>Adds concentration to the distribution of particles.</p>"},{"location":"API/particula/particles/distribution_strategies/#arguments","title":"Arguments","text":"<ul> <li><code>distribution</code> - The distribution of particle sizes or masses.</li> <li><code>concentration</code> - The concentration of each particle size or mass in     the distribution.</li> <li><code>added_distribution</code> - The distribution to be added.</li> <li><code>added_concentration</code> - The concentration to be added.</li> </ul>"},{"location":"API/particula/particles/distribution_strategies/#returns","title":"Returns","text":"<ul> <li><code>(distribution,</code> concentration) - The new distribution array and the     new concentration array.</li> </ul>"},{"location":"API/particula/particles/distribution_strategies/#signature_1","title":"Signature","text":"<pre><code>@abstractmethod\ndef add_concentration(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    added_distribution: NDArray[np.float64],\n    added_concentration: NDArray[np.float64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#distributionstrategyadd_mass","title":"DistributionStrategy().add_mass","text":"<p>Show source in distribution_strategies.py:98</p> <p>Adds mass to the distribution of particles.</p>"},{"location":"API/particula/particles/distribution_strategies/#arguments_1","title":"Arguments","text":"<ul> <li><code>distribution</code> - The distribution of particle sizes or masses.</li> <li><code>concentration</code> - The concentration of each particle size or mass in     the distribution.</li> <li><code>density</code> - The density of the particles.</li> <li><code>added_mass</code> - The mass to be added per distribution bin.</li> </ul>"},{"location":"API/particula/particles/distribution_strategies/#returns_1","title":"Returns","text":"<ul> <li><code>(distribution,</code> concentration) - The new distribution array and the     new concentration array.</li> </ul>"},{"location":"API/particula/particles/distribution_strategies/#signature_2","title":"Signature","text":"<pre><code>@abstractmethod\ndef add_mass(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    density: NDArray[np.float64],\n    added_mass: NDArray[np.float64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#distributionstrategycollide_pairs","title":"DistributionStrategy().collide_pairs","text":"<p>Show source in distribution_strategies.py:142</p> <p>Collides index pairs.</p>"},{"location":"API/particula/particles/distribution_strategies/#arguments_2","title":"Arguments","text":"<ul> <li><code>distribution</code> - The distribution of particle sizes or masses.</li> <li><code>concentration</code> - The concentration of each particle size or mass in     the distribution.</li> <li><code>density</code> - The density of the particles.</li> <li><code>indices</code> - The indices of the particles to collide.</li> </ul>"},{"location":"API/particula/particles/distribution_strategies/#returns_2","title":"Returns","text":"<ul> <li><code>(distribution,</code> concentration) - The new distribution array and the     new concentration array.</li> </ul>"},{"location":"API/particula/particles/distribution_strategies/#signature_3","title":"Signature","text":"<pre><code>@abstractmethod\ndef collide_pairs(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    density: NDArray[np.float64],\n    indices: NDArray[np.int64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#distributionstrategyget_mass","title":"DistributionStrategy().get_mass","text":"<p>Show source in distribution_strategies.py:45</p> <p>Calculates the mass of the particles (or bin).</p>"},{"location":"API/particula/particles/distribution_strategies/#arguments_3","title":"Arguments","text":"<ul> <li><code>distribution</code> - The distribution of particle sizes or masses.</li> <li><code>density</code> - The density of the particles.</li> </ul>"},{"location":"API/particula/particles/distribution_strategies/#returns_3","title":"Returns","text":"<ul> <li><code>NDArray[np.float64]</code> - The mass of the particles.</li> </ul>"},{"location":"API/particula/particles/distribution_strategies/#signature_4","title":"Signature","text":"<pre><code>def get_mass(\n    self, distribution: NDArray[np.float64], density: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#distributionstrategyget_name","title":"DistributionStrategy().get_name","text":"<p>Show source in distribution_strategies.py:27</p> <p>Return the type of the distribution strategy.</p>"},{"location":"API/particula/particles/distribution_strategies/#signature_5","title":"Signature","text":"<pre><code>def get_name(self) -&gt; str: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#distributionstrategyget_radius","title":"DistributionStrategy().get_radius","text":"<p>Show source in distribution_strategies.py:84</p> <p>Calculates the radius of the particles.</p>"},{"location":"API/particula/particles/distribution_strategies/#arguments_4","title":"Arguments","text":"<ul> <li><code>distribution</code> - The distribution of particle sizes or masses.</li> <li><code>density</code> - The density of the particles.</li> </ul>"},{"location":"API/particula/particles/distribution_strategies/#returns_4","title":"Returns","text":"<ul> <li><code>NDArray[np.float64]</code> - The radius of the particles.</li> </ul>"},{"location":"API/particula/particles/distribution_strategies/#signature_6","title":"Signature","text":"<pre><code>@abstractmethod\ndef get_radius(\n    self, distribution: NDArray[np.float64], density: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#distributionstrategyget_species_mass","title":"DistributionStrategy().get_species_mass","text":"<p>Show source in distribution_strategies.py:31</p> <p>The mass per species in the particles (or bin).</p>"},{"location":"API/particula/particles/distribution_strategies/#arguments_5","title":"Arguments","text":"<ul> <li><code>distribution</code> - The distribution of particle sizes or masses.</li> <li><code>density</code> - The density of the particles.</li> </ul>"},{"location":"API/particula/particles/distribution_strategies/#returns_5","title":"Returns","text":"<ul> <li><code>NDArray[np.float64]</code> - The mass of the particles</li> </ul>"},{"location":"API/particula/particles/distribution_strategies/#signature_7","title":"Signature","text":"<pre><code>@abstractmethod\ndef get_species_mass(\n    self, distribution: NDArray[np.float64], density: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#distributionstrategyget_total_mass","title":"DistributionStrategy().get_total_mass","text":"<p>Show source in distribution_strategies.py:63</p> <p>Calculates the total mass of all particles (or bin).</p>"},{"location":"API/particula/particles/distribution_strategies/#arguments_6","title":"Arguments","text":"<ul> <li><code>distribution</code> - The distribution of particle sizes or masses.</li> <li><code>concentration</code> - The concentration of each particle size or mass in the distribution.</li> <li><code>density</code> - The density of the particles.</li> </ul>"},{"location":"API/particula/particles/distribution_strategies/#returns_6","title":"Returns","text":"<ul> <li><code>np.float64</code> - The total mass of the particles.</li> </ul>"},{"location":"API/particula/particles/distribution_strategies/#signature_8","title":"Signature","text":"<pre><code>def get_total_mass(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    density: NDArray[np.float64],\n) -&gt; np.float64: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#massbasedmovingbin","title":"MassBasedMovingBin","text":"<p>Show source in distribution_strategies.py:165</p> <p>A strategy for particles represented by their mass distribution.</p> <p>This strategy calculates particle mass, radius, and total mass based on the particle's mass, number concentration, and density. It also moves the bins when adding mass to the distribution.</p>"},{"location":"API/particula/particles/distribution_strategies/#signature_9","title":"Signature","text":"<pre><code>class MassBasedMovingBin(DistributionStrategy): ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#see-also","title":"See also","text":"<ul> <li>DistributionStrategy</li> </ul>"},{"location":"API/particula/particles/distribution_strategies/#massbasedmovingbinadd_concentration","title":"MassBasedMovingBin().add_concentration","text":"<p>Show source in distribution_strategies.py:197</p>"},{"location":"API/particula/particles/distribution_strategies/#signature_10","title":"Signature","text":"<pre><code>def add_concentration(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    added_distribution: NDArray[np.float64],\n    added_concentration: NDArray[np.float64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#massbasedmovingbinadd_mass","title":"MassBasedMovingBin().add_mass","text":"<p>Show source in distribution_strategies.py:187</p>"},{"location":"API/particula/particles/distribution_strategies/#signature_11","title":"Signature","text":"<pre><code>def add_mass(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    density: NDArray[np.float64],\n    added_mass: NDArray[np.float64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#massbasedmovingbincollide_pairs","title":"MassBasedMovingBin().collide_pairs","text":"<p>Show source in distribution_strategies.py:234</p>"},{"location":"API/particula/particles/distribution_strategies/#signature_12","title":"Signature","text":"<pre><code>def collide_pairs(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    density: NDArray[np.float64],\n    indices: NDArray[np.int64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#massbasedmovingbinget_radius","title":"MassBasedMovingBin().get_radius","text":"<p>Show source in distribution_strategies.py:179</p>"},{"location":"API/particula/particles/distribution_strategies/#signature_13","title":"Signature","text":"<pre><code>def get_radius(\n    self, distribution: NDArray[np.float64], density: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#massbasedmovingbinget_species_mass","title":"MassBasedMovingBin().get_species_mass","text":"<p>Show source in distribution_strategies.py:173</p>"},{"location":"API/particula/particles/distribution_strategies/#signature_14","title":"Signature","text":"<pre><code>def get_species_mass(\n    self, distribution: NDArray[np.float64], density: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#particleresolvedspeciatedmass","title":"ParticleResolvedSpeciatedMass","text":"<p>Show source in distribution_strategies.py:432</p> <p>Strategy for resolved particles via speciated mass.</p> <p>Strategy for resolved particles with speciated mass. Particles may have different densities and their mass is distributed across different species. This strategy calculates mass, radius, and total mass based on the species at each mass, density, the particle concentration.</p>"},{"location":"API/particula/particles/distribution_strategies/#signature_15","title":"Signature","text":"<pre><code>class ParticleResolvedSpeciatedMass(DistributionStrategy): ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#see-also_1","title":"See also","text":"<ul> <li>DistributionStrategy</li> </ul>"},{"location":"API/particula/particles/distribution_strategies/#particleresolvedspeciatedmassadd_concentration","title":"ParticleResolvedSpeciatedMass().add_concentration","text":"<p>Show source in distribution_strategies.py:479</p>"},{"location":"API/particula/particles/distribution_strategies/#signature_16","title":"Signature","text":"<pre><code>def add_concentration(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    added_distribution: NDArray[np.float64],\n    added_concentration: NDArray[np.float64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#particleresolvedspeciatedmassadd_mass","title":"ParticleResolvedSpeciatedMass().add_mass","text":"<p>Show source in distribution_strategies.py:457</p>"},{"location":"API/particula/particles/distribution_strategies/#signature_17","title":"Signature","text":"<pre><code>def add_mass(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    density: NDArray[np.float64],\n    added_mass: NDArray[np.float64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#particleresolvedspeciatedmasscollide_pairs","title":"ParticleResolvedSpeciatedMass().collide_pairs","text":"<p>Show source in distribution_strategies.py:541</p>"},{"location":"API/particula/particles/distribution_strategies/#signature_18","title":"Signature","text":"<pre><code>def collide_pairs(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    density: NDArray[np.float64],\n    indices: NDArray[np.int64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#particleresolvedspeciatedmassget_radius","title":"ParticleResolvedSpeciatedMass().get_radius","text":"<p>Show source in distribution_strategies.py:447</p>"},{"location":"API/particula/particles/distribution_strategies/#signature_19","title":"Signature","text":"<pre><code>def get_radius(\n    self, distribution: NDArray[np.float64], density: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#particleresolvedspeciatedmassget_species_mass","title":"ParticleResolvedSpeciatedMass().get_species_mass","text":"<p>Show source in distribution_strategies.py:442</p>"},{"location":"API/particula/particles/distribution_strategies/#signature_20","title":"Signature","text":"<pre><code>def get_species_mass(\n    self, distribution: NDArray[np.float64], density: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#radiibasedmovingbin","title":"RadiiBasedMovingBin","text":"<p>Show source in distribution_strategies.py:249</p> <p>A strategy for particles represented by their radius.</p> <p>This strategy calculates particle mass, radius, and total mass based on the particle's radius, number concentration, and density.</p>"},{"location":"API/particula/particles/distribution_strategies/#signature_21","title":"Signature","text":"<pre><code>class RadiiBasedMovingBin(DistributionStrategy): ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#see-also_2","title":"See also","text":"<ul> <li>DistributionStrategy</li> </ul>"},{"location":"API/particula/particles/distribution_strategies/#radiibasedmovingbinadd_concentration","title":"RadiiBasedMovingBin().add_concentration","text":"<p>Show source in distribution_strategies.py:288</p>"},{"location":"API/particula/particles/distribution_strategies/#signature_22","title":"Signature","text":"<pre><code>def add_concentration(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    added_distribution: NDArray[np.float64],\n    added_concentration: NDArray[np.float64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#radiibasedmovingbinadd_mass","title":"RadiiBasedMovingBin().add_mass","text":"<p>Show source in distribution_strategies.py:270</p>"},{"location":"API/particula/particles/distribution_strategies/#signature_23","title":"Signature","text":"<pre><code>def add_mass(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    density: NDArray[np.float64],\n    added_mass: NDArray[np.float64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#radiibasedmovingbincollide_pairs","title":"RadiiBasedMovingBin().collide_pairs","text":"<p>Show source in distribution_strategies.py:323</p>"},{"location":"API/particula/particles/distribution_strategies/#signature_24","title":"Signature","text":"<pre><code>def collide_pairs(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    density: NDArray[np.float64],\n    indices: NDArray[np.int64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#radiibasedmovingbinget_radius","title":"RadiiBasedMovingBin().get_radius","text":"<p>Show source in distribution_strategies.py:263</p>"},{"location":"API/particula/particles/distribution_strategies/#signature_25","title":"Signature","text":"<pre><code>def get_radius(\n    self, distribution: NDArray[np.float64], density: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#radiibasedmovingbinget_species_mass","title":"RadiiBasedMovingBin().get_species_mass","text":"<p>Show source in distribution_strategies.py:256</p>"},{"location":"API/particula/particles/distribution_strategies/#signature_26","title":"Signature","text":"<pre><code>def get_species_mass(\n    self, distribution: NDArray[np.float64], density: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#speciatedmassmovingbin","title":"SpeciatedMassMovingBin","text":"<p>Show source in distribution_strategies.py:338</p> <p>Strategy for particles with speciated mass distribution.</p> <p>Strategy for particles with speciated mass distribution. Some particles may have different densities and their mass is distributed across different species. This strategy calculates mass, radius, and total mass based on the species at each mass, density, the particle concentration.</p>"},{"location":"API/particula/particles/distribution_strategies/#signature_27","title":"Signature","text":"<pre><code>class SpeciatedMassMovingBin(DistributionStrategy): ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#see-also_3","title":"See also","text":"<ul> <li>DistributionStrategy</li> </ul>"},{"location":"API/particula/particles/distribution_strategies/#speciatedmassmovingbinadd_concentration","title":"SpeciatedMassMovingBin().add_concentration","text":"<p>Show source in distribution_strategies.py:382</p>"},{"location":"API/particula/particles/distribution_strategies/#signature_28","title":"Signature","text":"<pre><code>def add_concentration(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    added_distribution: NDArray[np.float64],\n    added_concentration: NDArray[np.float64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#speciatedmassmovingbinadd_mass","title":"SpeciatedMassMovingBin().add_mass","text":"<p>Show source in distribution_strategies.py:360</p>"},{"location":"API/particula/particles/distribution_strategies/#signature_29","title":"Signature","text":"<pre><code>def add_mass(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    density: NDArray[np.float64],\n    added_mass: NDArray[np.float64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#speciatedmassmovingbincollide_pairs","title":"SpeciatedMassMovingBin().collide_pairs","text":"<p>Show source in distribution_strategies.py:417</p>"},{"location":"API/particula/particles/distribution_strategies/#signature_30","title":"Signature","text":"<pre><code>def collide_pairs(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    density: NDArray[np.float64],\n    indices: NDArray[np.int64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#speciatedmassmovingbinget_radius","title":"SpeciatedMassMovingBin().get_radius","text":"<p>Show source in distribution_strategies.py:353</p>"},{"location":"API/particula/particles/distribution_strategies/#signature_31","title":"Signature","text":"<pre><code>def get_radius(\n    self, distribution: NDArray[np.float64], density: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/particles/distribution_strategies/#speciatedmassmovingbinget_species_mass","title":"SpeciatedMassMovingBin().get_species_mass","text":"<p>Show source in distribution_strategies.py:348</p>"},{"location":"API/particula/particles/distribution_strategies/#signature_32","title":"Signature","text":"<pre><code>def get_species_mass(\n    self, distribution: NDArray[np.float64], density: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/particles/representation/","title":"Representation","text":"<p>Particula Index / Particula / Particles / Representation</p> <p>Auto-generated documentation for particula.particles.representation module.</p>"},{"location":"API/particula/particles/representation/#particlerepresentation","title":"ParticleRepresentation","text":"<p>Show source in representation.py:20</p> <p>Everything needed to represent a particle or a collection of particles.</p> <p>Represents a particle or a collection of particles, encapsulating the strategy for calculating mass, radius, and total mass based on a specified particle distribution, density, and concentration. This class allows for flexibility in representing particles.</p>"},{"location":"API/particula/particles/representation/#attributes","title":"Attributes","text":"<ul> <li>strategy : The computation strategy for particle representations.</li> <li>activity : The activity strategy for the partial pressure     calculations.</li> <li>surface : The surface strategy for surface tension and Kelvin effect.</li> <li>distribution : The distribution data for the particles, which could     represent sizes, masses, or another relevant metric.</li> <li>density : The density of the material from which the particles are     made.</li> <li>concentration : The concentration of particles within the     distribution.</li> <li>charge : The charge on each particle.</li> <li>volume : The air volume for simulation of particles in the air,     default is 1 m^3. This is only used in ParticleResolved Strategies.</li> </ul>"},{"location":"API/particula/particles/representation/#signature","title":"Signature","text":"<pre><code>class ParticleRepresentation:\n    def __init__(\n        self,\n        strategy: DistributionStrategy,\n        activity: ActivityStrategy,\n        surface: SurfaceStrategy,\n        distribution: NDArray[np.float64],\n        density: NDArray[np.float64],\n        concentration: NDArray[np.float64],\n        charge: NDArray[np.float64],\n        volume: float = 1,\n    ): ...\n</code></pre>"},{"location":"API/particula/particles/representation/#see-also","title":"See also","text":"<ul> <li>ActivityStrategy</li> <li>DistributionStrategy</li> <li>SurfaceStrategy</li> </ul>"},{"location":"API/particula/particles/representation/#particlerepresentationstr","title":"ParticleRepresentation().str","text":"<p>Show source in representation.py:64</p> <p>Returns a string representation of the particle representation.</p>"},{"location":"API/particula/particles/representation/#returns","title":"Returns","text":"<ul> <li>str : A string representation of the particle representation.</li> </ul>"},{"location":"API/particula/particles/representation/#examples","title":"Examples","text":"Get String Representation<pre><code>str_rep = str(particle_representation)\nprint(str_rep)\n</code></pre>"},{"location":"API/particula/particles/representation/#signature_1","title":"Signature","text":"<pre><code>def __str__(self) -&gt; str: ...\n</code></pre>"},{"location":"API/particula/particles/representation/#particlerepresentationadd_concentration","title":"ParticleRepresentation().add_concentration","text":"<p>Show source in representation.py:416</p> <p>Adds concentration to the particle distribution.</p>"},{"location":"API/particula/particles/representation/#arguments","title":"Arguments","text":"<ul> <li>added_concentration : The concentration to be   added per distribution bin.</li> </ul>"},{"location":"API/particula/particles/representation/#examples_1","title":"Examples","text":"Add Concentration<pre><code>particle_representation.add_concentration(added_concentration)\n</code></pre>"},{"location":"API/particula/particles/representation/#signature_2","title":"Signature","text":"<pre><code>def add_concentration(\n    self,\n    added_concentration: NDArray[np.float64],\n    added_distribution: Optional[NDArray[np.float64]] = None,\n) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/particles/representation/#particlerepresentationadd_mass","title":"ParticleRepresentation().add_mass","text":"<p>Show source in representation.py:396</p> <p>Adds mass to the particle distribution, and updates parameters.</p>"},{"location":"API/particula/particles/representation/#arguments_1","title":"Arguments","text":"<ul> <li>added_mass : The mass to be added per   distribution bin.</li> </ul>"},{"location":"API/particula/particles/representation/#examples_2","title":"Examples","text":"Add Mass<pre><code>particle_representation.add_mass(added_mass)\n</code></pre>"},{"location":"API/particula/particles/representation/#signature_3","title":"Signature","text":"<pre><code>def add_mass(self, added_mass: NDArray[np.float64]) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/particles/representation/#particlerepresentationcollide_pairs","title":"ParticleRepresentation().collide_pairs","text":"<p>Show source in representation.py:447</p> <p>Collide pairs of indices, used for ParticleResolved Strategies.</p>"},{"location":"API/particula/particles/representation/#arguments_2","title":"Arguments","text":"<ul> <li>indices : The indices to collide.</li> </ul>"},{"location":"API/particula/particles/representation/#examples_3","title":"Examples","text":"Collide Pairs<pre><code>particle_representation.collide_pairs(indices)\n</code></pre>"},{"location":"API/particula/particles/representation/#signature_4","title":"Signature","text":"<pre><code>def collide_pairs(self, indices: NDArray[np.int64]) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/particles/representation/#particlerepresentationget_activity","title":"ParticleRepresentation().get_activity","text":"<p>Show source in representation.py:119</p> <p>Returns the activity strategy used for partial pressure calculations.</p>"},{"location":"API/particula/particles/representation/#arguments_3","title":"Arguments","text":"<ul> <li>clone : If True, then return a deepcopy of the activity strategy.</li> </ul>"},{"location":"API/particula/particles/representation/#returns_1","title":"Returns","text":"<ul> <li>The activity strategy used for partial pressure calculations.</li> </ul>"},{"location":"API/particula/particles/representation/#examples_4","title":"Examples","text":"Get Activity Strategy<pre><code>activity = particle_representation.get_activity()\n</code></pre>"},{"location":"API/particula/particles/representation/#signature_5","title":"Signature","text":"<pre><code>def get_activity(self, clone: bool = False) -&gt; ActivityStrategy: ...\n</code></pre>"},{"location":"API/particula/particles/representation/#see-also_1","title":"See also","text":"<ul> <li>ActivityStrategy</li> </ul>"},{"location":"API/particula/particles/representation/#particlerepresentationget_activity_name","title":"ParticleRepresentation().get_activity_name","text":"<p>Show source in representation.py:138</p> <p>Returns the name of the activity strategy used for partial pressure calculations.</p>"},{"location":"API/particula/particles/representation/#returns_2","title":"Returns","text":"<ul> <li>The name of the activity strategy used for partial pressure   calculations.</li> </ul>"},{"location":"API/particula/particles/representation/#examples_5","title":"Examples","text":"Get Activity Strategy Name<pre><code>activity_name = particle_representation.get_activity_name()\nprint(activity_name)\n</code></pre>"},{"location":"API/particula/particles/representation/#signature_6","title":"Signature","text":"<pre><code>def get_activity_name(self) -&gt; str: ...\n</code></pre>"},{"location":"API/particula/particles/representation/#particlerepresentationget_charge","title":"ParticleRepresentation().get_charge","text":"<p>Show source in representation.py:266</p> <p>Returns the charge per particle.</p>"},{"location":"API/particula/particles/representation/#arguments_4","title":"Arguments","text":"<ul> <li>clone : If True, then return a copy of the charge array.</li> </ul>"},{"location":"API/particula/particles/representation/#returns_3","title":"Returns","text":"<ul> <li>The charge of the particles.</li> </ul>"},{"location":"API/particula/particles/representation/#examples_6","title":"Examples","text":"Get Charge Array<pre><code>charge = particle_representation.get_charge()\n</code></pre>"},{"location":"API/particula/particles/representation/#signature_7","title":"Signature","text":"<pre><code>def get_charge(self, clone: bool = False) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/particles/representation/#particlerepresentationget_concentration","title":"ParticleRepresentation().get_concentration","text":"<p>Show source in representation.py:225</p> <p>Returns the volume concentration of the particles.</p> <p>For ParticleResolved Strategies, the concentration is the number of particles per self.volume to get concentration/m^3. For other Strategies, the concentration is the already per 1/m^3.</p>"},{"location":"API/particula/particles/representation/#arguments_5","title":"Arguments","text":"<ul> <li>clone : If True, then return a copy of the concentration array.</li> </ul>"},{"location":"API/particula/particles/representation/#returns_4","title":"Returns","text":"<ul> <li>The concentration of the particles.</li> </ul>"},{"location":"API/particula/particles/representation/#examples_7","title":"Examples","text":"Get Concentration Array<pre><code>concentration = particle_representation.get_concentration()\n</code></pre>"},{"location":"API/particula/particles/representation/#signature_8","title":"Signature","text":"<pre><code>def get_concentration(self, clone: bool = False) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/particles/representation/#particlerepresentationget_density","title":"ParticleRepresentation().get_density","text":"<p>Show source in representation.py:207</p> <p>Returns the density of the particles.</p>"},{"location":"API/particula/particles/representation/#arguments_6","title":"Arguments","text":"<ul> <li>clone : If True, then return a copy of the density array.</li> </ul>"},{"location":"API/particula/particles/representation/#returns_5","title":"Returns","text":"<ul> <li>The density of the particles.</li> </ul>"},{"location":"API/particula/particles/representation/#examples_8","title":"Examples","text":"Get Density Array<pre><code>density = particle_representation.get_density()\n</code></pre>"},{"location":"API/particula/particles/representation/#signature_9","title":"Signature","text":"<pre><code>def get_density(self, clone: bool = False) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/particles/representation/#particlerepresentationget_distribution","title":"ParticleRepresentation().get_distribution","text":"<p>Show source in representation.py:189</p> <p>Returns the distribution of the particles.</p>"},{"location":"API/particula/particles/representation/#arguments_7","title":"Arguments","text":"<ul> <li>clone : If True, then return a copy of the distribution array.</li> </ul>"},{"location":"API/particula/particles/representation/#returns_6","title":"Returns","text":"<ul> <li>The distribution of the particles.</li> </ul>"},{"location":"API/particula/particles/representation/#examples_9","title":"Examples","text":"Get Distribution Array<pre><code>distribution = particle_representation.get_distribution()\n</code></pre>"},{"location":"API/particula/particles/representation/#signature_10","title":"Signature","text":"<pre><code>def get_distribution(self, clone: bool = False) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/particles/representation/#particlerepresentationget_mass","title":"ParticleRepresentation().get_mass","text":"<p>Show source in representation.py:322</p> <p>Returns the mass of the particles as calculated by the strategy.</p>"},{"location":"API/particula/particles/representation/#arguments_8","title":"Arguments","text":"<ul> <li>clone : If True, then return a copy of the mass array.</li> </ul>"},{"location":"API/particula/particles/representation/#returns_7","title":"Returns","text":"<ul> <li>The mass of the particles.</li> </ul>"},{"location":"API/particula/particles/representation/#examples_10","title":"Examples","text":"Get Mass<pre><code>mass = particle_representation.get_mass()\n</code></pre>"},{"location":"API/particula/particles/representation/#signature_11","title":"Signature","text":"<pre><code>def get_mass(self, clone: bool = False) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/particles/representation/#particlerepresentationget_mass_concentration","title":"ParticleRepresentation().get_mass_concentration","text":"<p>Show source in representation.py:342</p> <p>Returns the total mass / volume simulated.</p> <p>The mass concentration is as calculated by the strategy, taking into account the distribution and concentration.</p>"},{"location":"API/particula/particles/representation/#arguments_9","title":"Arguments","text":"<ul> <li>clone : If True, then return a copy of the mass concentration.</li> </ul>"},{"location":"API/particula/particles/representation/#returns_8","title":"Returns","text":"<ul> <li>np.float64 : The mass concentration of the particles, kg/m^3.</li> </ul>"},{"location":"API/particula/particles/representation/#examples_11","title":"Examples","text":"Get Mass Concentration<pre><code>mass_concentration = (\n    particle_representation.get_mass_concentration()\n)\nprint(mass_concentration)\n</code></pre>"},{"location":"API/particula/particles/representation/#signature_12","title":"Signature","text":"<pre><code>def get_mass_concentration(self, clone: bool = False) -&gt; np.float64: ...\n</code></pre>"},{"location":"API/particula/particles/representation/#particlerepresentationget_radius","title":"ParticleRepresentation().get_radius","text":"<p>Show source in representation.py:376</p> <p>Returns the radius of the particles as calculated by the strategy.</p>"},{"location":"API/particula/particles/representation/#arguments_10","title":"Arguments","text":"<ul> <li>clone : If True, then return a copy of the radius array.</li> </ul>"},{"location":"API/particula/particles/representation/#returns_9","title":"Returns","text":"<ul> <li>The radius of the particles.</li> </ul>"},{"location":"API/particula/particles/representation/#examples_12","title":"Examples","text":"Get Radius<pre><code>radius = particle_representation.get_radius()\n</code></pre>"},{"location":"API/particula/particles/representation/#signature_13","title":"Signature","text":"<pre><code>def get_radius(self, clone: bool = False) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/particles/representation/#particlerepresentationget_species_mass","title":"ParticleRepresentation().get_species_mass","text":"<p>Show source in representation.py:302</p> <p>Returns the masses per species in the particles.</p>"},{"location":"API/particula/particles/representation/#arguments_11","title":"Arguments","text":"<ul> <li>clone : If True, then return a copy of the mass array.</li> </ul>"},{"location":"API/particula/particles/representation/#returns_10","title":"Returns","text":"<ul> <li>The mass of the particles per species.</li> </ul>"},{"location":"API/particula/particles/representation/#examples_13","title":"Examples","text":"Get Species Mass<pre><code>species_mass = particle_representation.get_species_mass()\n</code></pre>"},{"location":"API/particula/particles/representation/#signature_14","title":"Signature","text":"<pre><code>def get_species_mass(self, clone: bool = False) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/particles/representation/#particlerepresentationget_strategy","title":"ParticleRepresentation().get_strategy","text":"<p>Show source in representation.py:87</p> <p>Returns the strategy used for particle representation.</p>"},{"location":"API/particula/particles/representation/#arguments_12","title":"Arguments","text":"<ul> <li>clone : If True, then return a deepcopy of the strategy.</li> </ul>"},{"location":"API/particula/particles/representation/#returns_11","title":"Returns","text":"<ul> <li>The strategy used for particle representation.</li> </ul>"},{"location":"API/particula/particles/representation/#examples_14","title":"Examples","text":"Get Strategy<pre><code>strategy = particle_representation.get_strategy()\n</code></pre>"},{"location":"API/particula/particles/representation/#signature_15","title":"Signature","text":"<pre><code>def get_strategy(self, clone: bool = False) -&gt; DistributionStrategy: ...\n</code></pre>"},{"location":"API/particula/particles/representation/#see-also_2","title":"See also","text":"<ul> <li>DistributionStrategy</li> </ul>"},{"location":"API/particula/particles/representation/#particlerepresentationget_strategy_name","title":"ParticleRepresentation().get_strategy_name","text":"<p>Show source in representation.py:105</p> <p>Returns the name of the strategy used for particle representation.</p>"},{"location":"API/particula/particles/representation/#returns_12","title":"Returns","text":"<ul> <li>The name of the strategy used for particle representation.</li> </ul>"},{"location":"API/particula/particles/representation/#examples_15","title":"Examples","text":"Get Strategy Name<pre><code>strategy_name = particle_representation.get_strategy_name()\nprint(strategy_name)\n</code></pre>"},{"location":"API/particula/particles/representation/#signature_16","title":"Signature","text":"<pre><code>def get_strategy_name(self) -&gt; str: ...\n</code></pre>"},{"location":"API/particula/particles/representation/#particlerepresentationget_surface","title":"ParticleRepresentation().get_surface","text":"<p>Show source in representation.py:154</p> <p>Returns the surface strategy used for surface tension and Kelvin effect.</p>"},{"location":"API/particula/particles/representation/#arguments_13","title":"Arguments","text":"<ul> <li>clone : If True, then return a deepcopy of the surface strategy.</li> </ul>"},{"location":"API/particula/particles/representation/#returns_13","title":"Returns","text":"<ul> <li>The surface strategy used for surface tension and Kelvin effect.</li> </ul>"},{"location":"API/particula/particles/representation/#examples_16","title":"Examples","text":"Get Surface Strategy<pre><code>surface = particle_representation.get_surface()\n</code></pre>"},{"location":"API/particula/particles/representation/#signature_17","title":"Signature","text":"<pre><code>def get_surface(self, clone: bool = False) -&gt; SurfaceStrategy: ...\n</code></pre>"},{"location":"API/particula/particles/representation/#see-also_3","title":"See also","text":"<ul> <li>SurfaceStrategy</li> </ul>"},{"location":"API/particula/particles/representation/#particlerepresentationget_surface_name","title":"ParticleRepresentation().get_surface_name","text":"<p>Show source in representation.py:173</p> <p>Returns the name of the surface strategy used for surface tension and Kelvin effect.</p>"},{"location":"API/particula/particles/representation/#returns_14","title":"Returns","text":"<ul> <li>The name of the surface strategy used for surface tension and     Kelvin effect.</li> </ul>"},{"location":"API/particula/particles/representation/#examples_17","title":"Examples","text":"Get Surface Strategy Name<pre><code>surface_name = particle_representation.get_surface_name()\nprint(surface_name)\n</code></pre>"},{"location":"API/particula/particles/representation/#signature_18","title":"Signature","text":"<pre><code>def get_surface_name(self) -&gt; str: ...\n</code></pre>"},{"location":"API/particula/particles/representation/#particlerepresentationget_total_concentration","title":"ParticleRepresentation().get_total_concentration","text":"<p>Show source in representation.py:247</p> <p>Returns the total concentration of the particles.</p>"},{"location":"API/particula/particles/representation/#arguments_14","title":"Arguments","text":"<ul> <li>clone : If True, then return a copy of the concentration array.</li> </ul>"},{"location":"API/particula/particles/representation/#returns_15","title":"Returns","text":"<ul> <li>The concentration of the particles.</li> </ul>"},{"location":"API/particula/particles/representation/#examples_18","title":"Examples","text":"Get Total Concentration<pre><code>total_concentration = (\n    particle_representation.get_total_concentration()\n)\nprint(total_concentration)\n</code></pre>"},{"location":"API/particula/particles/representation/#signature_19","title":"Signature","text":"<pre><code>def get_total_concentration(self, clone: bool = False) -&gt; np.float64: ...\n</code></pre>"},{"location":"API/particula/particles/representation/#particlerepresentationget_volume","title":"ParticleRepresentation().get_volume","text":"<p>Show source in representation.py:284</p> <p>Returns the volume of the particles.</p>"},{"location":"API/particula/particles/representation/#arguments_15","title":"Arguments","text":"<ul> <li>clone : If True, then return a copy of the volume array.</li> </ul>"},{"location":"API/particula/particles/representation/#returns_16","title":"Returns","text":"<ul> <li>The volume of the particles.</li> </ul>"},{"location":"API/particula/particles/representation/#examples_19","title":"Examples","text":"Get Volume<pre><code>volume = particle_representation.get_volume()\n</code></pre>"},{"location":"API/particula/particles/representation/#signature_20","title":"Signature","text":"<pre><code>def get_volume(self, clone: bool = False) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/particles/representation_builders/","title":"Representation Builders","text":"<p>Particula Index / Particula / Particles / Representation Builders</p> <p>Auto-generated documentation for particula.particles.representation_builders module.</p>"},{"location":"API/particula/particles/representation_builders/#builderactivitystrategymixin","title":"BuilderActivityStrategyMixin","text":"<p>Show source in representation_builders.py:113</p> <p>Mixin class for Builder classes to set activity_strategy.</p>"},{"location":"API/particula/particles/representation_builders/#methods","title":"Methods","text":"<ul> <li>set_activity_strategy : Set the activity_strategy attribute.</li> </ul>"},{"location":"API/particula/particles/representation_builders/#signature","title":"Signature","text":"<pre><code>class BuilderActivityStrategyMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/particles/representation_builders/#builderactivitystrategymixinset_activity_strategy","title":"BuilderActivityStrategyMixin().set_activity_strategy","text":"<p>Show source in representation_builders.py:123</p> <p>Set the activity strategy of the particle.</p>"},{"location":"API/particula/particles/representation_builders/#arguments","title":"Arguments","text":"<ul> <li>activity_strategy : Activity strategy of the particle.</li> <li>activity_strategy_units : Not used. (for interface consistency)</li> </ul>"},{"location":"API/particula/particles/representation_builders/#signature_1","title":"Signature","text":"<pre><code>def set_activity_strategy(\n    self,\n    activity_strategy: ActivityStrategy,\n    activity_strategy_units: Optional[str] = None,\n): ...\n</code></pre>"},{"location":"API/particula/particles/representation_builders/#see-also","title":"See also","text":"<ul> <li>ActivityStrategy</li> </ul>"},{"location":"API/particula/particles/representation_builders/#builderdistributionstrategymixin","title":"BuilderDistributionStrategyMixin","text":"<p>Show source in representation_builders.py:83</p> <p>Mixin class for Builder classes to set distribution_strategy.</p>"},{"location":"API/particula/particles/representation_builders/#methods_1","title":"Methods","text":"<ul> <li>set_distribution_strategy : Set the distribution_strategy attribute.</li> </ul>"},{"location":"API/particula/particles/representation_builders/#signature_2","title":"Signature","text":"<pre><code>class BuilderDistributionStrategyMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/particles/representation_builders/#builderdistributionstrategymixinset_distribution_strategy","title":"BuilderDistributionStrategyMixin().set_distribution_strategy","text":"<p>Show source in representation_builders.py:93</p> <p>Set the distribution strategy of the particle.</p>"},{"location":"API/particula/particles/representation_builders/#arguments_1","title":"Arguments","text":"<ul> <li>distribution_strategy : Distribution strategy of the particle.</li> <li>distribution_strategy_units : Not used. (for interface)</li> </ul>"},{"location":"API/particula/particles/representation_builders/#signature_3","title":"Signature","text":"<pre><code>def set_distribution_strategy(\n    self,\n    distribution_strategy: DistributionStrategy,\n    distribution_strategy_units: Optional[str] = None,\n): ...\n</code></pre>"},{"location":"API/particula/particles/representation_builders/#see-also_1","title":"See also","text":"<ul> <li>DistributionStrategy</li> </ul>"},{"location":"API/particula/particles/representation_builders/#buildersurfacestrategymixin","title":"BuilderSurfaceStrategyMixin","text":"<p>Show source in representation_builders.py:55</p> <p>Mixin class for Builder classes to set surface_strategy.</p>"},{"location":"API/particula/particles/representation_builders/#methods_2","title":"Methods","text":"<ul> <li>set_surface_strategy : Set the surface_strategy attribute.</li> </ul>"},{"location":"API/particula/particles/representation_builders/#signature_4","title":"Signature","text":"<pre><code>class BuilderSurfaceStrategyMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/particles/representation_builders/#buildersurfacestrategymixinset_surface_strategy","title":"BuilderSurfaceStrategyMixin().set_surface_strategy","text":"<p>Show source in representation_builders.py:65</p> <p>Set the surface strategy of the particle.</p>"},{"location":"API/particula/particles/representation_builders/#arguments_2","title":"Arguments","text":"<ul> <li>surface_strategy : Surface strategy of the particle.</li> <li>surface_strategy_units : Not used. (for interface consistency)</li> </ul>"},{"location":"API/particula/particles/representation_builders/#signature_5","title":"Signature","text":"<pre><code>def set_surface_strategy(\n    self, surface_strategy: SurfaceStrategy, surface_strategy_units: Optional[str] = None\n): ...\n</code></pre>"},{"location":"API/particula/particles/representation_builders/#see-also_2","title":"See also","text":"<ul> <li>SurfaceStrategy</li> </ul>"},{"location":"API/particula/particles/representation_builders/#particlemassrepresentationbuilder","title":"ParticleMassRepresentationBuilder","text":"<p>Show source in representation_builders.py:140</p> <p>General ParticleRepresentation objects with mass-based bins.</p>"},{"location":"API/particula/particles/representation_builders/#attributes","title":"Attributes","text":"<ul> <li>distribution_strategy : Set the DistributionStrategy.</li> <li>activity_strategy : Set the ActivityStrategy.</li> <li>surface_strategy : Set the SurfaceStrategy.</li> <li>mass : Set the mass of the particles. Default units are 'kg'.</li> <li>density : Set the density of the particles. Default units are     'kg/m^3'.</li> <li>concentration : Set the concentration of the particles.     Default units are '1/m^3'.</li> <li>charge : Set the number of charges.</li> </ul>"},{"location":"API/particula/particles/representation_builders/#signature_6","title":"Signature","text":"<pre><code>class ParticleMassRepresentationBuilder(\n    BuilderABC,\n    BuilderDistributionStrategyMixin,\n    BuilderActivityStrategyMixin,\n    BuilderSurfaceStrategyMixin,\n    BuilderMassMixin,\n    BuilderDensityMixin,\n    BuilderConcentrationMixin,\n    BuilderChargeMixin,\n):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/particles/representation_builders/#see-also_3","title":"See also","text":"<ul> <li>BuilderABC</li> <li>BuilderActivityStrategyMixin</li> <li>BuilderChargeMixin</li> <li>BuilderConcentrationMixin</li> <li>BuilderDensityMixin</li> <li>BuilderDistributionStrategyMixin</li> <li>BuilderMassMixin</li> <li>BuilderSurfaceStrategyMixin</li> </ul>"},{"location":"API/particula/particles/representation_builders/#particlemassrepresentationbuilderbuild","title":"ParticleMassRepresentationBuilder().build","text":"<p>Show source in representation_builders.py:183</p> <p>Validate and return the ParticleRepresentation object.</p>"},{"location":"API/particula/particles/representation_builders/#returns","title":"Returns","text":"<ul> <li>The validated ParticleRepresentation object.</li> </ul>"},{"location":"API/particula/particles/representation_builders/#signature_7","title":"Signature","text":"<pre><code>def build(self) -&gt; ParticleRepresentation: ...\n</code></pre>"},{"location":"API/particula/particles/representation_builders/#see-also_4","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/particles/representation_builders/#particleradiusrepresentationbuilder","title":"ParticleRadiusRepresentationBuilder","text":"<p>Show source in representation_builders.py:201</p> <p>General ParticleRepresentation objects with radius-based bins.</p>"},{"location":"API/particula/particles/representation_builders/#attributes_1","title":"Attributes","text":"<ul> <li>distribution_strategy : Set the DistributionStrategy.</li> <li>activity_strategy : Set the ActivityStrategy.</li> <li>surface_strategy : Set the SurfaceStrategy.</li> <li>radius : Set the radius of the particles. Default units are 'm'.</li> <li>density : Set the density of the particles. Default units are     'kg/m**3'.</li> <li>concentration : Set the concentration of the particles. Default units     are '1/m^3'.</li> <li>charge : Set the number of charges.</li> </ul>"},{"location":"API/particula/particles/representation_builders/#signature_8","title":"Signature","text":"<pre><code>class ParticleRadiusRepresentationBuilder(\n    BuilderABC,\n    BuilderDistributionStrategyMixin,\n    BuilderActivityStrategyMixin,\n    BuilderSurfaceStrategyMixin,\n    BuilderRadiusMixin,\n    BuilderDensityMixin,\n    BuilderConcentrationMixin,\n    BuilderChargeMixin,\n):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/particles/representation_builders/#see-also_5","title":"See also","text":"<ul> <li>BuilderABC</li> <li>BuilderActivityStrategyMixin</li> <li>BuilderChargeMixin</li> <li>BuilderConcentrationMixin</li> <li>BuilderDensityMixin</li> <li>BuilderDistributionStrategyMixin</li> <li>BuilderRadiusMixin</li> <li>BuilderSurfaceStrategyMixin</li> </ul>"},{"location":"API/particula/particles/representation_builders/#particleradiusrepresentationbuilderbuild","title":"ParticleRadiusRepresentationBuilder().build","text":"<p>Show source in representation_builders.py:244</p> <p>Validate and return the ParticleRepresentation object.</p>"},{"location":"API/particula/particles/representation_builders/#returns_1","title":"Returns","text":"<ul> <li>The validated ParticleRepresentation object.</li> </ul>"},{"location":"API/particula/particles/representation_builders/#signature_9","title":"Signature","text":"<pre><code>def build(self) -&gt; ParticleRepresentation: ...\n</code></pre>"},{"location":"API/particula/particles/representation_builders/#see-also_6","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/particles/representation_builders/#presetparticleradiusbuilder","title":"PresetParticleRadiusBuilder","text":"<p>Show source in representation_builders.py:262</p> <p>General ParticleRepresentation objects with radius-based bins.</p>"},{"location":"API/particula/particles/representation_builders/#attributes_2","title":"Attributes","text":"<ul> <li>mode : Set the mode(s) of the distribution.     Default is np.array([100e-9, 1e-6]) meters.</li> <li>geometric_standard_deviation : Set the geometric standard     deviation(s) of the distribution. Default is np.array([1.2, 1.4]).</li> <li>number_concentration : Set the number concentration of the     distribution. Default is np.array([1e4x1e6, 1e3x1e6])     particles/m^3.</li> <li>radius_bins : Set the radius bins of the distribution. Default is     np.logspace(-9, -4, 250), meters.</li> </ul>"},{"location":"API/particula/particles/representation_builders/#signature_10","title":"Signature","text":"<pre><code>class PresetParticleRadiusBuilder(\n    BuilderABC,\n    BuilderDistributionStrategyMixin,\n    BuilderActivityStrategyMixin,\n    BuilderSurfaceStrategyMixin,\n    BuilderRadiusMixin,\n    BuilderDensityMixin,\n    BuilderConcentrationMixin,\n    BuilderChargeMixin,\n    BuilderLognormalMixin,\n):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/particles/representation_builders/#see-also_7","title":"See also","text":"<ul> <li>BuilderABC</li> <li>BuilderActivityStrategyMixin</li> <li>BuilderChargeMixin</li> <li>BuilderConcentrationMixin</li> <li>BuilderDensityMixin</li> <li>BuilderDistributionStrategyMixin</li> <li>BuilderLognormalMixin</li> <li>BuilderRadiusMixin</li> <li>BuilderSurfaceStrategyMixin</li> </ul>"},{"location":"API/particula/particles/representation_builders/#presetparticleradiusbuilderbuild","title":"PresetParticleRadiusBuilder().build","text":"<p>Show source in representation_builders.py:355</p> <p>Validate and return the ParticleRepresentation object.</p> <p>This will build a distribution of particles with a lognormal size distribution, before returning the ParticleRepresentation object.</p>"},{"location":"API/particula/particles/representation_builders/#returns_2","title":"Returns","text":"<ul> <li>The validated ParticleRepresentation object.</li> </ul>"},{"location":"API/particula/particles/representation_builders/#signature_11","title":"Signature","text":"<pre><code>def build(self) -&gt; ParticleRepresentation: ...\n</code></pre>"},{"location":"API/particula/particles/representation_builders/#see-also_8","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/particles/representation_builders/#presetparticleradiusbuilderset_distribution_type","title":"PresetParticleRadiusBuilder().set_distribution_type","text":"<p>Show source in representation_builders.py:336</p> <p>Set the distribution type for the particle representation.</p>"},{"location":"API/particula/particles/representation_builders/#arguments_3","title":"Arguments","text":"<ul> <li>distribution_type : The type of distribution to use.</li> </ul>"},{"location":"API/particula/particles/representation_builders/#signature_12","title":"Signature","text":"<pre><code>def set_distribution_type(\n    self, distribution_type: str, distribution_type_units: Optional[str] = None\n): ...\n</code></pre>"},{"location":"API/particula/particles/representation_builders/#presetparticleradiusbuilderset_radius_bins","title":"PresetParticleRadiusBuilder().set_radius_bins","text":"<p>Show source in representation_builders.py:317</p> <p>Set the radius bins for the distribution</p>"},{"location":"API/particula/particles/representation_builders/#arguments_4","title":"Arguments","text":"<ul> <li>radius_bins : The radius bins for the distribution.</li> </ul>"},{"location":"API/particula/particles/representation_builders/#signature_13","title":"Signature","text":"<pre><code>def set_radius_bins(\n    self, radius_bins: NDArray[np.float64], radius_bins_units: str = \"m\"\n): ...\n</code></pre>"},{"location":"API/particula/particles/representation_builders/#presetresolvedparticlemassbuilder","title":"PresetResolvedParticleMassBuilder","text":"<p>Show source in representation_builders.py:472</p> <p>General ParticleRepresentation objects with particle resolved masses.</p> <p>This class has preset values for all the attributes, and allows you to override them as needed. This is useful when you want to quickly particle representation object with resolved masses.</p>"},{"location":"API/particula/particles/representation_builders/#attributes_3","title":"Attributes","text":"<ul> <li>distribution_strategy : Set the DistributionStrategy.</li> <li>activity_strategy : Set the ActivityStrategy.</li> <li>surface_strategy : Set the SurfaceStrategy.</li> <li>mass : Set the mass of the particles Default     units are 'kg'.</li> <li>density : Set the density of the particles.     Default units are 'kg/m^3'.</li> <li>charge : Set the number of charges.</li> <li>mode : Set the mode(s) of the distribution.     Default is np.array([100e-9, 1e-6]) meters.</li> <li>geometric_standard_deviation : Set the geometric standard     deviation(s) of the distribution. Default is np.array([1.2, 1.4]).</li> <li>number_concentration : Set the number concentration of the     distribution. Default is np.array([1e4 1e6, 1e3 1e6])     particles/m^3.</li> <li>particle_resolved_count : Set the number of resolved particles.</li> </ul>"},{"location":"API/particula/particles/representation_builders/#signature_14","title":"Signature","text":"<pre><code>class PresetResolvedParticleMassBuilder(\n    BuilderABC,\n    BuilderDistributionStrategyMixin,\n    BuilderActivityStrategyMixin,\n    BuilderSurfaceStrategyMixin,\n    BuilderDensityMixin,\n    BuilderChargeMixin,\n    BuilderLognormalMixin,\n    BuilderVolumeMixin,\n    BuilderParticleResolvedCountMixin,\n):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/particles/representation_builders/#see-also_9","title":"See also","text":"<ul> <li>BuilderABC</li> <li>BuilderActivityStrategyMixin</li> <li>BuilderChargeMixin</li> <li>BuilderDensityMixin</li> <li>BuilderDistributionStrategyMixin</li> <li>BuilderLognormalMixin</li> <li>BuilderParticleResolvedCountMixin</li> <li>BuilderSurfaceStrategyMixin</li> <li>BuilderVolumeMixin</li> </ul>"},{"location":"API/particula/particles/representation_builders/#presetresolvedparticlemassbuilderbuild","title":"PresetResolvedParticleMassBuilder().build","text":"<p>Show source in representation_builders.py:540</p> <p>Validate and return the ParticleRepresentation object.</p> <p>This will build a distribution of particles with a lognormal size distribution, before returning the ParticleRepresentation object.</p>"},{"location":"API/particula/particles/representation_builders/#returns_3","title":"Returns","text":"<ul> <li>The validated ParticleRepresentation object.</li> </ul>"},{"location":"API/particula/particles/representation_builders/#signature_15","title":"Signature","text":"<pre><code>def build(self) -&gt; ParticleRepresentation: ...\n</code></pre>"},{"location":"API/particula/particles/representation_builders/#see-also_10","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/particles/representation_builders/#resolvedparticlemassrepresentationbuilder","title":"ResolvedParticleMassRepresentationBuilder","text":"<p>Show source in representation_builders.py:395</p> <p>Builder class for constructing ParticleRepresentation objects with resolved masses.</p> <p>This class allows you to set various attributes for a particle representation, such as distribution strategy, mass, density, charge, volume, and more. These attributes are validated and there a no presets.</p>"},{"location":"API/particula/particles/representation_builders/#attributes_4","title":"Attributes","text":"<ul> <li>distribution_strategy : Set the distribution strategy for particles.</li> <li>activity_strategy : Set the activity strategy for the particles.</li> <li>surface_strategy : Set the surface strategy for the particles.</li> <li>mass : Set the particle mass. Defaults to 'kg'.</li> <li>density : Set the particle density. Defaults to 'kg/m^3'.</li> <li>charge : Set the particle charge.</li> <li>volume : Set the particle volume. Defaults to 'm^3'.</li> </ul>"},{"location":"API/particula/particles/representation_builders/#signature_16","title":"Signature","text":"<pre><code>class ResolvedParticleMassRepresentationBuilder(\n    BuilderABC,\n    BuilderDistributionStrategyMixin,\n    BuilderActivityStrategyMixin,\n    BuilderSurfaceStrategyMixin,\n    BuilderDensityMixin,\n    BuilderChargeMixin,\n    BuilderVolumeMixin,\n    BuilderMassMixin,\n):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/particles/representation_builders/#see-also_11","title":"See also","text":"<ul> <li>BuilderABC</li> <li>BuilderActivityStrategyMixin</li> <li>BuilderChargeMixin</li> <li>BuilderDensityMixin</li> <li>BuilderDistributionStrategyMixin</li> <li>BuilderMassMixin</li> <li>BuilderSurfaceStrategyMixin</li> <li>BuilderVolumeMixin</li> </ul>"},{"location":"API/particula/particles/representation_builders/#resolvedparticlemassrepresentationbuilderbuild","title":"ResolvedParticleMassRepresentationBuilder().build","text":"<p>Show source in representation_builders.py:442</p> <p>Validate and return a ParticleRepresentation object.</p> <p>This method validates all the required attributes and builds a particle representation with a lognormal size distribution.</p>"},{"location":"API/particula/particles/representation_builders/#returns_4","title":"Returns","text":"<ul> <li>ParticleRepresentation : A validated particle representation     object.</li> </ul>"},{"location":"API/particula/particles/representation_builders/#signature_17","title":"Signature","text":"<pre><code>def build(self) -&gt; ParticleRepresentation: ...\n</code></pre>"},{"location":"API/particula/particles/representation_builders/#see-also_12","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/particles/representation_factories/","title":"Representation Factories","text":"<p>Particula Index / Particula / Particles / Representation Factories</p> <p>Auto-generated documentation for particula.particles.representation_factories module.</p>"},{"location":"API/particula/particles/representation_factories/#particlerepresentationfactory","title":"ParticleRepresentationFactory","text":"<p>Show source in representation_factories.py:17</p> <p>Factory class to create particle representation builders.</p>"},{"location":"API/particula/particles/representation_factories/#methods","title":"Methods","text":"<ul> <li>get_builders : Returns the mapping of strategy types to builder     instances.</li> <li>get_strategy : Gets the strategy instance for the specified strategy.<ul> <li>strategy_type : Type of particle representation strategy to use,     can be 'radius' (default) or 'mass'.</li> <li>parameters : Parameters required for     the builder</li> </ul> </li> </ul>"},{"location":"API/particula/particles/representation_factories/#signature","title":"Signature","text":"<pre><code>class ParticleRepresentationFactory(\n    StrategyFactory[\n        Union[\n            ParticleMassRepresentationBuilder,\n            ParticleRadiusRepresentationBuilder,\n            PresetParticleRadiusBuilder,\n            ResolvedParticleMassRepresentationBuilder,\n            PresetResolvedParticleMassBuilder,\n        ],\n        ParticleRepresentation,\n    ]\n): ...\n</code></pre>"},{"location":"API/particula/particles/representation_factories/#see-also","title":"See also","text":"<ul> <li>ParticleMassRepresentationBuilder</li> <li>ParticleRadiusRepresentationBuilder</li> <li>ParticleRepresentation</li> <li>PresetParticleRadiusBuilder</li> <li>PresetResolvedParticleMassBuilder</li> <li>ResolvedParticleMassRepresentationBuilder</li> </ul>"},{"location":"API/particula/particles/representation_factories/#particlerepresentationfactoryget_builders","title":"ParticleRepresentationFactory().get_builders","text":"<p>Show source in representation_factories.py:43</p> <p>Returns the mapping of strategy types to builder instances.</p>"},{"location":"API/particula/particles/representation_factories/#returns","title":"Returns","text":"<p>A dictionary with the strategy types as keys and the builder instances as values. - 'mass' : MassParticleRepresentationBuilder - 'radius' : RadiusParticleRepresentationBuilder - 'preset_radius' : LimitedRadiusParticleBuilder - 'resolved_mass' : ResolvedMassParticleRepresentationBuilder - 'preset_resolved_mass' : PresetResolvedMassParticleBuilder</p>"},{"location":"API/particula/particles/representation_factories/#signature_1","title":"Signature","text":"<pre><code>def get_builders(self): ...\n</code></pre>"},{"location":"API/particula/particles/surface_builders/","title":"Surface Builders","text":"<p>Particula Index / Particula / Particles / Surface Builders</p> <p>Auto-generated documentation for particula.particles.surface_builders module.</p>"},{"location":"API/particula/particles/surface_builders/#surfacestrategymassbuilder","title":"SurfaceStrategyMassBuilder","text":"<p>Show source in surface_builders.py:67</p> <p>Builder class for SurfaceStrategyMass objects.</p>"},{"location":"API/particula/particles/surface_builders/#methods","title":"Methods","text":"<ul> <li><code>set_surface_tension(surface_tension,</code> surface_tension_units) - Set the     surface tension of the particle in N/m. Default units are 'N/m'.</li> <li><code>set_density(density,</code> density_units) - Set the density of the particle in     kg/m^3. Default units are 'kg/m^3'.</li> <li><code>set_parameters(params)</code> - Set the parameters of the SurfaceStrategyMass     object from a dictionary including optional units.</li> <li><code>build()</code> - Validate and return the SurfaceStrategyMass object.</li> </ul>"},{"location":"API/particula/particles/surface_builders/#signature","title":"Signature","text":"<pre><code>class SurfaceStrategyMassBuilder(\n    BuilderABC, BuilderSurfaceTensionMixin, BuilderDensityMixin\n):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/particles/surface_builders/#see-also","title":"See also","text":"<ul> <li>BuilderABC</li> <li>BuilderDensityMixin</li> <li>BuilderSurfaceTensionMixin</li> </ul>"},{"location":"API/particula/particles/surface_builders/#surfacestrategymassbuilderbuild","title":"SurfaceStrategyMassBuilder().build","text":"<p>Show source in surface_builders.py:88</p> <p>Validate and return the SurfaceStrategyMass object.</p>"},{"location":"API/particula/particles/surface_builders/#returns","title":"Returns","text":"<ul> <li><code>SurfaceStrategyMass</code> - Instance of the SurfaceStrategyMass object.</li> </ul>"},{"location":"API/particula/particles/surface_builders/#signature_1","title":"Signature","text":"<pre><code>def build(self) -&gt; SurfaceStrategyMass: ...\n</code></pre>"},{"location":"API/particula/particles/surface_builders/#see-also_1","title":"See also","text":"<ul> <li>SurfaceStrategyMass</li> </ul>"},{"location":"API/particula/particles/surface_builders/#surfacestrategymolarbuilder","title":"SurfaceStrategyMolarBuilder","text":"<p>Show source in surface_builders.py:26</p> <p>Builder class for SurfaceStrategyMolar objects.</p>"},{"location":"API/particula/particles/surface_builders/#methods_1","title":"Methods","text":"<ul> <li><code>set_surface_tension(surface_tension,</code> surface_tension_units) - Set the     surface tension of the particle in N/m. Default units are 'N/m'.</li> <li><code>set_density(density,</code> density_units) - Set the density of the particle in     kg/m^3. Default units are 'kg/m^3'.</li> <li><code>set_molar_mass(molar_mass,</code> molar_mass_units) - Set the molar mass of the     particle in kg/mol. Default units are 'kg/mol'.</li> <li><code>set_parameters(params)</code> - Set the parameters of the SurfaceStrategyMolar     object from a dictionary including optional units.</li> <li><code>build()</code> - Validate and return the SurfaceStrategyMolar object.</li> </ul>"},{"location":"API/particula/particles/surface_builders/#signature_2","title":"Signature","text":"<pre><code>class SurfaceStrategyMolarBuilder(\n    BuilderABC, BuilderDensityMixin, BuilderSurfaceTensionMixin, BuilderMolarMassMixin\n):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/particles/surface_builders/#see-also_2","title":"See also","text":"<ul> <li>BuilderABC</li> <li>BuilderDensityMixin</li> <li>BuilderMolarMassMixin</li> <li>BuilderSurfaceTensionMixin</li> </ul>"},{"location":"API/particula/particles/surface_builders/#surfacestrategymolarbuilderbuild","title":"SurfaceStrategyMolarBuilder().build","text":"<p>Show source in surface_builders.py:53</p> <p>Validate and return the SurfaceStrategyMass object.</p>"},{"location":"API/particula/particles/surface_builders/#returns_1","title":"Returns","text":"<ul> <li><code>SurfaceStrategyMolar</code> - Instance of the SurfaceStrategyMolar object.</li> </ul>"},{"location":"API/particula/particles/surface_builders/#signature_3","title":"Signature","text":"<pre><code>def build(self) -&gt; SurfaceStrategyMolar: ...\n</code></pre>"},{"location":"API/particula/particles/surface_builders/#see-also_3","title":"See also","text":"<ul> <li>SurfaceStrategyMolar</li> </ul>"},{"location":"API/particula/particles/surface_builders/#surfacestrategyvolumebuilder","title":"SurfaceStrategyVolumeBuilder","text":"<p>Show source in surface_builders.py:101</p> <p>Builder class for SurfaceStrategyVolume objects.</p>"},{"location":"API/particula/particles/surface_builders/#methods_2","title":"Methods","text":"<ul> <li><code>set_surface_tension(surface_tension,</code> surface_tension_units) - Set the     surface tension of the particle in N/m. Default units are 'N/m'.</li> <li><code>set_density(density,</code> density_units) - Set the density of the particle in     kg/m^3. Default units are 'kg/m^3'.</li> <li><code>set_parameters(params)</code> - Set the parameters of the SurfaceStrategyVolume     object from a dictionary including optional units.</li> <li><code>build()</code> - Validate and return the SurfaceStrategyVolume object.</li> </ul>"},{"location":"API/particula/particles/surface_builders/#signature_4","title":"Signature","text":"<pre><code>class SurfaceStrategyVolumeBuilder(\n    BuilderABC, BuilderSurfaceTensionMixin, BuilderDensityMixin\n):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/particles/surface_builders/#see-also_4","title":"See also","text":"<ul> <li>BuilderABC</li> <li>BuilderDensityMixin</li> <li>BuilderSurfaceTensionMixin</li> </ul>"},{"location":"API/particula/particles/surface_builders/#surfacestrategyvolumebuilderbuild","title":"SurfaceStrategyVolumeBuilder().build","text":"<p>Show source in surface_builders.py:122</p> <p>Validate and return the SurfaceStrategyVolume object.</p>"},{"location":"API/particula/particles/surface_builders/#returns_2","title":"Returns","text":"<ul> <li><code>SurfaceStrategyVolume</code> - Instance of the SurfaceStrategyVolume     object.</li> </ul>"},{"location":"API/particula/particles/surface_builders/#signature_5","title":"Signature","text":"<pre><code>def build(self) -&gt; SurfaceStrategyVolume: ...\n</code></pre>"},{"location":"API/particula/particles/surface_builders/#see-also_5","title":"See also","text":"<ul> <li>SurfaceStrategyVolume</li> </ul>"},{"location":"API/particula/particles/surface_factories/","title":"Surface Factories","text":"<p>Particula Index / Particula / Particles / Surface Factories</p> <p>Auto-generated documentation for particula.particles.surface_factories module.</p>"},{"location":"API/particula/particles/surface_factories/#surfacefactory","title":"SurfaceFactory","text":"<p>Show source in surface_factories.py:18</p> <p>Factory class to call and create surface tension strategies.</p> <p>Factory class to create surface tension strategy builders for calculating surface tension and the Kelvin effect for species in particulate phases.</p>"},{"location":"API/particula/particles/surface_factories/#methods","title":"Methods","text":"<ul> <li><code>get_builders()</code> - Returns the mapping of strategy types to builder instances.</li> <li><code>get_strategy(strategy_type,</code> parameters) - Gets the strategy instance for the specified strategy type.<ul> <li><code>strategy_type</code> - Type of surface tension strategy to use, can be 'volume', 'mass', or 'molar'. parameters(Dict[str, Any], optional): Parameters required for the builder, dependent on the chosen strategy type.<ul> <li><code>volume</code> - density, surface_tension</li> <li><code>mass</code> - density, surface_tension</li> <li><code>molar</code> - molar_mass, density, surface_tension</li> </ul> </li> </ul> </li> </ul>"},{"location":"API/particula/particles/surface_factories/#returns","title":"Returns","text":"<ul> <li><code>SurfaceStrategy</code> - An instance of the specified SurfaceStrategy.</li> </ul>"},{"location":"API/particula/particles/surface_factories/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code> - If an unknown strategy type is provided.</li> <li><code>ValueError</code> - If any required key is missing during check_keys or     pre_build_check, or if trying to set an invalid parameter.</li> </ul>"},{"location":"API/particula/particles/surface_factories/#signature","title":"Signature","text":"<pre><code>class SurfaceFactory(\n    StrategyFactory[\n        Union[\n            SurfaceStrategyVolumeBuilder,\n            SurfaceStrategyMassBuilder,\n            SurfaceStrategyMolarBuilder,\n        ],\n        Union[SurfaceStrategyVolume, SurfaceStrategyMass, SurfaceStrategyMolar],\n    ]\n): ...\n</code></pre>"},{"location":"API/particula/particles/surface_factories/#see-also","title":"See also","text":"<ul> <li>SurfaceStrategyMassBuilder</li> <li>SurfaceStrategyMass</li> <li>SurfaceStrategyMolarBuilder</li> <li>SurfaceStrategyMolar</li> <li>SurfaceStrategyVolumeBuilder</li> <li>SurfaceStrategyVolume</li> </ul>"},{"location":"API/particula/particles/surface_factories/#surfacefactoryget_builders","title":"SurfaceFactory().get_builders","text":"<p>Show source in surface_factories.py:58</p> <p>Returns the mapping of strategy types to builder instances.</p>"},{"location":"API/particula/particles/surface_factories/#returns_1","title":"Returns","text":"<ul> <li><code>Dict[str,</code> BuilderT] - A dictionary mapping strategy types to builder instances.<ul> <li><code>volume</code> - SurfaceStrategyVolumeBuilder</li> <li><code>mass</code> - SurfaceStrategyMassBuilder</li> <li><code>molar</code> - SurfaceStrategyMolarBuilder</li> </ul> </li> </ul>"},{"location":"API/particula/particles/surface_factories/#signature_1","title":"Signature","text":"<pre><code>def get_builders(self): ...\n</code></pre>"},{"location":"API/particula/particles/surface_strategies/","title":"Surface Strategies","text":"<p>Particula Index / Particula / Particles / Surface Strategies</p> <p>Auto-generated documentation for particula.particles.surface_strategies module.</p>"},{"location":"API/particula/particles/surface_strategies/#surfacestrategy","title":"SurfaceStrategy","text":"<p>Show source in surface_strategies.py:18</p> <p>ABC class for Surface Strategies.</p> <p>Abstract class for implementing strategies to calculate surface tension and the Kelvin effect for species in particulate phases.</p>"},{"location":"API/particula/particles/surface_strategies/#methods","title":"Methods","text":"<ul> <li><code>effective_surface_tension</code> - Calculate the effective surface tension of     species based on their concentration.</li> <li><code>effective_density</code> - Calculate the effective density of species based on     their concentration.</li> <li><code>get_name</code> - Return the type of the surface strategy.</li> <li><code>kelvin_radius</code> - Calculate the Kelvin radius which determines the     curvature effect on vapor pressure.</li> <li><code>kelvin_term</code> - Calculate the Kelvin term, which quantifies the effect of     particle curvature on vapor pressure.</li> </ul>"},{"location":"API/particula/particles/surface_strategies/#signature","title":"Signature","text":"<pre><code>class SurfaceStrategy(ABC): ...\n</code></pre>"},{"location":"API/particula/particles/surface_strategies/#surfacestrategyeffective_density","title":"SurfaceStrategy().effective_density","text":"<p>Show source in surface_strategies.py:49</p> <p>Calculate the effective density of the species mixture.</p>"},{"location":"API/particula/particles/surface_strategies/#arguments","title":"Arguments","text":"<ul> <li><code>mass_concentration</code> - Concentration of the species [kg/m^3].</li> </ul>"},{"location":"API/particula/particles/surface_strategies/#returns","title":"Returns","text":"<p>float or NDArray[float]: Effective density of the species [kg/m^3].</p>"},{"location":"API/particula/particles/surface_strategies/#signature_1","title":"Signature","text":"<pre><code>@abstractmethod\ndef effective_density(\n    self, mass_concentration: Union[float, NDArray[np.float64]]\n) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/particles/surface_strategies/#surfacestrategyeffective_surface_tension","title":"SurfaceStrategy().effective_surface_tension","text":"<p>Show source in surface_strategies.py:36</p> <p>Calculate the effective surface tension of the species mixture.</p>"},{"location":"API/particula/particles/surface_strategies/#arguments_1","title":"Arguments","text":"<ul> <li><code>mass_concentration</code> - Concentration of the species [kg/m^3].</li> </ul>"},{"location":"API/particula/particles/surface_strategies/#returns_1","title":"Returns","text":"<p>float or NDArray[float]: Effective surface tension [N/m].</p>"},{"location":"API/particula/particles/surface_strategies/#signature_2","title":"Signature","text":"<pre><code>@abstractmethod\ndef effective_surface_tension(\n    self, mass_concentration: Union[float, NDArray[np.float64]]\n) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/particles/surface_strategies/#surfacestrategyget_name","title":"SurfaceStrategy().get_name","text":"<p>Show source in surface_strategies.py:62</p> <p>Return the type of the surface strategy.</p>"},{"location":"API/particula/particles/surface_strategies/#signature_3","title":"Signature","text":"<pre><code>def get_name(self) -&gt; str: ...\n</code></pre>"},{"location":"API/particula/particles/surface_strategies/#surfacestrategykelvin_radius","title":"SurfaceStrategy().kelvin_radius","text":"<p>Show source in surface_strategies.py:66</p> <p>Calculate the Kelvin radius which determines the curvature effect.</p> <p>The kelvin radius is molecule specific and depends on the surface tension, molar mass, density, and temperature of the system. It is used to calculate the Kelvin term, which quantifies the effect of particle curvature on vapor pressure.</p>"},{"location":"API/particula/particles/surface_strategies/#arguments_2","title":"Arguments","text":"<ul> <li><code>surface_tension</code> - Surface tension of the mixture [N/m].</li> <li><code>molar_mass</code> - Molar mass of the species [kg/mol].</li> <li><code>mass_concentration</code> - Concentration of the species [kg/m^3].</li> <li><code>temperature</code> - Temperature of the system [K].</li> </ul>"},{"location":"API/particula/particles/surface_strategies/#returns_2","title":"Returns","text":"<p>float or NDArray[float]: Kelvin radius [m].</p>"},{"location":"API/particula/particles/surface_strategies/#references","title":"References","text":"<ul> <li>Based on Neil Donahue's approach to the Kelvin equation: r = 2 * surface_tension * molar_mass / (R * T * density) Kelvin Wikipedia</li> </ul>"},{"location":"API/particula/particles/surface_strategies/#signature_4","title":"Signature","text":"<pre><code>def kelvin_radius(\n    self,\n    molar_mass: Union[float, NDArray[np.float64]],\n    mass_concentration: Union[float, NDArray[np.float64]],\n    temperature: float,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/surface_strategies/#surfacestrategykelvin_term","title":"SurfaceStrategy().kelvin_term","text":"<p>Show source in surface_strategies.py:100</p> <p>Calculate the Kelvin term, which multiplies the vapor pressure.</p> <p>The Kelvin term is used to adjust the vapor pressure of a species due to the curvature of the particle.</p>"},{"location":"API/particula/particles/surface_strategies/#arguments_3","title":"Arguments","text":"<ul> <li><code>radius</code> - Radius of the particle [m].</li> <li><code>molar_mass</code> - Molar mass of the species a [kg/mol].</li> <li><code>mass_concentration</code> - Concentration of the species [kg/m^3].</li> <li><code>temperature</code> - Temperature of the system [K].</li> </ul>"},{"location":"API/particula/particles/surface_strategies/#returns_3","title":"Returns","text":"<p>float or NDArray[float]: The exponential factor adjusting vapor     pressure due to curvature.</p>"},{"location":"API/particula/particles/surface_strategies/#references_1","title":"References","text":"<p>Based on Neil Donahue's approach to the Kelvin equation: exp(kelvin_radius / particle_radius) Kelvin Eq Wikipedia</p>"},{"location":"API/particula/particles/surface_strategies/#signature_5","title":"Signature","text":"<pre><code>def kelvin_term(\n    self,\n    radius: Union[float, NDArray[np.float64]],\n    molar_mass: Union[float, NDArray[np.float64]],\n    mass_concentration: Union[float, NDArray[np.float64]],\n    temperature: float,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/surface_strategies/#surfacestrategymass","title":"SurfaceStrategyMass","text":"<p>Show source in surface_strategies.py:186</p> <p>Surface tension and density, based on mass fraction weighted values.</p>"},{"location":"API/particula/particles/surface_strategies/#arguments_4","title":"Arguments","text":"<ul> <li><code>surface_tension</code> - Surface tension of the species [N/m]. If a single     value is provided, it will be used for all species.</li> <li><code>density</code> - Density of the species [kg/m^3]. If a single value is     provided, it will be used for all species.</li> </ul>"},{"location":"API/particula/particles/surface_strategies/#references_2","title":"References","text":"<p>Mass Fractions</p>"},{"location":"API/particula/particles/surface_strategies/#signature_6","title":"Signature","text":"<pre><code>class SurfaceStrategyMass(SurfaceStrategy):\n    def __init__(\n        self,\n        surface_tension: Union[float, NDArray[np.float64]] = 0.072,\n        density: Union[float, NDArray[np.float64]] = 1000,\n    ): ...\n</code></pre>"},{"location":"API/particula/particles/surface_strategies/#see-also","title":"See also","text":"<ul> <li>SurfaceStrategy</li> </ul>"},{"location":"API/particula/particles/surface_strategies/#surfacestrategymasseffective_density","title":"SurfaceStrategyMass().effective_density","text":"<p>Show source in surface_strategies.py:219</p>"},{"location":"API/particula/particles/surface_strategies/#signature_7","title":"Signature","text":"<pre><code>def effective_density(\n    self, mass_concentration: Union[float, NDArray[np.float64]]\n) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/particles/surface_strategies/#surfacestrategymasseffective_surface_tension","title":"SurfaceStrategyMass().effective_surface_tension","text":"<p>Show source in surface_strategies.py:207</p>"},{"location":"API/particula/particles/surface_strategies/#signature_8","title":"Signature","text":"<pre><code>def effective_surface_tension(\n    self, mass_concentration: Union[float, NDArray[np.float64]]\n) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/particles/surface_strategies/#surfacestrategymolar","title":"SurfaceStrategyMolar","text":"<p>Show source in surface_strategies.py:134</p> <p>Surface tension and density, based on mole fraction weighted values.</p>"},{"location":"API/particula/particles/surface_strategies/#arguments_5","title":"Arguments","text":"<ul> <li><code>surface_tension</code> - Surface tension of the species [N/m]. If a single     value is provided, it will be used for all species.</li> <li><code>density</code> - Density of the species [kg/m^3]. If a single value is     provided, it will be used for all species.</li> <li><code>molar_mass</code> - Molar mass of the species [kg/mol]. If a single value is     provided, it will be used for all species.</li> </ul>"},{"location":"API/particula/particles/surface_strategies/#references_3","title":"References","text":"<p>Mole Fractions</p>"},{"location":"API/particula/particles/surface_strategies/#signature_9","title":"Signature","text":"<pre><code>class SurfaceStrategyMolar(SurfaceStrategy):\n    def __init__(\n        self,\n        surface_tension: Union[float, NDArray[np.float64]] = 0.072,\n        density: Union[float, NDArray[np.float64]] = 1000,\n        molar_mass: Union[float, NDArray[np.float64]] = 0.01815,\n    ): ...\n</code></pre>"},{"location":"API/particula/particles/surface_strategies/#see-also_1","title":"See also","text":"<ul> <li>SurfaceStrategy</li> </ul>"},{"location":"API/particula/particles/surface_strategies/#surfacestrategymolareffective_density","title":"SurfaceStrategyMolar().effective_density","text":"<p>Show source in surface_strategies.py:172</p>"},{"location":"API/particula/particles/surface_strategies/#signature_10","title":"Signature","text":"<pre><code>def effective_density(\n    self, mass_concentration: Union[float, NDArray[np.float64]]\n) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/particles/surface_strategies/#surfacestrategymolareffective_surface_tension","title":"SurfaceStrategyMolar().effective_surface_tension","text":"<p>Show source in surface_strategies.py:159</p>"},{"location":"API/particula/particles/surface_strategies/#signature_11","title":"Signature","text":"<pre><code>def effective_surface_tension(\n    self, mass_concentration: Union[float, NDArray[np.float64]]\n) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/particles/surface_strategies/#surfacestrategyvolume","title":"SurfaceStrategyVolume","text":"<p>Show source in surface_strategies.py:230</p> <p>Surface tension and density, based on volume fraction weighted values.</p>"},{"location":"API/particula/particles/surface_strategies/#arguments_6","title":"Arguments","text":"<ul> <li><code>surface_tension</code> - Surface tension of the species [N/m]. If a single     value is provided, it will be used for all species.</li> <li><code>density</code> - Density of the species [kg/m^3]. If a single value is     provided, it will be used for all species.</li> </ul>"},{"location":"API/particula/particles/surface_strategies/#references_4","title":"References","text":"<p>Volume Fractions</p>"},{"location":"API/particula/particles/surface_strategies/#signature_12","title":"Signature","text":"<pre><code>class SurfaceStrategyVolume(SurfaceStrategy):\n    def __init__(\n        self,\n        surface_tension: Union[float, NDArray[np.float64]] = 0.072,\n        density: Union[float, NDArray[np.float64]] = 1000,\n    ): ...\n</code></pre>"},{"location":"API/particula/particles/surface_strategies/#see-also_2","title":"See also","text":"<ul> <li>SurfaceStrategy</li> </ul>"},{"location":"API/particula/particles/surface_strategies/#surfacestrategyvolumeeffective_density","title":"SurfaceStrategyVolume().effective_density","text":"<p>Show source in surface_strategies.py:264</p>"},{"location":"API/particula/particles/surface_strategies/#signature_13","title":"Signature","text":"<pre><code>def effective_density(\n    self, mass_concentration: Union[float, NDArray[np.float64]]\n) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/particles/surface_strategies/#surfacestrategyvolumeeffective_surface_tension","title":"SurfaceStrategyVolume().effective_surface_tension","text":"<p>Show source in surface_strategies.py:251</p>"},{"location":"API/particula/particles/surface_strategies/#signature_14","title":"Signature","text":"<pre><code>def effective_surface_tension(\n    self, mass_concentration: Union[float, NDArray[np.float64]]\n) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/particles/properties/","title":"Properties","text":"<p>Particula Index / Particula / Particles / Properties</p> <p>Auto-generated documentation for particula.particles.properties module.</p>"},{"location":"API/particula/particles/properties/#modules","title":"Modules","text":"<ul> <li>Activity Module</li> <li>Aerodynamic Mobility Module</li> <li>Aerodynamic Size</li> <li>Collision Radius Module</li> <li>Coulomb Enhancement</li> <li>Diffusion Coefficient</li> <li>Diffusive Knudsen Module</li> <li>Friction Factor Module</li> <li>Kelvin Effect Module</li> <li>Knudsen Number Module</li> <li>Lognormal Size Distribution</li> <li>Mean Thermal Speed Module</li> <li>Partial Pressure Module</li> <li>Settling Velocity</li> <li>Slip Correction Module</li> <li>Special Functions</li> <li>Vapor Correction Module</li> </ul>"},{"location":"API/particula/particles/properties/activity_module/","title":"Activity Module","text":"<p>Particula Index / Particula / Particles / Properties / Activity Module</p> <p>Auto-generated documentation for particula.particles.properties.activity_module module.</p>"},{"location":"API/particula/particles/properties/activity_module/#calculate_partial_pressure","title":"calculate_partial_pressure","text":"<p>Show source in activity_module.py:223</p> <p>Calculate the partial pressure of a species based on its activity and pure     vapor pressure.</p>"},{"location":"API/particula/particles/properties/activity_module/#arguments","title":"Arguments","text":"<p>pure_vapor_pressure (float or NDArray[np.float64]): Pure vapor pressure     of the species in pascals (Pa). activity (float or NDArray[np.float64]): Activity of the species,     unitless.</p>"},{"location":"API/particula/particles/properties/activity_module/#returns","title":"Returns","text":"<p>float or NDArray[np.float64]: Partial pressure of the species in pascals (Pa).</p>"},{"location":"API/particula/particles/properties/activity_module/#examples","title":"Examples","text":"Example<pre><code>calculate_partial_pressure(1000.0, 0.95)\n# 950.0\n</code></pre>"},{"location":"API/particula/particles/properties/activity_module/#signature","title":"Signature","text":"<pre><code>def calculate_partial_pressure(\n    pure_vapor_pressure: Union[float, NDArray[np.float64]],\n    activity: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/activity_module/#ideal_activity_mass","title":"ideal_activity_mass","text":"<p>Show source in activity_module.py:88</p> <p>Calculate the ideal activity of a species based on mass fractions.</p> <p>This function computes the activity based on the mass fractions of species consistent with Raoult's Law.</p>"},{"location":"API/particula/particles/properties/activity_module/#arguments_1","title":"Arguments","text":"<p>mass_concentration (float or NDArray[np.float64]): Mass concentration     of the species in kilograms per cubic meter (kg/m^3).</p>"},{"location":"API/particula/particles/properties/activity_module/#returns_1","title":"Returns","text":"<p>float or NDArray[np.float64]]: Activity of the species, unitless.</p>"},{"location":"API/particula/particles/properties/activity_module/#examples_1","title":"Examples","text":"Example<pre><code>ideal_activity_mass(np.array([1.0, 2.0]))\narray([0.3333, 0.6667])\n</code></pre>"},{"location":"API/particula/particles/properties/activity_module/#references","title":"References","text":"<ul> <li><code>Raoult's</code> Law - https://en.wikipedia.org/wiki/Raoult%27s_law</li> </ul>"},{"location":"API/particula/particles/properties/activity_module/#signature_1","title":"Signature","text":"<pre><code>def ideal_activity_mass(\n    mass_concentration: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/activity_module/#ideal_activity_molar","title":"ideal_activity_molar","text":"<p>Show source in activity_module.py:10</p> <p>Calculate the ideal activity of a species based on mole fractions.</p> <p>This function computes the activity based on the mole fractions of species according to Raoult's Law.</p>"},{"location":"API/particula/particles/properties/activity_module/#arguments_2","title":"Arguments","text":"<p>mass_concentration (float or NDArray[np.float64]): Mass concentration     of the species in kilograms per cubic meter (kg/m^3). molar_mass (float or NDArray[np.float64]): Molar mass of the species in     kilograms per mole (kg/mol). A single value applies to all species     if only one is provided.</p>"},{"location":"API/particula/particles/properties/activity_module/#returns_2","title":"Returns","text":"<p>float or NDArray[np.float64]: Activity of the species, unitless.</p>"},{"location":"API/particula/particles/properties/activity_module/#examples_2","title":"Examples","text":"Example<pre><code>ideal_activity_molar(\n    mass_concentration=np.array([1.0, 2.0]),\n    molar_mass=np.array([18.015, 28.97]))\n# array([0.0525, 0.0691])\n</code></pre>"},{"location":"API/particula/particles/properties/activity_module/#references_1","title":"References","text":"<ul> <li><code>Raoult's</code> Law - https://en.wikipedia.org/wiki/Raoult%27s_law</li> </ul>"},{"location":"API/particula/particles/properties/activity_module/#signature_2","title":"Signature","text":"<pre><code>def ideal_activity_molar(\n    mass_concentration: Union[float, NDArray[np.float64]],\n    molar_mass: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/activity_module/#ideal_activity_volume","title":"ideal_activity_volume","text":"<p>Show source in activity_module.py:49</p> <p>Calculate the ideal activity of a species based on volume fractions.</p> <p>This function computes the activity based on the volume fractions of species consistent with Raoult's Law.</p>"},{"location":"API/particula/particles/properties/activity_module/#arguments_3","title":"Arguments","text":"<p>mass_concentration (float or NDArray[np.float64]): Mass concentration     of the species in kilograms per cubic meter (kg/m^3). density (float or NDArray[np.float64]): Density of the species in     kilograms per cubic meter (kg/m^3). A single value applies to all     species if only one is provided.</p>"},{"location":"API/particula/particles/properties/activity_module/#returns_3","title":"Returns","text":"<p>float or NDArray[np.float64]: Activity of the species, unitless.</p>"},{"location":"API/particula/particles/properties/activity_module/#examples_3","title":"Examples","text":"Example<pre><code>ideal_activity_volume(\n    mass_concentration=np.array([1.0, 2.0]),\n    density=np.array([1000.0, 1200.0]))\n# array([0.001, 0.002])\n</code></pre>"},{"location":"API/particula/particles/properties/activity_module/#references_2","title":"References","text":"<ul> <li><code>Raoult's</code> Law - https://en.wikipedia.org/wiki/Raoult%27s_law</li> </ul>"},{"location":"API/particula/particles/properties/activity_module/#signature_3","title":"Signature","text":"<pre><code>def ideal_activity_volume(\n    mass_concentration: Union[float, NDArray[np.float64]],\n    density: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/activity_module/#kappa_activity","title":"kappa_activity","text":"<p>Show source in activity_module.py:121</p> <p>Calculate the activity of species based on the kappa hygroscopic parameter.</p> <p>This function computes the activity using the kappa parameter and the species' mass concentrations, considering the volume fractions and water content.</p>"},{"location":"API/particula/particles/properties/activity_module/#arguments_4","title":"Arguments","text":"<p>mass_concentration (float or NDArray[np.float64]]): Mass concentration     of the species in kilograms per cubic meter (kg/m^3). - <code>kappa</code> NDArray[np.float64] - Kappa hygroscopic parameter, unitless. - <code>density</code> NDArray[np.float64] - Density of the species in kilograms per     cubic meter (kg/m^3). - <code>molar_mass</code> NDArray[np.float64] - Molar mass of the species in     kilograms per mole (kg/mol). - <code>water_index</code> int - Index of water in the mass concentration array.</p>"},{"location":"API/particula/particles/properties/activity_module/#returns_4","title":"Returns","text":"<ul> <li><code>NDArray[np.float64]</code> - Activity of the species, unitless.</li> </ul>"},{"location":"API/particula/particles/properties/activity_module/#examples_4","title":"Examples","text":"Example<pre><code>kappa_activity(\n    mass_concentration=np.array([[1.0, 2.0], [3.0, 4.0]]),\n    kappa=np.array([0.0, 0.2]),\n    density=np.array([1000.0, 1200.0]),\n    molar_mass=np.array([18.015, 28.97]),\n    water_index=0\n)\n# array([[0.95, 0.75], [0.85, 0.65]])\n</code></pre>"},{"location":"API/particula/particles/properties/activity_module/#references_3","title":"References","text":"<p>Petters, M. D., &amp; Kreidenweis, S. M. (2007). A single parameter representation of hygroscopic growth and cloud condensation nucleus activity. Atmospheric Chemistry and Physics, 7(8), 1961-1971. - <code>DOI</code> - https://doi.org/10.5194/acp-7-1961-2007</p>"},{"location":"API/particula/particles/properties/activity_module/#signature_4","title":"Signature","text":"<pre><code>def kappa_activity(\n    mass_concentration: NDArray[np.float64],\n    kappa: NDArray[np.float64],\n    density: NDArray[np.float64],\n    molar_mass: NDArray[np.float64],\n    water_index: int,\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/aerodynamic_mobility_module/","title":"Aerodynamic Mobility Module","text":"<p>Particula Index / Particula / Particles / Properties / Aerodynamic Mobility Module</p> <p>Auto-generated documentation for particula.particles.properties.aerodynamic_mobility_module module.</p>"},{"location":"API/particula/particles/properties/aerodynamic_mobility_module/#particle_aerodynamic_mobility","title":"particle_aerodynamic_mobility","text":"<p>Show source in aerodynamic_mobility_module.py:12</p> <p>Calculate the aerodynamic mobility of a particle.</p> <p>This is defined as the ratio of the slip correction factor to the product of the dynamic viscosity of the fluid, the particle radius, and a slip correction constant derived. This mobility quantifies the ease with which a particle can move through a fluid.</p>"},{"location":"API/particula/particles/properties/aerodynamic_mobility_module/#arguments","title":"Arguments","text":"<ul> <li>radius : The radius of the particle (m).</li> <li>slip_correction_factor : The slip correction factor for the particle      in the fluid (dimensionless).</li> <li>dynamic_viscosity : The dynamic viscosity of the fluid (Pa.s).</li> </ul>"},{"location":"API/particula/particles/properties/aerodynamic_mobility_module/#returns","title":"Returns","text":"<p>The particle aerodynamic mobility (m^2/s).</p>"},{"location":"API/particula/particles/properties/aerodynamic_mobility_module/#examples","title":"Examples","text":"Example<pre><code>aerodynamic_mobility = particle_aerodynamic_mobility(\n    radius=0.00005,\n    slip_correction_factor=1.1,\n    dynamic_viscosity=0.0000181,\n)\n</code></pre>"},{"location":"API/particula/particles/properties/aerodynamic_mobility_module/#signature","title":"Signature","text":"<pre><code>def particle_aerodynamic_mobility(\n    radius: Union[float, NDArray[np.float64]],\n    slip_correction_factor: Union[float, NDArray[np.float64]],\n    dynamic_viscosity: float,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/aerodynamic_size/","title":"Aerodynamic Size","text":"<p>Particula Index / Particula / Particles / Properties / Aerodynamic Size</p> <p>Auto-generated documentation for particula.particles.properties.aerodynamic_size module.</p>"},{"location":"API/particula/particles/properties/aerodynamic_size/#get_aerodynamic_shape_factor","title":"get_aerodynamic_shape_factor","text":"<p>Show source in aerodynamic_size.py:81</p> <p>Retrieve the aerodynamic shape factor for a given particle shape.</p>"},{"location":"API/particula/particles/properties/aerodynamic_size/#arguments","title":"Arguments","text":"<ul> <li>shape_key : The shape of the particle as a string. Options include:     sphere, cube, cylinder_avg_aspect_2, cylinder_avg_aspect_5,     cylinder_avg_aspect_10, spheres_cluster_3, spheres_cluster_4,     bituminous_coal, quartz, sand, talc</li> </ul>"},{"location":"API/particula/particles/properties/aerodynamic_size/#returns","title":"Returns","text":"<p>The shape factor of the particle as a float.</p>"},{"location":"API/particula/particles/properties/aerodynamic_size/#examples","title":"Examples","text":"Example<pre><code>shape_factor = get_aerodynamic_shape_factor(\"sand\")\n# shape_factor = 1.57\n</code></pre>"},{"location":"API/particula/particles/properties/aerodynamic_size/#raises","title":"Raises","text":"<ul> <li>ValueError : If the shape is not found in the predefined shape     factor dictionary.</li> </ul>"},{"location":"API/particula/particles/properties/aerodynamic_size/#signature","title":"Signature","text":"<pre><code>def get_aerodynamic_shape_factor(shape_key: str) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/particles/properties/aerodynamic_size/#particle_aerodynamic_length","title":"particle_aerodynamic_length","text":"<p>Show source in aerodynamic_size.py:25</p> <p>Calculate the aerodynamic length scale of a particle.</p> <p>The aerodynamic size is used to compare the aerodynamic properties of particles with their physical properties, particularly when interpreting aerodynamic particle sizer measurements. This is either the aerodynamic diameter or radius, depending on length scale input.</p>"},{"location":"API/particula/particles/properties/aerodynamic_size/#arguments_1","title":"Arguments","text":"<ul> <li>physical_length : Physical length scale of the particle (m).</li> <li>physical_slip_correction_factor : Slip correction factor for the      particle's physical radius in the fluid (dimensionless).</li> <li>aerodynamic_slip_correction_factor : Slip correction factor for the      particle's aerodynamic radius in the fluid (dimensionless).</li> <li>density : Density of the particle (kg/m^3).</li> <li>reference_density : Reference density for the particle, typically      the density of water (1000 kg/m^3 by default).</li> <li>aerodynamic_shape_factor : Shape factor of the particle, accounting      for non-sphericity (dimensionless, default is 1.0 for spherical      particles).</li> </ul>"},{"location":"API/particula/particles/properties/aerodynamic_size/#returns_1","title":"Returns","text":"<p>Aerodynamic radius of the particle (m).</p>"},{"location":"API/particula/particles/properties/aerodynamic_size/#examples_1","title":"Examples","text":"Example<pre><code>aerodynamic_length = particle_aerodynamic_length(\n    physical_length=0.00005,\n    physical_slip_correction_factor=1.1,\n    aerodynamic_slip_correction_factor=1.0,\n    density=1000,\n    reference_density=1000,\n    aerodynamic_shape_factor=1.0,\n)\n</code></pre>"},{"location":"API/particula/particles/properties/aerodynamic_size/#references","title":"References","text":"<ul> <li>https://en.wikipedia.org/wiki/Aerosol#Aerodynamic_diameter</li> <li>Hinds, W.C. (1998) Aerosol Technology: Properties, behavior, and     measurement of airborne particles. Wiley-Interscience, New York.     pp 51-53, section 3.6.</li> </ul>"},{"location":"API/particula/particles/properties/aerodynamic_size/#signature_1","title":"Signature","text":"<pre><code>def particle_aerodynamic_length(\n    physical_length: Union[float, NDArray[np.float64]],\n    physical_slip_correction_factor: Union[float, NDArray[np.float64]],\n    aerodynamic_slip_correction_factor: Union[float, NDArray[np.float64]],\n    density: Union[float, NDArray[np.float64]],\n    reference_density: float = 1000,\n    aerodynamic_shape_factor: float = 1.0,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/collision_radius_module/","title":"Collision Radius Module","text":"<p>Particula Index / Particula / Particles / Properties / Collision Radius Module</p> <p>Auto-generated documentation for particula.particles.properties.collision_radius_module module.</p>"},{"location":"API/particula/particles/properties/collision_radius_module/#mulholland_1988","title":"mulholland_1988","text":"<p>Show source in collision_radius_module.py:15</p> <p>Collision radius is equal to the radius of gyration.</p>"},{"location":"API/particula/particles/properties/collision_radius_module/#arguments","title":"Arguments","text":"<ul> <li><code>radius_gyration</code> - Radius of gyration of the particle [m].</li> </ul>"},{"location":"API/particula/particles/properties/collision_radius_module/#returns","title":"Returns","text":"<p>(float or NDArray[float]): Collision radius of the particle [m].</p>"},{"location":"API/particula/particles/properties/collision_radius_module/#references","title":"References","text":"<p>Mulholland, G. W., Mountain, R. D., Samson, R. J., &amp; Ernst, M. H. (1988). Cluster Size Distribution for Free Molecular Agglomeration. Energy and Fuels, 2(4). https://doi.org/10.1021/ef00010a014</p>"},{"location":"API/particula/particles/properties/collision_radius_module/#examples","title":"Examples","text":"Example<pre><code>mulholland_1988(1.5)\n# 1.5\n</code></pre>"},{"location":"API/particula/particles/properties/collision_radius_module/#signature","title":"Signature","text":"<pre><code>def mulholland_1988(\n    radius_gyration: Union[NDArray[np.float64], float],\n) -&gt; Union[NDArray[np.float64], float]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/collision_radius_module/#qian_2022_rg","title":"qian_2022_rg","text":"<p>Show source in collision_radius_module.py:140</p> <p>Fitted model using radius of gyration.</p>"},{"location":"API/particula/particles/properties/collision_radius_module/#arguments_1","title":"Arguments","text":"<ul> <li><code>radius_gyration</code> - radius of gyration [m].</li> <li><code>radius_monomer</code> - monomer radius [m].</li> </ul>"},{"location":"API/particula/particles/properties/collision_radius_module/#returns_1","title":"Returns","text":"<ul> <li><code>(float)</code> - Collision radius of the particle [m].</li> </ul>"},{"location":"API/particula/particles/properties/collision_radius_module/#references_1","title":"References","text":"<p>Qian, W., Kronenburg, A., Hui, X., Lin, Y., &amp; Karsch, M. (2022). Effects of agglomerate characteristics on their collision kernels in the free molecular regime. Journal of Aerosol Science, 159. https://doi.org/10.1016/j.jaerosci.2021.105868</p>"},{"location":"API/particula/particles/properties/collision_radius_module/#examples_1","title":"Examples","text":"Example<pre><code>qian_2022_rg(1.5, 0.1)\n# 1.5036\n</code></pre>"},{"location":"API/particula/particles/properties/collision_radius_module/#signature_1","title":"Signature","text":"<pre><code>def qian_2022_rg(\n    radius_gyration: Union[NDArray[np.float64], float], radius_monomer: float\n) -&gt; Union[NDArray[np.float64], float]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/collision_radius_module/#qian_2022_rg_df","title":"qian_2022_rg_df","text":"<p>Show source in collision_radius_module.py:171</p> <p>New model Rc with Rg and Df parameters.</p>"},{"location":"API/particula/particles/properties/collision_radius_module/#arguments_2","title":"Arguments","text":"<ul> <li><code>fractal_dimension</code> - Fractal dimension of the particle [-].</li> <li><code>radius_gyration</code> - Scaled radius of gyration [m].</li> <li><code>radius_monomer</code> - Monomer radius [m].</li> </ul>"},{"location":"API/particula/particles/properties/collision_radius_module/#returns_2","title":"Returns","text":"<ul> <li><code>(float)</code> - Collision radius of the particle [m].</li> </ul>"},{"location":"API/particula/particles/properties/collision_radius_module/#references_2","title":"References","text":"<p>Qian, W., Kronenburg, A., Hui, X., Lin, Y., &amp; Karsch, M. (2022). Effects of agglomerate characteristics on their collision kernels in the free molecular regime. Journal of Aerosol Science, 159. https://doi.org/10.1016/j.jaerosci.2021.105868</p>"},{"location":"API/particula/particles/properties/collision_radius_module/#examples_2","title":"Examples","text":"Example<pre><code>qian_2022_rg_df(2.5, 1.5, 0.1)\n# 1.661\n</code></pre>"},{"location":"API/particula/particles/properties/collision_radius_module/#signature_2","title":"Signature","text":"<pre><code>def qian_2022_rg_df(\n    fractal_dimension: Union[NDArray[np.float64], float],\n    radius_gyration: Union[NDArray[np.float64], float],\n    radius_monomer: float,\n) -&gt; Union[NDArray[np.float64], float]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/collision_radius_module/#qian_2022_rg_df_k0","title":"qian_2022_rg_df_k0","text":"<p>Show source in collision_radius_module.py:207</p> <p>New model Rc with Rg, Df, and k0 parameters.</p>"},{"location":"API/particula/particles/properties/collision_radius_module/#arguments_3","title":"Arguments","text":"<ul> <li><code>fractal_dimension</code> - Fractal dimension of the particle [-].</li> <li><code>fractal_prefactor</code> - Fractal prefactor of the particle [-].</li> <li><code>radius_gyration</code> - radius of gyration [m].</li> <li><code>radius_monomer</code> - monomer radius [m].</li> </ul>"},{"location":"API/particula/particles/properties/collision_radius_module/#returns_3","title":"Returns","text":"<ul> <li><code>(float)</code> - Collision radius of the particle [m].</li> </ul>"},{"location":"API/particula/particles/properties/collision_radius_module/#references_3","title":"References","text":"<p>Qian, W., Kronenburg, A., Hui, X., Lin, Y., &amp; Karsch, M. (2022). Effects of agglomerate characteristics on their collision kernels in the free molecular regime. Journal of Aerosol Science, 159. https://doi.org/10.1016/j.jaerosci.2021.105868</p>"},{"location":"API/particula/particles/properties/collision_radius_module/#examples_3","title":"Examples","text":"Example<pre><code>qian_2022_rg_df_k0(2.5, 1.2, 1.5, 0.1)\n# 1.832\n</code></pre>"},{"location":"API/particula/particles/properties/collision_radius_module/#signature_3","title":"Signature","text":"<pre><code>def qian_2022_rg_df_k0(\n    fractal_dimension: float,\n    fractal_prefactor: float,\n    radius_gyration: Union[NDArray[np.float64], float],\n    radius_monomer: float,\n) -&gt; Union[NDArray[np.float64], float]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/collision_radius_module/#qian_2022_rg_df_k0_a13","title":"qian_2022_rg_df_k0_a13","text":"<p>Show source in collision_radius_module.py:247</p> <p>New model Rc with Rg, Df, k0, and A13 parameters.</p>"},{"location":"API/particula/particles/properties/collision_radius_module/#arguments_4","title":"Arguments","text":"<ul> <li><code>fractal_dimension</code> - Fractal dimension of the particle [-].</li> <li><code>fractal_prefactor</code> - Fractal prefactor of the particle [-].</li> <li><code>shape_anisotropy</code> - Parameter A13 for the model [-].</li> <li><code>radius_gyration</code> - Radius of gyration [m].</li> <li><code>radius_monomer</code> - Monomer radius [m].</li> </ul>"},{"location":"API/particula/particles/properties/collision_radius_module/#returns_4","title":"Returns","text":"<ul> <li><code>(float)</code> - Collision radius of the particle [m].</li> </ul>"},{"location":"API/particula/particles/properties/collision_radius_module/#references_4","title":"References","text":"<p>Qian, W., Kronenburg, A., Hui, X., Lin, Y., &amp; Karsch, M. (2022). Effects of agglomerate characteristics on their collision kernels in the free molecular regime. Journal of Aerosol Science, 159. https://doi.org/10.1016/j.jaerosci.2021.105868</p>"},{"location":"API/particula/particles/properties/collision_radius_module/#examples_4","title":"Examples","text":"Example<pre><code>qian_2022_rg_df_k0_a13(2.5, 1.2, 0.5, 1.5, 0.1)\n# 1.823\n</code></pre>"},{"location":"API/particula/particles/properties/collision_radius_module/#signature_4","title":"Signature","text":"<pre><code>def qian_2022_rg_df_k0_a13(\n    fractal_dimension: float,\n    fractal_prefactor: float,\n    shape_anisotropy: float,\n    radius_gyration: Union[NDArray[np.float64], float],\n    radius_monomer: float,\n) -&gt; Union[NDArray[np.float64], float]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/collision_radius_module/#rogak_flagan_1992","title":"rogak_flagan_1992","text":"<p>Show source in collision_radius_module.py:40</p> <p>Collision radius with fractal dimension by Rogak and Flagan 1992.</p>"},{"location":"API/particula/particles/properties/collision_radius_module/#arguments_5","title":"Arguments","text":"<ul> <li><code>radius_gyration</code> - Radius of gyration of the particle [m].</li> <li><code>fractal_dimension</code> - Fractal dimension of the particle     [dimensionless, df].</li> </ul>"},{"location":"API/particula/particles/properties/collision_radius_module/#returns_5","title":"Returns","text":"<p>(float or NDArray[float]): Collision radius of the particle [m].</p>"},{"location":"API/particula/particles/properties/collision_radius_module/#references_5","title":"References","text":"<p>Rogak, S. N., &amp; Flagan, R. C. (1992). Coagulation of aerosol agglomerates in the transition regime. Journal of Colloid and Interface Science, 151(1), 203-224. https://doi.org/10.1016/0021-9797(92)90252-H</p>"},{"location":"API/particula/particles/properties/collision_radius_module/#examples_5","title":"Examples","text":"Example<pre><code>rogak_flagan_1992(1.5, 2.5)\n# 1.83711\n</code></pre>"},{"location":"API/particula/particles/properties/collision_radius_module/#signature_5","title":"Signature","text":"<pre><code>def rogak_flagan_1992(\n    radius_gyration: Union[NDArray[np.float64], float],\n    fractal_dimension: Union[NDArray[np.float64], float],\n) -&gt; Union[NDArray[np.float64], float]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/collision_radius_module/#thajudeen_2012","title":"thajudeen_2012","text":"<p>Show source in collision_radius_module.py:99</p> <p>Collision radius according to Thajudeen et al. (2012).</p>"},{"location":"API/particula/particles/properties/collision_radius_module/#arguments_6","title":"Arguments","text":"<ul> <li><code>fractal_dimension</code> - Fractal dimension of the particle [dimensionless].</li> <li><code>number_of_particles</code> - Number of particles in the aggregate.</li> <li><code>radius_gyration</code> - Radius of gyration of the particle [m].</li> <li><code>radius_monomer</code> - Monomer radius [m].</li> </ul>"},{"location":"API/particula/particles/properties/collision_radius_module/#returns_6","title":"Returns","text":"<ul> <li><code>(float)</code> - Collision radius of the particle [m].</li> </ul>"},{"location":"API/particula/particles/properties/collision_radius_module/#references_6","title":"References","text":"<p>Thajudeen, T., Gopalakrishnan, R., &amp; Hogan, C. J. (2012). The collision rate of nonspherical particles and aggregates for all diffusive knudsen numbers. Aerosol Science and Technology, 46(11). https://doi.org/10.1080/02786826.2012.701353</p>"},{"location":"API/particula/particles/properties/collision_radius_module/#examples_6","title":"Examples","text":"Example<pre><code>thajudeen_2012(2.5, 100, 1.5, 0.1)\n# 2.034\n</code></pre>"},{"location":"API/particula/particles/properties/collision_radius_module/#signature_6","title":"Signature","text":"<pre><code>def thajudeen_2012(\n    fractal_dimension: float,\n    number_of_particles: float,\n    radius_gyration: Union[NDArray[np.float64], float],\n    radius_monomer: float,\n) -&gt; Union[NDArray[np.float64], float]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/collision_radius_module/#zurita_gotor_2002","title":"zurita_gotor_2002","text":"<p>Show source in collision_radius_module.py:69</p> <p>Collision radius according to Zurita-Gotor and Rosner (2002).</p>"},{"location":"API/particula/particles/properties/collision_radius_module/#arguments_7","title":"Arguments","text":"<ul> <li><code>radius_gyration</code> - Radius of gyration of the particle [m].</li> <li><code>fractal_prefactor</code> - Fractal prefactor of the particle     [dimensionless, k0].</li> </ul>"},{"location":"API/particula/particles/properties/collision_radius_module/#returns_7","title":"Returns","text":"<p>(float or NDArray[float]): Collision radius of the particle [m].</p>"},{"location":"API/particula/particles/properties/collision_radius_module/#references_7","title":"References","text":"<p>Zurita-Gotor, M., &amp; Rosner, D. E. (2002). Effective diameters for collisions of fractal-like aggregates: Recommendations for improved aerosol coagulation frequency predictions. Journal of Colloid and Interface Science, 255(1). https://doi.org/10.1006/jcis.2002.8634</p>"},{"location":"API/particula/particles/properties/collision_radius_module/#examples_7","title":"Examples","text":"Example<pre><code>zurita_gotor_2002(1.5, 1.2)\n# 1.577\n</code></pre>"},{"location":"API/particula/particles/properties/collision_radius_module/#signature_7","title":"Signature","text":"<pre><code>def zurita_gotor_2002(\n    radius_gyration: Union[NDArray[np.float64], float],\n    fractal_prefactor: Union[NDArray[np.float64], float],\n) -&gt; Union[NDArray[np.float64], float]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/coulomb_enhancement/","title":"Coulomb Enhancement","text":"<p>Particula Index / Particula / Particles / Properties / Coulomb Enhancement</p> <p>Auto-generated documentation for particula.particles.properties.coulomb_enhancement module.</p>"},{"location":"API/particula/particles/properties/coulomb_enhancement/#continuum","title":"continuum","text":"<p>Show source in coulomb_enhancement.py:89</p> <p>Calculates the Coulombic enhancement continuum limit. For all particle- particle interactions.</p>"},{"location":"API/particula/particles/properties/coulomb_enhancement/#arguments","title":"Arguments","text":"<ul> <li><code>coulomb_potential</code> - The Coulomb potential ratio [dimensionless].</li> </ul>"},{"location":"API/particula/particles/properties/coulomb_enhancement/#returns","title":"Returns","text":"<p>The Coulomb enhancement for the continuum limit [dimensionless].</p>"},{"location":"API/particula/particles/properties/coulomb_enhancement/#references","title":"References","text":"<p>Equation 6b in: Gopalakrishnan, R., &amp; Hogan, C. J. (2012). Coulomb-influenced collisions in aerosols and dusty plasmas. Physical Review E - Statistical, Nonlinear, and Soft Matter Physics, 85(2). (https://doi.org/10.1103/PhysRevE.85.026410)</p>"},{"location":"API/particula/particles/properties/coulomb_enhancement/#signature","title":"Signature","text":"<pre><code>def continuum(\n    coulomb_potential: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/coulomb_enhancement/#kinetic","title":"kinetic","text":"<p>Show source in coulomb_enhancement.py:61</p> <p>Calculates the Coulombic enhancement kinetic limit. For all particle- particle interactions.</p>"},{"location":"API/particula/particles/properties/coulomb_enhancement/#arguments_1","title":"Arguments","text":"<ul> <li><code>coulomb_potential</code> - The Coulomb potential ratio [dimensionless].</li> </ul>"},{"location":"API/particula/particles/properties/coulomb_enhancement/#returns_1","title":"Returns","text":"<p>The Coulomb enhancement for the kinetic limit [dimensionless].</p>"},{"location":"API/particula/particles/properties/coulomb_enhancement/#references_1","title":"References","text":"<p>Equation 6d and 6e in, Gopalakrishnan, R., &amp; Hogan, C. J. (2012). Coulomb-influenced collisions in aerosols and dusty plasmas. Physical Review E - Statistical, Nonlinear, and Soft Matter Physics, 85(2). (https://doi.org/10.1103/PhysRevE.85.026410)</p>"},{"location":"API/particula/particles/properties/coulomb_enhancement/#signature_1","title":"Signature","text":"<pre><code>def kinetic(\n    coulomb_potential: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/coulomb_enhancement/#ratio","title":"ratio","text":"<p>Show source in coulomb_enhancement.py:22</p> <p>Calculates the Coulomb potential ratio, phi_E. For all particle- particle interactions.</p>"},{"location":"API/particula/particles/properties/coulomb_enhancement/#arguments_2","title":"Arguments","text":"<ul> <li><code>radius</code> - The radius of the particle [m].</li> <li><code>charge</code> - The number of charges on the particle [dimensionless].</li> <li><code>temperature</code> - The temperature of the system [K].</li> </ul>"},{"location":"API/particula/particles/properties/coulomb_enhancement/#returns_2","title":"Returns","text":"<p>The Coulomb potential ratio [dimensionless].</p>"},{"location":"API/particula/particles/properties/coulomb_enhancement/#references_2","title":"References","text":"<ul> <li><code>Equation</code> 7 - Gopalakrishnan, R., &amp; Hogan, C. J. (2012).     Coulomb-influenced collisions in aerosols and dusty plasmas.     Physical Review E - Statistical, Nonlinear, and Soft Matter     Physics, 85(2). (https://doi.org/10.1103/PhysRevE.85.026410)</li> </ul>"},{"location":"API/particula/particles/properties/coulomb_enhancement/#signature_2","title":"Signature","text":"<pre><code>def ratio(\n    radius: Union[float, NDArray[np.float64]],\n    charge: Union[int, NDArray[np.float64]] = 0,\n    temperature: float = 298.15,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/diffusion_coefficient/","title":"Diffusion Coefficient","text":"<p>Particula Index / Particula / Particles / Properties / Diffusion Coefficient</p> <p>Auto-generated documentation for particula.particles.properties.diffusion_coefficient module.</p>"},{"location":"API/particula/particles/properties/diffusion_coefficient/#particle_diffusion_coefficient","title":"particle_diffusion_coefficient","text":"<p>Show source in diffusion_coefficient.py:21</p> <p>Calculate the diffusion coefficient of a particle.</p>"},{"location":"API/particula/particles/properties/diffusion_coefficient/#arguments","title":"Arguments","text":"<ul> <li><code>temperature</code> - The temperature at which the particle is     diffusing, in Kelvin. Defaults to 298.15 K.</li> <li><code>boltzmann_constant</code> - The Boltzmann constant. Defaults to the     standard value of 1.380649 x 10^-23 J/K.</li> <li><code>aerodynamic_mobility</code> - The aerodynamic mobility of     the particle [m^2/s].</li> </ul>"},{"location":"API/particula/particles/properties/diffusion_coefficient/#returns","title":"Returns","text":"<p>The diffusion coefficient of the particle [m^2/s].</p>"},{"location":"API/particula/particles/properties/diffusion_coefficient/#signature","title":"Signature","text":"<pre><code>def particle_diffusion_coefficient(\n    temperature: Union[float, NDArray[np.float64]],\n    aerodynamic_mobility: Union[float, NDArray[np.float64]],\n    boltzmann_constant: float = BOLTZMANN_CONSTANT,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/diffusion_coefficient/#see-also","title":"See also","text":"<ul> <li>BOLTZMANN_CONSTANT</li> </ul>"},{"location":"API/particula/particles/properties/diffusion_coefficient/#particle_diffusion_coefficient_via_system_state","title":"particle_diffusion_coefficient_via_system_state","text":"<p>Show source in diffusion_coefficient.py:43</p> <p>Calculate the diffusion coefficient of a particle.</p>"},{"location":"API/particula/particles/properties/diffusion_coefficient/#arguments_1","title":"Arguments","text":"<ul> <li><code>temperature</code> - The temperature of the system in Kelvin (K).</li> <li><code>particle_radius</code> - The radius of the particle in meters (m).</li> <li><code>pressure</code> - The pressure of the system in Pascals (Pa).</li> </ul>"},{"location":"API/particula/particles/properties/diffusion_coefficient/#returns_1","title":"Returns","text":"<p>The diffusion coefficient of the particle in square meters per second (m\u00b2/s).</p>"},{"location":"API/particula/particles/properties/diffusion_coefficient/#signature_1","title":"Signature","text":"<pre><code>def particle_diffusion_coefficient_via_system_state(\n    particle_radius: Union[float, NDArray[np.float64]],\n    temperature: float,\n    pressure: float,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/diffusive_knudsen_module/","title":"Diffusive Knudsen Module","text":"<p>Particula Index / Particula / Particles / Properties / Diffusive Knudsen Module</p> <p>Auto-generated documentation for particula.particles.properties.diffusive_knudsen_module module.</p>"},{"location":"API/particula/particles/properties/diffusive_knudsen_module/#diffusive_knudsen_number","title":"diffusive_knudsen_number","text":"<p>Show source in diffusive_knudsen_module.py:13</p> <p>Diffusive Knudsen number. The diffusive Knudsen number is different from Knudsen number. Ratio of: mean persistence of one particle to the effective length scale of particle--particle Coulombic interaction</p>"},{"location":"API/particula/particles/properties/diffusive_knudsen_module/#arguments","title":"Arguments","text":"<ul> <li><code>-</code> radius - The radius of the particle [m].</li> <li><code>-</code> mass_particle - The mass of the particle [kg].</li> <li><code>-</code> friction_factor - The friction factor of the particle [dimensionless].</li> <li><code>-</code> coulomb_potential_ratio - The Coulomb potential ratio, zero if  no charges [dimensionless].</li> <li><code>-</code> temperature - The temperature of the system [K].</li> </ul>"},{"location":"API/particula/particles/properties/diffusive_knudsen_module/#returns","title":"Returns","text":"<p>The diffusive Knudsen number [dimensionless], as a square matrix, of all particle-particle interactions.</p>"},{"location":"API/particula/particles/properties/diffusive_knudsen_module/#references","title":"References","text":"<ul> <li>Equation 5 in, with charges: Chahl, H. S., &amp; Gopalakrishnan, R. (2019). High potential, near free molecular regime Coulombic collisions in aerosols and dusty plasmas. Aerosol Science and Technology, 53(8), 933-957. https://doi.org/10.1080/02786826.2019.1614522</li> <li>Equation 3b in, no charges: Gopalakrishnan, R., &amp; Hogan, C. J. (2012). Coulomb-influenced collisions in aerosols and dusty plasmas. Physical Review E - Statistical, Nonlinear, and Soft Matter Physics, 85(2). https://doi.org/10.1103/PhysRevE.85.026410</li> </ul>"},{"location":"API/particula/particles/properties/diffusive_knudsen_module/#signature","title":"Signature","text":"<pre><code>def diffusive_knudsen_number(\n    radius: Union[float, NDArray[np.float64]],\n    mass_particle: Union[float, NDArray[np.float64]],\n    friction_factor: Union[float, NDArray[np.float64]],\n    coulomb_potential_ratio: Union[float, NDArray[np.float64]] = 0.0,\n    temperature: float = 298.15,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/friction_factor_module/","title":"Friction Factor Module","text":"<p>Particula Index / Particula / Particles / Properties / Friction Factor Module</p> <p>Auto-generated documentation for particula.particles.properties.friction_factor_module module.</p>"},{"location":"API/particula/particles/properties/friction_factor_module/#friction_factor","title":"friction_factor","text":"<p>Show source in friction_factor_module.py:15</p> <p>Returns a particle's friction factor. Property of the particle's size and surrounding medium. Multiplying the friction factor by the fluid velocity yields the drag force on the particle.</p>"},{"location":"API/particula/particles/properties/friction_factor_module/#arguments","title":"Arguments","text":"<ul> <li>radius : The radius of the particle [m].</li> <li>dynamic_viscosity : The dynamic viscosity of the fluid [Pa s].</li> <li>slip_correction : The slip correction factor [unitless].</li> </ul>"},{"location":"API/particula/particles/properties/friction_factor_module/#returns","title":"Returns","text":"<p>The friction factor of the particle [N s/m].</p>"},{"location":"API/particula/particles/properties/friction_factor_module/#references","title":"References","text":"<p>It is best thought of as an inverse of mobility or the ratio between thermal energy and diffusion coefficient. The modified Stoke's diffusion coefficient is defined as kT / (6 * np.pi * dyn_vis_air * radius / slip_corr) and thus the friction factor can be defined as (6 * np.pi * dyn_vis_air * radius / slip_corr).</p> <p>In the continuum limit (Kn -&gt; 0; Cc -&gt; 1): 6 * np.pi * dyn_vis_air * radius</p> <p>In the kinetic limit (Kn -&gt; inf): 8.39 * (dyn_vis_air/mfp_air) * const * radius**2</p> <p>Zhang, C., Thajudeen, T., Larriba, C., Schwartzentruber, T. E., &amp; Hogan, C. J. (2012). Determination of the Scalar Friction Factor for Nonspherical Particles and Aggregates Across the Entire Knudsen Number Range by Direct Simulation Monte Carlo (DSMC). Aerosol Science and Technology, 46(10), 1065-1078. https://doi.org/10.1080/02786826.2012.690543</p>"},{"location":"API/particula/particles/properties/friction_factor_module/#signature","title":"Signature","text":"<pre><code>def friction_factor(\n    radius: Union[float, NDArray[np.float64]],\n    dynamic_viscosity: float,\n    slip_correction: Union[float, NDArray[np.float64]],\n): ...\n</code></pre>"},{"location":"API/particula/particles/properties/kelvin_effect_module/","title":"Kelvin Effect Module","text":"<p>Particula Index / Particula / Particles / Properties / Kelvin Effect Module</p> <p>Auto-generated documentation for particula.particles.properties.kelvin_effect_module module.</p>"},{"location":"API/particula/particles/properties/kelvin_effect_module/#kelvin_radius","title":"kelvin_radius","text":"<p>Show source in kelvin_effect_module.py:10</p> <p>Calculate the Kelvin radius which determines the curvature effect on vapor pressure.</p>"},{"location":"API/particula/particles/properties/kelvin_effect_module/#arguments","title":"Arguments","text":"<ul> <li>surface_tension (float or NDArray[float]): Surface tension of the mixture [N/m].</li> <li>molar_mass (float or NDArray[float]): Molar mass of the species [kg/mol].</li> <li>mass_concentration (float or NDArray[float]): Concentration of the species [kg/m^3].</li> <li>temperature (float): Temperature of the system [K].</li> </ul>"},{"location":"API/particula/particles/properties/kelvin_effect_module/#returns","title":"Returns","text":"<ul> <li>float or NDArray[float]: Kelvin radius [m].</li> </ul>"},{"location":"API/particula/particles/properties/kelvin_effect_module/#references","title":"References","text":"<ul> <li>Based on Neil Donahue's approach to the Kelvin equation: r = 2 * surface_tension * molar_mass / (R * T * density)</li> <li><code>See</code> more - https://en.wikipedia.org/wiki/Kelvin_equation</li> </ul>"},{"location":"API/particula/particles/properties/kelvin_effect_module/#signature","title":"Signature","text":"<pre><code>def kelvin_radius(\n    effective_surface_tension: Union[float, NDArray[np.float64]],\n    effective_density: Union[float, NDArray[np.float64]],\n    molar_mass: Union[float, NDArray[np.float64]],\n    temperature: float,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/kelvin_effect_module/#kelvin_term","title":"kelvin_term","text":"<p>Show source in kelvin_effect_module.py:45</p> <p>Calculate the Kelvin term, which quantifies the effect of particle curvature on vapor pressure.</p>"},{"location":"API/particula/particles/properties/kelvin_effect_module/#arguments_1","title":"Arguments","text":"<ul> <li>radius (float or NDArray[float]): Radius of the particle [m].</li> <li>kelvin_radius (float or NDArray[float]): Kelvin radius [m].</li> </ul>"},{"location":"API/particula/particles/properties/kelvin_effect_module/#returns_1","title":"Returns","text":"<ul> <li>float or NDArray[float]: The exponential factor adjusting vapor pressure due to curvature.</li> </ul>"},{"location":"API/particula/particles/properties/kelvin_effect_module/#references_1","title":"References","text":"<p>Based on Neil Donahue's collection of terms in the Kelvin equation: exp(kelvin_radius / particle_radius) - <code>See</code> more - https://en.wikipedia.org/wiki/Kelvin_equation</p>"},{"location":"API/particula/particles/properties/kelvin_effect_module/#signature_1","title":"Signature","text":"<pre><code>def kelvin_term(\n    radius: Union[float, NDArray[np.float64]],\n    kelvin_radius_value: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/knudsen_number_module/","title":"Knudsen Number Module","text":"<p>Particula Index / Particula / Particles / Properties / Knudsen Number Module</p> <p>Auto-generated documentation for particula.particles.properties.knudsen_number_module module.</p>"},{"location":"API/particula/particles/properties/knudsen_number_module/#calculate_knudsen_number","title":"calculate_knudsen_number","text":"<p>Show source in knudsen_number_module.py:12</p> <p>Calculate the Knudsen number using the mean free path of the gas and the radius of the particle. The Knudsen number is a dimensionless number that indicates the regime of gas flow relative to the size of particles.</p>"},{"location":"API/particula/particles/properties/knudsen_number_module/#arguments","title":"Arguments","text":"<ul> <li>mean_free_path (Union[float, NDArray[np.float64]]): The mean free path of the gas molecules [meters (m)].</li> <li>particle_radius (Union[float, NDArray[np.float64]]): The radius of the particle [meters (m)].</li> </ul>"},{"location":"API/particula/particles/properties/knudsen_number_module/#returns","title":"Returns","text":"<ul> <li>Union[float, NDArray[np.float64]]: The Knudsen number, which is the ratio of the mean free path to the particle radius.</li> </ul>"},{"location":"API/particula/particles/properties/knudsen_number_module/#references","title":"References","text":"<ul> <li>For more information at https://en.wikipedia.org/wiki/Knudsen_number</li> </ul>"},{"location":"API/particula/particles/properties/knudsen_number_module/#signature","title":"Signature","text":"<pre><code>def calculate_knudsen_number(\n    mean_free_path: Union[float, NDArray[np.float64]],\n    particle_radius: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/lognormal_size_distribution/","title":"Lognormal Size Distribution","text":"<p>Particula Index / Particula / Particles / Properties / Lognormal Size Distribution</p> <p>Auto-generated documentation for particula.particles.properties.lognormal_size_distribution module.</p>"},{"location":"API/particula/particles/properties/lognormal_size_distribution/#lognormal_pdf_distribution","title":"lognormal_pdf_distribution","text":"<p>Show source in lognormal_size_distribution.py:12</p> <p>Probability Density Function for the lognormal distribution of particles for varying modes, geometric standard deviations, and numbers of particles, across a range of x_values.</p>"},{"location":"API/particula/particles/properties/lognormal_size_distribution/#arguments","title":"Arguments","text":"<ul> <li><code>x_values</code> - The size interval of the distribution.</li> <li><code>mode</code> - Scales corresponding to the mode in lognormal for different     modes.</li> <li><code>geometric_standard_deviation</code> - Geometric standard deviations of the     distribution for different modes.</li> <li><code>number_of_particles</code> - Number of particles for each mode.</li> </ul>"},{"location":"API/particula/particles/properties/lognormal_size_distribution/#returns","title":"Returns","text":"<p>The normalized lognormal distribution of the particles, summed across all modes.</p>"},{"location":"API/particula/particles/properties/lognormal_size_distribution/#references","title":"References","text":"<ul> <li>Log-normal Distribution Wikipedia</li> <li>Probability Density Function Wikipedia</li> </ul>"},{"location":"API/particula/particles/properties/lognormal_size_distribution/#signature","title":"Signature","text":"<pre><code>def lognormal_pdf_distribution(\n    x_values: NDArray[np.float64],\n    mode: NDArray[np.float64],\n    geometric_standard_deviation: NDArray[np.float64],\n    number_of_particles: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/lognormal_size_distribution/#lognormal_pmf_distribution","title":"lognormal_pmf_distribution","text":"<p>Show source in lognormal_size_distribution.py:67</p> <p>Probability Mass function for lognormal distribution of particles for varying modes, geometric standard deviations, and numbers of particles, across a range of x_values.</p>"},{"location":"API/particula/particles/properties/lognormal_size_distribution/#arguments_1","title":"Arguments","text":"<ul> <li><code>x_values</code> - The size interval of the distribution.</li> <li><code>mode</code> - Scales corresponding to the mode in lognormal for different     modes.</li> <li><code>geometric_standard_deviation</code> - Geometric standard deviations of the     distribution for different modes.</li> <li><code>number_of_particles</code> - Number of particles for each mode.</li> </ul>"},{"location":"API/particula/particles/properties/lognormal_size_distribution/#returns_1","title":"Returns","text":"<p>The normalized lognormal distribution of the particles, summed across all modes.</p>"},{"location":"API/particula/particles/properties/lognormal_size_distribution/#references_1","title":"References","text":"<ul> <li>Log-normal Distribution Wikipedia</li> <li>Probability Mass Function Wikipedia</li> </ul>"},{"location":"API/particula/particles/properties/lognormal_size_distribution/#signature_1","title":"Signature","text":"<pre><code>def lognormal_pmf_distribution(\n    x_values: NDArray[np.float64],\n    mode: NDArray[np.float64],\n    geometric_standard_deviation: NDArray[np.float64],\n    number_of_particles: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/lognormal_size_distribution/#lognormal_sample_distribution","title":"lognormal_sample_distribution","text":"<p>Show source in lognormal_size_distribution.py:121</p> <p>Sample a Probability Density Function for the lognormal distribution.</p> <p>Samples a set of samples (particle) to represent the lognormal distribution for varying modes, geometric standard deviations, and numbers of particles, across a range of x_values.</p>"},{"location":"API/particula/particles/properties/lognormal_size_distribution/#arguments_2","title":"Arguments","text":"<ul> <li><code>mode</code> - Scales corresponding to the mode in lognormal for different     modes.</li> <li><code>geometric_standard_deviation</code> - Geometric standard deviations of the     distribution for different modes.</li> <li><code>number_of_particles</code> - Number of particles for each mode.</li> <li><code>number_of_samples</code> - Number of samples to generate.</li> </ul>"},{"location":"API/particula/particles/properties/lognormal_size_distribution/#returns_2","title":"Returns","text":"<p>The normalized lognormal distribution of the particles, summed across all modes.</p>"},{"location":"API/particula/particles/properties/lognormal_size_distribution/#references_2","title":"References","text":"<ul> <li>Log-normal Distribution Wikipedia</li> <li>Probability Density Function Wikipedia</li> </ul>"},{"location":"API/particula/particles/properties/lognormal_size_distribution/#signature_2","title":"Signature","text":"<pre><code>def lognormal_sample_distribution(\n    mode: NDArray[np.float64],\n    geometric_standard_deviation: NDArray[np.float64],\n    number_of_particles: NDArray[np.float64],\n    number_of_samples: int,\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/mean_thermal_speed_module/","title":"Mean Thermal Speed Module","text":"<p>Particula Index / Particula / Particles / Properties / Mean Thermal Speed Module</p> <p>Auto-generated documentation for particula.particles.properties.mean_thermal_speed_module module.</p>"},{"location":"API/particula/particles/properties/mean_thermal_speed_module/#mean_thermal_speed","title":"mean_thermal_speed","text":"<p>Show source in mean_thermal_speed_module.py:11</p> <p>Returns the particles mean thermal speed. Due to the the impact of air molecules on the particles, the particles will have a mean thermal speed.</p>"},{"location":"API/particula/particles/properties/mean_thermal_speed_module/#args","title":"Args","text":"<p>mass : The per particle mass of the particles [kg]. temperature : The temperature of the air [K].</p>"},{"location":"API/particula/particles/properties/mean_thermal_speed_module/#returns","title":"Returns","text":"<p>The mean thermal speed of the particles [m/s].</p>"},{"location":"API/particula/particles/properties/mean_thermal_speed_module/#references","title":"References","text":"<p>Seinfeld, J. H., &amp; Pandis, S. N. (2016). Atmospheric chemistry and physics, Section 9.5.3 Mean Free Path of an Aerosol Particle Equation 9.87.</p>"},{"location":"API/particula/particles/properties/mean_thermal_speed_module/#signature","title":"Signature","text":"<pre><code>def mean_thermal_speed(\n    mass: Union[float, NDArray[np.float64]],\n    temperature: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/partial_pressure_module/","title":"Partial Pressure Module","text":"<p>Particula Index / Particula / Particles / Properties / Partial Pressure Module</p> <p>Auto-generated documentation for particula.particles.properties.partial_pressure_module module.</p>"},{"location":"API/particula/particles/properties/partial_pressure_module/#partial_pressure_delta","title":"partial_pressure_delta","text":"<p>Show source in partial_pressure_module.py:9</p> <p>Calculate the difference in partial pressure of a species between the gas phase and the particle phase, which is used in the calculation of the rate of change of mass of an aerosol particle.</p>"},{"location":"API/particula/particles/properties/partial_pressure_module/#arguments","title":"Arguments","text":"<ul> <li><code>partial_pressure_gas</code> - The partial pressure of the species in the     gas phase.</li> <li><code>partial_pressure_particle</code> - The partial pressure of the species in     the particle phase.</li> <li><code>kelvin_term</code> - Kelvin effect to account for the curvature of     the particle.</li> </ul>"},{"location":"API/particula/particles/properties/partial_pressure_module/#returns","title":"Returns","text":"<p>The difference in partial pressure between the gas phase and the     particle phase.</p>"},{"location":"API/particula/particles/properties/partial_pressure_module/#signature","title":"Signature","text":"<pre><code>def partial_pressure_delta(\n    partial_pressure_gas: Union[float, NDArray[np.float64]],\n    partial_pressure_particle: Union[float, NDArray[np.float64]],\n    kelvin_term: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/settling_velocity/","title":"Settling Velocity","text":"<p>Particula Index / Particula / Particles / Properties / Settling Velocity</p> <p>Auto-generated documentation for particula.particles.properties.settling_velocity module.</p>"},{"location":"API/particula/particles/properties/settling_velocity/#particle_settling_velocity","title":"particle_settling_velocity","text":"<p>Show source in settling_velocity.py:22</p> <p>Calculate the settling velocity of a particle in a fluid.</p>"},{"location":"API/particula/particles/properties/settling_velocity/#arguments","title":"Arguments","text":"<ul> <li><code>particle_radius</code> - The radius of the particle [m].</li> <li><code>particle_density</code> - The density of the particle [kg/m\u00b3].</li> <li><code>slip_correction_factor</code> - The slip correction factor to     account for non-continuum effects [dimensionless].</li> <li><code>gravitational_acceleration</code> - The gravitational acceleration.     Defaults to standard gravity [9.80665 m/s\u00b2].</li> <li><code>dynamic_viscosity</code> - The dynamic viscosity of the fluid [Pa*s].</li> </ul>"},{"location":"API/particula/particles/properties/settling_velocity/#returns","title":"Returns","text":"<p>The settling velocity of the particle in the fluid [m/s].</p>"},{"location":"API/particula/particles/properties/settling_velocity/#signature","title":"Signature","text":"<pre><code>def particle_settling_velocity(\n    particle_radius: Union[float, NDArray[np.float64]],\n    particle_density: Union[float, NDArray[np.float64]],\n    slip_correction_factor: Union[float, NDArray[np.float64]],\n    dynamic_viscosity: float,\n    gravitational_acceleration: float = STANDARD_GRAVITY,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/settling_velocity/#see-also","title":"See also","text":"<ul> <li>STANDARD_GRAVITY</li> </ul>"},{"location":"API/particula/particles/properties/settling_velocity/#particle_settling_velocity_via_system_state","title":"particle_settling_velocity_via_system_state","text":"<p>Show source in settling_velocity.py:58</p> <p>Calculate the settling velocity of a particle.</p>"},{"location":"API/particula/particles/properties/settling_velocity/#arguments_1","title":"Arguments","text":"<ul> <li><code>particle_radius</code> - The radius of the particle in meters (m).</li> <li><code>particle_density</code> - The density of the particle (kg/m\u00b3).</li> <li><code>temperature</code> - The temperature of the system in Kelvin (K).</li> <li><code>pressure</code> - The pressure of the system in Pascals (Pa).</li> </ul>"},{"location":"API/particula/particles/properties/settling_velocity/#returns_1","title":"Returns","text":"<p>The settling velocity of the particle in meters per second (m/s).</p>"},{"location":"API/particula/particles/properties/settling_velocity/#signature_1","title":"Signature","text":"<pre><code>def particle_settling_velocity_via_system_state(\n    particle_radius: Union[float, NDArray[np.float64]],\n    particle_density: Union[float, NDArray[np.float64]],\n    temperature: float,\n    pressure: float,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/slip_correction_module/","title":"Slip Correction Module","text":"<p>Particula Index / Particula / Particles / Properties / Slip Correction Module</p> <p>Auto-generated documentation for particula.particles.properties.slip_correction_module module.</p>"},{"location":"API/particula/particles/properties/slip_correction_module/#cunningham_slip_correction","title":"cunningham_slip_correction","text":"<p>Show source in slip_correction_module.py:9</p> <p>Calculate the Cunningham slip correction factor. Accounts for non-continuum effects on small particles.</p>"},{"location":"API/particula/particles/properties/slip_correction_module/#arguments","title":"Arguments","text":"<ul> <li><code>-</code> knudsen_number - Knudsen number [unitless].</li> </ul>"},{"location":"API/particula/particles/properties/slip_correction_module/#returns","title":"Returns","text":"<ul> <li>Slip correction factor [unitless].</li> </ul>"},{"location":"API/particula/particles/properties/slip_correction_module/#reference","title":"Reference:","text":"<ul> <li>Dimensionless quantity accounting for non-continuum effects on small particles. It is a deviation from Stokes' Law. Stokes assumes a no-slip condition that is not correct at high Knudsen numbers. The slip correction factor is used to calculate the friction factor. Thus, the slip correction factor is about unity (1) for larger particles (Kn -&gt; 0). Its behavior on the other end of the spectrum (smaller particles; Kn -&gt; inf) is more nuanced, though it tends to scale linearly on a log-log scale, log Cc vs log Kn.</li> <li>https://en.wikipedia.org/wiki/Cunningham_correction_factor</li> </ul>"},{"location":"API/particula/particles/properties/slip_correction_module/#signature","title":"Signature","text":"<pre><code>def cunningham_slip_correction(\n    knudsen_number: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/special_functions/","title":"Special Functions","text":"<p>Particula Index / Particula / Particles / Properties / Special Functions</p> <p>Auto-generated documentation for particula.particles.properties.special_functions module.</p>"},{"location":"API/particula/particles/properties/special_functions/#debye_function","title":"debye_function","text":"<p>Show source in special_functions.py:11</p> <p>Calculate the Debye function for a given variable.</p> <p>The generalized Debye function where <code>x</code> is a dimensionless variable and <code>n</code> is an integer exponent. By default, <code>n</code> is 1, which corresponds to the most common form of the Debye function.</p>"},{"location":"API/particula/particles/properties/special_functions/#arguments","title":"Arguments","text":"<ul> <li><code>variable</code> - The upper limit of integration. Can be a float or a     numpy array. If a numpy array is provided, the function will     return an array of Debye function values.</li> <li><code>integration_points</code> - The number of points to use in the numerical     integration. Default is 1000.</li> <li><code>n</code> - The exponent in the Debye function. Default is 1.</li> </ul>"},{"location":"API/particula/particles/properties/special_functions/#returns","title":"Returns","text":"<p>The value of the Debye function evaluation for the given input. If the input is a float, a float is returned. If the input is an array, an array of the same shape is returned.</p>"},{"location":"API/particula/particles/properties/special_functions/#examples","title":"Examples","text":"Dubye function with n=1 for a single float value<pre><code>out = debye_function(1.0)\nprint(out)\n# Output: 0.7765038970390566\n</code></pre> Dubye function with n=2 for a single float value<pre><code>out = debye_function(1.0, n=2)\nprint(out)\n# Output: 0.6007582206816492\n</code></pre> Dubye function with n=1 for a numpy array<pre><code>out = debye_function(np.array([1.0, 2.0, 3.0]))\nprint(out)\n# Output: [0.84140566 0.42278434 0.28784241]\n</code></pre>"},{"location":"API/particula/particles/properties/special_functions/#references","title":"References","text":"<ul> <li>https://en.wikipedia.org/wiki/Debye_function</li> <li>https://mathworld.wolfram.com/DebyeFunctions.html</li> </ul>"},{"location":"API/particula/particles/properties/special_functions/#signature","title":"Signature","text":"<pre><code>def debye_function(\n    variable: Union[float, NDArray[np.float64]],\n    integration_points: int = 1000,\n    n: int = 1,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/particles/properties/vapor_correction_module/","title":"Vapor Correction Module","text":"<p>Particula Index / Particula / Particles / Properties / Vapor Correction Module</p> <p>Auto-generated documentation for particula.particles.properties.vapor_correction_module module.</p>"},{"location":"API/particula/particles/properties/vapor_correction_module/#vapor_transition_correction","title":"vapor_transition_correction","text":"<p>Show source in vapor_correction_module.py:11</p> <p>Calculate the transition correction factor, f(Kn, alpha), for a given Knudsen number and mass accommodation coefficient. This function is used to account for the intermediate regime between continuum and free molecular flow. This is the Suchs and Futugin transition function.</p>"},{"location":"API/particula/particles/properties/vapor_correction_module/#arguments","title":"Arguments","text":"<ul> <li>knudsen_number (Union[float, NDArray[np.float64]]): The Knudsen number, which quantifies the relative importance of the mean free path of gas molecules to the size of the particle.</li> <li>mass_accommodation (Union[float, NDArray[np.float64]]): The mass accommodation coefficient, representing the probability of a gas molecule sticking to the particle upon collision.</li> </ul>"},{"location":"API/particula/particles/properties/vapor_correction_module/#returns","title":"Returns","text":"<ul> <li>Union[float, NDArray[np.float64]]: The transition correction value calculated based on the specified inputs.</li> </ul>"},{"location":"API/particula/particles/properties/vapor_correction_module/#references","title":"References","text":"<ul> <li>Seinfeld and Pandis, \"Atmospheric Chemistry and Physics\", Chapter 12, equation 12.43.</li> <li><code>Note</code> - There are various formulations for this correction, so further extensions of this function might be necessary depending on specific requirements.</li> <li>Original reference: FUCHS, N. A., &amp; SUTUGIN, A. G. (1971). HIGH-DISPERSED AEROSOLS. In Topics in Current Aerosol Research (p. 1). Elsevier. https://doi.org/10.1016/B978-0-08-016674-2.50006-6</li> </ul>"},{"location":"API/particula/particles/properties/vapor_correction_module/#signature","title":"Signature","text":"<pre><code>def vapor_transition_correction(\n    knudsen_number: Union[float, NDArray[np.float64]],\n    mass_accommodation: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/util/","title":"Util","text":"<p>Particula Index / Particula / Util</p> <p>Auto-generated documentation for particula.util module.</p>"},{"location":"API/particula/util/#modules","title":"Modules","text":"<ul> <li>Colors</li> <li>Constants</li> <li>Convert</li> <li>Converting</li> <li>Lf2013 Coagulation</li> <li>Machine Limit</li> <li>Reduced Quantity</li> <li>Size Distribution Convert</li> <li>Surface Tension</li> <li>Validate Inputs</li> </ul>"},{"location":"API/particula/util/colors/","title":"Colors","text":"<p>Particula Index / Particula / Util / Colors</p> <p>Auto-generated documentation for particula.util.colors module.</p>"},{"location":"API/particula/util/constants/","title":"Constants","text":"<p>Particula Index / Particula / Util / Constants</p> <p>Auto-generated documentation for particula.util.constants module.</p>"},{"location":"API/particula/util/constants/#attributes","title":"Attributes","text":"<ul> <li> <p><code>GAS_CONSTANT</code> - Gas constant in J mol^-1 K^-1 = m^2 kg mol^-1 s^-2 K^-1   J = kg m^2 s^-2: BOLTZMANN_CONSTANT * AVOGADRO_NUMBER</p> </li> <li> <p><code>RELATIVE_PERMITTIVITY_AIR_ROOM</code> - Relative permittivity of air at approx.   296.15 K and 101325 Pa and 40% RH   See https://www.osti.gov/servlets/purl/1504063   Previously known as the \"dielectric constant\"   Often denoted as epsilon: 1.000530569</p> </li> <li> <p><code>RELATIVE_PERMITTIVITY_AIR_STP</code> - At STP (273.15 K, 1 atm):   see: https://en.wikipedia.org/wiki/Relative_permittivity: 1.00058986</p> </li> <li> <p><code>RELATIVE_PERMITTIVITY_AIR</code> - select one of the two:: RELATIVE_PERMITTIVITY_AIR_ROOM</p> </li> <li> <p><code>VACUUM_PERMITTIVITY</code> - Permittivity of free space in F/m   Also known as the electric constant, permittivity of free space   Often denoted by epsilon_0: scipy.constants.epsilon_0</p> </li> <li> <p><code>REF_VISCOSITY_AIR_STP</code> - These values are used to calculate the dynamic viscosity of air   Here, REF temperature and viscosity are at STP:   Standard temperature and pressure (273.15 K and 101325 Pa): 1.716e-05</p> </li> </ul>"},{"location":"API/particula/util/convert/","title":"Convert","text":"<p>Particula Index / Particula / Util / Convert</p> <p>Auto-generated documentation for particula.util.convert module.</p>"},{"location":"API/particula/util/convert/#coerce_type","title":"coerce_type","text":"<p>Show source in convert.py:9</p> <p>Coerces data to dtype if it is not already of that type.</p>"},{"location":"API/particula/util/convert/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; coerce_type(1, float)\n1.0\n&gt;&gt;&gt; coerce_type([1, 2, 3], np.ndarray)\narray([1, 2, 3])\n</code></pre>"},{"location":"API/particula/util/convert/#arguments","title":"Arguments","text":"<ul> <li><code>data</code> - The data to be coerced.</li> <li><code>dtype</code> - The desired data type.</li> </ul>"},{"location":"API/particula/util/convert/#returns","title":"Returns","text":"<p>The coerced data.</p>"},{"location":"API/particula/util/convert/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code> - If the data cannot be coerced to the desired type.</li> </ul>"},{"location":"API/particula/util/convert/#signature","title":"Signature","text":"<pre><code>def coerce_type(data, dtype): ...\n</code></pre>"},{"location":"API/particula/util/convert/#convert_sizer_dn","title":"convert_sizer_dn","text":"<p>Show source in convert.py:440</p> <p>Converts the sizer data from dn/dlogdp to d_num.</p> <p>The bin width is defined as the  difference between the upper and lower diameter limits of each bin. This function calculates the bin widths based on the input diameter array. Assumes a log10 scale for dp edges.</p>"},{"location":"API/particula/util/convert/#arguments_1","title":"Arguments","text":"<ul> <li><code>diameter</code> np.ndarray - Array of particle diameters.</li> <li><code>dn_dlogdp</code> np.ndarray - Array of number concentration of particles per unit logarithmic diameter.</li> <li><code>inverse</code> bool - If True, converts from d_num to dn/dlogdp.</li> </ul>"},{"location":"API/particula/util/convert/#returns_1","title":"Returns","text":"<ul> <li><code>np.ndarray</code> - Array of number concentration of particles per unit diameter.</li> </ul>"},{"location":"API/particula/util/convert/#references","title":"References","text":"<ul> <li><code>Eq</code> - dN/dlogD_p = dN/( log(D_{p-upper}) - log(D_{p-lower}) ) https://tsi.com/getmedia/1621329b-f410-4dce-992b-e21e1584481a/ PR-001-RevA_Aerosol-Statistics-AppNote?ext=.pdf</li> </ul>"},{"location":"API/particula/util/convert/#signature_1","title":"Signature","text":"<pre><code>def convert_sizer_dn(\n    diameter: np.ndarray, dn_dlogdp: np.ndarray, inverse: bool = False\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/util/convert/#data_shape_check","title":"data_shape_check","text":"<p>Show source in convert.py:543</p> <p>Check the shape of the input data and header list, and reshape the data if necessary. The data array can be 1D or 2D. If the data array is 2D, the time array must match the last dimensions of the data array. If the data array is 1D, the header list must be a single entry.</p>"},{"location":"API/particula/util/convert/#arguments_2","title":"Arguments","text":"<ul> <li><code>time</code> np.ndarray - 1D array of time values.</li> <li><code>data</code> np.ndarray - 1D or 2D array of data values.</li> <li><code>header</code> list - List of header values.</li> </ul>"},{"location":"API/particula/util/convert/#returns_2","title":"Returns","text":"<p>Reshaped data array.</p>"},{"location":"API/particula/util/convert/#raises_1","title":"Raises","text":"<ul> <li><code>ValueError</code> - If the length of the header list does not match the first dimension of the data array.</li> </ul>"},{"location":"API/particula/util/convert/#signature_2","title":"Signature","text":"<pre><code>def data_shape_check(time: np.ndarray, data: np.ndarray, header: list) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/util/convert/#distribution_convert_pdf_pms","title":"distribution_convert_pdf_pms","text":"<p>Show source in convert.py:603</p> <p>Convert between a probability density function (PDF) and a probability mass spectrum (PMS) based on the specified direction.</p>"},{"location":"API/particula/util/convert/#arguments_3","title":"Arguments","text":"<p>x_array : An array of radii corresponding to the bins of the     distribution, shape (m). distribution : The concentration values of the distribution     (either PDF or PMS) at the given radii. Supports broadcasting     across x_array (n,m). to_PDF : Direction of conversion. If True, converts PMS to PDF.     If False, converts PDF to PMS.</p>"},{"location":"API/particula/util/convert/#returns_3","title":"Returns","text":"<p>converted_distribution : The converted distribution array     (either PDF or PMS).</p>"},{"location":"API/particula/util/convert/#signature_3","title":"Signature","text":"<pre><code>def distribution_convert_pdf_pms(\n    x_array: np.ndarray, distribution: np.ndarray, to_pdf: bool = True\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/util/convert/#effective_refractive_index","title":"effective_refractive_index","text":"<p>Show source in convert.py:402</p> <p>Calculate the effective refractive index of a mixture of two solutes, given the refractive index of each solute and the volume of each solute. The mixing is based on volume-weighted molar refraction.</p>"},{"location":"API/particula/util/convert/#arguments_4","title":"Arguments","text":"<ul> <li><code>m_zero</code> - The refractive index of solute 0.</li> <li><code>m_one</code> - The refractive index of solute 1.</li> <li><code>volume_zero</code> - The volume of solute 0.</li> <li><code>volume_one</code> - The volume of solute 1.</li> </ul>"},{"location":"API/particula/util/convert/#returns_4","title":"Returns","text":"<p>The effective refractive index of the mixture.</p>"},{"location":"API/particula/util/convert/#references_1","title":"References","text":"<p>Liu, Y., &amp; Daum, P. H. (2008). Relationship of refractive index to mass density and self-consistency mixing rules for multicomponent mixtures like ambient aerosols. Journal of Aerosol Science, 39(11), 974-986. https://doi.org/10.1016/j.jaerosci.2008.06.006</p>"},{"location":"API/particula/util/convert/#signature_4","title":"Signature","text":"<pre><code>def effective_refractive_index(\n    m_zero: Union[float, complex],\n    m_one: Union[float, complex],\n    volume_zero: float,\n    volume_one: float,\n) -&gt; Union[float, complex]: ...\n</code></pre>"},{"location":"API/particula/util/convert/#get_values_in_dict","title":"get_values_in_dict","text":"<p>Show source in convert.py:509</p> <p>Returns a list of values for keys in a dictionary.</p>"},{"location":"API/particula/util/convert/#examples_1","title":"Examples","text":"<pre><code>&gt;&gt;&gt; my_dict = {'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; get_values_in_dict(['a', 'c'], my_dict)\n[1, 3]\n</code></pre>"},{"location":"API/particula/util/convert/#arguments_5","title":"Arguments","text":"<ul> <li><code>key_list</code> - List of keys to check in the dictionary.</li> <li><code>dict_to_check</code> - The dictionary to check for the given keys.</li> </ul>"},{"location":"API/particula/util/convert/#returns_5","title":"Returns","text":"<ul> <li><code>List</code> - A list of values for keys in the dictionary.</li> </ul>"},{"location":"API/particula/util/convert/#raises_2","title":"Raises","text":"<ul> <li><code>KeyError</code> - If any of the keys in the <code>key_list</code> are not present in the dictionary.</li> </ul>"},{"location":"API/particula/util/convert/#signature_5","title":"Signature","text":"<pre><code>def get_values_in_dict(\n    key_list: List[str], dict_to_check: Dict[str, Any]\n) -&gt; List[Any]: ...\n</code></pre>"},{"location":"API/particula/util/convert/#kappa_from_volume","title":"kappa_from_volume","text":"<p>Show source in convert.py:206</p> <p>Calculate the kappa parameter from the volume of solute and water, given the water activity.</p>"},{"location":"API/particula/util/convert/#arguments_6","title":"Arguments","text":"<ul> <li><code>volume_solute</code> - The volume of solute.</li> <li><code>volume_water</code> - The volume of water.</li> <li><code>water_activity</code> - The water activity.</li> </ul>"},{"location":"API/particula/util/convert/#returns_6","title":"Returns","text":"<pre><code>The kappa parameter as a float.\n</code></pre>"},{"location":"API/particula/util/convert/#signature_6","title":"Signature","text":"<pre><code>def kappa_from_volume(\n    volume_solute: Union[float, np.ndarray],\n    volume_water: Union[float, np.ndarray],\n    water_activity: Union[float, np.ndarray],\n) -&gt; Union[float, np.ndarray]: ...\n</code></pre>"},{"location":"API/particula/util/convert/#kappa_volume_solute","title":"kappa_volume_solute","text":"<p>Show source in convert.py:148</p> <p>Calculate the volume of solute in a volume of total solution, given the kappa parameter and water activity.</p>"},{"location":"API/particula/util/convert/#arguments_7","title":"Arguments","text":"<ul> <li><code>volume_total</code> - The volume of the total solution.</li> <li><code>kappa</code> - The kappa parameter.</li> <li><code>water_activity</code> - The water activity.</li> </ul>"},{"location":"API/particula/util/convert/#returns_7","title":"Returns","text":"<pre><code>The volume of solute as a numpy array.\n</code></pre>"},{"location":"API/particula/util/convert/#signature_7","title":"Signature","text":"<pre><code>def kappa_volume_solute(\n    volume_total: Union[float, np.ndarray],\n    kappa: Union[float, np.ndarray],\n    water_activity: Union[float, np.ndarray],\n) -&gt; Union[float, np.ndarray]: ...\n</code></pre>"},{"location":"API/particula/util/convert/#kappa_volume_water","title":"kappa_volume_water","text":"<p>Show source in convert.py:178</p> <p>Calculate the volume of water given volume of solute, kappa parameter, and water activity.</p>"},{"location":"API/particula/util/convert/#arguments_8","title":"Arguments","text":"<ul> <li><code>volume_solute</code> - The volume of solute.</li> <li><code>kappa</code> - The kappa parameter.</li> <li><code>water_activity</code> - The water activity.</li> </ul>"},{"location":"API/particula/util/convert/#returns_8","title":"Returns","text":"<pre><code>The volume of water as a float.\n</code></pre>"},{"location":"API/particula/util/convert/#signature_8","title":"Signature","text":"<pre><code>def kappa_volume_water(\n    volume_solute: Union[float, NDArray[np.float64]],\n    kappa: Union[float, NDArray[np.float64]],\n    water_activity: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/util/convert/#length_to_volume","title":"length_to_volume","text":"<p>Show source in convert.py:125</p> <p>Convert radius or diameter to volume.</p>"},{"location":"API/particula/util/convert/#arguments_9","title":"Arguments","text":"<ul> <li><code>length</code> - The length to be converted.</li> <li><code>length_type</code> - The type of length ('radius' or 'diameter').     Default is 'radius'.</li> </ul>"},{"location":"API/particula/util/convert/#returns_9","title":"Returns","text":"<pre><code>The volume.\n</code></pre>"},{"location":"API/particula/util/convert/#signature_9","title":"Signature","text":"<pre><code>def length_to_volume(\n    length: Union[float, np.ndarray], length_type: str = \"radius\"\n) -&gt; Union[float, np.ndarray]: ...\n</code></pre>"},{"location":"API/particula/util/convert/#list_to_dict","title":"list_to_dict","text":"<p>Show source in convert.py:486</p> <p>Converts a list of strings to a dictionary. The keys are the strings and the values are the index of the string in the list.</p>"},{"location":"API/particula/util/convert/#arguments_10","title":"Arguments","text":"<ul> <li><code>list_of_str</code> list - A non-empty list of strings.</li> </ul>"},{"location":"API/particula/util/convert/#returns_10","title":"Returns","text":"<ul> <li><code>dict</code> - A dictionary where the keys are the strings and the values are     the index of the string in the list.</li> </ul>"},{"location":"API/particula/util/convert/#signature_10","title":"Signature","text":"<pre><code>def list_to_dict(list_of_str: list) -&gt; dict: ...\n</code></pre>"},{"location":"API/particula/util/convert/#mass_concentration_to_mole_fraction","title":"mass_concentration_to_mole_fraction","text":"<p>Show source in convert.py:284</p> <p>Convert mass concentrations to mole fractions for N components.</p>"},{"location":"API/particula/util/convert/#arguments_11","title":"Arguments","text":"<ul> <li><code>mass_concentrations</code> - A list or ndarray of mass concentrations (e.g., kg/m^3).</li> <li><code>molar_masses</code> - A list or ndarray of molecular weights (e.g., g/mol).</li> </ul>"},{"location":"API/particula/util/convert/#returns_11","title":"Returns","text":"<p>An ndarray of mole fractions.</p>"},{"location":"API/particula/util/convert/#notes","title":"Notes","text":"<p>The mole fraction of a component is given by the ratio of its molar concentration to the total molar concentration of all components.</p>"},{"location":"API/particula/util/convert/#signature_11","title":"Signature","text":"<pre><code>def mass_concentration_to_mole_fraction(\n    mass_concentrations: NDArray[np.float64], molar_masses: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/util/convert/#mass_concentration_to_volume_fraction","title":"mass_concentration_to_volume_fraction","text":"<p>Show source in convert.py:311</p> <p>Convert mass concentrations to volume fractions for N components.</p>"},{"location":"API/particula/util/convert/#arguments_12","title":"Arguments","text":"<ul> <li><code>mass_concentrations</code> - A list or ndarray of mass concentrations (e.g., kg/m^3).</li> <li><code>densities</code> - A list or ndarray of densities of each component (e.g., kg/m^3).</li> </ul>"},{"location":"API/particula/util/convert/#returns_12","title":"Returns","text":"<p>An ndarray of volume fractions.</p>"},{"location":"API/particula/util/convert/#notes_1","title":"Notes","text":"<p>The volume fraction of a component is calculated by dividing the volume of that component (derived from mass concentration and density) by the total volume of all components.</p>"},{"location":"API/particula/util/convert/#signature_12","title":"Signature","text":"<pre><code>def mass_concentration_to_volume_fraction(\n    mass_concentrations: NDArray[np.float64], densities: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/util/convert/#mass_fraction_to_volume_fraction","title":"mass_fraction_to_volume_fraction","text":"<p>Show source in convert.py:342</p> <p>Converts the mass fraction of a solute to the volume fraction in a binary mixture.</p>"},{"location":"API/particula/util/convert/#arguments_13","title":"Arguments","text":"<ul> <li><code>mass_fraction</code> float - The mass fraction of the solute in the mixture.</li> <li><code>density_solute</code> float - The density of the solute.</li> <li><code>density_solvent</code> float - The density of the solvent.</li> </ul>"},{"location":"API/particula/util/convert/#returns_13","title":"Returns","text":"<ul> <li><code>Tuple[float,</code> float] - A tuple containing the volume fraction of the     solute and solvent in the mixture.</li> </ul>"},{"location":"API/particula/util/convert/#examples_2","title":"Examples","text":"<p>If <code>mass_fraction</code> is 0.5, <code>density_solute</code> is 1.5 g/cm^3, and <code>density_solvent</code> is 2 g/cm^3, this function returns (0.5714, 0.4285), indicating that the solute and solvent occupy 57% and 42% of the mixture's volume, respectively.</p>"},{"location":"API/particula/util/convert/#signature_13","title":"Signature","text":"<pre><code>def mass_fraction_to_volume_fraction(\n    mass_fraction: float, density_solute: float, density_solvent: float\n) -&gt; Tuple[float, float]: ...\n</code></pre>"},{"location":"API/particula/util/convert/#mole_fraction_to_mass_fraction","title":"mole_fraction_to_mass_fraction","text":"<p>Show source in convert.py:233</p> <p>Convert mole fraction to mass fraction.</p>"},{"location":"API/particula/util/convert/#arguments_14","title":"Arguments","text":"<ul> <li><code>mole_fraction0</code> - The mole fraction of the first component.</li> <li><code>molecular_weight0</code> - The molecular weight of the first component.</li> <li><code>molecular_weight1</code> - The molecular weight of the second component.</li> </ul>"},{"location":"API/particula/util/convert/#returns_14","title":"Returns","text":"<p>A tuple containing the mass fractions of the two components as floats.</p>"},{"location":"API/particula/util/convert/#signature_14","title":"Signature","text":"<pre><code>def mole_fraction_to_mass_fraction(\n    mole_fraction0: float, molecular_weight0: float, molecular_weight1: float\n) -&gt; Tuple[float, float]: ...\n</code></pre>"},{"location":"API/particula/util/convert/#mole_fraction_to_mass_fraction_multi","title":"mole_fraction_to_mass_fraction_multi","text":"<p>Show source in convert.py:259</p> <p>Convert mole fractions to mass fractions for N components. Assumes that sum(mole_fractions) == 1.</p>"},{"location":"API/particula/util/convert/#arguments_15","title":"Arguments","text":"<ul> <li><code>mole_fractions</code> - A list of mole fractions.</li> <li><code>molecular_weights</code> - A list of molecular weights.</li> </ul>"},{"location":"API/particula/util/convert/#returns_15","title":"Returns","text":"<p>A list of mass fractions.</p>"},{"location":"API/particula/util/convert/#signature_15","title":"Signature","text":"<pre><code>def mole_fraction_to_mass_fraction_multi(\n    mole_fractions: list[float], molecular_weights: list[float]\n) -&gt; list[float]: ...\n</code></pre>"},{"location":"API/particula/util/convert/#radius_diameter","title":"radius_diameter","text":"<p>Show source in convert.py:87</p> <p>Convert a radius to a diameter, or vice versa.</p>"},{"location":"API/particula/util/convert/#arguments_16","title":"Arguments","text":"<ul> <li><code>value</code> - The value to be converted.</li> <li><code>to_diameter</code> - If True, convert from radius to diameter. If False, convert from diameter to radius.</li> </ul>"},{"location":"API/particula/util/convert/#returns_16","title":"Returns","text":"<p>The converted value.</p>"},{"location":"API/particula/util/convert/#signature_16","title":"Signature","text":"<pre><code>def radius_diameter(value: float, to_diameter: bool = True) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/util/convert/#round_arbitrary","title":"round_arbitrary","text":"<p>Show source in convert.py:37</p> <p>Rounds the input values to the nearest multiple of the base.</p> <p>For values exactly halfway between rounded decimal values, \"Bankers rounding applies\" rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0, -0.5 and 0.5 round to 0.0, etc.</p>"},{"location":"API/particula/util/convert/#arguments_17","title":"Arguments","text":"<ul> <li><code>values</code> - The values to be rounded.</li> <li><code>base</code> - The base to which the values should be rounded.</li> <li><code>mode</code> - The rounding mode: 'round', 'floor', 'ceil'</li> <li><code>nonzero_edge</code> - If true the zero values are replaced by the original values.</li> </ul>"},{"location":"API/particula/util/convert/#returns_17","title":"Returns","text":"<ul> <li><code>rounded</code> - The rounded values.</li> </ul>"},{"location":"API/particula/util/convert/#signature_17","title":"Signature","text":"<pre><code>def round_arbitrary(\n    values: Union[float, list[float], np.ndarray],\n    base: Union[float, np.float64] = 1.0,\n    mode: str = \"round\",\n    nonzero_edge: bool = False,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/util/convert/#volume_to_length","title":"volume_to_length","text":"<p>Show source in convert.py:102</p> <p>Convert a volume to a radius or diameter.</p>"},{"location":"API/particula/util/convert/#arguments_18","title":"Arguments","text":"<ul> <li><code>volume</code> - The volume to be converted.</li> <li><code>length_type</code> - The type of length to convert to ('radius' or 'diameter') Default is 'radius'.</li> </ul>"},{"location":"API/particula/util/convert/#returns_18","title":"Returns","text":"<p>The converted length.</p>"},{"location":"API/particula/util/convert/#signature_18","title":"Signature","text":"<pre><code>def volume_to_length(\n    volume: Union[float, NDArray[np.float64]], length_type: str = \"radius\"\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/util/convert/#volume_water_from_volume_fraction","title":"volume_water_from_volume_fraction","text":"<p>Show source in convert.py:376</p> <p>Calculates the volume of water in a volume of solute, given the volume fraction of water in the mixture.</p>"},{"location":"API/particula/util/convert/#arguments_19","title":"Arguments","text":"<ul> <li><code>volume_solute_dry</code> float - The volume of the solute, excluding water.</li> <li><code>volume_fraction_water</code> float - The volume fraction of water in the                     mixture, expressed as a decimal between 0 and 1.</li> </ul>"},{"location":"API/particula/util/convert/#returns_19","title":"Returns","text":"<ul> <li><code>float</code> - The volume of water in the mixture, in the same units as     <code>volume_solute_dry</code>.</li> </ul>"},{"location":"API/particula/util/convert/#examples_3","title":"Examples","text":"<p>If <code>volume_solute_dry</code> is 100 mL and <code>volume_fraction_water</code> is 0.8, this function returns 400 mL, indicating that there are 400 mL of water in the total 100 mL + 400 mL mixture.</p>"},{"location":"API/particula/util/convert/#signature_19","title":"Signature","text":"<pre><code>def volume_water_from_volume_fraction(\n    volume_solute_dry: float, volume_fraction_water: float\n) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/util/machine_limit/","title":"Machine Limit","text":"<p>Particula Index / Particula / Util / Machine Limit</p> <p>Auto-generated documentation for particula.util.machine_limit module.</p>"},{"location":"API/particula/util/machine_limit/#safe_exp","title":"safe_exp","text":"<p>Show source in machine_limit.py:12</p> <p>Compute the exponential of each element in the input array, with limits to prevent overflow based on machine precision.</p>"},{"location":"API/particula/util/machine_limit/#arguments","title":"Arguments","text":"<ul> <li><code>value</code> ArrayLike - Input array.</li> </ul>"},{"location":"API/particula/util/machine_limit/#returns","title":"Returns","text":"<ul> <li><code>np.ndarray</code> - Exponential of the input array with overflow protection.</li> </ul>"},{"location":"API/particula/util/machine_limit/#signature","title":"Signature","text":"<pre><code>def safe_exp(value: ArrayLike) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/util/machine_limit/#safe_log","title":"safe_log","text":"<p>Show source in machine_limit.py:28</p> <p>Compute the natural logarithm of each element in the input array, with limits to prevent underflow based on machine precision.</p>"},{"location":"API/particula/util/machine_limit/#arguments_1","title":"Arguments","text":"<ul> <li><code>value</code> ArrayLike - Input array.</li> </ul>"},{"location":"API/particula/util/machine_limit/#returns_1","title":"Returns","text":"<ul> <li><code>np.ndarray</code> - Natural logarithm of the input array with underflow protection.</li> </ul>"},{"location":"API/particula/util/machine_limit/#signature_1","title":"Signature","text":"<pre><code>def safe_log(value: ArrayLike) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/util/machine_limit/#safe_log10","title":"safe_log10","text":"<p>Show source in machine_limit.py:45</p> <p>Compute the base 10 logarithm of each element in the input array, with limits to prevent underflow based on machine precision.</p>"},{"location":"API/particula/util/machine_limit/#arguments_2","title":"Arguments","text":"<ul> <li><code>value</code> ArrayLike - Input array.</li> </ul>"},{"location":"API/particula/util/machine_limit/#returns_2","title":"Returns","text":"<ul> <li><code>np.ndarray</code> - Base 10 logarithm of the input array with underflow protection.</li> </ul>"},{"location":"API/particula/util/machine_limit/#signature_2","title":"Signature","text":"<pre><code>def safe_log10(value: ArrayLike) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/util/reduced_quantity/","title":"Reduced Quantity","text":"<p>Particula Index / Particula / Util / Reduced Quantity</p> <p>Auto-generated documentation for particula.util.reduced_quantity module.</p>"},{"location":"API/particula/util/reduced_quantity/#reduced_self_broadcast","title":"reduced_self_broadcast","text":"<p>Show source in reduced_quantity.py:56</p> <p>Returns the reduced value of an array with itself, broadcasting the array into a matrix and calculating the reduced value of each element pair. reduced_value = alpha_matrix * alpha_matrix_Transpose                 / (alpha_matrix + alpha_matrix_Transpose)</p>"},{"location":"API/particula/util/reduced_quantity/#arguments","title":"Arguments","text":"<ul> <li>alpha_array : The array to be broadcast and reduced.</li> </ul>"},{"location":"API/particula/util/reduced_quantity/#returns","title":"Returns","text":"<ul> <li>A square matrix of the reduced values.</li> </ul>"},{"location":"API/particula/util/reduced_quantity/#signature","title":"Signature","text":"<pre><code>def reduced_self_broadcast(alpha_array: NDArray[np.float64]) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/util/reduced_quantity/#reduced_value","title":"reduced_value","text":"<p>Show source in reduced_quantity.py:15</p> <p>Returns the reduced value of two parameters, calculated as: reduced_value = alpha * beta / (alpha + beta)</p> <p>This formula calculates an \"effective inertial\" quantity, allowing two-body problems to be solved as if they were one-body problems.</p>"},{"location":"API/particula/util/reduced_quantity/#arguments_1","title":"Arguments","text":"<ul> <li>alpha : The first parameter (scalar or array).</li> <li>beta : The second parameter (scalar or array).</li> </ul>"},{"location":"API/particula/util/reduced_quantity/#returns_1","title":"Returns","text":"<ul> <li>A value or array of the same dimension as the input parameters.     Returns zero where alpha + beta equals zero to handle division     by zero gracefully.</li> </ul>"},{"location":"API/particula/util/reduced_quantity/#raises","title":"Raises","text":"<ul> <li>ValueError : If alpha and beta are arrays and their shapes do     not match.</li> </ul>"},{"location":"API/particula/util/reduced_quantity/#signature_1","title":"Signature","text":"<pre><code>def reduced_value(\n    alpha: Union[float, NDArray[np.float64]], beta: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/","title":"Size Distribution Convert","text":"<p>Particula Index / Particula / Util / Size Distribution Convert</p> <p>Auto-generated documentation for particula.util.size_distribution_convert module.</p>"},{"location":"API/particula/util/size_distribution_convert/#conversionstrategy","title":"ConversionStrategy","text":"<p>Show source in size_distribution_convert.py:23</p> <p>Defines an interface for conversion strategies between particle size distribution formats.</p> <p>Subclasses must implement the convert method to perform specific conversion logic.</p>"},{"location":"API/particula/util/size_distribution_convert/#signature","title":"Signature","text":"<pre><code>class ConversionStrategy: ...\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/#conversionstrategyconvert","title":"ConversionStrategy().convert","text":"<p>Show source in size_distribution_convert.py:31</p> <p>Converter method common interface, for subclasses.</p>"},{"location":"API/particula/util/size_distribution_convert/#arguments","title":"Arguments","text":"<ul> <li><code>diameters</code> np.ndarray - The particle diameters.</li> <li><code>concentration</code> np.ndarray - The concentration values.</li> <li><code>inverse</code> bool - Flag to perform the inverse conversion.</li> </ul>"},{"location":"API/particula/util/size_distribution_convert/#returns","title":"Returns","text":"<ul> <li><code>np.ndarray</code> - The concentration values converted.</li> </ul>"},{"location":"API/particula/util/size_distribution_convert/#raises","title":"Raises","text":"<ul> <li><code>NotImplementedError</code> - If the subclass does not implement this.</li> </ul>"},{"location":"API/particula/util/size_distribution_convert/#signature_1","title":"Signature","text":"<pre><code>def convert(\n    self, diameters: np.ndarray, concentration: np.ndarray, inverse: bool = False\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/#dndlogdptopdfconversionstrategy","title":"DNdlogDPtoPDFConversionStrategy","text":"<p>Show source in size_distribution_convert.py:83</p> <p>Implements conversion between dn/dlogdp and PDF formats through an intermediate PMS format.</p>"},{"location":"API/particula/util/size_distribution_convert/#signature_2","title":"Signature","text":"<pre><code>class DNdlogDPtoPDFConversionStrategy(ConversionStrategy): ...\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/#see-also","title":"See also","text":"<ul> <li>ConversionStrategy</li> </ul>"},{"location":"API/particula/util/size_distribution_convert/#dndlogdptopdfconversionstrategyconvert","title":"DNdlogDPtoPDFConversionStrategy().convert","text":"<p>Show source in size_distribution_convert.py:87</p>"},{"location":"API/particula/util/size_distribution_convert/#signature_3","title":"Signature","text":"<pre><code>def convert(\n    self, diameters: np.ndarray, concentration: np.ndarray, inverse: bool = False\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/#dndlogdptopmsconversionstrategy","title":"DNdlogDPtoPMSConversionStrategy","text":"<p>Show source in size_distribution_convert.py:61</p> <p>Implements conversion between dn/dlogdp and PMS formats using the convert_sizer_dn method.</p>"},{"location":"API/particula/util/size_distribution_convert/#signature_4","title":"Signature","text":"<pre><code>class DNdlogDPtoPMSConversionStrategy(ConversionStrategy): ...\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/#see-also_1","title":"See also","text":"<ul> <li>ConversionStrategy</li> </ul>"},{"location":"API/particula/util/size_distribution_convert/#dndlogdptopmsconversionstrategyconvert","title":"DNdlogDPtoPMSConversionStrategy().convert","text":"<p>Show source in size_distribution_convert.py:65</p>"},{"location":"API/particula/util/size_distribution_convert/#signature_5","title":"Signature","text":"<pre><code>def convert(\n    self, diameters: np.ndarray, concentration: np.ndarray, inverse: bool = False\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/#pmstopdfconversionstrategy","title":"PMStoPDFConversionStrategy","text":"<p>Show source in size_distribution_convert.py:73</p> <p>Implements conversion between PMS and PDF formats.</p>"},{"location":"API/particula/util/size_distribution_convert/#signature_6","title":"Signature","text":"<pre><code>class PMStoPDFConversionStrategy(ConversionStrategy): ...\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/#see-also_2","title":"See also","text":"<ul> <li>ConversionStrategy</li> </ul>"},{"location":"API/particula/util/size_distribution_convert/#pmstopdfconversionstrategyconvert","title":"PMStoPDFConversionStrategy().convert","text":"<p>Show source in size_distribution_convert.py:76</p>"},{"location":"API/particula/util/size_distribution_convert/#signature_7","title":"Signature","text":"<pre><code>def convert(\n    self, diameters: np.ndarray, concentration: np.ndarray, inverse: bool = False\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/#samescaleconversionstrategy","title":"SameScaleConversionStrategy","text":"<p>Show source in size_distribution_convert.py:52</p> <p>Implements conversion between the same scales, which is a no-op.</p>"},{"location":"API/particula/util/size_distribution_convert/#signature_8","title":"Signature","text":"<pre><code>class SameScaleConversionStrategy(ConversionStrategy): ...\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/#see-also_3","title":"See also","text":"<ul> <li>ConversionStrategy</li> </ul>"},{"location":"API/particula/util/size_distribution_convert/#samescaleconversionstrategyconvert","title":"SameScaleConversionStrategy().convert","text":"<p>Show source in size_distribution_convert.py:55</p>"},{"location":"API/particula/util/size_distribution_convert/#signature_9","title":"Signature","text":"<pre><code>def convert(\n    self, diameters: np.ndarray, concentration: np.ndarray, inverse: bool = False\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/#sizerconverter","title":"SizerConverter","text":"<p>Show source in size_distribution_convert.py:102</p> <p>A converter that uses a specified ConversionStrategy to convert particle size distribution data between different formats.</p>"},{"location":"API/particula/util/size_distribution_convert/#signature_10","title":"Signature","text":"<pre><code>class SizerConverter:\n    def __init__(self, strategy: ConversionStrategy): ...\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/#see-also_4","title":"See also","text":"<ul> <li>ConversionStrategy</li> </ul>"},{"location":"API/particula/util/size_distribution_convert/#sizerconverterconvert","title":"SizerConverter().convert","text":"<p>Show source in size_distribution_convert.py:114</p> <p>Converts particle size distribution data using the specified strategy.</p>"},{"location":"API/particula/util/size_distribution_convert/#arguments_1","title":"Arguments","text":"<ul> <li><code>diameters</code> np.ndarray - The particle diameters.</li> <li><code>concentration</code> np.ndarray - The concentration values.</li> <li><code>inverse</code> bool - Flag to perform the inverse conversion.</li> </ul>"},{"location":"API/particula/util/size_distribution_convert/#returns_1","title":"Returns","text":"<ul> <li><code>np.ndarray</code> - The converted concentration values.</li> </ul>"},{"location":"API/particula/util/size_distribution_convert/#signature_11","title":"Signature","text":"<pre><code>def convert(\n    self, diameters: np.ndarray, concentration: np.ndarray, inverse: bool = False\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/#get_conversion_strategy","title":"get_conversion_strategy","text":"<p>Show source in size_distribution_convert.py:130</p> <p>Factory function to create and return an appropriate conversion strategy based on input and output scales. Use the inverse flag in the converter to invert the directions of the input and output scales.</p>"},{"location":"API/particula/util/size_distribution_convert/#arguments_2","title":"Arguments","text":"<ul> <li><code>input_scale</code> - The scale of the input concentration values.     Either 'dn/dlogdp' or 'pms'.</li> <li><code>output_scale</code> - The desired scale of the output concentration     values. Either 'pms' or 'pdf'. Use inverse flag to invert the input     and output scales.</li> </ul>"},{"location":"API/particula/util/size_distribution_convert/#returns_2","title":"Returns","text":"<ul> <li>ConversionStrategy - A strategy object capable of converting between     the specified scales.</li> </ul>"},{"location":"API/particula/util/size_distribution_convert/#raises_1","title":"Raises","text":"<ul> <li><code>ValueError</code> - If the input_scale or output_scale is not supported, or     if the specified conversion is unsupported.</li> </ul>"},{"location":"API/particula/util/size_distribution_convert/#examples","title":"Examples","text":"Convert dn/dlogdp to PMS<pre><code>strategy = get_conversion_strategy('dn/dlogdp', 'pms')\nconverter = Converter(strategy)\nconverted_concentration = converter.convert(\n    diameters, concentration, inverse=False)\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/#signature_12","title":"Signature","text":"<pre><code>def get_conversion_strategy(\n    input_scale: str, output_scale: str\n) -&gt; ConversionStrategy: ...\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/#see-also_5","title":"See also","text":"<ul> <li>ConversionStrategy</li> </ul>"},{"location":"API/particula/util/surface_tension/","title":"Surface Tension","text":"<p>Particula Index / Particula / Util / Surface Tension</p> <p>Auto-generated documentation for particula.util.surface_tension module.</p>"},{"location":"API/particula/util/surface_tension/#dry_mixing","title":"dry_mixing","text":"<p>Show source in surface_tension.py:33</p> <p>Function to calculate the effective surface tension of a dry mixture.</p>"},{"location":"API/particula/util/surface_tension/#arguments","title":"Arguments","text":"<ul> <li>volume_fractions : array, volume fractions of solutes</li> <li>surface_tensions : array, surface tensions of solutes</li> </ul>"},{"location":"API/particula/util/surface_tension/#returns","title":"Returns","text":"<ul> <li>sigma : array, surface tension of droplet</li> </ul>"},{"location":"API/particula/util/surface_tension/#signature","title":"Signature","text":"<pre><code>def dry_mixing(volume_fractions, surface_tensions): ...\n</code></pre>"},{"location":"API/particula/util/surface_tension/#water","title":"water","text":"<p>Show source in surface_tension.py:8</p> <p>Calculate the surface tension of water using the equation from Kalova and Mares (2018).</p>"},{"location":"API/particula/util/surface_tension/#arguments_1","title":"Arguments","text":"<ul> <li>Temperature : float, Ambient temperature of air</li> <li>CritTemp : float, optional: Critical temperature of water</li> </ul>"},{"location":"API/particula/util/surface_tension/#returns_1","title":"Returns","text":"<ul> <li>sigma : float, Surface tension of water at the given temperature</li> </ul>"},{"location":"API/particula/util/surface_tension/#signature_1","title":"Signature","text":"<pre><code>def water(temperature, critical_temperature=647.15): ...\n</code></pre>"},{"location":"API/particula/util/surface_tension/#wet_mixing","title":"wet_mixing","text":"<p>Show source in surface_tension.py:53</p> <p>Function to calculate the effective surface tension of a wet mixture.</p>"},{"location":"API/particula/util/surface_tension/#arguments_2","title":"Arguments","text":"<ul> <li>volume_solute : array, volume of solute mixture</li> <li>volume_water : array, volume of water</li> <li>surface_tension_solute : array, surface tension of solute mixture</li> <li>temperature : float, temperature of droplet</li> <li>method : str, optional: [film, volume] method to calculate effective     surface tension</li> </ul>"},{"location":"API/particula/util/surface_tension/#returns_2","title":"Returns","text":"<ul> <li>EffSigma : array, effective surface tension of droplet</li> </ul>"},{"location":"API/particula/util/surface_tension/#signature_2","title":"Signature","text":"<pre><code>def wet_mixing(\n    volume_solute,\n    volume_water,\n    wet_radius,\n    surface_tension_solute,\n    temperature,\n    method=\"film\",\n): ...\n</code></pre>"},{"location":"API/particula/util/validate_inputs/","title":"Validate Inputs","text":"<p>Particula Index / Particula / Util / Validate Inputs</p> <p>Auto-generated documentation for particula.util.validate_inputs module.</p>"},{"location":"API/particula/util/validate_inputs/#validate_inputs","title":"validate_inputs","text":"<p>Show source in validate_inputs.py:40</p> <p>A decorator to validate that specified arguments meet certain constraints.</p>"},{"location":"API/particula/util/validate_inputs/#arguments","title":"Arguments","text":"<ul> <li><code>dict_args</code> - Dictionary of argument names and their constraints.</li> </ul>"},{"location":"API/particula/util/validate_inputs/#returns","title":"Returns","text":"<p>A decorator for input validation.</p>"},{"location":"API/particula/util/validate_inputs/#signature","title":"Signature","text":"<pre><code>def validate_inputs(dict_args): ...\n</code></pre>"},{"location":"API/particula/util/validate_inputs/#validate_negative","title":"validate_negative","text":"<p>Show source in validate_inputs.py:16</p> <p>validate negative</p>"},{"location":"API/particula/util/validate_inputs/#signature_1","title":"Signature","text":"<pre><code>def validate_negative(value, name): ...\n</code></pre>"},{"location":"API/particula/util/validate_inputs/#validate_nonnegative","title":"validate_nonnegative","text":"<p>Show source in validate_inputs.py:28</p> <p>validate nonnegative</p>"},{"location":"API/particula/util/validate_inputs/#signature_2","title":"Signature","text":"<pre><code>def validate_nonnegative(value, name): ...\n</code></pre>"},{"location":"API/particula/util/validate_inputs/#validate_nonpositive","title":"validate_nonpositive","text":"<p>Show source in validate_inputs.py:22</p> <p>validate nonpositive</p>"},{"location":"API/particula/util/validate_inputs/#signature_3","title":"Signature","text":"<pre><code>def validate_nonpositive(value, name): ...\n</code></pre>"},{"location":"API/particula/util/validate_inputs/#validate_nonzero","title":"validate_nonzero","text":"<p>Show source in validate_inputs.py:34</p> <p>validate nonzero</p>"},{"location":"API/particula/util/validate_inputs/#signature_4","title":"Signature","text":"<pre><code>def validate_nonzero(value, name): ...\n</code></pre>"},{"location":"API/particula/util/validate_inputs/#validate_positive","title":"validate_positive","text":"<p>Show source in validate_inputs.py:10</p> <p>validate positive</p>"},{"location":"API/particula/util/validate_inputs/#signature_5","title":"Signature","text":"<pre><code>def validate_positive(value, name): ...\n</code></pre>"},{"location":"API/particula/util/converting/","title":"Converting","text":"<p>Particula Index / Particula / Util / Converting</p> <p>Auto-generated documentation for particula.util.converting module.</p>"},{"location":"API/particula/util/converting/#modules","title":"Modules","text":"<ul> <li>Convert Mass Concentration</li> </ul>"},{"location":"API/particula/util/converting/convert_mass_concentration/","title":"Convert Mass Concentration","text":"<p>Particula Index / Particula / Util / Converting / Convert Mass Concentration</p> <p>Auto-generated documentation for particula.util.converting.convert_mass_concentration module.</p>"},{"location":"API/particula/util/converting/convert_mass_concentration/#to_mass_fraction","title":"to_mass_fraction","text":"<p>Show source in convert_mass_concentration.py:97</p> <p>Convert mass concentrations to mass fractions for N components.</p> <p>If inputs are one-dimensional or float, the summation is done over the entire array. If mass_concentration is a 2D array, the summation is done row-wise.</p>"},{"location":"API/particula/util/converting/convert_mass_concentration/#arguments","title":"Arguments","text":"<ul> <li><code>mass_concentrations</code> - A list or ndarray of mass concentrations     (SI, kg/m^3).</li> </ul>"},{"location":"API/particula/util/converting/convert_mass_concentration/#returns","title":"Returns","text":"<p>An ndarray of mass fractions.</p> <p>Reference:     The mass fraction of a component is calculated by dividing the mass     concentration of that component by the total mass concentration of     all components.     - https://en.wikipedia.org/wiki/Mass_fraction_(chemistry)</p>"},{"location":"API/particula/util/converting/convert_mass_concentration/#signature","title":"Signature","text":"<pre><code>def to_mass_fraction(\n    mass_concentrations: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/util/converting/convert_mass_concentration/#to_mole_fraction","title":"to_mole_fraction","text":"<p>Show source in convert_mass_concentration.py:7</p> <p>Convert mass concentrations to mole fractions for N components.</p> <p>If the input mass_concentrations is 1D, the summation is performed over the entire array. If mass_concentrations is 2D, the summation is done row-wise.</p>"},{"location":"API/particula/util/converting/convert_mass_concentration/#arguments_1","title":"Arguments","text":"<ul> <li><code>mass_concentrations</code> - A list or ndarray of mass concentrations     (SI, kg/m^3).</li> <li><code>molar_masses</code> - A list or ndarray of molecular weights (SI, kg/mol).</li> </ul>"},{"location":"API/particula/util/converting/convert_mass_concentration/#returns_1","title":"Returns","text":"<p>An ndarray of mole fractions.</p> <p>Reference:     The mole fraction of a component is given by the ratio of its molar     concentration to the total molar concentration of all components.     - https://en.wikipedia.org/wiki/Mole_fraction</p>"},{"location":"API/particula/util/converting/convert_mass_concentration/#signature_1","title":"Signature","text":"<pre><code>def to_mole_fraction(\n    mass_concentrations: NDArray[np.float64], molar_masses: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/util/converting/convert_mass_concentration/#to_volume_fraction","title":"to_volume_fraction","text":"<p>Show source in convert_mass_concentration.py:51</p> <p>Convert mass concentrations to volume fractions for N components.</p> <p>If inputs are the one dimensional or float, the summation is done over the the whole array. It mass_concentration is a 2D array, the summation is done row-wise.</p>"},{"location":"API/particula/util/converting/convert_mass_concentration/#arguments_2","title":"Arguments","text":"<ul> <li><code>mass_concentrations</code> - A list or ndarray of mass concentrations     (SI, kg/m^3).</li> <li><code>densities</code> - A list or ndarray of densities of each component     (SI, kg/m^3).</li> </ul>"},{"location":"API/particula/util/converting/convert_mass_concentration/#returns_2","title":"Returns","text":"<p>An ndarray of volume fractions.</p> <p>Reference:     The volume fraction of a component is calculated by dividing the volume     of that component (derived from mass concentration and density) by the     total volume of all components.     - https://en.wikipedia.org/wiki/Volume_fraction</p>"},{"location":"API/particula/util/converting/convert_mass_concentration/#signature_2","title":"Signature","text":"<pre><code>def to_volume_fraction(\n    mass_concentrations: NDArray[np.float64], densities: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/util/lf2013_coagulation/","title":"Lf2013 Coagulation","text":"<p>Particula Index / Particula / Util / Lf2013 Coagulation</p> <p>Auto-generated documentation for particula.util.lf2013_coagulation module.</p>"},{"location":"API/particula/util/lf2013_coagulation/#modules","title":"Modules","text":"<ul> <li>Src Lf2013 Coagulation</li> </ul>"},{"location":"API/particula/util/lf2013_coagulation/src_lf2013_coagulation/","title":"Src Lf2013 Coagulation","text":"<p>Particula Index / Particula / Util / Lf2013 Coagulation / Src Lf2013 Coagulation</p> <p>Auto-generated documentation for particula.util.lf2013_coagulation.src_lf2013_coagulation module.</p>"},{"location":"API/particula/util/lf2013_coagulation/src_lf2013_coagulation/#lf2013_coag_full","title":"lf2013_coag_full","text":"<p>Show source in src_lf2013_coagulation.py:14</p> <p>calculate ion--particle coagulation according to lf2013</p>"},{"location":"API/particula/util/lf2013_coagulation/src_lf2013_coagulation/#signature","title":"Signature","text":"<pre><code>def lf2013_coag_full(\n    ion_type=\"air\",\n    particle_type=\"conductive\",\n    temperature_val=298.15,\n    pressure_val=101325,\n    charge_vals=None,\n    radius_vals=None,\n): ...\n</code></pre>"},{"location":"Discussions/","title":"Discussions","text":""},{"location":"Discussions/#technical-topics","title":"Technical Topics","text":"<ul> <li>Condensation Equations</li> <li>Dynamic Viscosity</li> <li>Mean Free Path</li> <li>Ion-Particle Coagulation</li> </ul>"},{"location":"Discussions/#particula-concepts","title":"Particula Concepts","text":"<ul> <li>Maps</li> </ul>"},{"location":"Discussions/Particula_Concepts/Particle_maps/","title":"Relational Maps","text":""},{"location":"Discussions/Particula_Concepts/Particle_maps/#particles","title":"Particles","text":"<pre><code>mindmap\n  root((*particula.next.particles*))\n    distribution\n      strategies\n        MassBasedMovingBin\n        RadiiBasedMovingBin\n        SpeciatedMassMovingBin\n        ParticleResolvedSpeciatedMass\n      builders\n      DistributionFactory\n    activity\n      strategies\n        ActivityIdealMass\n        ActivityIdealMolar\n        ActivityKappaParameter\n      builders\n      ActivityFactory\n    representation\n      ParticleRepresentation\n      builders\n      ParticleRepresentationFactory\n    surface\n      strategies\n        SurfaceStrategyVolume\n        SurfaceStrategyMass\n        SurfaceStrategyMolar\n      builders\n      SurfaceFactory\n    properties</code></pre>"},{"location":"Discussions/Technical/Condensation_Equations/","title":"Condensation Discussion","text":"<p>Iso thermal and non-isothermal condensation processes are important in aerosol dynamics. The condensation process is the addition of a gas phase species to the particle phase. This can be a reversible process, where the species can evaporate back into the gas phase. The condensation process is important in the formation of cloud droplets, and the growth of particles in the atmosphere.</p>"},{"location":"Discussions/Technical/Condensation_Equations/#condensation-equations-isothermal","title":"Condensation Equations (Isothermal)","text":"<p>With the gas phase and particle phase defined, we can start the condensation process. Excluding the latent heat of vaporization for the gas-particle phase transition, which is important in cloud droplet formation.</p> <p>This follows Chapter 2 (EQ 2.41) by Topping, D., &amp; Bane, M. (2022). Introduction to Aerosol Modelling (D. Topping &amp; M. Bane, Eds.). Wiley. https://doi.org/10.1002/9781119625728. Also Chapter 12 and 13 (EQ 13.3) of Seinfeld, J. H., &amp; Pandis, S. N. (2016). Atmospheric Chemistry and Physics: From Air Pollution to Climate Change (3<sup>rd</sup> ed.). Wiley.</p> <p>The isothermal condensation or evaporation process is defined by the following equation:</p> \\[ \\frac{dm_{i}}{dt} = N \\frac{k_{cond} (p_{i, gas} - p_{i, particle~surface})}{RT/ molar~mass_{i}} \\] <p>Where:</p> <ul> <li>\\(m_{i}\\) is the mass of species \\(i\\) in the particle phase, of a specific bin</li> <li>\\(N\\) is the number of particles</li> <li>\\(k_{cond}\\) is the per-particle for order condensation coefficient</li> <li>\\(p_{i, gas}\\) is the partial pressure of species \\(i\\) in the gas phase</li> <li>\\(p_{i, particle~surface}\\) is the partial pressure of species \\(i\\) at the surface of the particle, acounting for Kelvin effect and activity coefficients.</li> <li>\\(R\\) is the ideal gas constant</li> <li>\\(T\\) is the temperature</li> <li>\\(molar mass_{i}\\) is the molar mass of species \\(i\\)</li> <li>\\(dm_{i}/dt\\) is the rate of change of mass of species \\(i\\) in the particle phase</li> </ul> <p>The first order condensation coefficient is defined as:</p> \\[ k_{cond} = 4 \\pi~radius_{particle}~D_{i}~f(Kn, \\alpha) \\] <p>Where:</p> <ul> <li>\\(radius_{particle}\\) is the radius of the particle</li> <li>\\(D_{i}\\) is the vapor diffusion coefficient of species \\(i\\)</li> <li>\\(f(Kn, \\alpha)\\) is the correction factor for the molecular regime to continuum regime transition. This is a function of the Knudsen number and the accommodation coefficient.</li> </ul> <p>The correction factor is defined as:</p> \\[ f(Kn, \\alpha_{i, accom.}) = \\frac{0.75 \\alpha_{i, accom.} (1 + Kn)}{     (Kn^2 + Kn) + 0.283 \\alpha_{i, accom.} Kn + 0.75 \\alpha_{i, accom.}} \\] <p>Where:</p> <ul> <li>\\(\\alpha_{i, accom.}\\) is the accommodation coefficient of species \\(i\\)</li> <li>\\(Kn\\) is the Knudsen number</li> <li>\\(Kn = \\frac{\\lambda_{i}}{radius_{particle}}\\)</li> <li>\\(\\lambda\\) is the mean free path of the gas molecules of species \\(i\\)</li> <li>\\(radius\\) is the radius of the particle</li> </ul>"},{"location":"Discussions/Technical/Condensation_Equations/#partial-pressures","title":"Partial Pressures","text":"<p>The partial pressures of species \\(i\\) in the gas phase and at the surface of the particle are defined as:</p> \\[ p_{i, gas} = conc_{i, gas} RT/molar~mass_{i} \\] <p>Where: - \\(conc_{i, gas}\\) is the concentration of species \\(i\\) in the gas phase</p> <p>At the surface of the particle, the partial pressure is defined as:</p> \\[ p_{i, particle~surface} = p^{pure}_{i} \\gamma_{i} x_{i} k_{i,Kelvin} \\] <p>Where:</p> <ul> <li>\\(p^{pure}_{i}\\) is the saturation vapor pressure of species \\(i\\), sometimes called \\(p^{sat}_{i}\\), \\(p^{vap}_{i}\\), or \\(p^{0}_{i}\\)</li> <li>\\(\\gamma_{i}\\) is the activity coefficient of species \\(i\\)</li> <li>\\(x_{i}\\) is the mole fraction of species \\(i\\) in the particle phase</li> <li>\\(k_{i,Kelvin}\\) is the Kelvin effect correction factor</li> <li>\\(k_{i,Kelvin} = exp(k_{i, Kelvin~radius}/radius_{particle})\\)</li> <li>\\(k_{i, Kelvin~radius} = 2 \\sigma_{surface}~molar~mass_{i} / (R  T ~ density)\\)<ul> <li>\\(\\sigma_{surface}\\) is the effective surface tension of the particle.</li> <li>\\(density\\) is the effective density of the particle.</li> </ul> </li> </ul>"},{"location":"Discussions/Technical/dynamic_viscosity/","title":"Dynamic Viscosity","text":"In\u00a0[1]: Copied! <pre>from particula.gas.properties import get_dynamic_viscosity\n\nair_dynamic_viscosity = get_dynamic_viscosity(\n    temperature=298.15\n)  # will produce approx 1.84e-5 kg/m/s\n\nprint(f\"Air dynamic viscosity at 298.15 K is {air_dynamic_viscosity:.2e} kg/m/s\")\n</pre> from particula.gas.properties import get_dynamic_viscosity  air_dynamic_viscosity = get_dynamic_viscosity(     temperature=298.15 )  # will produce approx 1.84e-5 kg/m/s  print(f\"Air dynamic viscosity at 298.15 K is {air_dynamic_viscosity:.2e} kg/m/s\") <pre>Air dynamic viscosity at 298.15 K is 1.84e-05 kg/m/s\n</pre>"},{"location":"Discussions/Technical/dynamic_viscosity/#dynamic-viscosity","title":"Dynamic Viscosity\u00b6","text":"<p>The dynamic viscosity is a property of the fluid, defining the resistance of the fluid to its own movement. The dynamic viscosity is calculated using the Sutherland formula (reference). The function can be found and is documented in <code>util.dynamic_viscosity.py</code>. It takes inputs of <code>temperature</code>, <code>reference_viscosity</code>, <code>reference_temperature</code>, and <code>sutherland_constant</code>. It returns a value for the dynamic viscosity at those variables. At default conditions (298.15 K and 101325 Pa), the dynamic viscosity is approximately 1.84e-5 kg/m/s. The Sutherland formula is</p> <p>$$ \\mu = \\frac{\\mu_{0}\\, (T/T_{0})^{3/2}\\, (T_{0} + C)}{C + T} $$</p> <p>where $\\mu$ is the dynamic viscosity, $\\mu_{0}$ is the reference dynamic viscosity, $T$ is temperature, $T_{0}$ is the reference temperature, and $C$ is the Sutherland constant.</p>"},{"location":"Discussions/Technical/ionparticle_coagulation/","title":"Ion\u2013particle coagulation","text":"In\u00a0[1]: Copied! <pre>try:\n    import particula, matplotlib\nexcept ImportError:\n    print(\"Setting up computational environment...\")\n    %pip install -U particula -qqq\n    %pip install matplotlib -qqq\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom particula import particle, u\nfrom particula.util.lf2013_coagulation import lf2013_coag_full\n</pre> try:     import particula, matplotlib except ImportError:     print(\"Setting up computational environment...\")     %pip install -U particula -qqq     %pip install matplotlib -qqq  import numpy as np from matplotlib import pyplot as plt from particula import particle, u from particula.util.lf2013_coagulation import lf2013_coag_full In\u00a0[2]: Copied! <pre>approx = [\"hardsphere\", \"gk2008\", \"gh2012\", \"dy2007\", \"cg2019\"]\nfor i in range(len(approx)):\n    shared_dict = {\n        \"temperature\": 278,\n        \"coagulation_approximation\": approx[i]\n    }\n    positive_particles = [\n        particle.Particle(\n            **shared_dict,\n            particle_radius=3e-9,\n            particle_charge=i,\n            particle_density=1700,\n        ) for i in range(1, 10)\n    ]\n    negative_ion = particle.Particle(\n        **shared_dict,\n        particle_radius=0.45e-9,\n        particle_charge=-1,\n        particle_density=1860,\n    )\n    coags = [\n        negative_ion.coagulation(particle)\n        for particle in positive_particles\n    ]\n    coags_ccps_mags = [\n        coags[index].to(\"cc/s\").m\n        for index in range(0, 9)\n    ]\n    plt.semilogy(range(1,10), np.array(coags_ccps_mags).squeeze(), label=approx[i]);\n   \n\n\nret = np.nan_to_num(lf2013_coag_full(\n        ion_type=\"air\",\n        particle_type=\"conductive\",\n        temperature_val=298.15,\n        pressure_val=101325,\n        charge_vals=np.arange(1, 10),\n        radius_vals=3e-9,)[0], 0)  # [0] returns negative, [1] returns positive ions\nplt.semilogy(range(1,10),  np.array(ret*1e6).squeeze(), label=\"lf2013\");\nplt.ylim([1e-7, 1e-4]); plt.ylabel(\"Attachment coefficient, cc/s\"); plt.legend(); plt.xlabel(\"# charges\");\n</pre> approx = [\"hardsphere\", \"gk2008\", \"gh2012\", \"dy2007\", \"cg2019\"] for i in range(len(approx)):     shared_dict = {         \"temperature\": 278,         \"coagulation_approximation\": approx[i]     }     positive_particles = [         particle.Particle(             **shared_dict,             particle_radius=3e-9,             particle_charge=i,             particle_density=1700,         ) for i in range(1, 10)     ]     negative_ion = particle.Particle(         **shared_dict,         particle_radius=0.45e-9,         particle_charge=-1,         particle_density=1860,     )     coags = [         negative_ion.coagulation(particle)         for particle in positive_particles     ]     coags_ccps_mags = [         coags[index].to(\"cc/s\").m         for index in range(0, 9)     ]     plt.semilogy(range(1,10), np.array(coags_ccps_mags).squeeze(), label=approx[i]);       ret = np.nan_to_num(lf2013_coag_full(         ion_type=\"air\",         particle_type=\"conductive\",         temperature_val=298.15,         pressure_val=101325,         charge_vals=np.arange(1, 10),         radius_vals=3e-9,)[0], 0)  # [0] returns negative, [1] returns positive ions plt.semilogy(range(1,10),  np.array(ret*1e6).squeeze(), label=\"lf2013\"); plt.ylim([1e-7, 1e-4]); plt.ylabel(\"Attachment coefficient, cc/s\"); plt.legend(); plt.xlabel(\"# charges\");"},{"location":"Discussions/Technical/ionparticle_coagulation/#ionparticle-coagulation","title":"Ion\u2013particle coagulation\u00b6","text":"<p>The problem here: positive particles (1 to 9 charges) of radius 3 nm colliding with a negative ion of radius 0.45 nm.</p> <p>Several coagulation approximations:</p> <ul> <li>hard shpere</li> <li>gh2012: https://journals.aps.org/pre/abstract/10.1103/PhysRevE.85.026410</li> <li>gk2008: https://journals.aps.org/pre/abstract/10.1103/PhysRevE.78.046402</li> <li>dy2007: https://aip.scitation.org/doi/10.1063/1.2713719</li> <li>cg2019: https://www.tandfonline.com/doi/suppl/10.1080/02786826.2019.1614522</li> <li>lf2013: https://www.tandfonline.com/doi/full/10.1080/02786826.2013.783684</li> </ul>"},{"location":"Discussions/Technical/mean_free_path/","title":"Mean Free Path","text":"In\u00a0[4]: Copied! <pre>from particula.gas.properties import molecule_mean_free_path, get_dynamic_viscosity\n\nair_dynamic_viscosity = get_dynamic_viscosity(temperature=298.15)\n\nmean_free_path = molecule_mean_free_path(\n    molar_mass=28.97e-3,\n    temperature=298.15,\n    pressure=101325,\n    dynamic_viscosity=air_dynamic_viscosity,\n)\n\nprint(f\"mean free path is {mean_free_path} m\") # will produce approx 66.5 nm\n</pre> from particula.gas.properties import molecule_mean_free_path, get_dynamic_viscosity  air_dynamic_viscosity = get_dynamic_viscosity(temperature=298.15)  mean_free_path = molecule_mean_free_path(     molar_mass=28.97e-3,     temperature=298.15,     pressure=101325,     dynamic_viscosity=air_dynamic_viscosity, )  print(f\"mean free path is {mean_free_path} m\") # will produce approx 66.5 nm <pre>mean free path is 6.647342358988276e-08 m\n</pre>"},{"location":"Discussions/Technical/mean_free_path/#mean-free-path","title":"Mean Free Path\u00b6","text":"<p>The mean free path is the average distance of a molecule between collisions with other molecules present in the medium. We use the kinetic theory of gases to calculate the mean free path in an ideal gas as</p> <p>$$ \\lambda = \\frac{2 \\mu / p}{(8 \\, \\mathrm{MW} / (\\pi R T))^{1/2}}  $$</p> <p>where $\\lambda$ is the mean free path, $\\mu$ is the dynamic viscosity, $p$ is the pressure, $\\mathrm{MW}$ is the molecular weight, $R$ is the gas constant, $T$ is the temperature. As noted above, the user can provide an explicit value for $\\mu$ or it can be calculated using the above formula (that is, the user can provide the inputs to the above formula for $\\mu$). At default conditions, $\\lambda$ is about 66.5 nm.</p>"},{"location":"How-To-Guides/","title":"How-To Guides","text":"<ul> <li> <p>Setup Particula</p> <p>How to setup python and install <code>Particula</code> via pip.</p> <p> Tutorial</p> </li> <li> <p>Chamber Wall Loss</p> <p>How to simulate experiments for the loss of particles to the chamber walls.</p> <p> Tutorial</p> </li> <li> <p>Equilibria</p> <p>How to simulate aerosol thermodynamic equilibria using the Binary Activity Thermodynamic <code>BAT</code> Model. Useful for water uptake and cloud droplet activation.</p> <p> Tutorial</p> </li> <li> <p>Nucleation</p> <p>How to simulate aerosol nucleation by adding particles during simulations. Showing how to add a nucleation event.</p> <p> Tutorial</p> </li> </ul>"},{"location":"How-To-Guides/Chamber_Wall_Loss/","title":"Index: Chamber Wall Loss","text":"<p>In this example we'll go through the steps for simulation of wall loss in a chamber.</p>"},{"location":"How-To-Guides/Chamber_Wall_Loss/#notebooks","title":"Notebooks","text":"<ul> <li>Wall Loss Forward Simulation</li> </ul>"},{"location":"How-To-Guides/Chamber_Wall_Loss/Notebooks/Chamber_Forward_Simulation/","title":"Chamber Forward Simulation","text":"In\u00a0[6]: Copied! <pre>import numpy as np\nfrom matplotlib import pyplot as plt\n\nfrom particula.dynamics import dilution, coagulation, wall_loss\nfrom particula.particles.properties import lognormal_pmf_distribution\n</pre> import numpy as np from matplotlib import pyplot as plt  from particula.dynamics import dilution, coagulation, wall_loss from particula.particles.properties import lognormal_pmf_distribution In\u00a0[7]: Copied! <pre># Define initial simulation parameters\nmode = np.array([100e-9, 500e-9])  # Median diameter of the particles in meters\ngeometric_standard_deviation = np.array([1.3, 1.5])  # Geometric standard deviation of particle size distribution\nnumber_in_mode = np.array([5e4, 5e3]) * 1e6  # Number of particles in each mode  1/m^3\n\n\n# define the radius bins for the simulation\nradius_bins = np.logspace(-8, -5, 250)\n\n\n# Create particle distribution using the defined parameters\n\nconcentraiton_pmf = lognormal_pmf_distribution(\n    x_values=radius_bins,\n    mode=mode,\n    geometric_standard_deviation=geometric_standard_deviation,\n    number_of_particles=number_in_mode,\n)\n\n\n# plot the initial particle distribution\nfig, ax = plt.subplots()\nax.plot(radius_bins, concentraiton_pmf, label=\"Initial distribution\",\n        marker='.')\nax.set_xscale(\"log\")\nax.set_xlabel(\"Particle radius (m)\")\nax.set_ylabel(r\"Particle Concentration (dN), $\\dfrac{1}{m^{3}}$\")\nplt.show()\n</pre> # Define initial simulation parameters mode = np.array([100e-9, 500e-9])  # Median diameter of the particles in meters geometric_standard_deviation = np.array([1.3, 1.5])  # Geometric standard deviation of particle size distribution number_in_mode = np.array([5e4, 5e3]) * 1e6  # Number of particles in each mode  1/m^3   # define the radius bins for the simulation radius_bins = np.logspace(-8, -5, 250)   # Create particle distribution using the defined parameters  concentraiton_pmf = lognormal_pmf_distribution(     x_values=radius_bins,     mode=mode,     geometric_standard_deviation=geometric_standard_deviation,     number_of_particles=number_in_mode, )   # plot the initial particle distribution fig, ax = plt.subplots() ax.plot(radius_bins, concentraiton_pmf, label=\"Initial distribution\",         marker='.') ax.set_xscale(\"log\") ax.set_xlabel(\"Particle radius (m)\") ax.set_ylabel(r\"Particle Concentration (dN), $\\dfrac{1}{m^{3}}$\") plt.show() In\u00a0[8]: Copied! <pre># coagulation rate\n\nmass_particle = 4/3 * np.pi * radius_bins**3 * 1000 # mass of the particles in kg\n\nkernel = coagulation.brownian_coagulation_kernel_via_system_state(\n    radius_particle=radius_bins,\n    mass_particle= mass_particle,\n    temperature=293.15,\n    pressure=101325,\n    alpha_collision_efficiency=1,\n)\ncoagulation_loss = coagulation.discrete_loss(\n    concentration=concentraiton_pmf,\n    kernel=kernel,\n)\ncoagulation_gain = coagulation.discrete_gain(\n    radius=radius_bins,\n    concentration=concentraiton_pmf,\n    kernel=kernel,\n)\ncoagulation_net = coagulation_gain - coagulation_loss\n\n# dilution rate\ndilution_coefficent = dilution.volume_dilution_coefficient(\n    volume=1, # m^3\n    input_flow_rate=2*1e-6, # m^3/s\n)\ndilution_loss = dilution.dilution_rate(\n    coefficient=dilution_coefficent,\n    concentration=concentraiton_pmf,\n)\n\n# wall loss rate\nchamber_wall_loss_rate = wall_loss.rectangle_wall_loss_rate(\n    wall_eddy_diffusivity=0.1,\n    particle_radius=radius_bins,\n    particle_density=1000,\n    particle_concentration=concentraiton_pmf,\n    temperature=293.15,\n    pressure=101325,\n    chamber_dimensions=(1, 1, 1),  # m\n)\n\n# plot rates\nfig, ax = plt.subplots()\nax.plot(radius_bins, coagulation_net, label=\"Coagulation Net\",)\nax.plot(radius_bins, dilution_loss, label=\"Dilution Loss\",)\nax.plot(radius_bins, chamber_wall_loss_rate, label=\"Chamber Wall Loss\",)\nax.plot(radius_bins, coagulation_net + dilution_loss + chamber_wall_loss_rate, label=\"Net Rate\", linestyle=\"--\")\nax.set_xscale(\"log\")\n# ax.set_yscale(\"log\")\nax.set_xlabel(\"Particle radius (m)\")\nax.set_ylabel(r\"Rate $\\dfrac{1}{m^{3} s^{1}}$\")\nax.grid()\nplt.legend()\nplt.show()\n</pre> # coagulation rate  mass_particle = 4/3 * np.pi * radius_bins**3 * 1000 # mass of the particles in kg  kernel = coagulation.brownian_coagulation_kernel_via_system_state(     radius_particle=radius_bins,     mass_particle= mass_particle,     temperature=293.15,     pressure=101325,     alpha_collision_efficiency=1, ) coagulation_loss = coagulation.discrete_loss(     concentration=concentraiton_pmf,     kernel=kernel, ) coagulation_gain = coagulation.discrete_gain(     radius=radius_bins,     concentration=concentraiton_pmf,     kernel=kernel, ) coagulation_net = coagulation_gain - coagulation_loss  # dilution rate dilution_coefficent = dilution.volume_dilution_coefficient(     volume=1, # m^3     input_flow_rate=2*1e-6, # m^3/s ) dilution_loss = dilution.dilution_rate(     coefficient=dilution_coefficent,     concentration=concentraiton_pmf, )  # wall loss rate chamber_wall_loss_rate = wall_loss.rectangle_wall_loss_rate(     wall_eddy_diffusivity=0.1,     particle_radius=radius_bins,     particle_density=1000,     particle_concentration=concentraiton_pmf,     temperature=293.15,     pressure=101325,     chamber_dimensions=(1, 1, 1),  # m )  # plot rates fig, ax = plt.subplots() ax.plot(radius_bins, coagulation_net, label=\"Coagulation Net\",) ax.plot(radius_bins, dilution_loss, label=\"Dilution Loss\",) ax.plot(radius_bins, chamber_wall_loss_rate, label=\"Chamber Wall Loss\",) ax.plot(radius_bins, coagulation_net + dilution_loss + chamber_wall_loss_rate, label=\"Net Rate\", linestyle=\"--\") ax.set_xscale(\"log\") # ax.set_yscale(\"log\") ax.set_xlabel(\"Particle radius (m)\") ax.set_ylabel(r\"Rate $\\dfrac{1}{m^{3} s^{1}}$\") ax.grid() plt.legend() plt.show() In\u00a0[9]: Copied! <pre># time steps\ntime_array = np.linspace(start=0, stop=3600, num=1000)\ndt = time_array[1] - time_array[0]\n\n# create a matrix to store the particle distribution at each time step\nconcentration_matrix = np.zeros((len(time_array), len(radius_bins)))\ncoagulation_net_matrix = np.zeros((len(time_array), len(radius_bins)))\ndilution_loss_matrix = np.zeros((len(time_array), len(radius_bins)))\nchamber_wall_loss_rate_matrix = np.zeros((len(time_array), len(radius_bins)))\n\n# set the initial concentration\nconcentration_matrix[0, :] = concentraiton_pmf\n\nkernel = coagulation.brownian_coagulation_kernel_via_system_state(\n    radius_particle=radius_bins,\n    mass_particle= mass_particle,\n    temperature=293.15,\n    pressure=101325,\n    alpha_collision_efficiency=1,\n)\n# iterate over the time steps\nfor i, time in enumerate(time_array[1:], start=1):\n\n    # calculate the coagulation rate\n    coagulation_loss = coagulation.discrete_loss(\n        concentration=concentration_matrix[i-1, :],\n        kernel=kernel,\n    )\n    coagulation_gain = coagulation.discrete_gain(\n        radius=radius_bins,\n        concentration=concentration_matrix[i-1, :],\n        kernel=kernel,\n    )\n    coagulation_net = coagulation_gain - coagulation_loss\n\n    # calculate the dilution rate\n    dilution_coefficent = dilution.volume_dilution_coefficient(\n        volume=1, # m^3\n        input_flow_rate=2*1e-6, # m^3/s\n    )\n    dilution_loss = dilution.dilution_rate(\n        coefficient=dilution_coefficent,\n        concentration=concentration_matrix[i-1, :],\n    )\n\n    # calculate the wall loss rate\n    chamber_wall_loss_rate = wall_loss.rectangle_wall_loss_rate(\n        wall_eddy_diffusivity=0.1,\n        particle_radius=radius_bins,\n        particle_density=1000,\n        particle_concentration=concentration_matrix[i-1, :],\n        temperature=293.15,\n        pressure=101325,\n        chamber_dimensions=(1, 1, 1),  # m\n    )\n\n    # update the concentration matrix\n    concentration_matrix[i, :] = concentration_matrix[i-1, :] + (coagulation_net + dilution_loss + chamber_wall_loss_rate) * dt\n\n    # update the rate matrices\n    coagulation_net_matrix[i, :] = coagulation_net\n    dilution_loss_matrix[i, :] = dilution_loss\n    chamber_wall_loss_rate_matrix[i, :] = chamber_wall_loss_rate\n\nprint(\"Done\")\n</pre> # time steps time_array = np.linspace(start=0, stop=3600, num=1000) dt = time_array[1] - time_array[0]  # create a matrix to store the particle distribution at each time step concentration_matrix = np.zeros((len(time_array), len(radius_bins))) coagulation_net_matrix = np.zeros((len(time_array), len(radius_bins))) dilution_loss_matrix = np.zeros((len(time_array), len(radius_bins))) chamber_wall_loss_rate_matrix = np.zeros((len(time_array), len(radius_bins)))  # set the initial concentration concentration_matrix[0, :] = concentraiton_pmf  kernel = coagulation.brownian_coagulation_kernel_via_system_state(     radius_particle=radius_bins,     mass_particle= mass_particle,     temperature=293.15,     pressure=101325,     alpha_collision_efficiency=1, ) # iterate over the time steps for i, time in enumerate(time_array[1:], start=1):      # calculate the coagulation rate     coagulation_loss = coagulation.discrete_loss(         concentration=concentration_matrix[i-1, :],         kernel=kernel,     )     coagulation_gain = coagulation.discrete_gain(         radius=radius_bins,         concentration=concentration_matrix[i-1, :],         kernel=kernel,     )     coagulation_net = coagulation_gain - coagulation_loss      # calculate the dilution rate     dilution_coefficent = dilution.volume_dilution_coefficient(         volume=1, # m^3         input_flow_rate=2*1e-6, # m^3/s     )     dilution_loss = dilution.dilution_rate(         coefficient=dilution_coefficent,         concentration=concentration_matrix[i-1, :],     )      # calculate the wall loss rate     chamber_wall_loss_rate = wall_loss.rectangle_wall_loss_rate(         wall_eddy_diffusivity=0.1,         particle_radius=radius_bins,         particle_density=1000,         particle_concentration=concentration_matrix[i-1, :],         temperature=293.15,         pressure=101325,         chamber_dimensions=(1, 1, 1),  # m     )      # update the concentration matrix     concentration_matrix[i, :] = concentration_matrix[i-1, :] + (coagulation_net + dilution_loss + chamber_wall_loss_rate) * dt      # update the rate matrices     coagulation_net_matrix[i, :] = coagulation_net     dilution_loss_matrix[i, :] = dilution_loss     chamber_wall_loss_rate_matrix[i, :] = chamber_wall_loss_rate  print(\"Done\") <pre>Done\n</pre> In\u00a0[10]: Copied! <pre># Plotting the simulation results\n# Adjusting the figure size for better clarity\nfig, ax = plt.subplots(1, 1, figsize=[8, 6])\n\n# plot the initial particle distribution\nax.plot(\n    radius_bins,\n    concentration_matrix[0, :],\n    label=\"Initial distribution\",\n)\n# plot the final particle distribution\nax.plot(radius_bins, concentration_matrix[-1, :], label=\"Final distribution\",)\nax.set_xscale(\"log\")\nax.set_xlabel(\"Particle radius (m)\")\nax.set_ylabel(r\"Particle Concentration (dN), $\\dfrac{1}{m^{3}}$\")\nplt.legend()\nplt.show()\n</pre> # Plotting the simulation results # Adjusting the figure size for better clarity fig, ax = plt.subplots(1, 1, figsize=[8, 6])  # plot the initial particle distribution ax.plot(     radius_bins,     concentration_matrix[0, :],     label=\"Initial distribution\", ) # plot the final particle distribution ax.plot(radius_bins, concentration_matrix[-1, :], label=\"Final distribution\",) ax.set_xscale(\"log\") ax.set_xlabel(\"Particle radius (m)\") ax.set_ylabel(r\"Particle Concentration (dN), $\\dfrac{1}{m^{3}}$\") plt.legend() plt.show()  In\u00a0[12]: Copied! <pre># plot the Initial and Final rates\nfig, ax = plt.subplots()\nax.plot(radius_bins, coagulation_net_matrix[1, :], label=\"Initial Coagulation Net\",)\nax.plot(radius_bins, dilution_loss_matrix[1, :], label=\"Initial Dilution Loss\",)\nax.plot(radius_bins, chamber_wall_loss_rate_matrix[1, :], label=\"Initial Chamber Wall Loss\",)\nax.plot(radius_bins, coagulation_net_matrix[-1, :], label=\"Final Coagulation Net\", linestyle=\"--\")\nax.plot(radius_bins, dilution_loss_matrix[-1, :], label=\"Final Dilution Loss\", linestyle=\"--\")\nax.plot(radius_bins, chamber_wall_loss_rate_matrix[-1, :], label=\"Final Chamber Wall Loss\", linestyle=\"--\")\nax.set_xscale(\"log\")\nax.set_xlabel(\"Particle radius (m)\")\nax.set_ylabel(r\"Rate $\\dfrac{1}{m^{3} s^{1}}$\")\nax.grid()\nplt.legend()\nplt.show()\n</pre> # plot the Initial and Final rates fig, ax = plt.subplots() ax.plot(radius_bins, coagulation_net_matrix[1, :], label=\"Initial Coagulation Net\",) ax.plot(radius_bins, dilution_loss_matrix[1, :], label=\"Initial Dilution Loss\",) ax.plot(radius_bins, chamber_wall_loss_rate_matrix[1, :], label=\"Initial Chamber Wall Loss\",) ax.plot(radius_bins, coagulation_net_matrix[-1, :], label=\"Final Coagulation Net\", linestyle=\"--\") ax.plot(radius_bins, dilution_loss_matrix[-1, :], label=\"Final Dilution Loss\", linestyle=\"--\") ax.plot(radius_bins, chamber_wall_loss_rate_matrix[-1, :], label=\"Final Chamber Wall Loss\", linestyle=\"--\") ax.set_xscale(\"log\") ax.set_xlabel(\"Particle radius (m)\") ax.set_ylabel(r\"Rate $\\dfrac{1}{m^{3} s^{1}}$\") ax.grid() plt.legend() plt.show()"},{"location":"How-To-Guides/Chamber_Wall_Loss/Notebooks/Chamber_Forward_Simulation/#chamber-forward-simulation","title":"Chamber Forward Simulation\u00b6","text":"<p>Comprehending particle dynamics within controlled environments is fundamental for the precise interpretation of experimental measurements. An aerosol chamber forward simulation is an approach employed to analyze and predict the behavior of particles under laboratory conditions. This method enables us to construct a virtual representation of the chamber dynamics, providing a platform to systematically examine the influence of different physical and chemical processes on aerosol populations. Specifically, we focus on three key processes: chamber aerosol dilution, particle coagulation, and wall loss (deposition). Each of these plays a pivotal role in shaping the size distribution of particles:</p> <ul> <li>Chamber Aerosol Dilution: Dilution refers to the reduction in particle concentration due to the introduction of clean air into the chamber. This process can lead to a decrease in the overall number of particles without altering the size distribution significantly. However, it can indirectly influence the dynamics of coagulation and deposition by changing the particle concentration.</li> <li>Particle Coagulation: Coagulation is the process where particles collide and stick together, forming larger particles. This leads to a shift in the size distribution towards larger sizes, reducing the number of smaller particles and increasing the average size of particles in the chamber. Coagulation is particularly significant for smaller particles due to their higher Brownian motion and likelihood of interaction.</li> <li>Wall Loss (Deposition): Wall loss occurs when particles deposit onto the walls of the chamber, removing them from the airborne population. This process preferentially affects larger particles due to their greater settling velocity and can lead to a decrease in the overall number of particles and a subtle shift in the size distribution towards smaller sizes.</li> </ul> <p>We'll be running a simulation of a chamber experiment, and turn on/off each of these processes to see how they affect the size distribution of particles. We'll also be able to see how the size distribution changes over time as the experiment progresses.</p> <p>The initial <code>particula</code> imports are next.</p>"},{"location":"How-To-Guides/Chamber_Wall_Loss/Notebooks/Chamber_Forward_Simulation/#initial-distribution","title":"Initial Distribution\u00b6","text":"<p>In this section, we define the initial conditions and parameters for our chamber simulation. The <code>simple_dic_kwargs</code> dictionary contains all the necessary parameters to initialize our particle distribution within the chamber. Here's a breakdown of each parameter:</p> <ul> <li>mode: The median diameter of the particles.</li> <li>geometric_standard_deviation: The geometric standard deviation of the particle size distribution.</li> <li>number_in_mode: The number of particles in the mode.</li> </ul> <p>We define the radius bins, logarithmically, the we can get the particle concentration in a Probability Mass Function (PMF) representation. Or more commonly called <code>dN</code>.</p>"},{"location":"How-To-Guides/Chamber_Wall_Loss/Notebooks/Chamber_Forward_Simulation/#rates","title":"Rates\u00b6","text":"<p>With the initial concentration setup we can now get the rates of change for the distribution of particles. These come from the <code>dynamics</code> module, which contains the functions to calculate the rates of change for each process. The <code>dynamics</code> module contains the following functions:</p> <ul> <li><code>dilution_rate</code>: Calculates the rate of change due to dilution.</li> <li><code>coagulation_rate</code>: Calculates the rate of change due to coagulation.</li> <li><code>wall_loss_rate</code>: Calculates the rate of change due to wall loss.</li> </ul>"},{"location":"How-To-Guides/Chamber_Wall_Loss/Notebooks/Chamber_Forward_Simulation/#for-loop-simulation","title":"For-loop Simulation\u00b6","text":"<p>With the an example of how to calculate the rates of change for each process, we can now simulate the chamber experiment. We'll iterate over a series of time steps and calculate the change in particle concentration due to each process. This is an iterative process where we update the particle distribution at each time step based on the rates of change calculated for dilution, coagulation, and wall loss. The rates are also updated at each time step to account for the changing particle concentration within the chamber.</p>"},{"location":"How-To-Guides/Chamber_Wall_Loss/Notebooks/Chamber_Forward_Simulation/#visualization-of-particle-size-distribution-over-time","title":"Visualization of Particle Size Distribution Over Time\u00b6","text":"<p>In our chamber simulation, the output solution is a matrix representing the evolution of particle size distribution over time. Specifically, the solution is a 500x100 matrix where each row corresponds to a specific particle size (500 size bins in total), and each column represents the particle distribution at a given time point (100 time steps in total).</p> <p>The semi-logarithmic plot visualizes how the particle size distribution changes over the course of the simulation. We are focusing on three specific time points to illustrate these dynamics:</p> <ul> <li>Initial Distribution: This is the distribution at the beginning of the simulation (t=0). It sets the baseline for how particles are initially distributed across different sizes.</li> <li>Mid-Time Distribution: Represents the distribution at a midpoint in time (here, at the 50th time step out of 100). This snapshot provides insight into the evolution of the distribution as particles undergo processes like coagulation, dilution, and wall loss.</li> <li>Final Distribution: Shows the distribution at the end of the simulation (at the 100th time step). It indicates the final state of the particle sizes after all the simulated processes have taken place over the full time course.</li> </ul> <p>By comparing these three distributions, we can observe and analyze how the particle sizes have coalesced, dispersed, or shifted due to the underlying aerosol dynamics within the chamber.</p>"},{"location":"How-To-Guides/Chamber_Wall_Loss/Notebooks/Chamber_Forward_Simulation/#takeaways","title":"Takeaways\u00b6","text":"<p>In this notebook, we conducted a series of simulations to study the behavior of aerosol particles within a controlled chamber environment. Our objective was to understand how different processes \u2014 namely coagulation, dilution, and wall loss \u2014 individually and collectively influence the size distribution of particles over time.</p> <p>Our simulations revealed several key findings:</p> <ul> <li>Coagulation Alone: When only coagulation was considered, the particle size distribution shifted towards larger particles as expected, since smaller particles tend to combine. However, this view was incomplete as it did not account for other loss mechanisms.</li> <li>Importance of Wall Loss: The inclusion of wall loss in the simulations proved to be significant. Wall loss, or deposition, especially affected the larger particles due to their higher probability of contact with the chamber walls. This process led to a noticeable reduction in the number concentration of particles, altering the peak and width of the size distribution.</li> <li>Combined Processes: By simulating a combination of processes, we observed a more complex and realistic representation of particle dynamics. The coagulation plus dilution scenario showed a lower overall concentration across all sizes, while adding wall loss further decreased the number concentration and altered the distribution shape, underscoring the importance of including wall loss in chamber simulations.</li> </ul> <p>The comparison between the different scenarios highlighted that coagulation alone could not fully explain the experimental observations. The absence of wall loss from the simulation would lead to discrepancies when comparing with empirical data, as wall loss is a critical process in chamber dynamics.</p>"},{"location":"How-To-Guides/Equilibria/","title":"Index Equilibria","text":""},{"location":"How-To-Guides/Equilibria/#notebooks","title":"Notebooks","text":"<ul> <li>Activity Coefficients</li> <li>Liquid-Liquid Equilibrium</li> </ul>"},{"location":"How-To-Guides/Equilibria/#what-is-equilibria","title":"What is Equilibria?","text":"<p>Equilibria, a fundamental concept in physical chemistry, refers to the state where the concentrations of reactants and products in a chemical reaction remain constant over time. In the context of aerosol science, equilibria are essential in understanding how aerosol particles interact with their environment, particularly with respect to liquid and vapor phases. This balance is crucial in predicting how aerosols behave under different atmospheric conditions.</p>"},{"location":"How-To-Guides/Equilibria/#why-is-equilibria-important","title":"Why is Equilibria Important?","text":"<p>Studying equilibria in aerosol systems is vital for several reasons:</p> <ol> <li> <p>Environmental Impact: Aerosols play a significant role in air quality and climate change. Understanding their equilibrium behavior helps in assessing their environmental impact, such as their role in cloud formation and solar radiation scattering.</p> </li> <li> <p>Health Implications: Aerosols affect human health, especially in terms of respiratory issues. Knowledge of equilibrium states helps in evaluating exposure risks and designing mitigation strategies.</p> </li> <li> <p>Atmospheric Chemistry: Equilibria studies contribute to our understanding of atmospheric chemistry, particularly in the formation and transformation of aerosols.</p> </li> </ol>"},{"location":"How-To-Guides/Equilibria/#how-does-equilibria-relate-to-these-notebooks","title":"How Does Equilibria Relate to These Notebooks?","text":"<p>The notebooks presented here are dedicated to exploring various aspects of equilibria in aerosol science:</p> <ol> <li> <p>Activity Coefficients and Phase Behavior: By calculating activity coefficients, we can predict how different components of aerosols partition between liquid and vapor phases. This is crucial in understanding the composition and concentration of aerosols under varying atmospheric conditions.</p> </li> <li> <p>Liquid-Vapor Equilibrium: The notebook delves into the equilibrium compositions of liquid-vapor mixtures, highlighting the role of relative humidity (RH) in shaping aerosol behavior.</p> </li> <li> <p>Practical Applications: Through examples and simulations, these notebooks provide practical insights into real-world scenarios, enhancing our understanding of aerosols in environmental and health contexts.</p> </li> </ol> <p>Overall, the notebooks serve as an interactive platform to explore and understand the complex yet fascinating world of equilibria in aerosol science. Whether you're a student, researcher, or enthusiast, these materials offer valuable insights into the dynamic equilibrium processes that govern aerosol behavior in our atmosphere.</p>"},{"location":"How-To-Guides/Equilibria/Notebooks/activity_part1/","title":"Activity Example","text":"In\u00a0[1]: Copied! <pre>import numpy as np  # For numerical operations\nimport matplotlib.pyplot as plt  # For plotting graphs\n# Specific functions from the particula package for activity calculations\nfrom particula.activity import binary_activity, phase_separation, species_density\n</pre> import numpy as np  # For numerical operations import matplotlib.pyplot as plt  # For plotting graphs # Specific functions from the particula package for activity calculations from particula.activity import binary_activity, phase_separation, species_density In\u00a0[2]: Copied! <pre># Define a range of organic mole fractions for the calculation\norganic_mole_fraction = np.linspace(0.001, 1, 1000)\n\n# Define other necessary parameters\noxygen2carbon = 0.225  # Oxygen to carbon ratio\nmolar_mass_ratio = 18.016 / 100  # Water to organic molecular weight ratio\ndensity = species_density.organic_density_estimate(\n    18.016 / molar_mass_ratio,\n    oxygen2carbon)  # Estimate of organic compound density\n\n# Calculate activity coefficients using the binary_activity function\nactivity_water, activity_organic, mass_water, mass_organic, gamma_water, gamma_organic = \\\n    binary_activity.activity_coefficients(\n        molar_mass_ratio,\n        organic_mole_fraction,\n        oxygen2carbon,\n        density,\n        functional_group=None)\n</pre> # Define a range of organic mole fractions for the calculation organic_mole_fraction = np.linspace(0.001, 1, 1000)  # Define other necessary parameters oxygen2carbon = 0.225  # Oxygen to carbon ratio molar_mass_ratio = 18.016 / 100  # Water to organic molecular weight ratio density = species_density.organic_density_estimate(     18.016 / molar_mass_ratio,     oxygen2carbon)  # Estimate of organic compound density  # Calculate activity coefficients using the binary_activity function activity_water, activity_organic, mass_water, mass_organic, gamma_water, gamma_organic = \\     binary_activity.activity_coefficients(         molar_mass_ratio,         organic_mole_fraction,         oxygen2carbon,         density,         functional_group=None) In\u00a0[3]: Copied! <pre>fig, ax = plt.subplots()\nax.plot(\n    1 - organic_mole_fraction,\n    activity_water,\n    label=\"water\",\n    linestyle='dashed'\n)\nax.plot(\n    1 - organic_mole_fraction,\n    activity_organic,\n    label=\"organic\",\n)\nax.set_ylim()\nax.set_xlabel(\"water mole fraction\")\nax.set_ylabel(\"activity\")\nax.legend()\nplt.show()\n\nfig, ax = plt.subplots()\nax.plot(\n    1 - organic_mole_fraction,\n    gamma_water,\n    label=\"water\",\n    linestyle='dashed'\n)\nax.plot(\n    1 - organic_mole_fraction,\n    gamma_organic,\n    label=\"organic\",\n)\nax.set_ylim()\nax.set_xlabel(\"water mole fraction\")\nax.set_ylabel(\"activity coefficient\")\nax.legend()\nplt.show()\n</pre> fig, ax = plt.subplots() ax.plot(     1 - organic_mole_fraction,     activity_water,     label=\"water\",     linestyle='dashed' ) ax.plot(     1 - organic_mole_fraction,     activity_organic,     label=\"organic\", ) ax.set_ylim() ax.set_xlabel(\"water mole fraction\") ax.set_ylabel(\"activity\") ax.legend() plt.show()  fig, ax = plt.subplots() ax.plot(     1 - organic_mole_fraction,     gamma_water,     label=\"water\",     linestyle='dashed' ) ax.plot(     1 - organic_mole_fraction,     gamma_organic,     label=\"organic\", ) ax.set_ylim() ax.set_xlabel(\"water mole fraction\") ax.set_ylabel(\"activity coefficient\") ax.legend() plt.show() In\u00a0[4]: Copied! <pre># Finding phase separation points and calculating q_alpha\nphase_sep_aw = phase_separation.find_phase_separation(\n    activity_water, activity_organic)\nq_alpha = phase_separation.q_alpha(\n    seperation_activity=phase_sep_aw['upper_seperation'],\n    activities=activity_water)\n\n# Plotting q_alpha\nfig, ax = plt.subplots()\nplt.plot(activity_water, q_alpha)\nplt.xlabel('Water Activity')\nplt.ylabel('$q^{\\\\alpha}$ [Organic Rich to Water Rich]')\nplt.show()\n</pre> # Finding phase separation points and calculating q_alpha phase_sep_aw = phase_separation.find_phase_separation(     activity_water, activity_organic) q_alpha = phase_separation.q_alpha(     seperation_activity=phase_sep_aw['upper_seperation'],     activities=activity_water)  # Plotting q_alpha fig, ax = plt.subplots() plt.plot(activity_water, q_alpha) plt.xlabel('Water Activity') plt.ylabel('$q^{\\\\alpha}$ [Organic Rich to Water Rich]') plt.show() In\u00a0[5]: Copied! <pre># select the water activity desired\nwater_activity_desired = np.linspace(0.5, 1, 100)\noxygen2carbon = 0.25\n\n# calculate the mass fraction of water in the alpha and beta phases\n# for each water activity\nalpha, beta, q_alpha = binary_activity.fixed_water_activity(\n        water_activity=water_activity_desired,\n        molar_mass_ratio=molar_mass_ratio,\n        oxygen2carbon=oxygen2carbon,\n        density=density\n        )\n\n# plot the results vs water activity\nfig, ax = plt.subplots()\nax.plot(\n    water_activity_desired,\n    alpha[2],\n    label=\"alpha phase mass fraction water\",\n)\nax.plot(\n        water_activity_desired,\n        q_alpha,\n        label=\"q_alpha\",\n        )\nif beta is not None:\n    ax.plot(\n        water_activity_desired,\n        beta[2],\n        label=\"beta phase mass fraction water\",\n    )\nax.set_ylim()\nax.set_xlabel(\"water activity (Relative Humidity/100)\")\nax.set_ylabel(\"mass fraction of water\")\nplt.legend()\nplt.show()\n</pre> # select the water activity desired water_activity_desired = np.linspace(0.5, 1, 100) oxygen2carbon = 0.25  # calculate the mass fraction of water in the alpha and beta phases # for each water activity alpha, beta, q_alpha = binary_activity.fixed_water_activity(         water_activity=water_activity_desired,         molar_mass_ratio=molar_mass_ratio,         oxygen2carbon=oxygen2carbon,         density=density         )  # plot the results vs water activity fig, ax = plt.subplots() ax.plot(     water_activity_desired,     alpha[2],     label=\"alpha phase mass fraction water\", ) ax.plot(         water_activity_desired,         q_alpha,         label=\"q_alpha\",         ) if beta is not None:     ax.plot(         water_activity_desired,         beta[2],         label=\"beta phase mass fraction water\",     ) ax.set_ylim() ax.set_xlabel(\"water activity (Relative Humidity/100)\") ax.set_ylabel(\"mass fraction of water\") plt.legend() plt.show() In\u00a0[6]: Copied! <pre># select the water activity desired\nwater_activity_desired = np.linspace(0.5, 1, 100)\n# select the oxygen to carbon ratio\noxygen2carbon = 0.6\n\n# calculate the mass fraction of water in the alpha and beta phases\n# for each water activity\nalpha, beta, q_alpha = binary_activity.fixed_water_activity(\n    water_activity=water_activity_desired,\n    molar_mass_ratio=molar_mass_ratio,\n    oxygen2carbon=oxygen2carbon,\n    density=density\n)\n\n# plot the results vs water activity\nfig, ax = plt.subplots()\nax.plot(\n    water_activity_desired,\n    alpha[2],\n    label=\"alpha phase mass fraction water\",\n)\nax.plot(\n    water_activity_desired,\n    q_alpha,\n    label=\"q_alpha\",\n)\nif beta is not None:\n    ax.plot(\n        water_activity_desired,\n        beta[2],\n        label=\"beta phase mass fraction water\",\n    )\nax.set_ylim()\nax.set_xlabel(\"water activity (Relative Humidity/100)\")\nax.set_ylabel(\"mass fraction of water\")\nplt.legend()\nplt.show()\n</pre> # select the water activity desired water_activity_desired = np.linspace(0.5, 1, 100) # select the oxygen to carbon ratio oxygen2carbon = 0.6  # calculate the mass fraction of water in the alpha and beta phases # for each water activity alpha, beta, q_alpha = binary_activity.fixed_water_activity(     water_activity=water_activity_desired,     molar_mass_ratio=molar_mass_ratio,     oxygen2carbon=oxygen2carbon,     density=density )  # plot the results vs water activity fig, ax = plt.subplots() ax.plot(     water_activity_desired,     alpha[2],     label=\"alpha phase mass fraction water\", ) ax.plot(     water_activity_desired,     q_alpha,     label=\"q_alpha\", ) if beta is not None:     ax.plot(         water_activity_desired,         beta[2],         label=\"beta phase mass fraction water\",     ) ax.set_ylim() ax.set_xlabel(\"water activity (Relative Humidity/100)\") ax.set_ylabel(\"mass fraction of water\") plt.legend() plt.show()"},{"location":"How-To-Guides/Equilibria/Notebooks/activity_part1/#activity-example","title":"Activity Example\u00b6","text":"<p>This notebook demonstrates the Binary Activity Theory (BAT) model application, crucial for calculating the activity of water and organic compounds in mixtures and understanding phase separation. This model, as detailed in Gorkowski, K., Preston, T. C., &amp; Zuend, A. (2019), provides critical insights into aerosol particle behavior, essential in environmental and climate change research.</p> <p>Reference: Gorkowski, K., Preston, T. C., &amp; Zuend, A. (2019). Relative-humidity-dependent organic aerosol thermodynamics Via an efficient reduced-complexity model. Atmospheric Chemistry and Physics https://doi.org/10.5194/acp-19-13383-2019</p>"},{"location":"How-To-Guides/Equilibria/Notebooks/activity_part1/#activity-calculation","title":"Activity Calculation\u00b6","text":"<p>Define the parameters required by the activity module to calculate the activity of water and organic compounds in a mixture, as well as phase separation. These parameters include organic mole fraction, density, molecular weight ratio [water/organic], and the density of the organic compound. Using these parameters helps in accurately modeling the behavior of aerosol particles in various environmental conditions.</p>"},{"location":"How-To-Guides/Equilibria/Notebooks/activity_part1/#plotting-the-activity-and-phase-separation","title":"Plotting the Activity and Phase Separation\u00b6","text":"<p>Here we plot the activity of water and the organic compound as a function of the organic mole fraction. Visualizing these activities helps in identifying phase separation or miscibility gaps, crucial for understanding the behavior of aerosols under different environmental conditions. Phase separation is indicated by activities greater than 1.0 or non-monotonic behavior in the activity curve, as shown below.</p>"},{"location":"How-To-Guides/Equilibria/Notebooks/activity_part1/#qalpha","title":"$ q^\\alpha $\u00b6","text":"<p>The $q^\\alpha$ parameter signifies the transition from an organic-rich phase to a water-rich phase. This transition is crucial for understanding the phase behavior of aerosol particles. It can be calculated using the <code>particula.activity.phase_separation</code> function. The plot below illustrates $q^\\alpha$ based on the activity calculations performed earlier.</p>"},{"location":"How-To-Guides/Equilibria/Notebooks/activity_part1/#water-activity-focus","title":"Water Activity Focus\u00b6","text":"<p>In atmospheric aerosol modeling, water activity is often a more critical parameter than mole fraction. This is because water activity is typically a controllable or known variable in atmospheric conditions, unlike the exact mole fractions in a solution. To correlate water activity with the mole fraction required to achieve it, we utilize functions from the <code>particula.activity</code> module.</p>"},{"location":"How-To-Guides/Equilibria/Notebooks/activity_part1/#higher-oxygen-to-carbon-ratios","title":"Higher Oxygen to Carbon Ratios\u00b6","text":"<p>Higher oxygen to carbon ratios in the mixture tend to inhibit phase separation. The following analysis demonstrates this effect. This observation is crucial in predicting the behavior of aerosol particles under varying chemical compositions (more or less 'aged').</p>"},{"location":"How-To-Guides/Equilibria/Notebooks/activity_part1/#summary","title":"Summary\u00b6","text":"<p>This notebook demonstrates how to use the activity module for calculating the activity of water and organic compounds in a mixture and assessing phase separation. The insights gained are vital for applications in aerosol thermodynamics, cloud condensation nuclei, and cloud microphysics.</p> <p>This is an implementation of the Binary Activity Theory (BAT) model developed in Gorkowski, K., Preston, T. C., &amp; Zuend, A. (2019).</p>"},{"location":"How-To-Guides/Equilibria/Notebooks/equilibria_part1/","title":"Liquid Vapor Equilibrium","text":"In\u00a0[1]: Copied! <pre># Importing necessary libraries\nimport matplotlib.pyplot as plt  # For creating plots and visualizations\nimport numpy as np  # For numerical operations\nfrom particula.activity import species_density  # For calculating species density\n# For partitioning calculations in liquid-vapor equilibrium\nfrom particula.equilibria import partitioning\n</pre> # Importing necessary libraries import matplotlib.pyplot as plt  # For creating plots and visualizations import numpy as np  # For numerical operations from particula.activity import species_density  # For calculating species density # For partitioning calculations in liquid-vapor equilibrium from particula.equilibria import partitioning In\u00a0[2]: Copied! <pre># Defining system parameters\nc_star_j_dry = [1e-6, 1e-4, 1e-1, 1e2, 1e4]  # Volatility distribution in ug/m3\n# Total concentration in ug/m3\nconcentration_organic_matter = [1, 5, 10, 15, 10]\noxygen2carbon = np.array([0.2, 0.3, 0.5, 0.4, 0.4])  # Oxygen to carbon ratios\n\nmolar_mass = np.array([200, 200, 200, 200, 200])  # Molar mass in g/mol\nwater_activity_desired = np.array([0.8])  # Desired water activity\nmolar_mass_ratio = 18.015 / np.array(molar_mass)  # Molar mass ratio\n\n# Calculate the density of organic compounds\ndensity = species_density.organic_array(\n    molar_mass,\n    oxygen2carbon,\n    hydrogen2carbon=None,\n    nitrogen2carbon=None)\n</pre> # Defining system parameters c_star_j_dry = [1e-6, 1e-4, 1e-1, 1e2, 1e4]  # Volatility distribution in ug/m3 # Total concentration in ug/m3 concentration_organic_matter = [1, 5, 10, 15, 10] oxygen2carbon = np.array([0.2, 0.3, 0.5, 0.4, 0.4])  # Oxygen to carbon ratios  molar_mass = np.array([200, 200, 200, 200, 200])  # Molar mass in g/mol water_activity_desired = np.array([0.8])  # Desired water activity molar_mass_ratio = 18.015 / np.array(molar_mass)  # Molar mass ratio  # Calculate the density of organic compounds density = species_density.organic_array(     molar_mass,     oxygen2carbon,     hydrogen2carbon=None,     nitrogen2carbon=None) In\u00a0[3]: Copied! <pre># Calculate the properties needed for liquid-vapor partitioning\ngamma_organic_ab, mass_fraction_water_ab, q_ab = \\\n    partitioning.get_properties_for_liquid_vapor_partitioning(\n        water_activity_desired=water_activity_desired,\n        molar_mass=molar_mass,\n        oxygen2carbon=oxygen2carbon,\n        density=density,\n    )\n\n# The optimization the partition coefficients, i.e. the partitioning calculation\nalpha_opt, beta_opt, system_opt, fit_result = \\\n    partitioning.liquid_vapor_partitioning(\n        c_star_j_dry=c_star_j_dry,\n        concentration_organic_matter=concentration_organic_matter,\n        molar_mass=molar_mass,\n        gamma_organic_ab=gamma_organic_ab,\n        mass_fraction_water_ab=mass_fraction_water_ab,\n        q_ab=q_ab,\n        partition_coefficient_guess=None,\n    )\n\nprint(f\"mass in organic aerosol [ug/m3]: {system_opt[0]}\")\nprint(f\"mass in water [ug/3]: {system_opt[1]}\")\n</pre> # Calculate the properties needed for liquid-vapor partitioning gamma_organic_ab, mass_fraction_water_ab, q_ab = \\     partitioning.get_properties_for_liquid_vapor_partitioning(         water_activity_desired=water_activity_desired,         molar_mass=molar_mass,         oxygen2carbon=oxygen2carbon,         density=density,     )  # The optimization the partition coefficients, i.e. the partitioning calculation alpha_opt, beta_opt, system_opt, fit_result = \\     partitioning.liquid_vapor_partitioning(         c_star_j_dry=c_star_j_dry,         concentration_organic_matter=concentration_organic_matter,         molar_mass=molar_mass,         gamma_organic_ab=gamma_organic_ab,         mass_fraction_water_ab=mass_fraction_water_ab,         q_ab=q_ab,         partition_coefficient_guess=None,     )  print(f\"mass in organic aerosol [ug/m3]: {system_opt[0]}\") print(f\"mass in water [ug/3]: {system_opt[1]}\") <pre>mass in organic aerosol [ug/m3]: 22.37729297689113\nmass in water [ug/3]: 4.826984139901269\n</pre> In\u00a0[4]: Copied! <pre># Calculating activity coefficients across a range of RH values\n# Range of water activity (RH/100)\nwater_activity_curve = np.linspace(0.01, 0.99, 80)\ntotal_oa_concentration = np.empty([len(water_activity_curve), 1], dtype=float)\nwater_concentration = np.empty([len(water_activity_curve), 1], dtype=float)\n\nfor i, water_activity in enumerate(water_activity_curve):\n    # Get properties for liquid-vapor partitioning at each RH value\n    gamma_organic_ab, mass_fraction_water_ab, q_ab = \\\n        partitioning.get_properties_for_liquid_vapor_partitioning(\n            water_activity_desired=water_activity,\n            molar_mass=molar_mass,\n            oxygen2carbon=oxygen2carbon,\n            density=density,\n        )\n\n    # Optimize the partition coefficients for each RH value\n    alpha_opt, beta_opt, system_opt, fit_result = \\\n        partitioning.liquid_vapor_partitioning(\n            c_star_j_dry=c_star_j_dry,\n            concentration_organic_matter=concentration_organic_matter,\n            molar_mass=molar_mass,\n            gamma_organic_ab=gamma_organic_ab,\n            mass_fraction_water_ab=mass_fraction_water_ab,\n            q_ab=q_ab,\n            partition_coefficient_guess=None,\n        )\n\n    # Record the total organic and water concentration\n    total_oa_concentration[i] = system_opt[0]\n    water_concentration[i] = system_opt[1]\n\nprint('Calculation complete')\n</pre> # Calculating activity coefficients across a range of RH values # Range of water activity (RH/100) water_activity_curve = np.linspace(0.01, 0.99, 80) total_oa_concentration = np.empty([len(water_activity_curve), 1], dtype=float) water_concentration = np.empty([len(water_activity_curve), 1], dtype=float)  for i, water_activity in enumerate(water_activity_curve):     # Get properties for liquid-vapor partitioning at each RH value     gamma_organic_ab, mass_fraction_water_ab, q_ab = \\         partitioning.get_properties_for_liquid_vapor_partitioning(             water_activity_desired=water_activity,             molar_mass=molar_mass,             oxygen2carbon=oxygen2carbon,             density=density,         )      # Optimize the partition coefficients for each RH value     alpha_opt, beta_opt, system_opt, fit_result = \\         partitioning.liquid_vapor_partitioning(             c_star_j_dry=c_star_j_dry,             concentration_organic_matter=concentration_organic_matter,             molar_mass=molar_mass,             gamma_organic_ab=gamma_organic_ab,             mass_fraction_water_ab=mass_fraction_water_ab,             q_ab=q_ab,             partition_coefficient_guess=None,         )      # Record the total organic and water concentration     total_oa_concentration[i] = system_opt[0]     water_concentration[i] = system_opt[1]  print('Calculation complete') <pre>Calculation complete\n</pre> In\u00a0[5]: Copied! <pre>fig, ax = plt.subplots()\nax.plot(water_activity_curve, total_oa_concentration,\n        label='total organic concentration', color='green')\naw=ax.twinx()\naw.plot(water_activity_curve, water_concentration,\n        label='water concentration', color='blue')\nplt.legend(loc='upper left')\nax.set_xlabel('water activity (a_w is RH/100)')\n\nhandles, labels = ax.get_legend_handles_labels()\naw_handles, aw_labels = aw.get_legend_handles_labels()\nhandles.extend(aw_handles)\nlabels.extend(aw_labels)\nplt.legend(handles, labels, loc='upper left')\n\nax.set_ylabel('organic aerosol concentration [ug/m3]')\naw.set_ylabel('aerosol water concentration [ug/m3]')\nplt.show()\n</pre> fig, ax = plt.subplots() ax.plot(water_activity_curve, total_oa_concentration,         label='total organic concentration', color='green') aw=ax.twinx() aw.plot(water_activity_curve, water_concentration,         label='water concentration', color='blue') plt.legend(loc='upper left') ax.set_xlabel('water activity (a_w is RH/100)')  handles, labels = ax.get_legend_handles_labels() aw_handles, aw_labels = aw.get_legend_handles_labels() handles.extend(aw_handles) labels.extend(aw_labels) plt.legend(handles, labels, loc='upper left')  ax.set_ylabel('organic aerosol concentration [ug/m3]') aw.set_ylabel('aerosol water concentration [ug/m3]') plt.show()"},{"location":"How-To-Guides/Equilibria/Notebooks/equilibria_part1/#liquid-vapor-equilibrium","title":"Liquid Vapor Equilibrium\u00b6","text":"<p>This notebook explores the calculation of equilibrium composition in liquid-vapor mixtures, a crucial concept in aerosol science and environmental studies. We utilize an activity coefficient model to understand how different volatile organic compounds distribute between the liquid and vapor phases. This analysis is particularly important for predicting aerosol behavior and understanding atmospheric processes.</p>"},{"location":"How-To-Guides/Equilibria/Notebooks/equilibria_part1/#setup-the-system","title":"Setup the System\u00b6","text":"<p>To simulate the liquid-vapor equilibrium, we define several key parameters:</p> <ul> <li><code>c_star_j_dry</code>: Represents the volatility distribution of organic compounds in dry air, calculable from vapor pressure.</li> <li><code>concentration_organic_matter</code>: The combined concentration of vapor and liquid organic matter in the system.</li> <li><code>oxygen2carbon</code>: The ratio of oxygen to carbon in the organic compounds, crucial for characterizing their chemical nature.</li> <li><code>molar_mass</code>: The molar mass of the organic compounds.</li> </ul> <p>These parameters help us determine the density of organics in the system, a vital step in understanding their distribution between phases.</p>"},{"location":"How-To-Guides/Equilibria/Notebooks/equilibria_part1/#calculate-the-activity-coefficients","title":"Calculate the Activity Coefficients\u00b6","text":"<p>The next step involves calculating the activity coefficients, which are pivotal in determining how the organic compounds distribute between the liquid and vapor phases. We use the <code>partitioning.get_properties_for_liquid_vapor_equilibrium</code> function, a specialized tool that simplifies the process by returning only the essential properties: activity coefficients, mass fractions, and the two-phase q values for the alpha-beta equilibrium.</p>"},{"location":"How-To-Guides/Equilibria/Notebooks/equilibria_part1/#activity-coefficients-as-a-function-of-relative-humidity-frh","title":"Activity Coefficients as a Function of Relative Humidity (f(RH))\u00b6","text":"<p>The binary activity model's key feature is its interaction with water, particularly through relative humidity (RH). Here, we will calculate how the activity coefficients vary as a function of RH. This is done by iterating over a range of RH values and computing the corresponding activity coefficients, providing insights into how atmospheric humidity influences the equilibrium behavior of the system.</p>"},{"location":"How-To-Guides/Equilibria/Notebooks/equilibria_part1/#plotting-the-equilibrium-composition-vs-relative-humidity","title":"Plotting the Equilibrium Composition vs. Relative Humidity\u00b6","text":"<p>Now that we have calculated the equilibrium composition for a range of RH values, we will visualize these results. The plot will show how the total organic aerosol concentration and the water concentration in the aerosol vary with changing RH. This visualization is crucial for understanding the dynamic behavior of aerosols in different atmospheric humidity conditions.</p>"},{"location":"How-To-Guides/Equilibria/Notebooks/equilibria_part1/#summary","title":"Summary\u00b6","text":"<p>In this notebook, we have journeyed through the process of defining a liquid-vapor equilibrium system and employing the binary activity model to calculate activity coefficients as a function of relative humidity (RH). We then used these coefficients to determine the equilibrium composition of the liquid and vapor phases. Finally, the results were visualized to demonstrate the impact of RH on aerosol behavior, which is essential for understanding atmospheric aerosol dynamics and their environmental implications.</p>"},{"location":"How-To-Guides/Nucleation/","title":"Nucleation","text":"<p>How to implement a custom nucleation model, and manually add particles to the simulation.</p>"},{"location":"How-To-Guides/Nucleation/#notebooks","title":"Notebooks","text":"<ul> <li>Single Species</li> </ul>"},{"location":"How-To-Guides/Nucleation/Notebooks/Custom_Nucleation_Single_Species/","title":"Custom Nucleation: Single Species","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# particula imports\nfrom particula import particles, dynamics\nfrom particula.aerosol import Aerosol\n\n# Gas phase species and atmosphere builders\nfrom particula.gas.species_builders import GasSpeciesBuilder\nfrom particula.gas.atmosphere_builders import AtmosphereBuilder\n\n# Vapor pressure factory for calculating vapor pressures\nfrom particula.gas.vapor_pressure_factories import VaporPressureFactory\n\nfrom particula.util.input_handling import convert_units\n</pre> import numpy as np import matplotlib.pyplot as plt  # particula imports from particula import particles, dynamics from particula.aerosol import Aerosol  # Gas phase species and atmosphere builders from particula.gas.species_builders import GasSpeciesBuilder from particula.gas.atmosphere_builders import AtmosphereBuilder  # Vapor pressure factory for calculating vapor pressures from particula.gas.vapor_pressure_factories import VaporPressureFactory  from particula.util.input_handling import convert_units In\u00a0[2]: Copied! <pre># Build the sulfate gas species\n\n# Ammonium sulfate properties\nmolar_mass_ammonium_sulfate = 132.14e-3  # kg/mol\ndensity_ammonium_sulfate = 1.77e3  # kg/m^3\n\n# Define vapor pressure parameters for ammonium sulfate\nparameters_vapor = {\n    \"vapor_pressure\": 4e-12,  # pascal\n    \"vapor_pressure_units\": \"atm\",  # units\n}\n\n# Create a constant vapor pressure strategy using the VaporPressureFactory\nvapor_pressure_sulfate = VaporPressureFactory().get_strategy(\n    \"constant\", parameters_vapor\n)\n\n# Calculate the saturation concentration at a given temperature\nsulfate_saturation = vapor_pressure_sulfate.saturation_concentration(\n    molar_mass=molar_mass_ammonium_sulfate,\n    temperature=298.15,  # Kelvin\n)\n\n# Set initial sulfate concentration as a fraction of saturation concentration\ninitial_sulfate_concentration = 0.5 * sulfate_saturation  # kg/m^3\n\n# Build the sulfate gas species using the GasSpeciesBuilder\ngas_sulfate = (\n    GasSpeciesBuilder()\n    .set_name(\"sulfate\")\n    .set_molar_mass(molar_mass_ammonium_sulfate, \"kg/mol\")\n    .set_condensable(True)\n    .set_vapor_pressure_strategy(vapor_pressure_sulfate)\n    .set_concentration(initial_sulfate_concentration, \"kg/m^3\")\n    .build()\n)\n\n# Build the atmosphere with the sulfate species and environmental conditions\natmosphere = (\n    AtmosphereBuilder()\n    .add_species(gas_sulfate)  # Add sulfate to the atmosphere\n    .set_temperature(25, temperature_units=\"degC\")  # Set temperature to 25\u00b0C\n    .set_pressure(1, pressure_units=\"atm\")  # Set pressure to 1 atm\n    .build()\n)\n\n# Generate a lognormal particle size distribution\nparticle_sample = particles.properties.lognormal_sample_distribution(\n    mode=np.array([400e-9]),  # Mean particle diameter of 400 nm\n    geometric_standard_deviation=np.array([1.4]),  # GSD of 1.4\n    number_of_particles=np.array(\n        [1e4]\n    ),  # Number of particles in the distribution\n    number_of_samples=100,  # Number of particle samples\n)\n\n# Calculate the mass of each particle based on its size and ammonium sulfate density\nparticle_mass_sample = (\n    4 / 3 * np.pi * particle_sample**3 * density_ammonium_sulfate  # kg\n)\n\nvolume_sim = 0.1 * convert_units(\"cm^3\", \"m^3\")  # m^3\n# Build the resolved particle mass representation for the aerosol particles\nresolved_masses = (\n    particles.ResolvedParticleMassRepresentationBuilder()\n    .set_distribution_strategy(particles.ParticleResolvedSpeciatedMass())\n    .set_activity_strategy(particles.ActivityIdealMass())\n    .set_surface_strategy(particles.SurfaceStrategyVolume())\n    .set_mass(particle_mass_sample, \"kg\")\n    .set_density(density_ammonium_sulfate, \"kg/m^3\")\n    .set_charge(0)\n    .set_volume(volume_sim, \"m^3\")\n    .build()\n)\n\n# Create the aerosol object with the atmosphere and particles\naerosol = Aerosol(atmosphere=atmosphere, particles=resolved_masses)\n\n# Print the properties of the created aerosol system\nprint(aerosol)\n</pre> # Build the sulfate gas species  # Ammonium sulfate properties molar_mass_ammonium_sulfate = 132.14e-3  # kg/mol density_ammonium_sulfate = 1.77e3  # kg/m^3  # Define vapor pressure parameters for ammonium sulfate parameters_vapor = {     \"vapor_pressure\": 4e-12,  # pascal     \"vapor_pressure_units\": \"atm\",  # units }  # Create a constant vapor pressure strategy using the VaporPressureFactory vapor_pressure_sulfate = VaporPressureFactory().get_strategy(     \"constant\", parameters_vapor )  # Calculate the saturation concentration at a given temperature sulfate_saturation = vapor_pressure_sulfate.saturation_concentration(     molar_mass=molar_mass_ammonium_sulfate,     temperature=298.15,  # Kelvin )  # Set initial sulfate concentration as a fraction of saturation concentration initial_sulfate_concentration = 0.5 * sulfate_saturation  # kg/m^3  # Build the sulfate gas species using the GasSpeciesBuilder gas_sulfate = (     GasSpeciesBuilder()     .set_name(\"sulfate\")     .set_molar_mass(molar_mass_ammonium_sulfate, \"kg/mol\")     .set_condensable(True)     .set_vapor_pressure_strategy(vapor_pressure_sulfate)     .set_concentration(initial_sulfate_concentration, \"kg/m^3\")     .build() )  # Build the atmosphere with the sulfate species and environmental conditions atmosphere = (     AtmosphereBuilder()     .add_species(gas_sulfate)  # Add sulfate to the atmosphere     .set_temperature(25, temperature_units=\"degC\")  # Set temperature to 25\u00b0C     .set_pressure(1, pressure_units=\"atm\")  # Set pressure to 1 atm     .build() )  # Generate a lognormal particle size distribution particle_sample = particles.properties.lognormal_sample_distribution(     mode=np.array([400e-9]),  # Mean particle diameter of 400 nm     geometric_standard_deviation=np.array([1.4]),  # GSD of 1.4     number_of_particles=np.array(         [1e4]     ),  # Number of particles in the distribution     number_of_samples=100,  # Number of particle samples )  # Calculate the mass of each particle based on its size and ammonium sulfate density particle_mass_sample = (     4 / 3 * np.pi * particle_sample**3 * density_ammonium_sulfate  # kg )  volume_sim = 0.1 * convert_units(\"cm^3\", \"m^3\")  # m^3 # Build the resolved particle mass representation for the aerosol particles resolved_masses = (     particles.ResolvedParticleMassRepresentationBuilder()     .set_distribution_strategy(particles.ParticleResolvedSpeciatedMass())     .set_activity_strategy(particles.ActivityIdealMass())     .set_surface_strategy(particles.SurfaceStrategyVolume())     .set_mass(particle_mass_sample, \"kg\")     .set_density(density_ammonium_sulfate, \"kg/m^3\")     .set_charge(0)     .set_volume(volume_sim, \"m^3\")     .build() )  # Create the aerosol object with the atmosphere and particles aerosol = Aerosol(atmosphere=atmosphere, particles=resolved_masses)  # Print the properties of the created aerosol system print(aerosol) <pre>Gas mixture at 298.15 K and 101325.0 Pa consisting of ['sulfate']\n[0]: Particle Representation:\n\tStrategy: ParticleResolvedSpeciatedMass\n\tActivity: ActivityIdealMass\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 8.737e-07 [kg/m^3]\n\tNumber Concentration: 1.000e+09 [#/m^3]\n</pre> In\u00a0[3]: Copied! <pre># Build the sulfate gas species\n\n# Ammonium sulfate and water vapor pressure\nmolar_mass_ammonium_sulfate = 132.14e-3  # kg/mol\ndensity_ammonium_sulfate = 1.77e3  # kg/m^3\nparameters_vapor = {\n    \"vapor_pressure\": 4e-12,  # pascal\n    \"vapor_pressure_units\": \"atm\",\n}\nvapor_pressure_sulfate = VaporPressureFactory().get_strategy(\n    \"constant\", parameters_vapor\n)\n\n# get initial vapor concentration\nsulfate_saturation = vapor_pressure_sulfate.saturation_concentration(\n    molar_mass=molar_mass_ammonium_sulfate,\n    temperature=298.15,\n)\n\ninitial_sulfate_concentration = 0.5 * sulfate_saturation\n\n\n# Create the gas species\ngas_sulfate = (\n    GasSpeciesBuilder()\n    .set_name(\"sulfate\")\n    .set_molar_mass(molar_mass_ammonium_sulfate, \"kg/mol\")\n    .set_condensable(True)\n    .set_vapor_pressure_strategy(vapor_pressure_sulfate)\n    .set_concentration(initial_sulfate_concentration, \"kg/m^3\")\n    .build()\n)\n\n# AtmosphereBuilder constructs the atmosphere with predefined species\natmosphere = (\n    AtmosphereBuilder()\n    .add_species(gas_sulfate)  # Add the sulfate gas species to the atmosphere\n    .set_temperature(25, temperature_units=\"degC\")  # Set temperature to 25\u00b0C\n    .set_pressure(1, pressure_units=\"atm\")  # Set pressure to 1 atmosphere\n    .build()  # Finalize the atmosphere object\n)\n\n# Generate a particle distribution using a lognormal sample distribution\n# This distribution has a mean particle diameter (mode) and geometric standard deviation (GSD)\nparticle_sample = particles.properties.lognormal_sample_distribution(\n    mode=np.array([400e-9]),  # Mean particle diameter of 100 nm\n    geometric_standard_deviation=np.array([1.4]),  # GSD of 1.3\n    number_of_particles=np.array([1e4]),  # Total number of particles\n    number_of_samples=100,  # Number of samples for particle distribution\n)\n\n\n# Calculate the mass of each particle in the sample\nparticle_mass_sample = (\n    4 / 3 * np.pi * particle_sample**3 * density_ammonium_sulfate\n)  # Particle mass in kg\n\n\n# Build a resolved mass representation for each particle\n# This defines how particle mass, activity, and surface are represented\nresolved_masses = (\n    particles.ResolvedParticleMassRepresentationBuilder()\n    .set_distribution_strategy(particles.ParticleResolvedSpeciatedMass())\n    .set_activity_strategy(particles.ActivityIdealMass())\n    .set_surface_strategy(particles.SurfaceStrategyVolume())\n    .set_mass(particle_mass_sample, \"kg\")\n    .set_density(density_ammonium_sulfate, \"kg/m^3\")\n    .set_charge(0)\n    .set_volume(0.1, \"cm^3\")\n    .build()\n)\n\n# # Create an aerosol object with the defined atmosphere and resolved particles\naerosol = Aerosol(atmosphere=atmosphere, particles=resolved_masses)\n\n\n# Print the properties of the atmosphere\nprint(aerosol)\n</pre> # Build the sulfate gas species  # Ammonium sulfate and water vapor pressure molar_mass_ammonium_sulfate = 132.14e-3  # kg/mol density_ammonium_sulfate = 1.77e3  # kg/m^3 parameters_vapor = {     \"vapor_pressure\": 4e-12,  # pascal     \"vapor_pressure_units\": \"atm\", } vapor_pressure_sulfate = VaporPressureFactory().get_strategy(     \"constant\", parameters_vapor )  # get initial vapor concentration sulfate_saturation = vapor_pressure_sulfate.saturation_concentration(     molar_mass=molar_mass_ammonium_sulfate,     temperature=298.15, )  initial_sulfate_concentration = 0.5 * sulfate_saturation   # Create the gas species gas_sulfate = (     GasSpeciesBuilder()     .set_name(\"sulfate\")     .set_molar_mass(molar_mass_ammonium_sulfate, \"kg/mol\")     .set_condensable(True)     .set_vapor_pressure_strategy(vapor_pressure_sulfate)     .set_concentration(initial_sulfate_concentration, \"kg/m^3\")     .build() )  # AtmosphereBuilder constructs the atmosphere with predefined species atmosphere = (     AtmosphereBuilder()     .add_species(gas_sulfate)  # Add the sulfate gas species to the atmosphere     .set_temperature(25, temperature_units=\"degC\")  # Set temperature to 25\u00b0C     .set_pressure(1, pressure_units=\"atm\")  # Set pressure to 1 atmosphere     .build()  # Finalize the atmosphere object )  # Generate a particle distribution using a lognormal sample distribution # This distribution has a mean particle diameter (mode) and geometric standard deviation (GSD) particle_sample = particles.properties.lognormal_sample_distribution(     mode=np.array([400e-9]),  # Mean particle diameter of 100 nm     geometric_standard_deviation=np.array([1.4]),  # GSD of 1.3     number_of_particles=np.array([1e4]),  # Total number of particles     number_of_samples=100,  # Number of samples for particle distribution )   # Calculate the mass of each particle in the sample particle_mass_sample = (     4 / 3 * np.pi * particle_sample**3 * density_ammonium_sulfate )  # Particle mass in kg   # Build a resolved mass representation for each particle # This defines how particle mass, activity, and surface are represented resolved_masses = (     particles.ResolvedParticleMassRepresentationBuilder()     .set_distribution_strategy(particles.ParticleResolvedSpeciatedMass())     .set_activity_strategy(particles.ActivityIdealMass())     .set_surface_strategy(particles.SurfaceStrategyVolume())     .set_mass(particle_mass_sample, \"kg\")     .set_density(density_ammonium_sulfate, \"kg/m^3\")     .set_charge(0)     .set_volume(0.1, \"cm^3\")     .build() )  # # Create an aerosol object with the defined atmosphere and resolved particles aerosol = Aerosol(atmosphere=atmosphere, particles=resolved_masses)   # Print the properties of the atmosphere print(aerosol) <pre>Gas mixture at 298.15 K and 101325.0 Pa consisting of ['sulfate']\n[0]: Particle Representation:\n\tStrategy: ParticleResolvedSpeciatedMass\n\tActivity: ActivityIdealMass\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 6.688e-07 [kg/m^3]\n\tNumber Concentration: 1.000e+09 [#/m^3]\n</pre> In\u00a0[4]: Copied! <pre># setup dynamics for condensation\ncondensation_method = dynamics.condensation.CondensationIsothermal(\n    molar_mass=molar_mass_ammonium_sulfate,\n    accommodation_coefficient=1,\n    diffusion_coefficient=2e-5,\n)\ncondensation_runnable = dynamics.MassCondensation(\n    condensation_strategy=condensation_method\n)\n# setup dynamics for coagulation\ncoagulation_runnable = dynamics.Coagulation(\n    coagulation_strategy=dynamics.coagulation.ParticleResolved()\n)\n\nstep_count = 0\n</pre> # setup dynamics for condensation condensation_method = dynamics.condensation.CondensationIsothermal(     molar_mass=molar_mass_ammonium_sulfate,     accommodation_coefficient=1,     diffusion_coefficient=2e-5, ) condensation_runnable = dynamics.MassCondensation(     condensation_strategy=condensation_method ) # setup dynamics for coagulation coagulation_runnable = dynamics.Coagulation(     coagulation_strategy=dynamics.coagulation.ParticleResolved() )  step_count = 0 <p>You can repeatedly run the next cell to see the evolution of the aerosol system.</p> In\u00a0[5]: Copied! <pre># Initialize or increment step counter\nstep_count += 1\nprint(f\"Step {step_count}\")\n\n# Define key parameters\nvapor_production = sulfate_saturation * 0.2  # Adding 20% of saturation concentration per second\nbase_nucleation_rate = 1e-8 * density_ammonium_sulfate  # Base nucleation rate in kg/m^3/s\nmass_nucleated_particle = 4/3 * np.pi * (2e-9)**3 * density_ammonium_sulfate  # Mass of a 10 nm particle in kg\nexponent_nucleation = 2  # Nucleation rate exponent (empirical)\ntime_step = 1  # Time step in seconds\n\n# 1. Add more vapor to the gas phase (e.g., by external sources)\nprint(\"Current sulfate concentration: \", aerosol.atmosphere.species[0].get_concentration())\naerosol.atmosphere.species[0].add_concentration(vapor_production * time_step)\nprint(\"New sulfate concentration: \", aerosol.atmosphere.species[0].get_concentration())\n\n# 2. Calculate the new saturation ratio for sulfate in the atmosphere\nsaturation_ratio = aerosol.atmosphere.species[0].get_saturation_ratio(temperature=298.15)\nprint(f\"Saturation ratio: {saturation_ratio}\")\n\n# 3. Calculate the nucleation rate based on the saturation ratio\n# Ensure the saturation ratio is above 1, nucleation only occurs above saturation\nsaturation_difference = np.maximum(saturation_ratio - 1, 0)  # No nucleation if S \u2264 1\n# Calculate the nucleation rate using the exponential form (custom)\n# note this is mass based, if you have a volume based nucleation rate, you need to convert it\n# to mass, as the resolved particles are mass based\nnucleation_rate = base_nucleation_rate * (saturation_difference / 500)**exponent_nucleation\nprint(f\"Nucleation rate [mass concentration per sec, kg/m^3/s]: {nucleation_rate}\")\n\n# 4. Calculate the number of new particles nucleated\n# Floor division ensures we only get whole particles\nnumber_of_new_particles = time_step * nucleation_rate // mass_nucleated_particle\nprint(f\"Number of new particles nucleated: {number_of_new_particles}\")\n\n# 5. Determine the number of resolved particles to create (based on simulation volume)\nsingle_resolved_particle = aerosol.particles[0].get_concentration().max()\nnumber_of_new_resolved_particles = int(number_of_new_particles // single_resolved_particle)\nprint(f\"Number of new resolved particles to be created: {number_of_new_resolved_particles}\")\n\n# 6. If new particles are nucleated, proceed to add them to the aerosol\nif number_of_new_resolved_particles &gt; 0:\n    # Remove nucleated mass from the gas phase to conserve mass\n    aerosol.atmosphere.species[0].add_concentration(\n        -number_of_new_resolved_particles * mass_nucleated_particle\n    )\n\n    # Create arrays to store the properties of the newly resolved particles\n    new_resolved_particle_masses = np.full(number_of_new_resolved_particles, mass_nucleated_particle)\n    new_resolved_particle_concentrations = np.ones_like(new_resolved_particle_masses)  # Concentration of 1 per particle\n\n    # Add the new resolved particles to the aerosol\n    aerosol.particles[0].add_concentration(\n        added_concentration=new_resolved_particle_concentrations,\n        added_distribution=new_resolved_particle_masses,\n    )\n\n# Print the total particle concentration before dynamics (for monitoring)\ntotal_particle_concentration = aerosol.particles[0].get_total_concentration()\nprint(f\"Total particle concentration before dynamics [#/m^3]: {total_particle_concentration}\")\n\n# 7. Perform the condensation step\ncondensation_runnable.execute(aerosol, time_step)\n\n# 8. Perform the coagulation step\ncoagulation_runnable.execute(aerosol, time_step)\n\n# Print the total particle concentration and mass after running the dynamics\ntotal_particle_concentration_after_process = aerosol.particles[0].get_total_concentration()\nprint(f\"Total particle concentration after dynamics [#/m^3]: {total_particle_concentration_after_process}\")\n\ntotal_particle_mass_after_process = aerosol.particles[0].get_mass_concentration()\nprint(f\"Total particle mass after dynamics [kg/m^3]: {total_particle_mass_after_process}\")\n\n# Retrieve and print the total number of resolved particles simulated\ntotal_resolved_particles_in_simulation = aerosol.particles[0].concentration.sum()\nprint(f\"Total resolved particles in simulation: {total_resolved_particles_in_simulation}\")\n</pre> # Initialize or increment step counter step_count += 1 print(f\"Step {step_count}\")  # Define key parameters vapor_production = sulfate_saturation * 0.2  # Adding 20% of saturation concentration per second base_nucleation_rate = 1e-8 * density_ammonium_sulfate  # Base nucleation rate in kg/m^3/s mass_nucleated_particle = 4/3 * np.pi * (2e-9)**3 * density_ammonium_sulfate  # Mass of a 10 nm particle in kg exponent_nucleation = 2  # Nucleation rate exponent (empirical) time_step = 1  # Time step in seconds  # 1. Add more vapor to the gas phase (e.g., by external sources) print(\"Current sulfate concentration: \", aerosol.atmosphere.species[0].get_concentration()) aerosol.atmosphere.species[0].add_concentration(vapor_production * time_step) print(\"New sulfate concentration: \", aerosol.atmosphere.species[0].get_concentration())  # 2. Calculate the new saturation ratio for sulfate in the atmosphere saturation_ratio = aerosol.atmosphere.species[0].get_saturation_ratio(temperature=298.15) print(f\"Saturation ratio: {saturation_ratio}\")  # 3. Calculate the nucleation rate based on the saturation ratio # Ensure the saturation ratio is above 1, nucleation only occurs above saturation saturation_difference = np.maximum(saturation_ratio - 1, 0)  # No nucleation if S \u2264 1 # Calculate the nucleation rate using the exponential form (custom) # note this is mass based, if you have a volume based nucleation rate, you need to convert it # to mass, as the resolved particles are mass based nucleation_rate = base_nucleation_rate * (saturation_difference / 500)**exponent_nucleation print(f\"Nucleation rate [mass concentration per sec, kg/m^3/s]: {nucleation_rate}\")  # 4. Calculate the number of new particles nucleated # Floor division ensures we only get whole particles number_of_new_particles = time_step * nucleation_rate // mass_nucleated_particle print(f\"Number of new particles nucleated: {number_of_new_particles}\")  # 5. Determine the number of resolved particles to create (based on simulation volume) single_resolved_particle = aerosol.particles[0].get_concentration().max() number_of_new_resolved_particles = int(number_of_new_particles // single_resolved_particle) print(f\"Number of new resolved particles to be created: {number_of_new_resolved_particles}\")  # 6. If new particles are nucleated, proceed to add them to the aerosol if number_of_new_resolved_particles &gt; 0:     # Remove nucleated mass from the gas phase to conserve mass     aerosol.atmosphere.species[0].add_concentration(         -number_of_new_resolved_particles * mass_nucleated_particle     )      # Create arrays to store the properties of the newly resolved particles     new_resolved_particle_masses = np.full(number_of_new_resolved_particles, mass_nucleated_particle)     new_resolved_particle_concentrations = np.ones_like(new_resolved_particle_masses)  # Concentration of 1 per particle      # Add the new resolved particles to the aerosol     aerosol.particles[0].add_concentration(         added_concentration=new_resolved_particle_concentrations,         added_distribution=new_resolved_particle_masses,     )  # Print the total particle concentration before dynamics (for monitoring) total_particle_concentration = aerosol.particles[0].get_total_concentration() print(f\"Total particle concentration before dynamics [#/m^3]: {total_particle_concentration}\")  # 7. Perform the condensation step condensation_runnable.execute(aerosol, time_step)  # 8. Perform the coagulation step coagulation_runnable.execute(aerosol, time_step)  # Print the total particle concentration and mass after running the dynamics total_particle_concentration_after_process = aerosol.particles[0].get_total_concentration() print(f\"Total particle concentration after dynamics [#/m^3]: {total_particle_concentration_after_process}\")  total_particle_mass_after_process = aerosol.particles[0].get_mass_concentration() print(f\"Total particle mass after dynamics [kg/m^3]: {total_particle_mass_after_process}\")  # Retrieve and print the total number of resolved particles simulated total_resolved_particles_in_simulation = aerosol.particles[0].concentration.sum() print(f\"Total resolved particles in simulation: {total_resolved_particles_in_simulation}\")  <pre>Step 1\nCurrent sulfate concentration:  1.0802192486690696e-11\nNew sulfate concentration:  1.5123069481366975e-11\nSaturation ratio: 0.7\nNucleation rate [mass concentration per sec, kg/m^3/s]: 0.0\nNumber of new particles nucleated: 0.0\nNumber of new resolved particles to be created: 0\nTotal particle concentration before dynamics [#/m^3]: 999999999.9999999\nTotal particle concentration after dynamics [#/m^3]: 999999999.9999999\nTotal particle mass after dynamics [kg/m^3]: 6.688268754297869e-07\nTotal resolved particles in simulation: 100.0\n</pre> In\u00a0[6]: Copied! <pre># Build the sulfate gas species using the GasSpeciesBuilder\ngas_sulfate = (\n    GasSpeciesBuilder()\n    .set_name(\"sulfate\")\n    .set_molar_mass(molar_mass_ammonium_sulfate, \"kg/mol\")\n    .set_condensable(True)\n    .set_vapor_pressure_strategy(vapor_pressure_sulfate)\n    .set_concentration(initial_sulfate_concentration, \"kg/m^3\")\n    .build()\n)\n\n# AtmosphereBuilder constructs the atmosphere with predefined species\natmosphere = (\n    AtmosphereBuilder()\n    .add_species(gas_sulfate)  # Add the sulfate gas species to the atmosphere\n    .set_temperature(25, temperature_units=\"degC\")  # Set temperature to 25\u00b0C\n    .set_pressure(1, pressure_units=\"atm\")  # Set pressure to 1 atmosphere\n    .build()  # Finalize the atmosphere object\n)\n# Build the resolved particle mass representation for the aerosol particles\nresolved_masses = (\n    particles.ResolvedParticleMassRepresentationBuilder()\n    .set_distribution_strategy(particles.ParticleResolvedSpeciatedMass())\n    .set_activity_strategy(particles.ActivityIdealMass())\n    .set_surface_strategy(particles.SurfaceStrategyVolume())\n    .set_mass(particle_mass_sample, \"kg\")\n    .set_density(density_ammonium_sulfate, \"kg/m^3\")\n    .set_charge(0)\n    .set_volume(0.1, \"cm^3\")\n    .build()\n)\n\n# Create the aerosol object with the atmosphere and particles\naerosol = Aerosol(atmosphere=atmosphere, particles=resolved_masses)\n\n# Print the properties of the created aerosol system\nprint(aerosol)\n\n\n# Set up time and sub-steps for the coagulation process\ntotal_time = 200\ntime_step = 1\nsub_steps = 2\n\n# bins\nbins_lognormal = np.logspace(-9, -7, 200)\n\n# output arrays\ntime = np.arange(0, total_time, time_step)\ntotal_mass_resolved = np.ones_like(time, dtype=np.float64)\nnumber_distribution_binned = np.zeros((len(time), len(bins_lognormal) - 1))\ntotal_number_resolved = np.ones_like(time, dtype=np.float64)\nsaturation_ratio_output = np.ones_like(time, dtype=np.float64)\n\nprint(f\"Total iterations to do: {len(time)*sub_steps}\")\n</pre> # Build the sulfate gas species using the GasSpeciesBuilder gas_sulfate = (     GasSpeciesBuilder()     .set_name(\"sulfate\")     .set_molar_mass(molar_mass_ammonium_sulfate, \"kg/mol\")     .set_condensable(True)     .set_vapor_pressure_strategy(vapor_pressure_sulfate)     .set_concentration(initial_sulfate_concentration, \"kg/m^3\")     .build() )  # AtmosphereBuilder constructs the atmosphere with predefined species atmosphere = (     AtmosphereBuilder()     .add_species(gas_sulfate)  # Add the sulfate gas species to the atmosphere     .set_temperature(25, temperature_units=\"degC\")  # Set temperature to 25\u00b0C     .set_pressure(1, pressure_units=\"atm\")  # Set pressure to 1 atmosphere     .build()  # Finalize the atmosphere object ) # Build the resolved particle mass representation for the aerosol particles resolved_masses = (     particles.ResolvedParticleMassRepresentationBuilder()     .set_distribution_strategy(particles.ParticleResolvedSpeciatedMass())     .set_activity_strategy(particles.ActivityIdealMass())     .set_surface_strategy(particles.SurfaceStrategyVolume())     .set_mass(particle_mass_sample, \"kg\")     .set_density(density_ammonium_sulfate, \"kg/m^3\")     .set_charge(0)     .set_volume(0.1, \"cm^3\")     .build() )  # Create the aerosol object with the atmosphere and particles aerosol = Aerosol(atmosphere=atmosphere, particles=resolved_masses)  # Print the properties of the created aerosol system print(aerosol)   # Set up time and sub-steps for the coagulation process total_time = 200 time_step = 1 sub_steps = 2  # bins bins_lognormal = np.logspace(-9, -7, 200)  # output arrays time = np.arange(0, total_time, time_step) total_mass_resolved = np.ones_like(time, dtype=np.float64) number_distribution_binned = np.zeros((len(time), len(bins_lognormal) - 1)) total_number_resolved = np.ones_like(time, dtype=np.float64) saturation_ratio_output = np.ones_like(time, dtype=np.float64)  print(f\"Total iterations to do: {len(time)*sub_steps}\") <pre>Gas mixture at 298.15 K and 101325.0 Pa consisting of ['sulfate']\n[0]: Particle Representation:\n\tStrategy: ParticleResolvedSpeciatedMass\n\tActivity: ActivityIdealMass\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 6.688e-07 [kg/m^3]\n\tNumber Concentration: 1.000e+09 [#/m^3]\nTotal iterations to do: 400\n</pre> In\u00a0[7]: Copied! <pre># Define key parameters\nvapor_production = sulfate_saturation * 0.2  # Adding 20% of saturation concentration per second\nbase_nucleation_rate = 1e-8 * density_ammonium_sulfate  # Base nucleation rate in kg/m^3/s\nmass_nucleated_particle = 4/3 * np.pi * (2e-9)**3 * density_ammonium_sulfate  # Mass of a 10 nm particle in kg\nexponent_nucleation = 2  # Nucleation rate exponent (empirical)\n\n\nfor i, t in enumerate(time):\n    if i &gt; 0:\n        # 1. Add more vapor to the gas phase (e.g., by external sources)\n        aerosol.atmosphere.species[0].add_concentration(vapor_production * time_step)\n\n        # 2. Calculate the new saturation ratio for sulfate in the atmosphere\n        saturation_ratio = aerosol.atmosphere.species[0].get_saturation_ratio(temperature=298.15)\n\n        # 3. Calculate the nucleation rate based on the saturation ratio\n        # Ensure the saturation ratio is above 1, nucleation only occurs above saturation\n        saturation_difference = np.maximum(saturation_ratio - 1, 0)  # No nucleation if S \u2264 1\n        # Calculate the nucleation rate using the exponential form (custom)\n        # note this is mass based, if you have a volume based nucleation rate, you need to convert it\n        # to mass, as the resolved particles are mass based\n        nucleation_rate = base_nucleation_rate * (saturation_difference / 500)**exponent_nucleation\n\n        # 4. Calculate the number of new particles nucleated\n        # Floor division ensures we only get whole particles\n        number_of_new_particles = time_step * nucleation_rate // mass_nucleated_particle\n\n        # 5. Determine the number of resolved particles to create (based on simulation volume)\n        single_resolved_particle = aerosol.particles[0].get_concentration().max()\n        number_of_new_resolved_particles = int(number_of_new_particles // single_resolved_particle)\n\n        # 6. If new particles are nucleated, proceed to add them to the aerosol\n        if number_of_new_resolved_particles &gt; 0:\n            # Remove nucleated mass from the gas phase to conserve mass\n            aerosol.atmosphere.species[0].add_concentration(\n                -number_of_new_resolved_particles * mass_nucleated_particle\n            )\n\n            # Create arrays to store the properties of the newly resolved particles\n            new_resolved_particle_masses = np.full(number_of_new_resolved_particles, mass_nucleated_particle)\n            new_resolved_particle_concentrations = np.ones_like(new_resolved_particle_masses)  # Concentration of 1 per particle\n\n            # Add the new resolved particles to the aerosol\n            aerosol.particles[0].add_concentration(\n                added_concentration=new_resolved_particle_concentrations,\n                added_distribution=new_resolved_particle_masses,\n            )\n\n        # 7. Perform the condensation step\n        condensation_runnable.execute(aerosol, time_step, sub_steps)\n\n        # 8. Perform the coagulation step\n        coagulation_runnable.execute(aerosol, time_step, sub_steps)\n\n    total_mass_resolved[i] = aerosol.particles[0].get_mass_concentration()\n    number_distribution = aerosol.particles[0].get_radius(clone=True)\n    number_distribution_binned[i, :], edges = np.histogram(number_distribution, bins=bins_lognormal)\n    total_number_resolved[i] = np.sum(number_distribution[i]&gt;0)\n    saturation_ratio_output[i] = aerosol.atmosphere.species[0].get_saturation_ratio(\n        temperature=298.15)\n\n    if i % 20 == 0:\n        # Retrieve and print the total number of resolved particles simulated\n        total_resolved_particles_in_simulation = aerosol.particles[0].concentration.sum()\n        print(f\"Index {i}: Total resolved particles in simulation: {total_resolved_particles_in_simulation}\")\n\n\nnumber_distribution_binned = number_distribution_binned / volume_sim\n</pre>  # Define key parameters vapor_production = sulfate_saturation * 0.2  # Adding 20% of saturation concentration per second base_nucleation_rate = 1e-8 * density_ammonium_sulfate  # Base nucleation rate in kg/m^3/s mass_nucleated_particle = 4/3 * np.pi * (2e-9)**3 * density_ammonium_sulfate  # Mass of a 10 nm particle in kg exponent_nucleation = 2  # Nucleation rate exponent (empirical)   for i, t in enumerate(time):     if i &gt; 0:         # 1. Add more vapor to the gas phase (e.g., by external sources)         aerosol.atmosphere.species[0].add_concentration(vapor_production * time_step)          # 2. Calculate the new saturation ratio for sulfate in the atmosphere         saturation_ratio = aerosol.atmosphere.species[0].get_saturation_ratio(temperature=298.15)          # 3. Calculate the nucleation rate based on the saturation ratio         # Ensure the saturation ratio is above 1, nucleation only occurs above saturation         saturation_difference = np.maximum(saturation_ratio - 1, 0)  # No nucleation if S \u2264 1         # Calculate the nucleation rate using the exponential form (custom)         # note this is mass based, if you have a volume based nucleation rate, you need to convert it         # to mass, as the resolved particles are mass based         nucleation_rate = base_nucleation_rate * (saturation_difference / 500)**exponent_nucleation          # 4. Calculate the number of new particles nucleated         # Floor division ensures we only get whole particles         number_of_new_particles = time_step * nucleation_rate // mass_nucleated_particle          # 5. Determine the number of resolved particles to create (based on simulation volume)         single_resolved_particle = aerosol.particles[0].get_concentration().max()         number_of_new_resolved_particles = int(number_of_new_particles // single_resolved_particle)          # 6. If new particles are nucleated, proceed to add them to the aerosol         if number_of_new_resolved_particles &gt; 0:             # Remove nucleated mass from the gas phase to conserve mass             aerosol.atmosphere.species[0].add_concentration(                 -number_of_new_resolved_particles * mass_nucleated_particle             )              # Create arrays to store the properties of the newly resolved particles             new_resolved_particle_masses = np.full(number_of_new_resolved_particles, mass_nucleated_particle)             new_resolved_particle_concentrations = np.ones_like(new_resolved_particle_masses)  # Concentration of 1 per particle              # Add the new resolved particles to the aerosol             aerosol.particles[0].add_concentration(                 added_concentration=new_resolved_particle_concentrations,                 added_distribution=new_resolved_particle_masses,             )          # 7. Perform the condensation step         condensation_runnable.execute(aerosol, time_step, sub_steps)          # 8. Perform the coagulation step         coagulation_runnable.execute(aerosol, time_step, sub_steps)      total_mass_resolved[i] = aerosol.particles[0].get_mass_concentration()     number_distribution = aerosol.particles[0].get_radius(clone=True)     number_distribution_binned[i, :], edges = np.histogram(number_distribution, bins=bins_lognormal)     total_number_resolved[i] = np.sum(number_distribution[i]&gt;0)     saturation_ratio_output[i] = aerosol.atmosphere.species[0].get_saturation_ratio(         temperature=298.15)      if i % 20 == 0:         # Retrieve and print the total number of resolved particles simulated         total_resolved_particles_in_simulation = aerosol.particles[0].concentration.sum()         print(f\"Index {i}: Total resolved particles in simulation: {total_resolved_particles_in_simulation}\")   number_distribution_binned = number_distribution_binned / volume_sim <pre>Index 0: Total resolved particles in simulation: 100.0\n</pre> <pre>Index 20: Total resolved particles in simulation: 360698.0\nIndex 40: Total resolved particles in simulation: 381036.0\nIndex 60: Total resolved particles in simulation: 355792.0\nIndex 80: Total resolved particles in simulation: 331894.0\nIndex 100: Total resolved particles in simulation: 310821.0\nIndex 120: Total resolved particles in simulation: 292075.0\nIndex 140: Total resolved particles in simulation: 275280.0\nIndex 160: Total resolved particles in simulation: 260109.0\nIndex 180: Total resolved particles in simulation: 246462.0\n</pre> In\u00a0[8]: Copied! <pre>fig, ax = plt.subplots(figsize=(8, 5))\n\n# Swap X and Y to reverse axes\nX, Y = np.meshgrid(\n    time, edges[:-1]\n)  # Now time is on the x-axis and edges on the y-axis\n\n# Plot the contour with updated X and Y\nlog_of_number_distribution_binned = np.log10(\n    number_distribution_binned,\n    out=np.nan * np.ones_like(number_distribution_binned),\n    where=number_distribution_binned &gt; 0,\n)\ncontour = ax.contourf(\n    X,\n    Y,\n    log_of_number_distribution_binned.T,\n    cmap=\"viridis\",\n    vmin=5,\n)\n\n# Add the color bar\ncbar = fig.colorbar(contour)\ncbar.set_label(\"Log10 of Number concentration (m^-3)\")\n\nax.set_ylim([1e-9, 1e-7])  # Set limits for y-axis\n\n# Set axis labels\nax.set_yscale(\"log\")  # Log scale for particle radius on y-axis\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(\"Particle radius (m)\")\nfig.tight_layout()\nplt.show()\n</pre> fig, ax = plt.subplots(figsize=(8, 5))  # Swap X and Y to reverse axes X, Y = np.meshgrid(     time, edges[:-1] )  # Now time is on the x-axis and edges on the y-axis  # Plot the contour with updated X and Y log_of_number_distribution_binned = np.log10(     number_distribution_binned,     out=np.nan * np.ones_like(number_distribution_binned),     where=number_distribution_binned &gt; 0, ) contour = ax.contourf(     X,     Y,     log_of_number_distribution_binned.T,     cmap=\"viridis\",     vmin=5, )  # Add the color bar cbar = fig.colorbar(contour) cbar.set_label(\"Log10 of Number concentration (m^-3)\")  ax.set_ylim([1e-9, 1e-7])  # Set limits for y-axis  # Set axis labels ax.set_yscale(\"log\")  # Log scale for particle radius on y-axis ax.set_xlabel(\"Time (s)\") ax.set_ylabel(\"Particle radius (m)\") fig.tight_layout() plt.show() In\u00a0[9]: Copied! <pre># plot the total mass and water saturation on twin y-axis\nfig, ax1 = plt.subplots(figsize=(8, 5))\n\nax1.plot(time, total_mass_resolved, label=\"Total mass\", color=\"blue\")\nax1.set_xlabel(\"Time (s)\")\nax1.set_ylabel(\"Total Particle mass (kg/m^3)\", color=\"blue\")\nax1.tick_params(axis=\"y\", labelcolor=\"blue\")\n\nax2 = ax1.twinx()\nax2.plot(time, saturation_ratio_output, label=\"Satruation Ratio\", color=\"red\")\nax2.set_ylabel(\"Saturation Ratio\", color=\"red\")\nax2.tick_params(axis=\"y\", labelcolor=\"red\")\n\nfig.tight_layout()\nplt.show()\n</pre> # plot the total mass and water saturation on twin y-axis fig, ax1 = plt.subplots(figsize=(8, 5))  ax1.plot(time, total_mass_resolved, label=\"Total mass\", color=\"blue\") ax1.set_xlabel(\"Time (s)\") ax1.set_ylabel(\"Total Particle mass (kg/m^3)\", color=\"blue\") ax1.tick_params(axis=\"y\", labelcolor=\"blue\")  ax2 = ax1.twinx() ax2.plot(time, saturation_ratio_output, label=\"Satruation Ratio\", color=\"red\") ax2.set_ylabel(\"Saturation Ratio\", color=\"red\") ax2.tick_params(axis=\"y\", labelcolor=\"red\")  fig.tight_layout() plt.show()"},{"location":"How-To-Guides/Nucleation/Notebooks/Custom_Nucleation_Single_Species/#custom-nucleation-single-species","title":"Custom Nucleation: Single Species\u00b6","text":"<p>In this How-to Guide, we will demonstrate how to create a custom nucleation model for a single-species aerosol system. We will use fixed nucleation rates for demonstration purposes. This approach highlights the flexibility of adding new processes to your aerosol simulation before full integration into the main codebase.</p> <p>This guide is based on the Dynamics Customization tutorial.</p> <p>Imports</p>"},{"location":"How-To-Guides/Nucleation/Notebooks/Custom_Nucleation_Single_Species/#aerosol-setup","title":"Aerosol Setup\u00b6","text":"<p>We will begin by setting up ammonium sulfate vapor alongside a few pre-existing particles. The vapor phase will include a constant vapor pressure for ammonium sulfate, and a lognormal distribution will be used to represent the initial particle population.</p> <p>The pre-existing particles are also necessary as, the zero particle case is not supported in the current version of the model.</p>"},{"location":"How-To-Guides/Nucleation/Notebooks/Custom_Nucleation_Single_Species/#simulation","title":"Simulation\u00b6","text":"<p>This section performs a step in the simulation using a manual stepping method. The steps include:</p> <ol> <li>Adding more vapors to the gas phase.</li> <li>Calculating the new saturation ratio.</li> <li>Calculating the nucleation rate based on the saturation difference.</li> <li>Determining the number of new particles nucleated.</li> <li>Determining the number of resolved particles to be added to the aerosol.</li> <li>Creating and adding the new particles to the aerosol.</li> <li>Performing a condensation step to account for gas-phase condensation onto existing particles.</li> <li>Performing a coagulation step to account for particle-particle interactions.</li> </ol> <p>And before we start, we also need to initialize the condensation and coagulation runnables.</p>"},{"location":"How-To-Guides/Nucleation/Notebooks/Custom_Nucleation_Single_Species/#time-loop","title":"Time Loop\u00b6","text":"<p>Now that we see the simulation is working, we can put that into a loop and save out the distribution of particles at each time step.</p> <p>We'll first reset the aerosol system to its initial state, create a output matrix, then run the previous simulation in a for loop.</p>"},{"location":"How-To-Guides/Nucleation/Notebooks/Custom_Nucleation_Single_Species/#graphing","title":"Graphing\u00b6","text":"<p>In this section, we will visualize the nucleation events over time. The initial particles will be displayed, followed by their coagulated pairs. As the simulation progresses, particle growth results from both coagulation and condensation processes.</p>"},{"location":"How-To-Guides/Nucleation/Notebooks/Custom_Nucleation_Single_Species/#conclusion","title":"Conclusion\u00b6","text":"<p>In this guide, we demonstrated how to integrate custom nucleation processes into the aerosol simulation. This shows the flexibility of the aerosol model, allowing for the addition of new processes before they are fully integrated into the core framework.</p> <p>Note: Custom nucleation, particularly at high rates, can significantly increase the number of particles simulated, potentially slowing down the computation. A rescaling mechanism to adjust the simulation volume and control the number of resolved particles is planned for future enhancements to address this issue.</p>"},{"location":"How-To-Guides/Setup_Particula/","title":"Index: Setup Particula","text":""},{"location":"How-To-Guides/Setup_Particula/#getting-started-with-python","title":"Getting Started with Python","text":"<p>If you are new to Python, it's highly recommended to go through an introductory course to build a solid foundation. \"Python for Everybody\" is an excellent free resource that covers the basics and beyond:</p> <ul> <li>Access the course and materials at Python for Everybody.</li> </ul>"},{"location":"How-To-Guides/Setup_Particula/#setting-up-your-development-environment","title":"Setting Up Your Development Environment","text":"<p>Step 1: Install Visual Studio Code (VSCode)</p> <p>To edit and manage your code efficiently, download and install Visual Studio Code, a popular code editor that supports Python and many other languages.</p> <ul> <li>Visit the Visual Studio Code website to download the installer for Windows.</li> <li>Follow the installation prompts to install VSCode on your machine.</li> <li>Once installed, launch VSCode to configure it for Python development.</li> </ul> <p>Step 2: Install Miniconda</p> <p>Install Miniconda, which includes Conda, a powerful package and environment manager. This tool will help you manage different project dependencies separately and efficiently.</p> <ul> <li>Download Miniconda for Windows from Miniconda's website.</li> <li>Follow the installation instructions to install Miniconda on your system.</li> </ul> <p>Step 3: Install Git</p> <p>Install Git to manage your code repositories effectively. Git is a version control system that lets you track changes, revert to previous stages, and collaborate on projects with others.</p> <ul> <li>Download Git from Git's official website.</li> <li>Run the downloaded file to start the installation.</li> <li>During the installation, choose your preferred editor for Git, and make sure to select \"Git from the command line and also from 3<sup>rd</sup>-party software\" to ensure it integrates well with your system's command prompt.</li> <li>Complete the installation by following the on-screen instructions.</li> </ul> <p>Once installed, you can verify the installation by opening a command prompt or terminal and typing <code>git --version</code>, which should display the installed version of Git.</p> <p>Step 4: Setup Proxy</p> <p>If you are behind a proxy, you may need to configure your proxy settings to allow Conda, Pip, git, and VScode to access the internet.</p> <p>Step 5: Create a New Python Environment </p> <p>Avoid conflicts with other development projects by creating an isolated Python environment. Here\u2019s how:</p> <ul> <li>Open VSCode, then open the integrated terminal (<code>Terminal &gt; New Terminal</code>).</li> <li>Be sure to select <code>cmd</code> for command prompt.</li> <li>Use the following Conda command to create an environment named <code>analysisV1</code> with Python 3.11:</li> </ul> <pre><code>conda create --name analysisV1 python=3.12\n</code></pre> <p>Step 6: Activate the Environment </p> <p>Ensure you\u2019re working within the context of your new environment: - In the VSCode terminal, activate your environment by running:</p> <pre><code>conda activate analysisV1\n</code></pre>"},{"location":"How-To-Guides/Setup_Particula/#installing-the-project","title":"Installing the Project","text":"<p>Step 7: Install the Project</p> <p>Now, install the <code>Particula</code> using pip in your activated environment, use one of the following methods:</p>"},{"location":"How-To-Guides/Setup_Particula/#install-the-pip-package","title":"Install the pip package","text":"<pre><code>pip install particula\n</code></pre>"},{"location":"How-To-Guides/Setup_Particula/#or-install-the-main-repository-or-any-forked-repository","title":"or Install the main repository or any forked repository","text":"<pre><code>pip install git+https://github.com/uncscode/particula.git\n</code></pre>"},{"location":"Tutorials/","title":"Tutorials","text":"<ul> <li> <p>Aerosol</p> <p>Learn what goes into the Aerosol object and why it is used.</p> <p> Tutorial</p> </li> <li> <p>Dynamics</p> <p>Dynamics is a collection of classes that processes <code>Aerosol</code> objects, to perform coagulation, condensation, and other processes.</p> <p> Tutorial</p> </li> <li> <p>Gas Phase</p> <p>Learn how to represent the Gas Phase, including vapor pressures and atmospheric properties.</p> <p> Tutorial</p> </li> <li> <p>Particle Phase</p> <p>Learn about how to represent the Particle Phase, including different particle representations; radius bins, speciated mass bins, and particle resolved.</p> <p> Tutorial</p> </li> </ul>"},{"location":"Tutorials/Aerosol/","title":"Index: Aerosols","text":""},{"location":"Tutorials/Aerosol/#notebooks","title":"Notebooks","text":"<ul> <li>Aerosol Tutorial</li> </ul>"},{"location":"Tutorials/Aerosol/Aerosol_Tutorial/","title":"Aerosol Tutorial","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\nfrom particula.particles import PresetParticleRadiusBuilder\nfrom particula.gas import AtmosphereBuilder, VaporPressureFactory, GasSpeciesBuilder\nfrom particula.aerosol import Aerosol\n</pre> import numpy as np import matplotlib.pyplot as plt  from particula.particles import PresetParticleRadiusBuilder from particula.gas import AtmosphereBuilder, VaporPressureFactory, GasSpeciesBuilder from particula.aerosol import Aerosol In\u00a0[2]: Copied! <pre># Glycerol gas\nmolar_mass_glycerol = 92.09382e-3  # kg/mol\nparameters_clausius = {\n    \"latent_heat\": 71.5*molar_mass_glycerol,\n    \"latent_heat_units\": \"kJ/kg\",\n    \"temperature_initial\": 125.5,\n    \"temperature_initial_units\": \"degC\",\n    \"pressure_initial\": 1,\n    \"pressure_initial_units\": \"mmHg\",\n}\nvapor_pressure_strategy = VaporPressureFactory().get_strategy(\"clausius_clapeyron\", parameters_clausius)\n\nsat_concentration = vapor_pressure_strategy.saturation_concentration(molar_mass_glycerol, 298.15)\nprint(f\"Saturation concentration: {sat_concentration:.2e} kg/m^3\")\n\nsat_factor = 0.5  # 50% of saturation concentration\nglycerol_gas = (\n    GasSpeciesBuilder()\n    .set_molar_mass(molar_mass_glycerol, \"kg/mol\")\n    .set_vapor_pressure_strategy(vapor_pressure_strategy)\n    .set_concentration(sat_concentration*sat_factor, \"kg/m^3\")\n    .set_name(\"Glycerol\")\n    .set_condensable(True)\n    .build()\n)\nprint(glycerol_gas)\n\natmosphere = (\n    AtmosphereBuilder()\n    .add_species(glycerol_gas)\n    .set_temperature(25, temperature_units=\"degC\")\n    .set_pressure(1, pressure_units=\"atm\")\n    .build()\n)\nprint(atmosphere)\n\n# Glycerol particle distribution\nlognormal_rep = (\n    PresetParticleRadiusBuilder()\n    .set_mode(np.array([100]), \"nm\")\n    .set_geometric_standard_deviation(np.array([1.5]))\n    .set_number_concentration(np.array([1e4]), \"1/cm^3\")\n    .set_density(1.26, \"g/cm^3\")\n    .build()\n)\n</pre> # Glycerol gas molar_mass_glycerol = 92.09382e-3  # kg/mol parameters_clausius = {     \"latent_heat\": 71.5*molar_mass_glycerol,     \"latent_heat_units\": \"kJ/kg\",     \"temperature_initial\": 125.5,     \"temperature_initial_units\": \"degC\",     \"pressure_initial\": 1,     \"pressure_initial_units\": \"mmHg\", } vapor_pressure_strategy = VaporPressureFactory().get_strategy(\"clausius_clapeyron\", parameters_clausius)  sat_concentration = vapor_pressure_strategy.saturation_concentration(molar_mass_glycerol, 298.15) print(f\"Saturation concentration: {sat_concentration:.2e} kg/m^3\")  sat_factor = 0.5  # 50% of saturation concentration glycerol_gas = (     GasSpeciesBuilder()     .set_molar_mass(molar_mass_glycerol, \"kg/mol\")     .set_vapor_pressure_strategy(vapor_pressure_strategy)     .set_concentration(sat_concentration*sat_factor, \"kg/m^3\")     .set_name(\"Glycerol\")     .set_condensable(True)     .build() ) print(glycerol_gas)  atmosphere = (     AtmosphereBuilder()     .add_species(glycerol_gas)     .set_temperature(25, temperature_units=\"degC\")     .set_pressure(1, pressure_units=\"atm\")     .build() ) print(atmosphere)  # Glycerol particle distribution lognormal_rep = (     PresetParticleRadiusBuilder()     .set_mode(np.array([100]), \"nm\")     .set_geometric_standard_deviation(np.array([1.5]))     .set_number_concentration(np.array([1e4]), \"1/cm^3\")     .set_density(1.26, \"g/cm^3\")     .build() ) <pre>Saturation concentration: 2.54e-03 kg/m^3\nGlycerol\nGas mixture at 298.15 K and 101325.0 Pa consisting of ['Glycerol']\n</pre> In\u00a0[3]: Copied! <pre>aerosol = Aerosol(atmosphere=atmosphere, particles=lognormal_rep)\n\nprint(aerosol)\n</pre> aerosol = Aerosol(atmosphere=atmosphere, particles=lognormal_rep)  print(aerosol) <pre>Gas mixture at 298.15 K and 101325.0 Pa consisting of ['Glycerol']\n[0]: Particle Representation:\n\tStrategy: RadiiBasedMovingBin\n\tActivity: ActivityIdealMass\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 1.106e-07 [kg/m^3]\n\tNumber Concentration: 1.000e+10 [#/m^3]\n</pre>"},{"location":"Tutorials/Aerosol/Aerosol_Tutorial/#aerosol-tutorial","title":"Aerosol Tutorial\u00b6","text":"<p>Aerosols are complex systems comprising both gaseous components and particulate matter. To accurately model such systems, we introduce the <code>Aerosol</code> class, which serves as a collection the <code>Atmosphere</code> and <code>ParticleRepresentation</code> objects.</p> <p>In this quick tutorial, we will demonstrate how to create an <code>Aerosol</code> object, as this is the key object that will track the state of the aerosol system during dynamics.</p>"},{"location":"Tutorials/Aerosol/Aerosol_Tutorial/#gas-atmosphere-and-particles","title":"Gas-&gt;Atmosphere and Particles\u00b6","text":"<p>First we'll create a simple <code>Atmosphere</code> object, which will represent the gas phase of the aerosol system. We'll also create a <code>ParticleRepresentation</code> object, which will represent the particulate phase of the aerosol system.</p> <p>For the chemical species, we will use a pure component glycerol system.</p>"},{"location":"Tutorials/Aerosol/Aerosol_Tutorial/#creating-an-aerosol-object","title":"Creating an Aerosol object\u00b6","text":"<p>With both the <code>Atmosphere</code> and <code>ParticleRepresentation</code> objects created, we can now create an <code>Aerosol</code> object. This object will contain both the gas and particle phase objects, and will be used to track the state of the aerosol system during dynamics.</p>"},{"location":"Tutorials/Aerosol/Aerosol_Tutorial/#summary","title":"Summary\u00b6","text":"<p>In this tutorial, we demonstrated how to create an <code>Aerosol</code> object, which is the key object that will track the state of the aerosol system during dynamics. It is pretty simple, as the <code>Aerosol</code> object is just a collection of the <code>Atmosphere</code> and <code>ParticleRepresentation</code> objects and only functions as a container for these objects. It can also iterate over the <code>Atmosphere</code> and <code>ParticleRepresentation</code> objects.</p>"},{"location":"Tutorials/Dynamics/","title":"Dynamics","text":""},{"location":"Tutorials/Dynamics/#condensation","title":"Condensation","text":"<ul> <li>Condensation 1: Bins</li> <li>Condensation 2: Masses Binned</li> <li>Condensation 3: Masses Resolved</li> </ul>"},{"location":"Tutorials/Dynamics/#coagulation","title":"Coagulation","text":"<ul> <li>Coagulation 1: PMF Pattern</li> </ul> <ul> <li>Coagulation 3: Particle Resolved</li> <li>Coagulation 4: Methods Compared</li> </ul>"},{"location":"Tutorials/Dynamics/#functional","title":"Functional","text":"<ul> <li>Coagulation 1: Probability Mass Function</li> <li>Coagulation Tutorial: Basic 2-PDF</li> <li>Coagulation Tutorial: Basic 3-Compared</li> <li>Coagulation Tutorial: Basic 4-Particle Resolved</li> <li>Coagulation Tutorial: Basic 5-Super Droplet Method</li> </ul>"},{"location":"Tutorials/Dynamics/#customization","title":"Customization","text":"<ul> <li>Adding Particles During Simulation</li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_1_PMF_Pattern/","title":"Coagulation Patterns: PMF Particle Distribution","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# particula imports\nfrom particula import particles\nfrom particula.aerosol import Aerosol\nfrom particula.gas import PresetGasSpeciesBuilder, AtmosphereBuilder\n\nfrom particula.dynamics import particle_process\nfrom particula.dynamics import coagulation\n</pre> import numpy as np import matplotlib.pyplot as plt  # particula imports from particula import particles from particula.aerosol import Aerosol from particula.gas import PresetGasSpeciesBuilder, AtmosphereBuilder  from particula.dynamics import particle_process from particula.dynamics import coagulation In\u00a0[2]: Copied! <pre># Preset gas species that does not condense in the atmosphere\n# AtmosphereBuilder constructs the atmosphere with predefined species\natmosphere = (\n    AtmosphereBuilder()\n    .add_species(PresetGasSpeciesBuilder().build())  # Add a preset gas species\n    .set_temperature(25, temperature_units=\"degC\")  # Set temperature to 25\u00b0C\n    .set_pressure(1, pressure_units=\"atm\")  # Set pressure to 1 atmosphere\n    .build()  # Finalize the atmosphere object\n)\n\n\n# Build a resolved mass representation for each particle\n# This defines how particle mass, activity, and surface are represented\nradius_bins = np.logspace(-8, -5, 250)  # Define the radius bins for the resolved mass representation\nresolved_masses = (\n    particles.PresetParticleRadiusBuilder()\n    .set_mode(np.array([100, 800]), mode_units=\"nm\")  # Set the mode radius\n    .set_geometric_standard_deviation(np.array([1.2, 1.5]))  # Set the geometric standard deviation\n    .set_number_concentration(np.array([1e5, 2e5]), number_concentration_units=\"cm^-3\")  # Set the number concentration\n    .set_distribution_type('pmf')  # Set the distribution type to PMF\n    .set_radius_bins(radius_bins, radius_bins_units=\"m\")  # Set the radius bins\n    .build()  # Finalize the resolved mass representation\n)\n\n# Create an aerosol object with the defined atmosphere and resolved particles\naerosol = Aerosol(atmosphere=atmosphere, particles=resolved_masses)\n\n# Print the properties\nprint(aerosol)\n</pre> # Preset gas species that does not condense in the atmosphere # AtmosphereBuilder constructs the atmosphere with predefined species atmosphere = (     AtmosphereBuilder()     .add_species(PresetGasSpeciesBuilder().build())  # Add a preset gas species     .set_temperature(25, temperature_units=\"degC\")  # Set temperature to 25\u00b0C     .set_pressure(1, pressure_units=\"atm\")  # Set pressure to 1 atmosphere     .build()  # Finalize the atmosphere object )   # Build a resolved mass representation for each particle # This defines how particle mass, activity, and surface are represented radius_bins = np.logspace(-8, -5, 250)  # Define the radius bins for the resolved mass representation resolved_masses = (     particles.PresetParticleRadiusBuilder()     .set_mode(np.array([100, 800]), mode_units=\"nm\")  # Set the mode radius     .set_geometric_standard_deviation(np.array([1.2, 1.5]))  # Set the geometric standard deviation     .set_number_concentration(np.array([1e5, 2e5]), number_concentration_units=\"cm^-3\")  # Set the number concentration     .set_distribution_type('pmf')  # Set the distribution type to PMF     .set_radius_bins(radius_bins, radius_bins_units=\"m\")  # Set the radius bins     .build()  # Finalize the resolved mass representation )  # Create an aerosol object with the defined atmosphere and resolved particles aerosol = Aerosol(atmosphere=atmosphere, particles=resolved_masses)  # Print the properties print(aerosol) <pre>Gas mixture at 298.15 K and 101325.0 Pa consisting of ['Preset100']\n[0]: Particle Representation:\n\tStrategy: RadiiBasedMovingBin\n\tActivity: ActivityIdealMass\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 8.993e-04 [kg/m^3]\n\tNumber Concentration: 3.000e+11 [#/m^3]\n</pre> In\u00a0[3]: Copied! <pre># Define the coagulation strategy and process\ncoagulation_strategy = coagulation.DiscreteSimple()\ncoagulation_process = particle_process.Coagulation(\n    coagulation_strategy=coagulation_strategy\n)\n\n# Set up time and sub-steps for the coagulation process\ntime_step = 1000\nsub_steps = 100\n\ninitial_radii = aerosol.particles[0].get_radius()\nconcentration_initial = np.copy(aerosol.particles[0].concentration)\n\n# # Perform coagulation process for step 1\naerosol = coagulation_process.execute(\n    aerosol, time_step=time_step, sub_steps=sub_steps\n)\nradii_after_step_1 = aerosol.particles[0].get_radius()\nconcentration_step_1 = np.copy(aerosol.particles[0].concentration)\n\n# Perform coagulation process for step 2\naerosol = coagulation_process.execute(\n    aerosol, time_step=time_step, sub_steps=sub_steps\n)\nradii_after_step_2 = aerosol.particles[0].get_radius()\nconcentration_step_2 = np.copy(aerosol.particles[0].concentration)\n</pre> # Define the coagulation strategy and process coagulation_strategy = coagulation.DiscreteSimple() coagulation_process = particle_process.Coagulation(     coagulation_strategy=coagulation_strategy )  # Set up time and sub-steps for the coagulation process time_step = 1000 sub_steps = 100  initial_radii = aerosol.particles[0].get_radius() concentration_initial = np.copy(aerosol.particles[0].concentration)  # # Perform coagulation process for step 1 aerosol = coagulation_process.execute(     aerosol, time_step=time_step, sub_steps=sub_steps ) radii_after_step_1 = aerosol.particles[0].get_radius() concentration_step_1 = np.copy(aerosol.particles[0].concentration)  # Perform coagulation process for step 2 aerosol = coagulation_process.execute(     aerosol, time_step=time_step, sub_steps=sub_steps ) radii_after_step_2 = aerosol.particles[0].get_radius() concentration_step_2 = np.copy(aerosol.particles[0].concentration) In\u00a0[4]: Copied! <pre># Create figure for visualizing the histogram of particle radii\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Plot the histogram of particle radii after step 1\nax.plot(initial_radii, concentration_initial, label=\"Initial\")\nax.plot(radii_after_step_1, concentration_step_1, label=\"Step 1\")\nax.plot(radii_after_step_2, concentration_step_2, label=\"Step 2\")\n\n# Set the labels and title of the plot\nax.set_xlabel(\"Particle Radius (m)\")\nax.set_ylabel(r\"Number Concentration ($m^{-3}$)\")\nax.set_title(\"Particle Radius Distribution After Coagulation Steps\")\nax.legend()\nax.set_xscale(\"log\")\nplt.show()\n</pre> # Create figure for visualizing the histogram of particle radii fig, ax = plt.subplots(figsize=(8, 6))  # Plot the histogram of particle radii after step 1 ax.plot(initial_radii, concentration_initial, label=\"Initial\") ax.plot(radii_after_step_1, concentration_step_1, label=\"Step 1\") ax.plot(radii_after_step_2, concentration_step_2, label=\"Step 2\")  # Set the labels and title of the plot ax.set_xlabel(\"Particle Radius (m)\") ax.set_ylabel(r\"Number Concentration ($m^{-3}$)\") ax.set_title(\"Particle Radius Distribution After Coagulation Steps\") ax.legend() ax.set_xscale(\"log\") plt.show()"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_1_PMF_Pattern/#coagulation-patterns-pmf-particle-distribution","title":"Coagulation Patterns: PMF Particle Distribution\u00b6","text":"<p>This notebook explores the coagulation process using a Probability Mass Function (PMF) to define the initial particle size distribution. A PMF provides a representation of discrete particle sizes bins and their associated counts.</p> <p>The PMF-based distribution allows us to model how the number of particles in each size category changes over time due to coagulation, providing insights into the size distribution's shift toward larger particles.</p> <p>PMF Particle Distribution: We initialize the particle size distribution using a PMF, where each particle bin has a concentration count. This discrete distribution captures the initial population of particles, categorized by size. The PMF provides flexibility in representing systems where specific particle sizes are dominant or where particles are grouped into size bins.</p> <p>Coagulation Process: The coagulation process is modeled using a discrete bin approach. We define the coagulation process using a flexible <code>Coagulation</code> class, which allows us to choose different coagulation strategies. In this notebook, we employ the <code>DiscreteSimple</code> strategy, which tracks each particle's properties as it undergoes coagulation.</p> <p>Imports:</p>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_1_PMF_Pattern/#aerosol-setup","title":"Aerosol Setup\u00b6","text":"<p>This section sets up the aerosol system, defining both the atmospheric conditions and the properties of the particles within it. We use the Builder pattern to construct the atmosphere and the particle mass distribution, ensuring that all parameters are defined explicitly and can be validated during the setup process.</p> <p>Atmospheric Setup</p> <p>The atmosphere is created using the <code>AtmosphereBuilder</code>. This class allows us to define key environmental parameters such as the gas species, temperature, and pressure.</p> <ul> <li>Gas Species: We add a preset gas species using the <code>PresetGasSpeciesBuilder</code>, which represents a non-condensing gas in the atmosphere.</li> <li>Temperature: The temperature is set to 25\u00b0C, representing typical atmospheric conditions.</li> <li>Pressure: Atmospheric pressure is set to 1 atm, simulating standard sea-level pressure.</li> </ul> <p>The <code>build()</code> method finalizes the atmosphere object, which will be used in the aerosol simulation.</p> <p>Resolved Particle Mass Representation</p> <p>Next, we define the particle mass distribution using the <code>PresetParticleRadiusBuilder</code>. This builder allows for setting up a detailed particle distribution based on physical properties such as particle size (mode), geometric standard deviation (GSD), and number concentration.</p> <ul> <li>Mode: The particle size modes are set to 100 nm and 800 nm, defining two distinct groups of particles within the aerosol.</li> <li>Geometric Standard Deviation (GSD): GSD values of 1.2 and 1.5 represent the spread of particle sizes within each mode, with the larger GSD indicating a broader distribution of particle sizes.</li> <li>Number Concentration: The number concentration for the two modes is defined as 1e5 and 2e5 particles per cm\u00b3, respectively.</li> <li>Distribution Type: We specify that the distribution follows a Probability Mass Function (PMF), which allows for a discrete representation of particle sizes.</li> <li>Radius Bins: The radius bins are defined using <code>np.logspace</code> to create a logarithmic spacing between particle radii ranging from 10 nm to 100 \u00b5m. This ensures that the distribution captures a wide range of particle sizes.</li> </ul> <p>Once all parameters are set, the <code>build()</code> method finalizes the particle mass representation.</p> <p>Aerosol Object Creation</p> <p>Finally, the aerosol system is created by combining the atmospheric conditions and the resolved particle masses. The resulting <code>aerosol</code> object contains both the gas phase and particle distribution, ready for use in the coagulation simulation.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_1_PMF_Pattern/#simulation","title":"Simulation\u00b6","text":"<p>In this section, we define the coagulation process and run it over multiple time steps. Coagulation is the process by which particles in an aerosol collide and merge, resulting in fewer, larger particles over time. The <code>Coagulation</code> class is used to simulate this behavior in a stepwise manner, updating the particle size distribution as the simulation progresses.</p> <p>Defining the Coagulation Strategy and Process</p> <p>We start by selecting a coagulation strategy using <code>DiscreteSimple()</code>, which defines how particles will interact and merge during the coagulation process. In this case, the <code>DiscreteSimple</code> strategy simplifies the coagulation by treating particle collisions discretely, allowing for straightforward tracking of particle size and number changes.</p> <ul> <li>Coagulation Strategy: The strategy dictates how particle interactions are handled. Here, <code>DiscreteSimple</code> offers a simplified, yet effective, approach for discrete particle interactions.</li> <li>Coagulation Process: The <code>Coagulation</code> class orchestrates the entire process, taking the defined strategy and applying it to the aerosol particles over the specified time and sub-steps.</li> </ul> <p>Simulation Setup: Time and Sub-Steps</p> <p>The coagulation process runs over defined time steps and sub-steps:</p> <ul> <li>Time Step: Each time step simulates the evolution of the aerosol system over a specific interval. In this case, it is set to 1000, representing a coarse time resolution.</li> <li>Sub-Steps: The time step is further divided into 100 sub-steps, which ensures a finer resolution for particle interactions, capturing the nuances of the coagulation process more accurately.</li> </ul> <p>Running the Coagulation Process</p> <p>The coagulation process is executed for the first time step using the <code>execute()</code> method. This method updates the aerosol object, modifying the particle size distribution as particles collide and merge. After this step:</p> <ul> <li>Radii After Step: The particle radii are extracted again to observe the changes in size distribution due to coagulation.</li> <li>Concentration After Step: The concentration of particles in each size bin is updated and saved for comparison.</li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_1_PMF_Pattern/#graphing","title":"Graphing\u00b6","text":"<p>In this section, we visualize how the particle size distribution evolves after each step of the coagulation process. The graph displays the number concentration of particles (in m\u207b\u00b3) as a function of particle radius (in meters). We use three curves to represent the distribution at different stages of the simulation:</p> <ol> <li>Initial: This curve represents the particle distribution before any coagulation occurs.</li> <li>Step 1: This curve shows how the distribution has changed after one step of the coagulation process.</li> <li>Step 2: This curve reflects the further evolution of the particle sizes after a second step of coagulation.</li> </ol> <p>Coagulation Effect:</p> <ul> <li>After the first step (orange line), the peaks shift downward, indicating a reduction in the number concentration of particles across both size ranges. This is due to smaller particles merging through coagulation, resulting in fewer particles overall.</li> <li>After the second step (green line), the number concentration of particles continues to decrease, with the peaks further reducing in height.</li> <li>The shift towards larger particles becomes more evident as the second peak moves slightly to the right. This is a typical result of coagulation, where larger particles grow as smaller particles merge into them.</li> </ul> <p>Distribution Changes:</p> <ul> <li>Decrease in Number Concentration: Coagulation leads to a reduction in the number of smaller particles as they combine to form larger ones. This is reflected in the decrease in concentration after each step.</li> <li>Shift Toward Larger Particles: The coagulation process shifts the distribution toward larger particle sizes. While the first step results in some particles merging, the second step pushes this trend further, as seen in the slight shift of the second peak to larger radii.</li> <li>Wider Distribution: As the simulation progresses, the particle size distribution becomes broader, indicating increased variability in particle sizes. This suggests that coagulation is affecting particles across a range of sizes, not just those at the peaks.</li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_1_PMF_Pattern/#conclusion","title":"Conclusion\u00b6","text":"<p>This notebook demonstrates how a PMF-based particle distribution can be used to model the coagulation process in an aerosol system. By tracking the changes in particle size distribution over time, we can observe the shift towards larger particles due to coagulation. The discrete representation of particle sizes allows for detailed insights into how particles interact and merge, leading to changes in the aerosol composition.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_3_Particle_Resolved_Pattern/","title":"Coagulation Patterns: Particle-Resolved Approach","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# particula imports\nfrom particula import particles\nfrom particula.aerosol import Aerosol\nfrom particula.gas import PresetGasSpeciesBuilder, AtmosphereBuilder\n\nfrom particula.dynamics import particle_process\nfrom particula.dynamics import coagulation\n</pre> import numpy as np import matplotlib.pyplot as plt  # particula imports from particula import particles from particula.aerosol import Aerosol from particula.gas import PresetGasSpeciesBuilder, AtmosphereBuilder  from particula.dynamics import particle_process from particula.dynamics import coagulation In\u00a0[2]: Copied! <pre># Preset gas species that does not condense in the atmosphere\n# AtmosphereBuilder constructs the atmosphere with predefined species\natmosphere = (\n    AtmosphereBuilder()\n    .add_species(PresetGasSpeciesBuilder().build())  # Add a preset gas species\n    .set_temperature(25, temperature_units=\"degC\")  # Set temperature to 25\u00b0C\n    .set_pressure(1, pressure_units=\"atm\")  # Set pressure to 1 atmosphere\n    .build()  # Finalize the atmosphere object\n)\n\n# Generate a particle distribution using a lognormal sample distribution\n# This distribution has a mean particle diameter (mode) and geometric standard deviation (GSD)\nparticle_sample = particles.properties.lognormal_sample_distribution(\n    mode=np.array([100e-9]),  # Mean particle diameter of 100 nm\n    geometric_standard_deviation=np.array([1.3]),  # GSD of 1.3\n    number_of_particles=np.array([1e4]),  # Total number of particles\n    number_of_samples=100_000,  # Number of samples for particle distribution\n)\n\n# Calculate the mass of each particle in the sample, assuming density of 1500 kg/m^3\nparticle_mass_sample = (\n    4 / 3 * np.pi * particle_sample**3 * 1500\n)  # Particle mass in kg\n\n# Build a resolved mass representation for each particle\n# This defines how particle mass, activity, and surface are represented\nresolved_masses = (\n    particles.ResolvedParticleMassRepresentationBuilder()\n    .set_distribution_strategy(particles.ParticleResolvedSpeciatedMass())  # Use speciated mass distribution\n    .set_activity_strategy(particles.ActivityIdealMass())  # Define activity based on ideal mass\n    .set_surface_strategy(particles.SurfaceStrategyVolume())  # Define surface area based on particle volume\n    .set_mass(particle_mass_sample, \"kg\")  # Assign mass of particles (in kg)\n    .set_density(1500, \"kg/m^3\")  # Set particle density to 1500 kg/m^3\n    .set_charge(0)  # Assume neutral particles with no charge\n    .set_volume(0.1, \"cm^3\")  # Set volume of particle distribution\n    .build()  # Finalize the resolved mass representation\n)\n\n# Create an aerosol object with the defined atmosphere and resolved particles\naerosol = Aerosol(atmosphere=atmosphere, particles=resolved_masses)\n\n# Print the properties of the atmosphere\nprint(aerosol)\n</pre> # Preset gas species that does not condense in the atmosphere # AtmosphereBuilder constructs the atmosphere with predefined species atmosphere = (     AtmosphereBuilder()     .add_species(PresetGasSpeciesBuilder().build())  # Add a preset gas species     .set_temperature(25, temperature_units=\"degC\")  # Set temperature to 25\u00b0C     .set_pressure(1, pressure_units=\"atm\")  # Set pressure to 1 atmosphere     .build()  # Finalize the atmosphere object )  # Generate a particle distribution using a lognormal sample distribution # This distribution has a mean particle diameter (mode) and geometric standard deviation (GSD) particle_sample = particles.properties.lognormal_sample_distribution(     mode=np.array([100e-9]),  # Mean particle diameter of 100 nm     geometric_standard_deviation=np.array([1.3]),  # GSD of 1.3     number_of_particles=np.array([1e4]),  # Total number of particles     number_of_samples=100_000,  # Number of samples for particle distribution )  # Calculate the mass of each particle in the sample, assuming density of 1500 kg/m^3 particle_mass_sample = (     4 / 3 * np.pi * particle_sample**3 * 1500 )  # Particle mass in kg  # Build a resolved mass representation for each particle # This defines how particle mass, activity, and surface are represented resolved_masses = (     particles.ResolvedParticleMassRepresentationBuilder()     .set_distribution_strategy(particles.ParticleResolvedSpeciatedMass())  # Use speciated mass distribution     .set_activity_strategy(particles.ActivityIdealMass())  # Define activity based on ideal mass     .set_surface_strategy(particles.SurfaceStrategyVolume())  # Define surface area based on particle volume     .set_mass(particle_mass_sample, \"kg\")  # Assign mass of particles (in kg)     .set_density(1500, \"kg/m^3\")  # Set particle density to 1500 kg/m^3     .set_charge(0)  # Assume neutral particles with no charge     .set_volume(0.1, \"cm^3\")  # Set volume of particle distribution     .build()  # Finalize the resolved mass representation )  # Create an aerosol object with the defined atmosphere and resolved particles aerosol = Aerosol(atmosphere=atmosphere, particles=resolved_masses)  # Print the properties of the atmosphere print(aerosol) <pre>Gas mixture at 298.15 K and 101325.0 Pa consisting of ['Preset100']\n[0]: Particle Representation:\n\tStrategy: ParticleResolvedSpeciatedMass\n\tActivity: ActivityIdealMass\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 8.543e-06 [kg/m^3]\n\tNumber Concentration: 1.000e+12 [#/m^3]\n</pre> In\u00a0[3]: Copied! <pre># Define the coagulation strategy and process\ncoagulation_strategy = coagulation.ParticleResolved()\ncoagulation_process = particle_process.Coagulation(\n    coagulation_strategy=coagulation_strategy\n)\n\n# Set up time and sub-steps for the coagulation process\ntime_step = 1000\nsub_steps = 100\n\n# Define lognormal bins for particle radius histogram\nbins_lognormal = np.logspace(-8, -6, 100)\n\n# Get initial particle radii before the coagulation process\ninitial_radii = aerosol.particles[0].get_radius()\n\n# Perform coagulation process for step 1\naerosol = coagulation_process.execute(\n    aerosol, time_step=time_step, sub_steps=sub_steps\n)\nradii_after_step_1 = aerosol.particles[0].get_radius()\n\n# Perform coagulation process for step 2\naerosol = coagulation_process.execute(\n    aerosol, time_step=time_step, sub_steps=sub_steps\n)\nradii_after_step_2 = aerosol.particles[0].get_radius()\n\n# Count particles that have coagulated (i.e., have zero mass)\nzero_count = np.sum(aerosol.particles[0].get_mass() == 0)\nprint(f\"Particles that coagulated: {zero_count}\")\n</pre> # Define the coagulation strategy and process coagulation_strategy = coagulation.ParticleResolved() coagulation_process = particle_process.Coagulation(     coagulation_strategy=coagulation_strategy )  # Set up time and sub-steps for the coagulation process time_step = 1000 sub_steps = 100  # Define lognormal bins for particle radius histogram bins_lognormal = np.logspace(-8, -6, 100)  # Get initial particle radii before the coagulation process initial_radii = aerosol.particles[0].get_radius()  # Perform coagulation process for step 1 aerosol = coagulation_process.execute(     aerosol, time_step=time_step, sub_steps=sub_steps ) radii_after_step_1 = aerosol.particles[0].get_radius()  # Perform coagulation process for step 2 aerosol = coagulation_process.execute(     aerosol, time_step=time_step, sub_steps=sub_steps ) radii_after_step_2 = aerosol.particles[0].get_radius()  # Count particles that have coagulated (i.e., have zero mass) zero_count = np.sum(aerosol.particles[0].get_mass() == 0) print(f\"Particles that coagulated: {zero_count}\") <pre>Particles that coagulated: 51826\n</pre> In\u00a0[4]: Copied! <pre># Create figure for visualizing the histogram of particle radii\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Plot initial radii distribution\nbins, edges = np.histogram(initial_radii, bins=bins_lognormal)\nax.bar(edges[:-1], bins, width=np.diff(edges), align=\"edge\", label=\"Initial\")\n\n# Plot radii distribution after step 1\nbins, edges = np.histogram(radii_after_step_1, bins=bins_lognormal)\nax.bar(\n    edges[:-1],\n    bins,\n    width=np.diff(edges),\n    align=\"edge\",\n    label=\"After 1 step\",\n    alpha=0.7,\n)\n\n# Plot radii distribution after step 2\nbins, edges = np.histogram(radii_after_step_2, bins=bins_lognormal)\nax.bar(\n    edges[:-1],\n    bins,\n    width=np.diff(edges),\n    align=\"edge\",\n    label=\"After 2 steps\",\n    alpha=0.6,\n)\n\n# Set axes to logarithmic scale for x-axis (particle radius)\nax.set_xscale(\"log\")\n\n# Add labels and legend\nax.set_xlabel(\"Radius (m)\")\nax.set_ylabel(\"Number of particles\")\nplt.legend()\n\n# Show the plot\nplt.show()\n</pre> # Create figure for visualizing the histogram of particle radii fig, ax = plt.subplots(figsize=(8, 6))  # Plot initial radii distribution bins, edges = np.histogram(initial_radii, bins=bins_lognormal) ax.bar(edges[:-1], bins, width=np.diff(edges), align=\"edge\", label=\"Initial\")  # Plot radii distribution after step 1 bins, edges = np.histogram(radii_after_step_1, bins=bins_lognormal) ax.bar(     edges[:-1],     bins,     width=np.diff(edges),     align=\"edge\",     label=\"After 1 step\",     alpha=0.7, )  # Plot radii distribution after step 2 bins, edges = np.histogram(radii_after_step_2, bins=bins_lognormal) ax.bar(     edges[:-1],     bins,     width=np.diff(edges),     align=\"edge\",     label=\"After 2 steps\",     alpha=0.6, )  # Set axes to logarithmic scale for x-axis (particle radius) ax.set_xscale(\"log\")  # Add labels and legend ax.set_xlabel(\"Radius (m)\") ax.set_ylabel(\"Number of particles\") plt.legend()  # Show the plot plt.show()"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_3_Particle_Resolved_Pattern/#coagulation-patterns-particle-resolved-approach","title":"Coagulation Patterns: Particle-Resolved Approach\u00b6","text":"<p>In this notebook, we explore coagulation patterns through a particle-resolved approach. Rather than directly invoking coagulation functions for each calculation, we adopt a more modular and object-oriented programming structure. By employing design patterns, such as the <code>Builder</code> pattern, we simplify the setup and validation of parameters, making the process more maintainable and scalable.</p> <p>This approach allows for the efficient management of both the gas phase and the particle distribution, incorporating the verification of input parameters for accuracy and consistency. The <code>Builder</code> classes facilitate setting up the coagulation environment, from defining the atmospheric conditions to creating particle distributions and specifying their resolved masses.</p> <p>In this example, we preset a non-condensing gas species in the atmosphere and use a lognormal distribution for particles. We represent the particles using a particle-resolved mass framework, where we handle properties like density, charge, and mass with strategies to define the activity, surface area, and distribution.</p> <p>Imports</p>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_3_Particle_Resolved_Pattern/#aerosol-setup","title":"Aerosol Setup\u00b6","text":"<p>In this section, we define the core components of our particle-resolved coagulation system, focusing on the atmosphere setup, particle distribution, and mass resolution. This step-by-step breakdown helps clarify how the <code>Builder</code> pattern organizes the construction of complex objects and ensures input parameters are properly verified.</p> <p>Atmospheric Setup We begin by configuring the atmosphere using the <code>AtmosphereBuilder</code>. This allows for flexibility in defining environmental parameters such as temperature and pressure, as well as adding gas species. In this case, we add a preset gas species that does not condense and set the atmospheric conditions to 25\u00b0C and 1 atm.</p> <p>Particle Distribution The particle distribution is generated using a lognormal distribution, a common approach for representing aerosol particle sizes. The parameters for this distribution include:</p> <ul> <li>A mode of 100 nm, representing the mean particle diameter.</li> <li>A geometric standard deviation (GSD) of 1.3, which controls the spread of particle sizes.</li> <li>The total number of particles is 100,000 samples taken to capture the variability of the distribution.</li> </ul> <p>Mass Calculation The mass of each particle is calculated assuming a particle density of 1500 kg/m\u00b3. This density corresponds to typical aerosol materials like dust or certain types of particulate matter. The particle masses are computed using the formula for the volume of a sphere, multiplied by the density.</p> <p>Resolved Particle Mass Representation To capture the diversity of the aerosol population, we use a particle-resolved representation for mass. This approach explicitly tracks individual particle masses and assigns properties such as density and charge. The key strategies used are:</p> <ul> <li>Distribution strategy: Defines how mass is distributed among particles.</li> <li>Activity strategy: Describes how the activity of the particles is represented, in this case, assuming ideal mass behavior.</li> <li>Surface strategy: Calculates particle surface behavior by volume mixing.</li> </ul> <p>Final Aerosol Object The <code>Aerosol</code> object brings together the atmosphere and the resolved particle masses into a cohesive framework. This encapsulated representation can then be used to simulate particle interactions and coagulation events within the atmosphere.</p> <p>Finally, we print the properties of the <code>aerosol</code> object\u2019s atmosphere to verify the correct setup.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_3_Particle_Resolved_Pattern/#simulation","title":"Simulation\u00b6","text":"<p>In this section, we run the coagulation simulation by first defining the coagulation strategy and the process through which it is executed.</p> <ul> <li><p>Coagulation Strategy: The strategy for how coagulation is performed is selected using <code>coagulation.ParticleResolved()</code>. This specific strategy dictates how particle interactions are handled at the individual particle level, ensuring that the coagulation process respects the details of a particle-resolved approach. In this context, particles are treated as distinct entities, and the merging process is computed explicitly for each pair that interacts.</p> </li> <li><p>Particle Process: Once the strategy is defined, the <code>Coagulation</code> process is initialized by passing the chosen strategy (<code>coagulation_strategy</code>) to the <code>particle_process.Coagulation</code> class. This <code>Coagulation</code> class is responsible for running the actual simulation. It orchestrates the execution of coagulation by applying the selected strategy over the particle distribution. During each execution step, the particle properties\u2014such as mass, size, and count\u2014are updated according to the rules defined by the particle-resolved strategy.</p> </li> <li><p>Execution of the Process: The coagulation process is applied in steps using the <code>coagulation_process.execute()</code> method. In each step, the particles' masses are updated based on the time step and sub-steps provided. The time step controls the temporal resolution of the simulation, while the sub-steps break the time step into finer increments to ensure accurate resolution of coagulation events.</p> </li> </ul> <p>For each step:</p> <ol> <li>The radii of particles are obtained before and after the coagulation step.</li> <li>The updated particle properties, such as radius and mass, are recorded.</li> <li>After the final step, we count the number of particles that have fully coagulated, i.e., those that have a mass of zero.</li> </ol>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_3_Particle_Resolved_Pattern/#graphing","title":"Graphing\u00b6","text":"<p>In this section, we visualize the evolution of the particle size distribution as the coagulation process progresses.</p> <ul> <li>We use a histogram to show the distribution of particle radii at three stages: initially, after step 1, and after step 2.</li> <li>The x-axis is scaled logarithmically to properly represent the range of particle sizes, which can span multiple orders of magnitude.</li> <li>The plot helps illustrate the effect of coagulation, where particles merge over time, shifting the distribution towards larger sizes and reducing the number of smaller particles.</li> </ul> <p>This visual representation provides an intuitive understanding of how the coagulation process influences particle sizes, which is key to understanding aerosol dynamics in various atmospheric conditions.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_3_Particle_Resolved_Pattern/#conclusion","title":"Conclusion\u00b6","text":"<p>In this notebook, we have demonstrated a particle-resolved approach to modeling coagulation patterns in aerosol systems. By leveraging the <code>Builder</code> pattern and modular design, we have created a flexible and extensible framework for simulating particle interactions and tracking their properties over time.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_4_Compared/","title":"Coagulation Patterns: Comparison of Number and Mass","text":"In\u00a0[14]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# particula imports\nfrom particula import particles\nfrom particula.aerosol import Aerosol\nfrom particula.gas import PresetGasSpeciesBuilder, AtmosphereBuilder\n\nfrom particula.dynamics import particle_process\nfrom particula.dynamics import coagulation\n\nfrom particula.util.input_handling import convert_units\n</pre> import numpy as np import matplotlib.pyplot as plt  # particula imports from particula import particles from particula.aerosol import Aerosol from particula.gas import PresetGasSpeciesBuilder, AtmosphereBuilder  from particula.dynamics import particle_process from particula.dynamics import coagulation  from particula.util.input_handling import convert_units In\u00a0[15]: Copied! <pre># common parameters\nmode = np.array([100e-9, 300e-9])  # m\ngeometric_standard_deviation = np.array([1.3, 1.3])\nnumber_of_particles = np.array([0.75, 0.25])  # effective when pdf has multiple modes\ndensity = np.array([1.0e3])\nvolume = 1 * convert_units('cm^3', 'm^3')  # cm^-3 to m^-3\n\n# Preset gas species that does not condense in the atmosphere\n# AtmosphereBuilder constructs the atmosphere with predefined species\natmosphere = (\n    AtmosphereBuilder()\n    .add_species(PresetGasSpeciesBuilder().build())  # Add a preset gas species\n    .set_temperature(25, temperature_units=\"degC\")  # Set temperature to 25\u00b0C\n    .set_pressure(1, pressure_units=\"atm\")  # Set pressure to 1 atmosphere\n    .build()  # Finalize the atmosphere object\n)\n</pre> # common parameters mode = np.array([100e-9, 300e-9])  # m geometric_standard_deviation = np.array([1.3, 1.3]) number_of_particles = np.array([0.75, 0.25])  # effective when pdf has multiple modes density = np.array([1.0e3]) volume = 1 * convert_units('cm^3', 'm^3')  # cm^-3 to m^-3  # Preset gas species that does not condense in the atmosphere # AtmosphereBuilder constructs the atmosphere with predefined species atmosphere = (     AtmosphereBuilder()     .add_species(PresetGasSpeciesBuilder().build())  # Add a preset gas species     .set_temperature(25, temperature_units=\"degC\")  # Set temperature to 25\u00b0C     .set_pressure(1, pressure_units=\"atm\")  # Set pressure to 1 atmosphere     .build()  # Finalize the atmosphere object ) <p>Particle Resolved</p> <p>In this section, we generate a particle distribution using a lognormal sample distribution, which is characterized by a specified mode (mean particle diameter) and geometric standard deviation (GSD). We then calculate the mass of each particle, assuming a constant density.</p> <p>Following this, we create a resolved mass representation for each particle, which defines how properties like mass, activity, and particle surfaces represented. The resolved mass representation is built using predefined strategies for mass distribution, activity, and surface area. We assign particle mass, set density, assume neutral particles (with no charge), and define the volume of the distribution.</p> <p>Finally, we combine the resolved particle properties with the atmospheric conditions to create an <code>Aerosol</code> object, which encapsulates both the particles and the atmosphere. The aerosol properties are then printed to provide an overview of the system.</p> In\u00a0[16]: Copied! <pre>number_of_samples = 100_000  # Number of samples for particle distribution\n\n# Generate a particle distribution using a lognormal sample distribution\n# This distribution has a mean particle diameter (mode) and geometric standard deviation (GSD)\nradii_sample= particles.properties.lognormal_sample_distribution(\n    mode=mode,\n    geometric_standard_deviation=geometric_standard_deviation,\n    number_of_particles=number_of_particles,\n    number_of_samples=number_of_samples,  # Number of samples for particle distribution\n)\n\n# Calculate the mass of each particle in the sample, assuming density of 1500 kg/m^3\nparticle_mass_sample = (\n    4 / 3 * np.pi * radii_sample**3 * density\n)  # Particle mass in kg\n\nprint(f\"Total mass of particles: {np.sum(particle_mass_sample):.2e} kg\")\n# Build a resolved mass representation for each particle\n# This defines how particle mass, activity, and surface are represented\nresolved_masses = (\n    particles.ResolvedParticleMassRepresentationBuilder()\n    # Use specieated mass distribution, ideal mass activity, and volume surface strategy\n    .set_distribution_strategy(particles.ParticleResolvedSpeciatedMass())\n    .set_activity_strategy(particles.ActivityIdealMass())\n    .set_surface_strategy(particles.SurfaceStrategyVolume())\n    .set_mass(particle_mass_sample, \"kg\")  # Assign mass of particles (in kg)\n    .set_density(density, \"kg/m^3\")  # Set particle density\n    .set_charge(0)  # Assume neutral particles with no charge\n    .set_volume(volume)  # Set volume of particle distribution\n    .build()  # Finalize the resolved mass representation\n)\n\n# Create an aerosol object with the defined atmosphere and resolved particles\naerosol_resolved = Aerosol(atmosphere=atmosphere, particles=resolved_masses)\n\n# Print the properties of the aerosol\nprint(aerosol_resolved)\n</pre> number_of_samples = 100_000  # Number of samples for particle distribution  # Generate a particle distribution using a lognormal sample distribution # This distribution has a mean particle diameter (mode) and geometric standard deviation (GSD) radii_sample= particles.properties.lognormal_sample_distribution(     mode=mode,     geometric_standard_deviation=geometric_standard_deviation,     number_of_particles=number_of_particles,     number_of_samples=number_of_samples,  # Number of samples for particle distribution )  # Calculate the mass of each particle in the sample, assuming density of 1500 kg/m^3 particle_mass_sample = (     4 / 3 * np.pi * radii_sample**3 * density )  # Particle mass in kg  print(f\"Total mass of particles: {np.sum(particle_mass_sample):.2e} kg\") # Build a resolved mass representation for each particle # This defines how particle mass, activity, and surface are represented resolved_masses = (     particles.ResolvedParticleMassRepresentationBuilder()     # Use specieated mass distribution, ideal mass activity, and volume surface strategy     .set_distribution_strategy(particles.ParticleResolvedSpeciatedMass())     .set_activity_strategy(particles.ActivityIdealMass())     .set_surface_strategy(particles.SurfaceStrategyVolume())     .set_mass(particle_mass_sample, \"kg\")  # Assign mass of particles (in kg)     .set_density(density, \"kg/m^3\")  # Set particle density     .set_charge(0)  # Assume neutral particles with no charge     .set_volume(volume)  # Set volume of particle distribution     .build()  # Finalize the resolved mass representation )  # Create an aerosol object with the defined atmosphere and resolved particles aerosol_resolved = Aerosol(atmosphere=atmosphere, particles=resolved_masses)  # Print the properties of the aerosol print(aerosol_resolved) <pre>Total mass of particles: 4.29e-12 kg\nGas mixture at 298.15 K and 101325.0 Pa consisting of ['Preset100']\n[0]: Particle Representation:\n\tStrategy: ParticleResolvedSpeciatedMass\n\tActivity: ActivityIdealMass\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 4.292e-06 [kg/m^3]\n\tNumber Concentration: 1.000e+11 [#/m^3]\n</pre> <p>PMF</p> <p>Here, we generate a Probability Mass Function (PMF) approach. We define the radius bins using a logarithmic scale and calculate the number concentration of particles based on the total number of particles and the system volume. The PMF distribution is then built by specifying the particle mode, geometric standard deviation, and number concentration.</p> <p>We set the distribution type to 'PMF' and define the radius bins, which represent the particle size categories. The particle density is also specified, and the PMF-based particle representation is finalized.</p> <p>After setting up the PMF particle distribution, we create an aerosol object that combines the PMF particle properties with the previously defined atmospheric conditions. The properties of the aerosol object are printed to give a summary of the system configuration.</p> In\u00a0[17]: Copied! <pre>radius_bins = np.logspace(-8, -6, 250)  # Define the radius bins for the resolved mass representation\n\nnumber_concentration = number_of_particles* np.array([number_of_samples/volume])  # Calculate the number concentration of particles\nprint(f\"Number concentration: {number_concentration[0]:.2e} m^-3\")\nparticle_pmf = (\n    particles.PresetParticleRadiusBuilder()\n    .set_mode(mode)\n    .set_geometric_standard_deviation(geometric_standard_deviation)\n    .set_number_concentration(number_concentration)\n    .set_distribution_type('pmf')  # Set the distribution type to PMF\n    .set_radius_bins(radius_bins, radius_bins_units=\"m\")  # Set the radius bins\n    .set_density(density, \"kg/m^3\")  # Set particle density\n    .build()  # Finalize the resolved mass representation\n)\n\n# Create an aerosol object with the defined atmosphere and resolved particles\naerosol_pmf = Aerosol(atmosphere=atmosphere, particles=particle_pmf)\n\n# Print the properties of the aerosol\nprint(aerosol_pmf)\n</pre> radius_bins = np.logspace(-8, -6, 250)  # Define the radius bins for the resolved mass representation  number_concentration = number_of_particles* np.array([number_of_samples/volume])  # Calculate the number concentration of particles print(f\"Number concentration: {number_concentration[0]:.2e} m^-3\") particle_pmf = (     particles.PresetParticleRadiusBuilder()     .set_mode(mode)     .set_geometric_standard_deviation(geometric_standard_deviation)     .set_number_concentration(number_concentration)     .set_distribution_type('pmf')  # Set the distribution type to PMF     .set_radius_bins(radius_bins, radius_bins_units=\"m\")  # Set the radius bins     .set_density(density, \"kg/m^3\")  # Set particle density     .build()  # Finalize the resolved mass representation )  # Create an aerosol object with the defined atmosphere and resolved particles aerosol_pmf = Aerosol(atmosphere=atmosphere, particles=particle_pmf)  # Print the properties of the aerosol print(aerosol_pmf)  <pre>Number concentration: 7.50e+10 m^-3\nGas mixture at 298.15 K and 101325.0 Pa consisting of ['Preset100']\n[0]: Particle Representation:\n\tStrategy: RadiiBasedMovingBin\n\tActivity: ActivityIdealMass\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 4.282e-06 [kg/m^3]\n\tNumber Concentration: 1.000e+11 [#/m^3]\n</pre> <p>PDF</p> <p>Lastly, we generate a particle distribution using the Probability Density Function (PDF) approach. Similar to the PMF setup, we specify the particle mode, geometric standard deviation, and number concentration. However, in this case, the distribution type is set to \"PDF\", which models the particle distribution as a continuous probability density function over the defined radius bins.</p> <p>We assign the same logarithmic radius bins as before, specify the particle density, and assume the particles are neutral by setting their charge to zero. After defining all necessary parameters, we finalize the PDF-based particle representation.</p> <p>As with the PMF approach, we create an aerosol object by combining the PDF-based particle distribution with the predefined atmospheric conditions. The properties of the resulting aerosol are printed to summarize the system configuration.</p> In\u00a0[18]: Copied! <pre>particle_pdf = (\n    particles.PresetParticleRadiusBuilder()\n    .set_mode(mode)\n    .set_geometric_standard_deviation(geometric_standard_deviation)\n    .set_number_concentration(number_concentration)\n    .set_distribution_type(\"pdf\")  # Set the distribution type to PMF\n    .set_radius_bins(radius_bins, radius_bins_units=\"m\")  # Set the radius bins\n    .set_density(density, \"kg/m^3\")  # Set particle density\n    .set_charge(np.zeros_like(radius_bins))  # Assume neutral particles with no charge\n    .build()  # Finalize the resolved mass representation\n)\n\n# Create an aerosol object with the defined atmosphere and resolved particles\naerosol_pdf = Aerosol(atmosphere=atmosphere, particles=particle_pdf)\n\n# Print the properties of the aerosol\nprint(aerosol_pdf)\n</pre> particle_pdf = (     particles.PresetParticleRadiusBuilder()     .set_mode(mode)     .set_geometric_standard_deviation(geometric_standard_deviation)     .set_number_concentration(number_concentration)     .set_distribution_type(\"pdf\")  # Set the distribution type to PMF     .set_radius_bins(radius_bins, radius_bins_units=\"m\")  # Set the radius bins     .set_density(density, \"kg/m^3\")  # Set particle density     .set_charge(np.zeros_like(radius_bins))  # Assume neutral particles with no charge     .build()  # Finalize the resolved mass representation )  # Create an aerosol object with the defined atmosphere and resolved particles aerosol_pdf = Aerosol(atmosphere=atmosphere, particles=particle_pdf)  # Print the properties of the aerosol print(aerosol_pdf) <pre>Gas mixture at 298.15 K and 101325.0 Pa consisting of ['Preset100']\n[0]: Particle Representation:\n\tStrategy: RadiiBasedMovingBin\n\tActivity: ActivityIdealMass\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 7.797e+02 [kg/m^3]\n\tNumber Concentration: 4.663e+19 [#/m^3]\n</pre> <p>Plot Initial Distributions</p> <p>In this section, we plot the initial particle distributions for the PMF, and particle-resolved approaches. The plots show the number concentration of particles as a function of particle radius for each method. The PMF is a line, and the particle-resolved has been binned into discrete sizes.</p> In\u00a0[19]: Copied! <pre># plot both\nradius_bins = particle_pmf.get_radius()\nradii_resolved = resolved_masses.get_radius()\n\nfig, ax = plt.subplots()\nbins, edges = np.histogram(radii_resolved, bins=radius_bins)\nax.bar(\n    edges[:-1],\n    bins/volume,\n    width=np.diff(edges),\n    align=\"edge\",\n    label=\"Resolved\",\n    alpha=0.7,\n)\nax.plot(\n    radius_bins,\n    particle_pmf.get_concentration(),\n    label=\"PMF\",\n    color=\"red\",\n)\nax.set_xscale(\"log\")\n# ax.set_yscale(\"log\")\nax.set_xlabel(\"Particle radius (m)\")\nax.set_ylabel(\"Number concentration (m^-3)\")\nax.legend()\nplt.show()\n</pre> # plot both radius_bins = particle_pmf.get_radius() radii_resolved = resolved_masses.get_radius()  fig, ax = plt.subplots() bins, edges = np.histogram(radii_resolved, bins=radius_bins) ax.bar(     edges[:-1],     bins/volume,     width=np.diff(edges),     align=\"edge\",     label=\"Resolved\",     alpha=0.7, ) ax.plot(     radius_bins,     particle_pmf.get_concentration(),     label=\"PMF\",     color=\"red\", ) ax.set_xscale(\"log\") # ax.set_yscale(\"log\") ax.set_xlabel(\"Particle radius (m)\") ax.set_ylabel(\"Number concentration (m^-3)\") ax.legend() plt.show() In\u00a0[20]: Copied! <pre># simulate aerosols, and save total mass and number distribution\n\n# Define the coagulation process\ncoagulation_process_pmf = particle_process.Coagulation(\n    coagulation_strategy=coagulation.DiscreteSimple()\n)\n\ncoagulation_process_resolved = particle_process.Coagulation(\n    coagulation_strategy=coagulation.ParticleResolved(\n        kernel_bins_per_decade=10)\n)\nhard_sphere = coagulation.HardSphere()\ncoagulation_process_pdf = particle_process.Coagulation(\n    coagulation_strategy=coagulation.ContinuousGeneralPDF(hard_sphere)\n)\n\n# Set up time and sub-steps for the coagulation process\ntotal_time = 10000\ntime_step = 100\nsub_steps = 1\n\n# output arrays\ntime = np.arange(0, total_time, time_step)\ntotal_mass_pmf = np.zeros_like(time, dtype=np.float64)\ntotal_mass_resolved = np.ones_like(time, dtype=np.float64)\ntotal_mass_pdf = np.zeros_like(time, dtype=np.float64)\nnumber_distribution_pmf = np.zeros((len(time), len(radius_bins)))\nnumber_distribution_resolved = np.zeros((len(time), number_of_samples))\nnumber_distribution_pdf = np.zeros((len(time), len(radius_bins)))\ntotal_number_pmf = np.zeros_like(time, dtype=np.float64)\ntotal_number_resolved = np.ones_like(time, dtype=np.float64)\ntotal_number_pdf = np.zeros_like(time, dtype=np.float64)\n</pre> # simulate aerosols, and save total mass and number distribution  # Define the coagulation process coagulation_process_pmf = particle_process.Coagulation(     coagulation_strategy=coagulation.DiscreteSimple() )  coagulation_process_resolved = particle_process.Coagulation(     coagulation_strategy=coagulation.ParticleResolved(         kernel_bins_per_decade=10) ) hard_sphere = coagulation.HardSphere() coagulation_process_pdf = particle_process.Coagulation(     coagulation_strategy=coagulation.ContinuousGeneralPDF(hard_sphere) )  # Set up time and sub-steps for the coagulation process total_time = 10000 time_step = 100 sub_steps = 1  # output arrays time = np.arange(0, total_time, time_step) total_mass_pmf = np.zeros_like(time, dtype=np.float64) total_mass_resolved = np.ones_like(time, dtype=np.float64) total_mass_pdf = np.zeros_like(time, dtype=np.float64) number_distribution_pmf = np.zeros((len(time), len(radius_bins))) number_distribution_resolved = np.zeros((len(time), number_of_samples)) number_distribution_pdf = np.zeros((len(time), len(radius_bins))) total_number_pmf = np.zeros_like(time, dtype=np.float64) total_number_resolved = np.ones_like(time, dtype=np.float64) total_number_pdf = np.zeros_like(time, dtype=np.float64) <p>Simulation Loop</p> <p>We then run a simulation loop that iterates over the specified time range, updating the particle distribution at each time step.</p> In\u00a0[21]: Copied! <pre># Simulation loop\n\nfor i, t in enumerate(time):\n    if i &gt; 0:\n        # Perform coagulation for the PDF aerosol\n        aerosol_pdf = coagulation_process_pdf.execute(aerosol_pdf, time_step, sub_steps)\n        # Perform coagulation for the PMF aerosol\n        aerosol_pmf = coagulation_process_pmf.execute(aerosol_pmf, time_step, sub_steps)\n        # Perform coagulation for the resolved aerosol\n        aerosol_resolved = coagulation_process_resolved.execute(aerosol_resolved, time_step, sub_steps)\n\n    total_mass_resolved[i] = aerosol_resolved.particles[0].get_mass_concentration()\n    number_distribution_resolved[i, :] = aerosol_resolved.particles[0].get_radius(clone=True)\n    total_number_resolved[i] = np.sum(number_distribution_resolved[i, :]&gt;0)\n\n    total_mass_pmf[i] = aerosol_pmf.particles[0].get_mass_concentration()\n    number_distribution_pmf[i, :] = aerosol_pmf.particles[0].get_concentration(clone=True)\n    total_number_pmf[i] = np.sum(number_distribution_pmf[i, :])\n\n    total_mass_pdf[i] = aerosol_pdf.particles[0].get_mass_concentration()\n    number_distribution_pdf[i, :] = aerosol_pdf.particles[0].get_concentration(clone=True)\n    total_number_pdf[i] = np.trapezoid(number_distribution_pdf[i, :], radius_bins)\n</pre> # Simulation loop  for i, t in enumerate(time):     if i &gt; 0:         # Perform coagulation for the PDF aerosol         aerosol_pdf = coagulation_process_pdf.execute(aerosol_pdf, time_step, sub_steps)         # Perform coagulation for the PMF aerosol         aerosol_pmf = coagulation_process_pmf.execute(aerosol_pmf, time_step, sub_steps)         # Perform coagulation for the resolved aerosol         aerosol_resolved = coagulation_process_resolved.execute(aerosol_resolved, time_step, sub_steps)      total_mass_resolved[i] = aerosol_resolved.particles[0].get_mass_concentration()     number_distribution_resolved[i, :] = aerosol_resolved.particles[0].get_radius(clone=True)     total_number_resolved[i] = np.sum(number_distribution_resolved[i, :]&gt;0)      total_mass_pmf[i] = aerosol_pmf.particles[0].get_mass_concentration()     number_distribution_pmf[i, :] = aerosol_pmf.particles[0].get_concentration(clone=True)     total_number_pmf[i] = np.sum(number_distribution_pmf[i, :])      total_mass_pdf[i] = aerosol_pdf.particles[0].get_mass_concentration()     number_distribution_pdf[i, :] = aerosol_pdf.particles[0].get_concentration(clone=True)     total_number_pdf[i] = np.trapezoid(number_distribution_pdf[i, :], radius_bins) In\u00a0[22]: Copied! <pre>print(aerosol_resolved)\nprint(aerosol_pmf)\n# print(aerosol_pdf)\n</pre> print(aerosol_resolved) print(aerosol_pmf) # print(aerosol_pdf) <pre>Gas mixture at 298.15 K and 101325.0 Pa consisting of ['Preset100']\n[0]: Particle Representation:\n\tStrategy: ParticleResolvedSpeciatedMass\n\tActivity: ActivityIdealMass\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 4.291e-06 [kg/m^3]\n\tNumber Concentration: 6.287e+10 [#/m^3]\nGas mixture at 298.15 K and 101325.0 Pa consisting of ['Preset100']\n[0]: Particle Representation:\n\tStrategy: RadiiBasedMovingBin\n\tActivity: ActivityIdealMass\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 4.242e-06 [kg/m^3]\n\tNumber Concentration: 6.259e+10 [#/m^3]\n</pre> In\u00a0[23]: Copied! <pre># plot the initial and final distributions\nfig, ax = plt.subplots(figsize=(8, 5))\n\nbins, edges = np.histogram(\n    number_distribution_resolved[0, :], bins=radius_bins\n)\nax.bar(\n    edges[:-1],\n    bins / volume,\n    width=np.diff(edges),\n    align=\"edge\",\n    label=\"Resolved initial\",\n    color=\"red\",\n    alpha=0.7,\n)\nbins, edges = np.histogram(\n    number_distribution_resolved[-1, :], bins=radius_bins\n)\nax.bar(\n    edges[:-1],\n    bins / volume,\n    width=np.diff(edges),\n    align=\"edge\",\n    label=\"Resolved final\",\n    color=\"blue\",\n    alpha=0.7,\n)\n\nax.plot(radius_bins, number_distribution_pmf[0, :], label=\"PMF initial\", color=\"red\")\nax.plot(radius_bins, number_distribution_pmf[-1, :], label=\"PMF final\", color=\"blue\")\n\nax.set_xscale(\"log\")\nax.set_xlabel(\"Particle radius (m)\")\nax.set_ylabel(\"Number concentration (m^-3)\")\nax.legend()\nplt.show()\n</pre> # plot the initial and final distributions fig, ax = plt.subplots(figsize=(8, 5))  bins, edges = np.histogram(     number_distribution_resolved[0, :], bins=radius_bins ) ax.bar(     edges[:-1],     bins / volume,     width=np.diff(edges),     align=\"edge\",     label=\"Resolved initial\",     color=\"red\",     alpha=0.7, ) bins, edges = np.histogram(     number_distribution_resolved[-1, :], bins=radius_bins ) ax.bar(     edges[:-1],     bins / volume,     width=np.diff(edges),     align=\"edge\",     label=\"Resolved final\",     color=\"blue\",     alpha=0.7, )  ax.plot(radius_bins, number_distribution_pmf[0, :], label=\"PMF initial\", color=\"red\") ax.plot(radius_bins, number_distribution_pmf[-1, :], label=\"PMF final\", color=\"blue\")  ax.set_xscale(\"log\") ax.set_xlabel(\"Particle radius (m)\") ax.set_ylabel(\"Number concentration (m^-3)\") ax.legend() plt.show() <p>Plot Mass Conservation</p> <p>In and ideal system, the mass should be conserved. In this section, we plot the mass conservation for the PMF, PDF, and particle-resolved approaches. The plots show the total mass of particles as a function of time during the coagulation process. The mass should remain constant over time, indicating that mass is conserved in the system.</p> <p>In our case, there is some numerical error in the mass conservation, this is particularly evident in the PMF method.</p> In\u00a0[24]: Copied! <pre># mass conservation plot\n\nmass_pmf_error = (total_mass_pmf - total_mass_pmf[0]) / total_mass_pmf[0]\nmass_resolved_error = (total_mass_resolved - total_mass_resolved[0]) / total_mass_resolved[0]\n\n\nfig, ax = plt.subplots(figsize=(8, 5))\nax.plot(time, mass_pmf_error, label=\"Probability Mass Function\")\nax.plot(time, mass_resolved_error, label=\"Particle Resolved\")\n# ax.set_yscale(\"log\")\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(\"Mass Error (relative to start)\")\nax.set_title(\"Error in mass conservation\")\nax.legend()\nplt.show()\n</pre> # mass conservation plot  mass_pmf_error = (total_mass_pmf - total_mass_pmf[0]) / total_mass_pmf[0] mass_resolved_error = (total_mass_resolved - total_mass_resolved[0]) / total_mass_resolved[0]   fig, ax = plt.subplots(figsize=(8, 5)) ax.plot(time, mass_pmf_error, label=\"Probability Mass Function\") ax.plot(time, mass_resolved_error, label=\"Particle Resolved\") # ax.set_yscale(\"log\") ax.set_xlabel(\"Time (s)\") ax.set_ylabel(\"Mass Error (relative to start)\") ax.set_title(\"Error in mass conservation\") ax.legend() plt.show() <p>Plot Number Error</p> <p>For the number concentration, we use the PDF distribution as the reference. We calculate the percent error in the number concentration for the PMF and particle-resolved approaches compared to the PDF distribution.</p> In\u00a0[25]: Copied! <pre># sum number concentration and plot\n\ntotal_pmf = np.sum(number_distribution_pmf, axis=1)\ntotal_resolved_non_zero = number_distribution_resolved &gt; 0\ntotal_resolved = np.sum(total_resolved_non_zero, axis=1) / volume\n\npercent_diff_resolved = (total_number_pdf - total_resolved) / total_number_pdf * 100\npercent_diff_pmf = (total_number_pdf - total_pmf) / total_number_pdf * 100\n\nprint(\n    f\"Resolved number final: {total_resolved[-1]:.2e}, PMF number final: {total_pmf[-1]:.2e}\"\n)\n\nfig, ax = plt.subplots(figsize=(8, 5))\nax.plot(time, percent_diff_resolved, label=\"Particle Resolved\", linestyle=\"--\")\nax.plot(time, percent_diff_pmf, label=\"Probability Mass Function\", linestyle=\"--\")\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(\"Percent Difference vs Probability Density Function\")\nax.set_title(\"Numerical Error in Number Concentration\")\nax.legend()\nplt.show()\n</pre> # sum number concentration and plot  total_pmf = np.sum(number_distribution_pmf, axis=1) total_resolved_non_zero = number_distribution_resolved &gt; 0 total_resolved = np.sum(total_resolved_non_zero, axis=1) / volume  percent_diff_resolved = (total_number_pdf - total_resolved) / total_number_pdf * 100 percent_diff_pmf = (total_number_pdf - total_pmf) / total_number_pdf * 100  print(     f\"Resolved number final: {total_resolved[-1]:.2e}, PMF number final: {total_pmf[-1]:.2e}\" )  fig, ax = plt.subplots(figsize=(8, 5)) ax.plot(time, percent_diff_resolved, label=\"Particle Resolved\", linestyle=\"--\") ax.plot(time, percent_diff_pmf, label=\"Probability Mass Function\", linestyle=\"--\") ax.set_xlabel(\"Time (s)\") ax.set_ylabel(\"Percent Difference vs Probability Density Function\") ax.set_title(\"Numerical Error in Number Concentration\") ax.legend() plt.show() <pre>Resolved number final: 6.29e+10, PMF number final: 6.26e+10\n</pre>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_4_Compared/#coagulation-patterns-comparison-of-number-and-mass","title":"Coagulation Patterns: Comparison of Number and Mass\u00b6","text":"<p>In this notebook, we explore and compare three distinct methods for representing particle distributions and modeling the coagulation process: the probability mass function (PMF), the probability density function (PDF), and the particle-resolved approach. The goal is to evaluate how each method impacts the number and mass of particles as coagulation progresses, providing insight into their strengths and limitations.</p> <p>Imports</p>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_4_Compared/#setup-distributions","title":"Setup Distributions\u00b6","text":"<p>In this section, we define the common parameters used throughout the notebook for modeling the particle distribution and atmosphere. These parameters include the mode of the particle size distribution, the geometric standard deviation, the number of particles in each mode, and the particle density. Additionally, we set the volume of the system for our simulations. The volume is only needed for the particle resolved approach, as the PMF and PDF methods do not require a volume to be defined.</p> <p>We also construct a simplified atmospheric environment using an <code>AtmosphereBuilder</code>, which includes a preset gas species that does not condense in the atmosphere. The temperature is set to 25\u00b0C and the pressure to 1 atmosphere, reflecting typical ambient conditions.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_4_Compared/#simulate-coagulation","title":"Simulate Coagulation\u00b6","text":"<p>In this section, we simulate the coagulation process for the PMF, PDF, and particle-resolved approaches. We define the time step for the simulation and the total simulation time. The time step is used to update the particle distribution at regular intervals, while the total simulation time determines the duration of the coagulation process.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_4_Compared/#results","title":"Results\u00b6","text":"<p>The results of the coagulation simulations are presented in this section. We compare the number and mass of particles for the PMF, PDF, and particle-resolved approaches at different time points during the coagulation process.</p> <p>The fist thing to check is the final state of the aerosol system.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_4_Compared/#conclusion","title":"Conclusion\u00b6","text":"<p>In this notebook, we compared the PMF, PDF, and particle-resolved approaches for modeling particle distributions and the coagulation process. We found that each method has its strengths and limitations, with the PMF and PDF approaches providing a more continuous representation of the particle distribution, while the particle-resolved approach offers a more detailed view of individual particles.</p> <p>They all have numerical errors, but the PDF method is the most accurate in terms of mass conservation and number concentration. The PMF method has the largest error in mass concentration. The particle-resolved method has variable error in number concentration.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/","title":"Coagulation Basic 1: PMF Representation","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# particula imports\nfrom particula.dynamics.coagulation import brownian_kernel, rate\nfrom particula.particles.properties.lognormal_size_distribution import (\n    lognormal_pmf_distribution,\n)\n\n# The `brownian_kernel` function calculates the Brownian coagulation kernel,\n# which determines the rate at which particles coagulate due to random motion.\n# The `rate` function computes the rate of change in particle concentration\n# due to the coagulation process.\n# The `lognormal_pmf_distribution` function generates a probability mass function\n# based on a lognormal size distribution, commonly used to represent aerosol particles.\n</pre> import numpy as np import matplotlib.pyplot as plt import pandas as pd  # particula imports from particula.dynamics.coagulation import brownian_kernel, rate from particula.particles.properties.lognormal_size_distribution import (     lognormal_pmf_distribution, )  # The `brownian_kernel` function calculates the Brownian coagulation kernel, # which determines the rate at which particles coagulate due to random motion. # The `rate` function computes the rate of change in particle concentration # due to the coagulation process. # The `lognormal_pmf_distribution` function generates a probability mass function # based on a lognormal size distribution, commonly used to represent aerosol particles. In\u00a0[2]: Copied! <pre># Create a size distribution for aerosol particles\n\n# Define the bins for particle radius using a logarithmic scale\nradius_bins = np.logspace(start=-9, stop=-5, num=10)  # m (1 nm to 10 \u03bcm)\n\n# Calculate the mass of particles for each size bin\n# The mass is calculated using the formula for the volume of a sphere (4/3 * \u03c0 * r^3)\n# and assuming a particle density of 1 g/cm^3 (which is 1000 kg/m^3 in SI units).\nmass_bins = 4 / 3 * np.pi * radius_bins**3 * 1e3  # kg\n</pre> # Create a size distribution for aerosol particles  # Define the bins for particle radius using a logarithmic scale radius_bins = np.logspace(start=-9, stop=-5, num=10)  # m (1 nm to 10 \u03bcm)  # Calculate the mass of particles for each size bin # The mass is calculated using the formula for the volume of a sphere (4/3 * \u03c0 * r^3) # and assuming a particle density of 1 g/cm^3 (which is 1000 kg/m^3 in SI units). mass_bins = 4 / 3 * np.pi * radius_bins**3 * 1e3  # kg In\u00a0[3]: Copied! <pre># Calculate the Brownian coagulation kernel matrix\n\n# The Brownian coagulation kernel is calculated using the `brownian_coagulation_kernel_via_system_state` function.\n# This function takes into account the particle size, mass, temperature, pressure, and collision efficiency\n# to compute the coagulation rates between particles of different sizes.\nkernel = brownian_kernel.brownian_coagulation_kernel_via_system_state(\n    radius_particle=radius_bins,\n    mass_particle=mass_bins,\n    temperature=293.15,  # Temperature in Kelvin (20\u00b0C)\n    pressure=101325,  # Pressure in Pascals (1 atm)\n    alpha_collision_efficiency=1.0,  # Assume perfect collision efficiency\n)\n\n# Display the shape of the kernel matrix to confirm its dimensions\nprint(f\"Kernel shape: {kernel.shape}\")\n\n# Create a pandas DataFrame from the kernel matrix\n# The DataFrame allows for easier analysis and visualization of the coagulation kernel.\n# Rows and columns are indexed by the particle radius bins, making it clear which sizes are interacting.\ndf_kernel = pd.DataFrame(kernel, index=radius_bins, columns=radius_bins)\n\n# Print the first 5 rows of the DataFrame to inspect the computed kernel values\ndf_kernel.head(5)\n\n# Optional: Save the kernel matrix to a CSV file for further analysis or sharing\n# df_kernel.to_csv(\"kernel.csv\")\n</pre> # Calculate the Brownian coagulation kernel matrix  # The Brownian coagulation kernel is calculated using the `brownian_coagulation_kernel_via_system_state` function. # This function takes into account the particle size, mass, temperature, pressure, and collision efficiency # to compute the coagulation rates between particles of different sizes. kernel = brownian_kernel.brownian_coagulation_kernel_via_system_state(     radius_particle=radius_bins,     mass_particle=mass_bins,     temperature=293.15,  # Temperature in Kelvin (20\u00b0C)     pressure=101325,  # Pressure in Pascals (1 atm)     alpha_collision_efficiency=1.0,  # Assume perfect collision efficiency )  # Display the shape of the kernel matrix to confirm its dimensions print(f\"Kernel shape: {kernel.shape}\")  # Create a pandas DataFrame from the kernel matrix # The DataFrame allows for easier analysis and visualization of the coagulation kernel. # Rows and columns are indexed by the particle radius bins, making it clear which sizes are interacting. df_kernel = pd.DataFrame(kernel, index=radius_bins, columns=radius_bins)  # Print the first 5 rows of the DataFrame to inspect the computed kernel values df_kernel.head(5)  # Optional: Save the kernel matrix to a CSV file for further analysis or sharing # df_kernel.to_csv(\"kernel.csv\") <pre>Kernel shape: (10, 10)\n</pre> Out[3]: 1.000000e-09 2.782559e-09 7.742637e-09 2.154435e-08 5.994843e-08 1.668101e-07 4.641589e-07 1.291550e-06 3.593814e-06 1.000000e-05 1.000000e-09 8.812734e-16 2.277171e-15 1.181152e-14 7.503580e-14 4.506909e-13 2.024284e-12 6.824175e-12 2.020759e-11 5.737860e-11 1.607645e-10 2.782559e-09 2.277171e-15 1.461722e-15 3.692369e-15 1.733024e-14 8.141373e-14 3.005388e-13 9.275265e-13 2.670597e-12 7.517319e-12 2.100038e-11 7.742637e-09 1.181152e-14 3.692369e-15 2.224511e-15 4.558035e-15 1.429060e-14 4.375392e-14 1.267816e-13 3.580220e-13 1.001331e-12 2.790647e-12 2.154435e-08 7.503580e-14 1.733024e-14 4.558035e-15 2.123764e-15 3.008409e-15 7.020882e-15 1.858550e-14 5.087944e-14 1.407135e-13 3.904922e-13 5.994843e-08 4.506909e-13 8.141373e-14 1.429060e-14 3.008409e-15 1.304527e-15 1.624475e-15 3.413800e-15 8.588241e-15 2.303139e-14 6.320152e-14 In\u00a0[4]: Copied! <pre># Plot the Brownian coagulation kernel\n\n# Create a figure and axis object using matplotlib\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Plot the kernel values against the particle radius bins\n# The kernel values are plotted on a logarithmic scale (log10) for better visualization.\nax.plot(radius_bins, np.log10(kernel))\n\n# Set the x-axis label to indicate the particle radius in meters\nax.set_xlabel(\"Particle radius (m)\")\n\n# Set the y-axis label to indicate the logarithm of the kernel values\nax.set_ylabel(\"Log10(Kernel)\")\n\n# Use a logarithmic scale for the x-axis to properly represent the wide range of particle sizes\nax.set_xscale(\"log\")\n\n# Optionally, the y-axis can also be set to a logarithmic scale if needed\n# ax.set_yscale(\"log\")\n\n# Display the plot\nplt.show()\n</pre> # Plot the Brownian coagulation kernel  # Create a figure and axis object using matplotlib fig, ax = plt.subplots(figsize=(8, 6))  # Plot the kernel values against the particle radius bins # The kernel values are plotted on a logarithmic scale (log10) for better visualization. ax.plot(radius_bins, np.log10(kernel))  # Set the x-axis label to indicate the particle radius in meters ax.set_xlabel(\"Particle radius (m)\")  # Set the y-axis label to indicate the logarithm of the kernel values ax.set_ylabel(\"Log10(Kernel)\")  # Use a logarithmic scale for the x-axis to properly represent the wide range of particle sizes ax.set_xscale(\"log\")  # Optionally, the y-axis can also be set to a logarithmic scale if needed # ax.set_yscale(\"log\")  # Display the plot plt.show() In\u00a0[5]: Copied! <pre># Define the initial particle concentration\n\n# Set the initial concentration for each size bin\n# The concentration is set uniformly across all bins at 100 particles per cubic centimeter (100 cm^-3),\n# which is equivalent to 100 * 1e6 particles per cubic meter (m^-3).\nconcentration_0 = np.ones_like(radius_bins) * 100 * 1e6  # m^-3\n\n# Plot the initial concentration distribution\n\n# Create a figure and axis object for the plot\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Plot the concentration against the particle radius\nax.plot(radius_bins, concentration_0)\n\n# Set the x-axis label to indicate the particle radius in meters\nax.set_xlabel(\"Particle radius (m)\")\n\n# Set the y-axis label to indicate the concentration in particles per cubic meter\nax.set_ylabel(\"Concentration (m^-3)\")\n\n# Use a logarithmic scale for both the x-axis and y-axis\n# This is because the concentration distribution is typically viewed across several orders of magnitude\nax.set_xscale(\"log\")\nax.set_yscale(\"log\")\n\n# Display the plot\nplt.show()\n</pre> # Define the initial particle concentration  # Set the initial concentration for each size bin # The concentration is set uniformly across all bins at 100 particles per cubic centimeter (100 cm^-3), # which is equivalent to 100 * 1e6 particles per cubic meter (m^-3). concentration_0 = np.ones_like(radius_bins) * 100 * 1e6  # m^-3  # Plot the initial concentration distribution  # Create a figure and axis object for the plot fig, ax = plt.subplots(figsize=(8, 6))  # Plot the concentration against the particle radius ax.plot(radius_bins, concentration_0)  # Set the x-axis label to indicate the particle radius in meters ax.set_xlabel(\"Particle radius (m)\")  # Set the y-axis label to indicate the concentration in particles per cubic meter ax.set_ylabel(\"Concentration (m^-3)\")  # Use a logarithmic scale for both the x-axis and y-axis # This is because the concentration distribution is typically viewed across several orders of magnitude ax.set_xscale(\"log\") ax.set_yscale(\"log\")  # Display the plot plt.show() In\u00a0[6]: Copied! <pre># Coagulation rate calculation\n\n# Calculate the gain, loss, and net change in particle concentration due to coagulation\n# `discrete_gain`: Calculates the rate at which particles are gained due to coagulation\n# `discrete_loss`: Calculates the rate at which particles are lost due to coagulation\ngain_0 = rate.discrete_gain(radius_bins, concentration_0, kernel)\nloss_0 = rate.discrete_loss(concentration_0, kernel)\nnet_0 = gain_0 - loss_0  # Net change in concentration\n\n# Create a DataFrame to display the gain, loss, and net coagulation rates\n# The DataFrame is indexed by particle radius bins for clarity\ndf = pd.DataFrame(\n    data={\"Gain\": gain_0, \"Loss\": loss_0, \"Net\": net_0}, index=radius_bins\n)\n\n# Display the first 5 rows of the DataFrame\ndf.head(5)\n</pre> # Coagulation rate calculation  # Calculate the gain, loss, and net change in particle concentration due to coagulation # `discrete_gain`: Calculates the rate at which particles are gained due to coagulation # `discrete_loss`: Calculates the rate at which particles are lost due to coagulation gain_0 = rate.discrete_gain(radius_bins, concentration_0, kernel) loss_0 = rate.discrete_loss(concentration_0, kernel) net_0 = gain_0 - loss_0  # Net change in concentration  # Create a DataFrame to display the gain, loss, and net coagulation rates # The DataFrame is indexed by particle radius bins for clarity df = pd.DataFrame(     data={\"Gain\": gain_0, \"Loss\": loss_0, \"Net\": net_0}, index=radius_bins )  # Display the first 5 rows of the DataFrame df.head(5) Out[6]: Gain Loss Net 1.000000e-09 4.379653 2.477398e+06 -2.477394e+06 2.782559e-09 25.830601 3.252254e+05 -3.251995e+05 7.742637e-09 79.877700 4.357112e+04 -4.349124e+04 2.154435e-08 1666.815122 7.097477e+03 -5.430662e+03 5.994843e-08 -12799.281898 6.505676e+03 -1.930496e+04 In\u00a0[7]: Copied! <pre># Plot the coagulation gain, loss, and net rates\n\n# Create a figure and axis object for the plot\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Plot the net coagulation rate\n# The net rate is plotted with a thicker gray line for emphasis\nax.plot(radius_bins, net_0, label=\"Net\", color=\"gray\", linewidth=4)\n\n# Plot the gain rate\n# The gain rate is plotted in dark green\nax.plot(radius_bins, gain_0, label=\"Gain\", color=\"darkgreen\")\n\n# Plot the loss rate\n# The loss rate is plotted in red, and multiplied by -1 for plotting to indicate that it's a removal process\nax.plot(radius_bins, -1 * loss_0, label=\"Loss\", color=\"red\")\n\n# Set the x-axis label to indicate the particle radius in meters\nax.set_xlabel(\"Particle radius (m)\")\n\n# Set the y-axis label to indicate the rate of change in concentration, with appropriate units\nax.set_ylabel(r\"Rate $\\dfrac{1}{m^{3} s^{1}}$\")\n\n# Use a logarithmic scale for the x-axis to account for the wide range of particle sizes\nax.set_xscale(\"log\")\n\n# Add a legend to the plot to identify the gain, loss, and net lines\nplt.legend()\n\n# Display the plot\nplt.show()\n</pre> # Plot the coagulation gain, loss, and net rates  # Create a figure and axis object for the plot fig, ax = plt.subplots(figsize=(8, 6))  # Plot the net coagulation rate # The net rate is plotted with a thicker gray line for emphasis ax.plot(radius_bins, net_0, label=\"Net\", color=\"gray\", linewidth=4)  # Plot the gain rate # The gain rate is plotted in dark green ax.plot(radius_bins, gain_0, label=\"Gain\", color=\"darkgreen\")  # Plot the loss rate # The loss rate is plotted in red, and multiplied by -1 for plotting to indicate that it's a removal process ax.plot(radius_bins, -1 * loss_0, label=\"Loss\", color=\"red\")  # Set the x-axis label to indicate the particle radius in meters ax.set_xlabel(\"Particle radius (m)\")  # Set the y-axis label to indicate the rate of change in concentration, with appropriate units ax.set_ylabel(r\"Rate $\\dfrac{1}{m^{3} s^{1}}$\")  # Use a logarithmic scale for the x-axis to account for the wide range of particle sizes ax.set_xscale(\"log\")  # Add a legend to the plot to identify the gain, loss, and net lines plt.legend()  # Display the plot plt.show() In\u00a0[8]: Copied! <pre># Simulating the coagulation process over time manually\n\n# Define the time step for the simulation\nTIME_STEP = 0.1  # seconds\n\n# Time step 1: Calculate the gain, loss, and net rate, then update concentration\n\n# Calculate the rate of change in concentration (gain and loss) for the initial concentration\ngain = rate.discrete_gain(radius_bins, concentration_0, kernel)\nloss = rate.discrete_loss(concentration_0, kernel)\nnet = gain - loss  # Net rate of change\n\n# Update the concentration for the next time step\nconcentration_1 = concentration_0 + net * TIME_STEP\n\n# Time step 2: Recalculate rates with the updated concentration and update again\n\n# Recalculate gain and loss based on the updated concentration from time step 1\ngain = rate.discrete_gain(radius_bins, concentration_1, kernel)\nloss = rate.discrete_loss(concentration_1, kernel)\nnet = gain - loss\n\n# Update the concentration for the next time step\nconcentration_2 = concentration_1 + net * TIME_STEP\n\n# Time step 3: Recalculate rates again and update concentration\n\n# Recalculate gain and loss based on the updated concentration from time step 2\ngain = rate.discrete_gain(radius_bins, concentration_2, kernel)\nloss = rate.discrete_loss(concentration_2, kernel)\nnet = gain - loss\n\n# Update the concentration for the next time step\nconcentration_3 = concentration_2 + net * TIME_STEP\n\n# Print the maximum concentration at each time step to observe changes\nprint(f\"Concentration 0 max: {concentration_0.max()}\")\nprint(f\"Concentration 1 max: {concentration_1.max()}\")\nprint(f\"Concentration 2 max: {concentration_2.max()}\")\nprint(f\"Concentration 3 max: {concentration_3.max()}\")\n\n# Combine the concentrations at each time step into a DataFrame for easy comparison\ndf_concentration = pd.DataFrame(\n    {\n        \"0\": concentration_0,\n        \"1\": concentration_1,\n        \"2\": concentration_2,\n        \"3\": concentration_3,\n    },\n    index=radius_bins,\n)\n\n# Display the first five rows of the DataFrame to inspect the concentration changes\ndf_concentration.head(5)\n\n# Optional: Save the concentration data to a CSV file for further analysis\n# df_concentration.to_csv(\"concentration_uniform_sim.csv\")\n</pre> # Simulating the coagulation process over time manually  # Define the time step for the simulation TIME_STEP = 0.1  # seconds  # Time step 1: Calculate the gain, loss, and net rate, then update concentration  # Calculate the rate of change in concentration (gain and loss) for the initial concentration gain = rate.discrete_gain(radius_bins, concentration_0, kernel) loss = rate.discrete_loss(concentration_0, kernel) net = gain - loss  # Net rate of change  # Update the concentration for the next time step concentration_1 = concentration_0 + net * TIME_STEP  # Time step 2: Recalculate rates with the updated concentration and update again  # Recalculate gain and loss based on the updated concentration from time step 1 gain = rate.discrete_gain(radius_bins, concentration_1, kernel) loss = rate.discrete_loss(concentration_1, kernel) net = gain - loss  # Update the concentration for the next time step concentration_2 = concentration_1 + net * TIME_STEP  # Time step 3: Recalculate rates again and update concentration  # Recalculate gain and loss based on the updated concentration from time step 2 gain = rate.discrete_gain(radius_bins, concentration_2, kernel) loss = rate.discrete_loss(concentration_2, kernel) net = gain - loss  # Update the concentration for the next time step concentration_3 = concentration_2 + net * TIME_STEP  # Print the maximum concentration at each time step to observe changes print(f\"Concentration 0 max: {concentration_0.max()}\") print(f\"Concentration 1 max: {concentration_1.max()}\") print(f\"Concentration 2 max: {concentration_2.max()}\") print(f\"Concentration 3 max: {concentration_3.max()}\")  # Combine the concentrations at each time step into a DataFrame for easy comparison df_concentration = pd.DataFrame(     {         \"0\": concentration_0,         \"1\": concentration_1,         \"2\": concentration_2,         \"3\": concentration_3,     },     index=radius_bins, )  # Display the first five rows of the DataFrame to inspect the concentration changes df_concentration.head(5)  # Optional: Save the concentration data to a CSV file for further analysis # df_concentration.to_csv(\"concentration_uniform_sim.csv\") <pre>Concentration 0 max: 100000000.0\nConcentration 1 max: 1263633883.0015862\nConcentration 2 max: 11241880825.442844\nConcentration 3 max: 98778247873.61397\n</pre> Out[8]: 0 1 2 3 1.000000e-09 100000000.0 9.975226e+07 9.765578e+07 7.995004e+07 2.782559e-09 100000000.0 9.996748e+07 9.969288e+07 9.733161e+07 7.742637e-09 100000000.0 9.999565e+07 9.995912e+07 9.964448e+07 2.154435e-08 100000000.0 9.999946e+07 9.999441e+07 9.995043e+07 5.994843e-08 100000000.0 9.999807e+07 9.999542e+07 9.998650e+07 In\u00a0[9]: Copied! <pre># Plot the evolution of particle concentration over time\n\n# Create a figure and axis object for the plot\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Plot the concentration distribution at each time step\nax.plot(radius_bins, concentration_0, label=\"t=0\", linestyle=\"-\", color=\"blue\")\nax.plot(\n    radius_bins, concentration_1, label=\"t=1\", linestyle=\"--\", color=\"green\"\n)\nax.plot(\n    radius_bins, concentration_2, label=\"t=2\", linestyle=\"-.\", color=\"orange\"\n)\nax.plot(radius_bins, concentration_3, label=\"t=3\", linestyle=\":\", color=\"red\")\n\n# Set the x-axis label to indicate the particle radius in meters\nax.set_xlabel(\"Particle radius (m)\")\n\n# Set the y-axis label to indicate the concentration in particles per cubic meter\nax.set_ylabel(r\"Concentration $\\dfrac{1}{m^{3}}$\")\n\n# Use logarithmic scales for both the x-axis and y-axis\n# This helps in visualizing the broad range of particle sizes and concentration changes\nax.set_xscale(\"log\")\nax.set_yscale(\"log\")\n\n# Add a legend to differentiate between the time steps\nplt.legend()\n\n# Display the plot\nplt.show()\n</pre> # Plot the evolution of particle concentration over time  # Create a figure and axis object for the plot fig, ax = plt.subplots(figsize=(8, 6))  # Plot the concentration distribution at each time step ax.plot(radius_bins, concentration_0, label=\"t=0\", linestyle=\"-\", color=\"blue\") ax.plot(     radius_bins, concentration_1, label=\"t=1\", linestyle=\"--\", color=\"green\" ) ax.plot(     radius_bins, concentration_2, label=\"t=2\", linestyle=\"-.\", color=\"orange\" ) ax.plot(radius_bins, concentration_3, label=\"t=3\", linestyle=\":\", color=\"red\")  # Set the x-axis label to indicate the particle radius in meters ax.set_xlabel(\"Particle radius (m)\")  # Set the y-axis label to indicate the concentration in particles per cubic meter ax.set_ylabel(r\"Concentration $\\dfrac{1}{m^{3}}$\")  # Use logarithmic scales for both the x-axis and y-axis # This helps in visualizing the broad range of particle sizes and concentration changes ax.set_xscale(\"log\") ax.set_yscale(\"log\")  # Add a legend to differentiate between the time steps plt.legend()  # Display the plot plt.show() In\u00a0[10]: Copied! <pre># Define fine scale radius bins and corresponding mass bins for a lognormal distribution\n\n# Create fine scale radius bins on a logarithmic scale from 1 nm to 10 \u03bcm\nradius_bins = np.logspace(start=-9, stop=-4, num=250)  # m (1 nm to 10 \u03bcm)\n\n# Calculate the mass for each particle size bin assuming a density of 1 g/cm^3 (1000 kg/m^3)\nmass_bins = 4 / 3 * np.pi * (radius_bins) ** 3 * 1e3  # kg\n\n# Generate a lognormal particle size distribution\n# This distribution is characterized by a mode (most probable size) of 100 nm,\n# a geometric standard deviation of 1.4, and a total number concentration of 10000 particles per cm^3.\nconcentration_lognormal_0 = lognormal_pmf_distribution(\n    x_values=radius_bins,\n    mode=np.array(100e-9),  # Mode of the distribution (100 nm)\n    geometric_standard_deviation=np.array(1.4),  # Geometric standard deviation\n    number_of_particles=np.array(\n        1e6 * 1e6  # Total concentration (10000 cm^-3 converted to m^-3)\n    ),\n)\n\n# Plot the lognormal concentration distribution\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(radius_bins, concentration_lognormal_0)\n\n# Set the x-axis to a logarithmic scale to capture the wide range of particle sizes\nax.set_xlabel(\"Particle radius (m)\")\n\n# Label the y-axis to show the concentration in particles per cubic meter\nax.set_ylabel(\"Concentration $\\dfrac{1}{m^{3}}$\")\n\n# Use a logarithmic scale for the x-axis to better visualize the distribution across particle sizes\nax.set_xscale(\"log\")\n\n# Set Title\nax.set_title(\"PMF: Lognormal Particle Size Distribution\")\n\n# Display the plot\nplt.show()\n</pre> # Define fine scale radius bins and corresponding mass bins for a lognormal distribution  # Create fine scale radius bins on a logarithmic scale from 1 nm to 10 \u03bcm radius_bins = np.logspace(start=-9, stop=-4, num=250)  # m (1 nm to 10 \u03bcm)  # Calculate the mass for each particle size bin assuming a density of 1 g/cm^3 (1000 kg/m^3) mass_bins = 4 / 3 * np.pi * (radius_bins) ** 3 * 1e3  # kg  # Generate a lognormal particle size distribution # This distribution is characterized by a mode (most probable size) of 100 nm, # a geometric standard deviation of 1.4, and a total number concentration of 10000 particles per cm^3. concentration_lognormal_0 = lognormal_pmf_distribution(     x_values=radius_bins,     mode=np.array(100e-9),  # Mode of the distribution (100 nm)     geometric_standard_deviation=np.array(1.4),  # Geometric standard deviation     number_of_particles=np.array(         1e6 * 1e6  # Total concentration (10000 cm^-3 converted to m^-3)     ), )  # Plot the lognormal concentration distribution fig, ax = plt.subplots(figsize=(8, 6)) ax.plot(radius_bins, concentration_lognormal_0)  # Set the x-axis to a logarithmic scale to capture the wide range of particle sizes ax.set_xlabel(\"Particle radius (m)\")  # Label the y-axis to show the concentration in particles per cubic meter ax.set_ylabel(\"Concentration $\\dfrac{1}{m^{3}}$\")  # Use a logarithmic scale for the x-axis to better visualize the distribution across particle sizes ax.set_xscale(\"log\")  # Set Title ax.set_title(\"PMF: Lognormal Particle Size Distribution\")  # Display the plot plt.show() <pre>&lt;&gt;:29: SyntaxWarning: invalid escape sequence '\\d'\n&lt;&gt;:29: SyntaxWarning: invalid escape sequence '\\d'\nC:\\Users\\kkgor\\AppData\\Local\\Temp\\ipykernel_19788\\2156227153.py:29: SyntaxWarning: invalid escape sequence '\\d'\n  ax.set_ylabel(\"Concentration $\\dfrac{1}{m^{3}}$\")\n</pre> In\u00a0[11]: Copied! <pre># Simulating the coagulation process over time for a lognormal distribution\n\n# Define the time step for the simulation\nTIME_STEP = 100  # seconds\n\n# Calculate the coagulation kernel\nkernel = brownian_kernel.brownian_coagulation_kernel_via_system_state(\n    radius_particle=radius_bins,\n    mass_particle=mass_bins,\n    temperature=293.15,  # Temperature in Kelvin\n    pressure=101325,  # Pressure in Pascals (1 atm)\n    alpha_collision_efficiency=1.0,  # Assume perfect collision efficiency\n)\n\n# Time step 1: Calculate gain, loss, and update concentration\ngain = rate.discrete_gain(radius_bins, concentration_lognormal_0, kernel)\nloss = rate.discrete_loss(concentration_lognormal_0, kernel)\nnet = gain - loss\nconcentration_lognormal_1 = concentration_lognormal_0 + net * TIME_STEP\nconcentration_lognormal_1[concentration_lognormal_1 &lt; 0] = (\n    0  # Ensure no negative concentrations\n)\n\n# Time step 2: Recalculate rates and update concentration\ngain = rate.discrete_gain(radius_bins, concentration_lognormal_1, kernel)\nloss = rate.discrete_loss(concentration_lognormal_1, kernel)\nnet = gain - loss\nconcentration_lognormal_2 = concentration_lognormal_1 + net * TIME_STEP\nconcentration_lognormal_2[concentration_lognormal_2 &lt; 0] = (\n    0  # Ensure no negative concentrations\n)\n\n# Time step 3: Recalculate rates and update concentration\ngain = rate.discrete_gain(radius_bins, concentration_lognormal_2, kernel)\nloss = rate.discrete_loss(concentration_lognormal_2, kernel)\nnet = gain - loss\nconcentration_lognormal_3 = concentration_lognormal_2 + net * TIME_STEP\nconcentration_lognormal_3[concentration_lognormal_3 &lt; 0] = (\n    0  # Ensure no negative concentrations\n)\n\n# Combine the concentrations at each time step into a DataFrame for easy comparison\ndf_concentration = pd.DataFrame(\n    {\n        \"0\": concentration_lognormal_0,\n        \"1\": concentration_lognormal_1,\n        \"2\": concentration_lognormal_2,\n        \"3\": concentration_lognormal_3,\n    },\n    index=radius_bins,\n)\n\n# Optional: Save the concentration data to a CSV file for further analysis\n# df_concentration.to_csv(\"concentration_lognormal_sim.csv\")\n</pre> # Simulating the coagulation process over time for a lognormal distribution  # Define the time step for the simulation TIME_STEP = 100  # seconds  # Calculate the coagulation kernel kernel = brownian_kernel.brownian_coagulation_kernel_via_system_state(     radius_particle=radius_bins,     mass_particle=mass_bins,     temperature=293.15,  # Temperature in Kelvin     pressure=101325,  # Pressure in Pascals (1 atm)     alpha_collision_efficiency=1.0,  # Assume perfect collision efficiency )  # Time step 1: Calculate gain, loss, and update concentration gain = rate.discrete_gain(radius_bins, concentration_lognormal_0, kernel) loss = rate.discrete_loss(concentration_lognormal_0, kernel) net = gain - loss concentration_lognormal_1 = concentration_lognormal_0 + net * TIME_STEP concentration_lognormal_1[concentration_lognormal_1 &lt; 0] = (     0  # Ensure no negative concentrations )  # Time step 2: Recalculate rates and update concentration gain = rate.discrete_gain(radius_bins, concentration_lognormal_1, kernel) loss = rate.discrete_loss(concentration_lognormal_1, kernel) net = gain - loss concentration_lognormal_2 = concentration_lognormal_1 + net * TIME_STEP concentration_lognormal_2[concentration_lognormal_2 &lt; 0] = (     0  # Ensure no negative concentrations )  # Time step 3: Recalculate rates and update concentration gain = rate.discrete_gain(radius_bins, concentration_lognormal_2, kernel) loss = rate.discrete_loss(concentration_lognormal_2, kernel) net = gain - loss concentration_lognormal_3 = concentration_lognormal_2 + net * TIME_STEP concentration_lognormal_3[concentration_lognormal_3 &lt; 0] = (     0  # Ensure no negative concentrations )  # Combine the concentrations at each time step into a DataFrame for easy comparison df_concentration = pd.DataFrame(     {         \"0\": concentration_lognormal_0,         \"1\": concentration_lognormal_1,         \"2\": concentration_lognormal_2,         \"3\": concentration_lognormal_3,     },     index=radius_bins, )  # Optional: Save the concentration data to a CSV file for further analysis # df_concentration.to_csv(\"concentration_lognormal_sim.csv\") In\u00a0[12]: Copied! <pre># Print the maximum and minimum concentrations at each time step\n\nprint(f\"Max concentration at t=0: {concentration_lognormal_0.max()}\")\nprint(f\"Min concentration at t=0: {concentration_lognormal_0.min()}\")\n\nprint(f\"Max concentration at t=1: {concentration_lognormal_1.max()}\")\nprint(f\"Min concentration at t=1: {concentration_lognormal_1.min()}\")\n\nprint(f\"Max concentration at t=2: {concentration_lognormal_2.max()}\")\nprint(f\"Min concentration at t=2: {concentration_lognormal_2.min()}\")\n\nprint(f\"Max concentration at t=3: {concentration_lognormal_3.max()}\")\nprint(f\"Min concentration at t=3: {concentration_lognormal_3.min()}\")\n</pre> # Print the maximum and minimum concentrations at each time step  print(f\"Max concentration at t=0: {concentration_lognormal_0.max()}\") print(f\"Min concentration at t=0: {concentration_lognormal_0.min()}\")  print(f\"Max concentration at t=1: {concentration_lognormal_1.max()}\") print(f\"Min concentration at t=1: {concentration_lognormal_1.min()}\")  print(f\"Max concentration at t=2: {concentration_lognormal_2.max()}\") print(f\"Min concentration at t=2: {concentration_lognormal_2.min()}\")  print(f\"Max concentration at t=3: {concentration_lognormal_3.max()}\") print(f\"Min concentration at t=3: {concentration_lognormal_3.min()}\") <pre>Max concentration at t=0: 54738275267.16476\nMin concentration at t=0: 1.6445825598006672e-81\nMax concentration at t=1: 51186782324.56813\nMin concentration at t=1: 0.0\nMax concentration at t=2: 48026245801.09982\nMin concentration at t=2: 0.0\nMax concentration at t=3: 45351022236.99084\nMin concentration at t=3: 0.0\n</pre> In\u00a0[13]: Copied! <pre># Plot the coagulation gain, loss, and net rates for the lognormal distribution\n\n# Create a figure and axis object for the plot\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Plot the net coagulation rate\n# The net rate is plotted with a thicker gray line for emphasis\nax.plot(radius_bins, net, label=\"Net\", color=\"gray\", linewidth=4)\n\n# Plot the gain rate\n# The gain rate is plotted in dark green\nax.plot(radius_bins, gain, label=\"Gain\", color=\"darkgreen\")\n\n# Plot the loss rate\n# The loss rate is plotted in red, and multiplied by -1 for plotting to indicate that it's a removal process\nax.plot(radius_bins, -1 * loss, label=\"Loss\", color=\"red\")\n\n# Set the x-axis label to indicate the particle radius in meters\nax.set_xlabel(\"Particle radius (m)\")\n\n# Set the y-axis label to indicate the rate of change in concentration, with appropriate units\nax.set_ylabel(r\"Rate $\\dfrac{1}{m^{3} s^{1}}$\")\n\n# Use a logarithmic scale for the x-axis to account for the wide range of particle sizes\nax.set_xscale(\"log\")\n\n# set title\nax.set_title(\"PMF: Coagulation gain, loss, and net rates\")\n\n# Add a legend to identify the gain, loss, and net lines\nplt.legend()\n\n# Display the plot\nplt.show()\n</pre> # Plot the coagulation gain, loss, and net rates for the lognormal distribution  # Create a figure and axis object for the plot fig, ax = plt.subplots(figsize=(8, 6))  # Plot the net coagulation rate # The net rate is plotted with a thicker gray line for emphasis ax.plot(radius_bins, net, label=\"Net\", color=\"gray\", linewidth=4)  # Plot the gain rate # The gain rate is plotted in dark green ax.plot(radius_bins, gain, label=\"Gain\", color=\"darkgreen\")  # Plot the loss rate # The loss rate is plotted in red, and multiplied by -1 for plotting to indicate that it's a removal process ax.plot(radius_bins, -1 * loss, label=\"Loss\", color=\"red\")  # Set the x-axis label to indicate the particle radius in meters ax.set_xlabel(\"Particle radius (m)\")  # Set the y-axis label to indicate the rate of change in concentration, with appropriate units ax.set_ylabel(r\"Rate $\\dfrac{1}{m^{3} s^{1}}$\")  # Use a logarithmic scale for the x-axis to account for the wide range of particle sizes ax.set_xscale(\"log\")  # set title ax.set_title(\"PMF: Coagulation gain, loss, and net rates\")  # Add a legend to identify the gain, loss, and net lines plt.legend()  # Display the plot plt.show() In\u00a0[14]: Copied! <pre># Plot the evolution of particle concentration over time for the lognormal distribution\n\n# Create a figure and axis object for the plot\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Plot the concentration distribution at each time step\nax.plot(\n    radius_bins,\n    concentration_lognormal_0,\n    label=\"t=0\",\n    linestyle=\"-\",\n    color=\"blue\",\n)\nax.plot(\n    radius_bins,\n    concentration_lognormal_1,\n    label=\"t=1\",\n    linestyle=\"--\",\n    color=\"green\",\n)\nax.plot(\n    radius_bins,\n    concentration_lognormal_2,\n    label=\"t=2\",\n    linestyle=\"-.\",\n    color=\"orange\",\n)\nax.plot(\n    radius_bins,\n    concentration_lognormal_3,\n    label=\"t=3\",\n    linestyle=\":\",\n    color=\"red\",\n)\n\n# Set the x-axis label to indicate the particle radius in meters\nax.set_xlabel(\"Particle radius (m)\")\n\n# Set the y-axis label to indicate the concentration in particles per cubic meter\nax.set_ylabel(r\"Concentration $\\dfrac{1}{m^{3}}$\")\n\n# set title\nax.set_title(\"PMF: Particle concentration evolution over time\")\n\n# Use a logarithmic scale for both the x-axis and y-axis\n# This is essential for visualizing the wide range of particle sizes and concentration changes\nax.set_xscale(\"log\")\n# ax.set_yscale(\"log\")\n\n# Add a legend to differentiate between the time steps\nplt.legend()\n\n# Display the plot\nplt.show()\n</pre> # Plot the evolution of particle concentration over time for the lognormal distribution  # Create a figure and axis object for the plot fig, ax = plt.subplots(figsize=(8, 6))  # Plot the concentration distribution at each time step ax.plot(     radius_bins,     concentration_lognormal_0,     label=\"t=0\",     linestyle=\"-\",     color=\"blue\", ) ax.plot(     radius_bins,     concentration_lognormal_1,     label=\"t=1\",     linestyle=\"--\",     color=\"green\", ) ax.plot(     radius_bins,     concentration_lognormal_2,     label=\"t=2\",     linestyle=\"-.\",     color=\"orange\", ) ax.plot(     radius_bins,     concentration_lognormal_3,     label=\"t=3\",     linestyle=\":\",     color=\"red\", )  # Set the x-axis label to indicate the particle radius in meters ax.set_xlabel(\"Particle radius (m)\")  # Set the y-axis label to indicate the concentration in particles per cubic meter ax.set_ylabel(r\"Concentration $\\dfrac{1}{m^{3}}$\")  # set title ax.set_title(\"PMF: Particle concentration evolution over time\")  # Use a logarithmic scale for both the x-axis and y-axis # This is essential for visualizing the wide range of particle sizes and concentration changes ax.set_xscale(\"log\") # ax.set_yscale(\"log\")  # Add a legend to differentiate between the time steps plt.legend()  # Display the plot plt.show() In\u00a0[15]: Copied! <pre># Summation of PMF distribution\n# Calculate the total concentration of particles at each time step\ntotal_concentration_0 = concentration_lognormal_0.sum()\ntotal_concentration_1 = concentration_lognormal_1.sum()\ntotal_concentration_2 = concentration_lognormal_2.sum()\ntotal_concentration_3 = concentration_lognormal_3.sum()\n\n# Create a figure and axis object for the plot\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Plot the total concentration at each time step\nax.plot(\n    [total_concentration_0, total_concentration_1, total_concentration_2, total_concentration_3],\n    label=\"Total concentration\",\n    marker=\"o\",  # Add markers to indicate each time step\n    linestyle=\"-\",  # Use a solid line to connect the markers\n    color=\"blue\",  # Set the line color to blue\n)\n\n# Set the x-axis label to indicate the time step\nax.set_xlabel(\"Time step\")\n\n# Set the y-axis label to indicate the total concentration in particles per cubic meter\nax.set_ylabel(\"Total concentration $(m^{-3})$\")\nax.set_ylim(bottom=0.84e12)\n\nax.set_title(\"PMF: Total concentration at each time step\")\n\n# Display the plot\nplt.show()\n</pre> # Summation of PMF distribution # Calculate the total concentration of particles at each time step total_concentration_0 = concentration_lognormal_0.sum() total_concentration_1 = concentration_lognormal_1.sum() total_concentration_2 = concentration_lognormal_2.sum() total_concentration_3 = concentration_lognormal_3.sum()  # Create a figure and axis object for the plot fig, ax = plt.subplots(figsize=(8, 6))  # Plot the total concentration at each time step ax.plot(     [total_concentration_0, total_concentration_1, total_concentration_2, total_concentration_3],     label=\"Total concentration\",     marker=\"o\",  # Add markers to indicate each time step     linestyle=\"-\",  # Use a solid line to connect the markers     color=\"blue\",  # Set the line color to blue )  # Set the x-axis label to indicate the time step ax.set_xlabel(\"Time step\")  # Set the y-axis label to indicate the total concentration in particles per cubic meter ax.set_ylabel(\"Total concentration $(m^{-3})$\") ax.set_ylim(bottom=0.84e12)  ax.set_title(\"PMF: Total concentration at each time step\")  # Display the plot plt.show()"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#coagulation-basic-1-pmf-representation","title":"Coagulation Basic 1: PMF Representation\u00b6","text":""},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#direct-implementation-for-discrete-particle-size-distributions","title":"Direct Implementation for Discrete Particle Size Distributions\u00b6","text":"<p>In this section, we present a direct implementation of the coagulation process based on the methodology outlined in Seinfeld and Pandis (2006). This notebook is designed to provide a clear understanding of the fundamental code required to simulate particle coagulation, without the abstraction layers provided by more advanced object-oriented approaches.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#objective","title":"Objective\u00b6","text":"<p>The primary goal is to demonstrate how to calculate the coagulation kernel and the resulting coagulation rates for a given particle size distribution. We will start with a uniform size bin and distribution to establish the basic principles. Then, we will extend this to a more realistic lognormal distribution, which is commonly observed in aerosol science.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#approach","title":"Approach\u00b6","text":"<ul> <li>Uniform Distribution: We first initialize a simple, uniform particle size distribution. This helps in understanding the basic coagulation mechanics.</li> <li>Lognormal Probability Mass Function: After establishing the basics, we move on to a lognormal size distribution, which better represents real-world aerosol size distributions. Probability mass functions (PMFs) is a bin representation of the lognormal distribution, so the sum of all bins equals total concentration.</li> </ul> <p>This step-by-step approach will provide a foundation for understanding more complex implementations, such as those available in the <code>particula</code> library.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#required-libraries","title":"Required Libraries\u00b6","text":"<p>We will utilize standard scientific libraries such as <code>numpy</code> for numerical computations, <code>matplotlib</code> for plotting, and <code>pandas</code> for data handling. Additionally, we import specific functions from the <code>particula</code> library to calculate the coagulation kernel and generate size distributions.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#creating-a-size-distribution","title":"Creating a Size Distribution\u00b6","text":"<p>In this section, we define the size distribution for aerosol particles. The particle sizes are distributed across several bins, allowing us to model the behavior of particles across a wide size range.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#particle-size-bins","title":"Particle Size Bins\u00b6","text":"<p>We first define the bins for particle radii using a logarithmic scale. The logarithmic scale (<code>np.logspace</code>) is particularly useful when dealing with aerosol particles because their sizes often span several orders of magnitude\u2014from nanometers to micrometers. This approach ensures that we capture the full range of particle sizes with more granularity where it matters.</p> <ul> <li><code>radius_bins</code>: These bins represent the particle radii, ranging from 1 nanometer (1e-9 m) to 10 micrometers (1e-5 m).</li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#particle-mass-calculation","title":"Particle Mass Calculation\u00b6","text":"<p>Next, we calculate the mass of particles in each size bin. The mass is determined using the formula for the volume of a sphere (<code>4/3 * \u03c0 * r^3</code>), assuming a uniform particle density of 1 g/cm\u00b3 (which corresponds to 1000 kg/m\u00b3 in SI units).</p> <ul> <li><code>mass_bins</code>: The resulting array contains the masses of particles corresponding to each size bin, which is a key parameter for understanding how these particles will interact and coagulate.</li> </ul> <p>This setup provides a foundation for further analysis of the coagulation process by linking particle size and mass, essential components in determining coagulation rates.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#calculating-the-brownian-coagulation-kernel","title":"Calculating the Brownian Coagulation Kernel\u00b6","text":"<p>In this section, we calculate the Brownian coagulation kernel matrix, which quantifies the rate at which particles of different sizes collide and coagulate due to Brownian motion. The kernel matrix is central to understanding the dynamics of particle coagulation.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#kernel-calculation","title":"Kernel Calculation\u00b6","text":"<p>We use the <code>brownian_coagulation_kernel_via_system_state</code> function from the <code>particula</code> library to compute the kernel matrix. This function requires the following inputs:</p> <ul> <li><code>radius_particle</code>: The array of particle radii, which we previously defined in <code>radius_bins</code>.</li> <li><code>mass_particle</code>: The corresponding array of particle masses from <code>mass_bins</code>.</li> <li><code>temperature</code>: The ambient temperature, set here to 293.15 K (equivalent to 20\u00b0C).</li> <li><code>pressure</code>: The ambient pressure, set to 101325 Pa (standard atmospheric pressure).</li> <li><code>alpha_collision_efficiency</code>: A dimensionless factor representing the efficiency of particle collisions, assumed to be 1.0 for perfect efficiency.</li> </ul> <p>The output is a matrix (kernel) where each element represents the coagulation rate between two specific particle sizes.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#analyzing-the-kernel","title":"Analyzing the Kernel\u00b6","text":"<p>We print the shape of the kernel matrix to verify its dimensions, which should match the number of radius bins (i.e., it will be a square matrix).</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#creating-a-dataframe","title":"Creating a DataFrame\u00b6","text":"<p>To facilitate analysis, we convert the kernel matrix into a <code>pandas</code> DataFrame. The DataFrame format allows for easy manipulation and visualization of the data. The rows and columns of the DataFrame are indexed by the particle radii, making it straightforward to identify which particle sizes are interacting.</p> <p>We then print the first five rows of the DataFrame to inspect the calculated values. This provides a quick glimpse into the interaction rates between the smallest particles.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#optional-saving-the-kernel-matrix","title":"Optional: Saving the Kernel Matrix\u00b6","text":"<p>For further analysis or to share with others, the kernel matrix can be saved as a CSV file. This step is optional but useful if you need to persist the results for future work.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#plotting-the-brownian-coagulation-kernel","title":"Plotting the Brownian Coagulation Kernel\u00b6","text":"<p>After calculating the Brownian coagulation kernel, the next step is to visualize the results. A plot of the kernel values against the particle radius provides insights into how the coagulation rates vary with particle size.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#visualization-setup","title":"Visualization Setup\u00b6","text":"<p>We use <code>matplotlib</code> to create the plot:</p> <ul> <li>Figure and Axis: We begin by creating a figure and an axis object using <code>plt.subplots()</code>, which provides a flexible framework for plotting.</li> <li>Kernel Plot: The kernel values are plotted on the y-axis, and the particle radii on the x-axis. Since the kernel values can span several orders of magnitude, we plot their logarithm (base 10) to better visualize the data.</li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#axes-configuration","title":"Axes Configuration\u00b6","text":"<ul> <li>X-axis: The x-axis represents the particle radius in meters. Given the wide range of particle sizes, we use a logarithmic scale (<code>set_xscale(\"log\")</code>) to evenly distribute the data across the axis.</li> <li>Y-axis: The y-axis represents the logarithm of the kernel values (<code>Log10(Kernel)</code>). This choice makes it easier to observe trends and differences in the coagulation rates across different particle sizes.</li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#optional-y-axis-logarithmic-scale","title":"Optional Y-axis Logarithmic Scale\u00b6","text":"<p>If a deeper examination of the kernel's range is required, the y-axis can also be set to a logarithmic scale by uncommenting the <code>ax.set_yscale(\"log\")</code> line. This is useful when the kernel values span several orders of magnitude and need to be visualized more clearly.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#adding-particle-concentrations","title":"Adding Particle Concentrations\u00b6","text":"<p>Now that we have calculated the Brownian coagulation kernel, the next step is to introduce the particle concentrations. While the coagulation kernel itself does not depend on the particle concentration, the concentrations are critical when calculating the actual rate of coagulation, as they determine how many particles are available to interact.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#initial-concentration-setup","title":"Initial Concentration Setup\u00b6","text":"<p>We define an initial particle concentration for each size bin:</p> <ul> <li>Uniform Concentration: In this example, we set a uniform concentration across all size bins. Specifically, we assign a concentration of 100 particles per cubic centimeter (100 cm^-3), which converts to 100 million particles per cubic meter (100 * 1e6 m^-3). This concentration is representative of a typical ambient particle concentration in the atmosphere.</li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#visualization-of-the-initial-concentration","title":"Visualization of the Initial Concentration\u00b6","text":"<p>To better understand the initial distribution of particle concentrations, we plot these values against the particle radius:</p> <ul> <li>X-axis: The x-axis represents the particle radius in meters, using a logarithmic scale to cover the wide range of particle sizes.</li> <li>Y-axis: The y-axis shows the particle concentration in particles per cubic meter (m^-3), also plotted on a logarithmic scale. The logarithmic scales on both axes allow us to clearly see the distribution across several orders of magnitude, which is common in aerosol science.</li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#importance-of-concentration","title":"Importance of Concentration\u00b6","text":"<p>While the kernel function determines the rate at which particles of different sizes</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#coagulation-rate-calculation","title":"Coagulation Rate Calculation\u00b6","text":"<p>With the coagulation kernel and initial concentrations defined, we can now calculate the rates at which particles are gained, lost, and the net change due to coagulation. These rates are essential for understanding how the particle size distribution evolves over time as particles collide and coagulate.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#gain-loss-and-net-rate-calculation","title":"Gain, Loss, and Net Rate Calculation\u00b6","text":"<ul> <li><p>Gain (<code>discrete_gain</code>): This function calculates the rate at which particles are gained in each size bin due to coagulation. Gain occurs when two smaller particles collide to form a larger particle, increasing the concentration in the corresponding size bin.</p> </li> <li><p>Loss (<code>discrete_loss</code>): This function calculates the rate at which particles are lost from each size bin due to coagulation. Loss happens when particles in a particular size bin collide with other particles, thereby decreasing the concentration in that bin.</p> </li> <li><p>Net Rate: The net rate is the difference between the gain and loss for each size bin (<code>net_0 = gain_0 - loss_0</code>). It represents the overall change in concentration for each particle size due to coagulation.</p> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#displaying-results","title":"Displaying Results\u00b6","text":"<p>We create a <code>pandas</code> DataFrame to organize and display the gain, loss, and net coagulation rates for each particle size bin. The DataFrame is indexed by particle radius, which makes it easy to understand the changes in concentration across different sizes.</p> <ul> <li>Gain: The rate at which particles are added to each bin due to coagulation.</li> <li>Loss: The rate at which particles are removed from each bin due to coagulation.</li> <li>Net: The overall change in concentration for each bin.</li> </ul> <p>Finally, we display the first five rows of the DataFrame to inspect the initial values for gain, loss, and net change. This provides a quick look at how coagulation is expected to alter the particle size distribution in the system.</p> <p>By analyzing these rates, we can predict the dynamic behavior of the aerosol particles over time, as smaller particles merge to form larger ones or disappear from the system.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#plotting-the-coagulation-gain-loss-and-net-rates","title":"Plotting the Coagulation Gain, Loss, and Net Rates\u00b6","text":"<p>After calculating the coagulation rates, it's crucial to visualize how these rates vary across different particle sizes. This plot will show the gain, loss, and net rates of particle concentration as a function of particle radius.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#plot-details","title":"Plot Details\u00b6","text":"<ul> <li>Net Rate: The net rate of change in particle concentration is plotted as a thick gray line. This line highlights the overall effect of coagulation, showing whether the concentration in each size bin is increasing or decreasing.</li> <li>Gain Rate: The gain rate is plotted in dark green. This line shows how particles are being added to each size bin as smaller particles coagulate to form larger ones.</li> <li>Loss Rate: The loss rate is plotted in red. To make it visually distinct and indicate that it's a removal process, the loss rate is plotted as <code>-1 * loss_0</code>. This negative value reflects the decrease in particle concentration due to coagulation.</li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#axes-configuration","title":"Axes Configuration\u00b6","text":"<ul> <li><p>X-axis: The x-axis represents the particle radius in meters, plotted on a logarithmic scale. This scale is essential for accurately representing the wide range of particle sizes, from nanometers to micrometers.</p> </li> <li><p>Y-axis: The y-axis shows the rate of change in concentration, with units of <code>m\u207b\u00b3 s\u207b\u00b9</code>, indicating how quickly particles are being gained, lost, or changing net concentration in the system.</p> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#interpretation","title":"Interpretation\u00b6","text":"<p>By analyzing this plot, you can determine which particle sizes are most affected by coagulation. For instance, sizes where the net rate is positive indicate that coagulation is leading to an increase in concentration, while negative values suggest a decrease. This visualization is crucial for understanding the evolution of the particle size distribution over time.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#simulating-the-coagulation-process-over-time","title":"Simulating the Coagulation Process Over Time\u00b6","text":"<p>In this section, we manually simulate the coagulation process over a few discrete time steps. This manual simulation allows us to observe how particle concentrations evolve as a result of coagulation.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#simulation-setup","title":"Simulation Setup\u00b6","text":"<ul> <li>Time Step: We define a time step of 0.1 seconds (<code>TIME_STEP = 0.1</code>). This value represents the interval at which we update the particle concentrations based on the coagulation rates.</li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#time-step-1","title":"Time Step 1\u00b6","text":"<ol> <li>Calculate Gain and Loss: Using the initial concentration (<code>concentration_0</code>), we calculate the gain and loss rates using the coagulation kernel.</li> <li>Net Rate: The net rate of change in concentration is determined by subtracting the loss from the gain.</li> <li>Update Concentration: The concentration is updated by adding the net rate multiplied by the time step to the initial concentration, resulting in <code>concentration_1</code>.</li> </ol>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#time-step-2","title":"Time Step 2\u00b6","text":"<ol> <li>Recalculate Gain and Loss: With the updated concentration from time step 1 (<code>concentration_1</code>), we recalculate the gain and loss rates.</li> <li>Net Rate: Again, we calculate the net rate of change.</li> <li>Update Concentration: The concentration is updated to <code>concentration_2</code> using the same method as in time step 1.</li> </ol>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#time-step-3","title":"Time Step 3\u00b6","text":"<ol> <li>Recalculate Gain and Loss: We perform the same calculations with the concentration from time step 2 (<code>concentration_2</code>).</li> <li>Update Concentration: The concentration is updated to <code>concentration_3</code>.</li> </ol>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#observing-changes","title":"Observing Changes\u00b6","text":"<p>We print the maximum concentration at each time step to observe how the distribution evolves due to coagulation. This can provide insights into how quickly particles are coalescing into larger sizes or being depleted.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#dataframe-creation","title":"DataFrame Creation\u00b6","text":"<p>The concentrations at each time step are combined into a <code>pandas</code> DataFrame, making it easier to compare how the distribution changes over time. We display the first few rows to inspect these changes.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#optional-saving-results","title":"Optional: Saving Results\u00b6","text":"<p>The concentration data can be saved to a CSV file for further analysis or visualization, allowing you to track the evolution of particle concentrations over time.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#interpretation","title":"Interpretation\u00b6","text":"<p>By manually simulating the coagulation process, we can see the step-by-step changes in particle concentrations. This approach highlights the dynamic nature of coagulation and how it impacts particle size distributions in aerosols over time.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#plotting-the-evolution-of-particle-concentration","title":"Plotting the Evolution of Particle Concentration\u00b6","text":"<p>To visualize how particle concentrations evolve over time due to coagulation, we plot the concentration distributions at different time steps. This allows us to observe the changes in particle size distribution as the coagulation process progresses.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#plot-details","title":"Plot Details\u00b6","text":"<ul> <li><p>Time Step 0 (<code>t=0</code>): The initial concentration distribution is plotted as a solid blue line. This serves as the baseline before any coagulation has occurred.</p> </li> <li><p>Time Step 1 (<code>t=1</code>): After the first time step, the concentration distribution is plotted as a dashed green line. This shows the immediate effect of coagulation on the particle distribution.</p> </li> <li><p>Time Step 2 (<code>t=2</code>): The concentration distribution at the second time step is plotted as a dash-dot orange line. By this point, we can begin to see more noticeable changes as particles coagulate.</p> </li> <li><p>Time Step 3 (<code>t=3</code>): Finally, the concentration distribution after the third time step is plotted as a dotted red line, illustrating further evolution of the particle sizes as the coagulation process continues.</p> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#axes-configuration","title":"Axes Configuration\u00b6","text":"<ul> <li><p>X-axis: The x-axis represents the particle radius in meters, and is plotted on a logarithmic scale to capture the wide range of particle sizes.</p> </li> <li><p>Y-axis: The y-axis shows the concentration in particles per cubic meter (m\u207b\u00b3), also on a logarithmic scale to reflect the changes in concentration across orders of magnitude.</p> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#interpretation","title":"Interpretation\u00b6","text":"<p>As expected, smaller particles tend to coagulate into larger sizes, leading to changes in the overall distribution. This plot provides a visual representation of the dynamic nature of coagulation, making it easier to understand how particle populations evolve in an aerosol system.</p> <p>The plot provides a visual representation of the dynamic nature of coagulation, making it easier to understand how particle populations evolve in an aerosol system.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#end-member-error","title":"End member Error\u00b6","text":"<p>Due to the underlying numerical integration assumptions, a flat distribution is not treated correctly at the largest sizes. But in real-world cases where the distribution is not flat, this error is not significant.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#lognormal-distribution","title":"Lognormal Distribution\u00b6","text":"<p>In this section, we will implement the coagulation process for a lognormal particle size distribution. A lognormal distribution is more representative of real-world aerosol systems, where particles are not uniformly distributed in size but instead follow a distribution where most particles are centered around a particular size with fewer particles in the smaller and larger size ranges.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#why-lognormal-distribution","title":"Why Lognormal Distribution?\u00b6","text":"<p>A lognormal distribution is often observed in natural aerosol populations due to the multiplicative processes that govern particle formation and growth. This distribution is characterized by a peak (or mode) at the most common particle size, with the number of particles decreasing logarithmically for sizes smaller and larger than the mode. Implementing coagulation for this distribution will provide a more realistic simulation of how aerosol particles behave in the atmosphere.</p> <p>We will proceed by defining the lognormal size distribution, calculating the coagulation kernel, and then simulating the coagulation process over time, similar to what we did for the uniform distribution. This approach will allow us to compare the results between the uniform and lognormal distributions, highlighting the differences in coagulation dynamics based on initial particle size distributions.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#defining-the-radius-and-mass-bins","title":"Defining the Radius and Mass Bins\u00b6","text":"<ul> <li>Radius Bins: We define the particle radius bins on a logarithmic scale ranging from 1 nanometer (1e-9 m) to 10 micrometers (1e-4 m). Using 250 bins ensures a fine resolution across this range, which is important for accurately representing the lognormal distribution.</li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#generating-the-lognormal-distribution","title":"Generating the Lognormal Distribution\u00b6","text":"<ul> <li>Lognormal Distribution: We generate the particle concentration using a lognormal distribution, which is characterized by:<ul> <li>A mode (most probable size) of 100 nanometers (100 nm).</li> <li>A geometric standard deviation of 1.4, which controls the spread of the distribution.</li> <li>A total number concentration of 10000 particles per cubic centimeter (10000 cm\u207b\u00b3), converted to particles per cubic meter for consistency with our units.</li> </ul> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#plotting-the-lognormal-distribution","title":"Plotting the Lognormal Distribution\u00b6","text":"<p>The resulting lognormal distribution is plotted with particle radius on the x-axis (logarithmic scale) and particle concentration on the y-axis. This plot visually demonstrates the lognormal distribution, showing a peak around the mode (100 nm) with concentrations decreasing for both smaller and larger particles.</p> <p>This setup provides a more realistic starting point for simulating the coagulation process in an aerosol system.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#simulating-the-coagulation-process-for-a-lognormal-distribution","title":"Simulating the Coagulation Process for a Lognormal Distribution\u00b6","text":"<p>Having established a lognormal particle size distribution, we now proceed to simulate the coagulation process over time. This simulation will show how the distribution evolves as particles coagulate and form larger particles.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#simulation-setup","title":"Simulation Setup\u00b6","text":"<ul> <li><p>Time Step: We set a time step of 100 seconds (<code>TIME_STEP = 100</code>). This interval determines how frequently the particle concentrations are updated based on the calculated coagulation rates.</p> </li> <li><p>Coagulation Kernel: The coagulation kernel is calculated using the same parameters as before (temperature, pressure, and perfect collision efficiency). The kernel remains constant throughout the simulation as it only depends on the physical properties of the particles and the environment.</p> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#time-step-calculations","title":"Time Step Calculations\u00b6","text":"<p>For each time step, we calculate the gain, loss, and net change in particle concentration:</p> <ol> <li><p>Time Step 1:</p> <ul> <li>Calculate the gain and loss rates for the initial concentration (<code>concentration_lognormal_0</code>).</li> <li>Update the concentration to <code>concentration_lognormal_1</code> by applying the net rate of change. Any negative concentrations resulting from numerical errors are set to zero.</li> </ul> </li> <li><p>Time Step 2:</p> <ul> <li>Recalculate the gain and loss rates based on <code>concentration_lognormal_1</code>.</li> <li>Update the concentration to <code>concentration_lognormal_2</code> and ensure no negative values.</li> </ul> </li> <li><p>Time Step 3:</p> <ul> <li>Recalculate the rates again based on <code>concentration_lognormal_2</code>.</li> <li>Update the concentration to <code>concentration_lognormal_3</code>, correcting any negative values.</li> </ul> </li> </ol>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#combining-results","title":"Combining Results\u00b6","text":"<p>The concentrations at each time step are combined into a <code>pandas</code> DataFrame. This structure allows for easy comparison of how the particle size distribution changes over time due to coagulation.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#optional-saving-results","title":"Optional: Saving Results\u00b6","text":"<p>The resulting concentration data can be saved to a CSV file for further analysis or visualization. This step is optional but useful for documenting the evolution of the lognormal distribution over time.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#interpretation","title":"Interpretation\u00b6","text":"<p>By simulating the coagulation process for a lognormal distribution, we can observe how initially peaked distributions broaden and shift as particles merge. The correction for negative concentrations ensures that the physical constraints of the system (i.e., non-negative particle counts) are respected throughout the simulation.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#analyzing-concentration-extremes-over-time","title":"Analyzing Concentration Extremes Over Time\u00b6","text":"<p>To gain insights into how the particle concentrations evolve during the coagulation process, it's important to track the maximum and minimum concentrations at each time step. These values can provide valuable information about the stability and dynamics of the particle distribution.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#concentration-extremes","title":"Concentration Extremes\u00b6","text":"<p>We print the maximum and minimum concentrations for each time step:</p> <ul> <li><p>Time Step 0 (<code>t=0</code>):</p> <ul> <li>Max Concentration: This represents the highest concentration of particles at the initial distribution.</li> <li>Min Concentration: This represents the lowest concentration at the initial distribution.</li> </ul> </li> <li><p>Time Step 1 (<code>t=1</code>):</p> <ul> <li>Max Concentration: After the first time step, we observe the highest concentration to see how it compares with the initial state.</li> <li>Min Concentration: Similarly, the lowest concentration is noted, which may indicate the depletion of certain particle sizes.</li> </ul> </li> <li><p>Time Step 2 (<code>t=2</code>):</p> <ul> <li>Max Concentration: As the simulation progresses, the peak concentration may shift due to ongoing coagulation.</li> <li>Min Concentration: Continued tracking of the minimum concentration helps in understanding the impact of coagulation on smaller particle sizes.</li> </ul> </li> <li><p>Time Step 3 (<code>t=3</code>):</p> <ul> <li>Max Concentration: The final maximum concentration provides an overview of how the distribution has evolved.</li> <li>Min Concentration: The minimum concentration may highlight which particle sizes have been most affected by coagulation.</li> </ul> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#interpretation","title":"Interpretation\u00b6","text":"<p>By examining these extremes, we can infer the following:</p> <ul> <li><p>Max Concentration: Changes in the maximum concentration over time can indicate the formation of larger particles as smaller ones coagulate. A decrease in max concentration suggests that the most abundant particle size at earlier steps is merging with others, leading to a broader or shifted distribution.</p> </li> <li><p>Min Concentration: The minimum concentration helps identify whether certain particle sizes are becoming scarce due to coagulation, which may cause those bins to empty out or reduce significantly.</p> </li> </ul> <p>This analysis is crucial for understanding the dynamic behavior of the particle size distribution under coagulation and for ensuring that the simulation reflects realistic physical constraints.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#plotting-the-coagulation-gain-loss-and-net-rates-for-lognormal-distribution","title":"Plotting the Coagulation Gain, Loss, and Net Rates for Lognormal Distribution\u00b6","text":"<p>To visualize the dynamics of coagulation for a lognormal particle size distribution, we plot the rates of gain, loss, and net change in concentration across the range of particle sizes. This plot provides insights into how particles are interacting during the coagulation process.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#plot-details","title":"Plot Details\u00b6","text":"<ul> <li><p>Net Rate: The net rate of change in particle concentration is plotted as a thick gray line. This line represents the overall effect of coagulation, indicating whether the concentration in each size bin is increasing or decreasing.</p> </li> <li><p>Gain Rate: The gain rate, plotted in dark green, shows how particles are being added to each size bin as smaller particles coagulate to form larger ones. This rate reflects the accumulation of particles in specific size bins.</p> </li> <li><p>Loss Rate: The loss rate is plotted in red, with the values multiplied by -1 to indicate that it represents a reduction in particle concentration. This line shows how particles are being depleted from each size bin due to coagulation.</p> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#axes-configuration","title":"Axes Configuration\u00b6","text":"<ul> <li><p>X-axis: The x-axis represents the particle radius in meters, plotted on a logarithmic scale to capture the wide range of particle sizes present in the distribution.</p> </li> <li><p>Y-axis: The y-axis shows the rate of change in concentration in units of particles per cubic meter per second ($\\dfrac{1}{m^{3} s^{1}}$), providing a clear view of how rapidly particles are being gained, lost, or changing net concentration in the system.</p> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#legend-and-interpretation","title":"Legend and Interpretation\u00b6","text":"<p>A legend is included to clearly differentiate between the net, gain, and loss lines on the plot. By analyzing these rates, we can determine the most active particle sizes in the coagulation process:</p> <ul> <li>Positive Net Rate: Indicates that the particle size bin is gaining particles, likely due to the aggregation of smaller particles.</li> <li>Negative Net Rate: Indicates that the particle size bin is losing particles, either because they are merging into larger particles or being depleted through other processes.</li> </ul> <p>This plot is essential for understanding the detailed behavior of the particle size distribution during coagulation, highlighting which sizes are most affected by the process.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#plotting-the-evolution-of-concentration-for-lognormal-distribution","title":"Plotting the Evolution of Concentration for Lognormal Distribution\u00b6","text":"<p>After simulating the coagulation process over several time steps, it is important to visualize how the particle concentration evolves. This plot shows the concentration distribution at different time steps, allowing us to observe the changes in the lognormal distribution as coagulation progresses.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#plot-details","title":"Plot Details\u00b6","text":"<ul> <li><p>Time Step 0 (<code>t=0</code>): The initial concentration distribution is plotted as a solid blue line. This represents the starting point of the simulation, with a lognormal distribution centered around the mode.</p> </li> <li><p>Time Step 1 (<code>t=1</code>): After the first time step, the concentration distribution is plotted as a dashed green line. This line shows the immediate impact of coagulation on the particle sizes.</p> </li> <li><p>Time Step 2 (<code>t=2</code>): The concentration distribution at the second time step is plotted as a dash-dot orange line. By this time, noticeable shifts in the distribution may start to appear as particles coagulate.</p> </li> <li><p>Time Step 3 (<code>t=3</code>): Finally, the concentration distribution after the third time step is plotted as a dotted red line. This line illustrates further evolution of the distribution, highlighting the ongoing effects of coagulation.</p> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#axes-configuration","title":"Axes Configuration\u00b6","text":"<ul> <li><p>X-axis: The x-axis represents the particle radius in meters, plotted on a logarithmic scale to cover the wide range of particle sizes in the lognormal distribution.</p> </li> <li><p>Y-axis: The y-axis shows the concentration in particles per cubic meter (m\u207b\u00b3), also plotted on a logarithmic scale to reflect the broad range of concentrations.</p> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#interpretation","title":"Interpretation\u00b6","text":"<p>By comparing the concentration distributions at different time steps, you can observe how the lognormal distribution shifts and broadens as particles coagulate. Typically, the concentration of smaller particles decreases over time as they merge to form larger particles, leading to an increase in the concentration of larger particles. This visualization provides a clear, temporal view of the coagulation process and its effects on the particle size distribution.</p> <p>This plot is crucial for understanding the dynamic evolution of aerosol particles under coagulation, particularly when starting with a realistic lognormal distribution.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#total-concentration-over-time","title":"Total Concentration Over Time\u00b6","text":"<p>To understand the overall impact of coagulation on the particle population, it is essential to track the total concentration of particles over time. This plot shows how the total concentration changes as particles coagulate and form larger sizes.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#summary","title":"Summary\u00b6","text":"<p>In this notebook, we explored the process of particle coagulation in aerosols, focusing on both uniform and lognormal particle size distributions. The notebook provided a step-by-step implementation of the coagulation process, highlighting key concepts and calculations necessary to simulate the dynamic behavior of aerosol particles over time.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#key-steps-and-findings","title":"Key Steps and Findings:\u00b6","text":"<ol> <li><p>Coagulation Basics:</p> <ul> <li>We began with a uniform particle size distribution to introduce the fundamental concepts of coagulation, including the calculation of the Brownian coagulation kernel and the rates of particle gain, loss, and net change.</li> <li>The initial uniform distribution allowed us to understand the basic mechanics of how particles interact and merge over time.</li> </ul> </li> <li><p>Transition to Lognormal Distribution:</p> <ul> <li>We then shifted to a more realistic lognormal particle size distribution, which better represents real-world aerosol systems. This distribution was characterized by a mode (most probable particle size), a geometric standard deviation, and a total number concentration.</li> <li>The coagulation process was simulated for this lognormal distribution, with the particle concentrations updated over several discrete time steps.</li> </ul> </li> <li><p>Simulation and Visualization:</p> <ul> <li>The evolution of the particle size distribution was tracked over time, with plots showing the changes in concentration for different particle sizes. These plots illustrated how smaller particles gradually merge to form larger ones, leading to a shift and broadening of the distribution.</li> <li>The rates of particle gain, loss, and net change were also visualized, providing insights into the most active particle sizes during the coagulation process.</li> </ul> </li> <li><p>Key Insights:</p> <ul> <li>The notebook demonstrated that coagulation leads to a decrease in the number concentration of smaller particles as they coalesce to form larger particles. This results in a broader size distribution with fewer small particles and an increased concentration of larger particles.</li> <li>The lognormal distribution, due to its realistic representation of aerosol particles, showed more complex dynamics compared to the uniform distribution, emphasizing the importance of starting with an appropriate initial distribution in simulations.</li> </ul> </li> </ol>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#conclusion","title":"Conclusion:\u00b6","text":"<p>This notebook provided a guide to simulating the coagulation process in aerosol particles, from basic principles to more advanced applications involving realistic size distributions. By comparing the results from uniform and lognormal distributions, we gained a deeper understanding of how particle populations evolve under coagulation, highlighting the critical role of particle size distribution in aerosol dynamics. The methods and visualizations presented here can be extended to further study and analyze aerosol behavior in various environmental and industrial contexts.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/","title":"Coagulation Basics 2: PDF Representation","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom scipy.integrate import trapezoid\n\n# particula imports\nfrom particula.dynamics.coagulation import brownian_kernel, rate\nfrom particula.particles.properties.lognormal_size_distribution import (\n    lognormal_pdf_distribution,\n)\nfrom particula.util.convert import distribution_convert_pdf_pms\n\n# The `brownian_kernel` function calculates the Brownian coagulation kernel,\n# determining the rate at which particles coagulate due to random motion.\n# The `rate` function computes the rate of change in particle concentration\n# resulting from coagulation.\n# The `lognormal_pdf_distribution` function generates a probability density\n# function (PDF) representing a lognormal size distribution.\n</pre> import numpy as np import matplotlib.pyplot as plt import pandas as pd from scipy.integrate import trapezoid  # particula imports from particula.dynamics.coagulation import brownian_kernel, rate from particula.particles.properties.lognormal_size_distribution import (     lognormal_pdf_distribution, ) from particula.util.convert import distribution_convert_pdf_pms  # The `brownian_kernel` function calculates the Brownian coagulation kernel, # determining the rate at which particles coagulate due to random motion. # The `rate` function computes the rate of change in particle concentration # resulting from coagulation. # The `lognormal_pdf_distribution` function generates a probability density # function (PDF) representing a lognormal size distribution. In\u00a0[2]: Copied! <pre># Create fine-scale radius bins on a logarithmic scale from 1 nm to 10 \u03bcm\nradius_bins = np.logspace(start=-9, stop=-4, num=500)  # m (1 nm to 10 \u03bcm)\n\n# Calculate the mass for each particle size bin assuming a density of 1 g/cm\u00b3 (1000 kg/m\u00b3)\nmass_bins = 4 / 3 * np.pi * radius_bins**3 * 1e3  # kg\n</pre> # Create fine-scale radius bins on a logarithmic scale from 1 nm to 10 \u03bcm radius_bins = np.logspace(start=-9, stop=-4, num=500)  # m (1 nm to 10 \u03bcm)  # Calculate the mass for each particle size bin assuming a density of 1 g/cm\u00b3 (1000 kg/m\u00b3) mass_bins = 4 / 3 * np.pi * radius_bins**3 * 1e3  # kg In\u00a0[3]: Copied! <pre># The Brownian coagulation kernel is calculated using the `brownian_coagulation_kernel_via_system_state` function.\n# This function takes into account particle size, mass, temperature, pressure, and collision efficiency\n# to compute the coagulation rates between particles of different sizes.\nkernel = brownian_kernel.brownian_coagulation_kernel_via_system_state(\n    radius_particle=radius_bins,\n    mass_particle=mass_bins,\n    temperature=293.15,  # Temperature in Kelvin (20\u00b0C)\n    pressure=101325,  # Pressure in Pascals (1 atm)\n    alpha_collision_efficiency=1.0,  # Assume perfect collision efficiency\n)\n\n# Display the shape of the kernel matrix to confirm its dimensions\nprint(f\"Kernel shape: {kernel.shape}\")\n\n# Create a pandas DataFrame from the kernel matrix\n# The DataFrame allows for easier analysis and visualization of the coagulation kernel.\n# Rows and columns are indexed by the particle radius bins, making it clear which sizes are interacting.\ndf_kernel = pd.DataFrame(kernel, index=radius_bins, columns=radius_bins)\n\n# Print the first 5 rows of the DataFrame to inspect the computed kernel values\ndf_kernel.head(5)\n\n# Optional: Save the kernel matrix to a CSV file for further analysis or sharing\n# df_kernel.to_csv(\"kernel.csv\")\n</pre> # The Brownian coagulation kernel is calculated using the `brownian_coagulation_kernel_via_system_state` function. # This function takes into account particle size, mass, temperature, pressure, and collision efficiency # to compute the coagulation rates between particles of different sizes. kernel = brownian_kernel.brownian_coagulation_kernel_via_system_state(     radius_particle=radius_bins,     mass_particle=mass_bins,     temperature=293.15,  # Temperature in Kelvin (20\u00b0C)     pressure=101325,  # Pressure in Pascals (1 atm)     alpha_collision_efficiency=1.0,  # Assume perfect collision efficiency )  # Display the shape of the kernel matrix to confirm its dimensions print(f\"Kernel shape: {kernel.shape}\")  # Create a pandas DataFrame from the kernel matrix # The DataFrame allows for easier analysis and visualization of the coagulation kernel. # Rows and columns are indexed by the particle radius bins, making it clear which sizes are interacting. df_kernel = pd.DataFrame(kernel, index=radius_bins, columns=radius_bins)  # Print the first 5 rows of the DataFrame to inspect the computed kernel values df_kernel.head(5)  # Optional: Save the kernel matrix to a CSV file for further analysis or sharing # df_kernel.to_csv(\"kernel.csv\") <pre>Kernel shape: (500, 500)\n</pre> Out[3]: 1.000000e-09 1.023340e-09 1.047225e-09 1.071668e-09 1.096681e-09 1.122277e-09 1.148472e-09 1.175277e-09 1.202708e-09 1.230780e-09 ... 8.124930e-05 8.314568e-05 8.508632e-05 8.707225e-05 8.910453e-05 9.118425e-05 9.331251e-05 9.549045e-05 9.771921e-05 1.000000e-04 1.000000e-09 8.812734e-16 8.867456e-16 8.930227e-16 9.001194e-16 9.080509e-16 9.168335e-16 9.264845e-16 9.370220e-16 9.484651e-16 9.608340e-16 ... 1.310366e-09 1.340961e-09 1.372270e-09 1.404310e-09 1.437098e-09 1.470650e-09 1.504986e-09 1.540123e-09 1.576080e-09 1.612876e-09 1.023340e-09 8.867456e-16 8.914801e-16 8.970151e-16 9.033642e-16 9.105423e-16 9.185649e-16 9.274485e-16 9.372104e-16 9.478690e-16 9.594436e-16 ... 1.251439e-09 1.280658e-09 1.310559e-09 1.341157e-09 1.372470e-09 1.404514e-09 1.437305e-09 1.470862e-09 1.505201e-09 1.540342e-09 1.047225e-09 8.930227e-16 8.970151e-16 9.018038e-16 9.074021e-16 9.138240e-16 9.210845e-16 9.291991e-16 9.381847e-16 9.480587e-16 9.588397e-16 ... 1.195165e-09 1.223070e-09 1.251626e-09 1.280848e-09 1.310753e-09 1.341355e-09 1.372672e-09 1.404719e-09 1.437514e-09 1.471075e-09 1.071668e-09 9.001194e-16 9.033642e-16 9.074021e-16 9.122455e-16 9.179079e-16 9.244034e-16 9.317470e-16 9.399548e-16 9.490434e-16 9.590307e-16 ... 1.141425e-09 1.168075e-09 1.195346e-09 1.223255e-09 1.251814e-09 1.281041e-09 1.310949e-09 1.341555e-09 1.372875e-09 1.404926e-09 1.096681e-09 9.080509e-16 9.105423e-16 9.138240e-16 9.179079e-16 9.228066e-16 9.285337e-16 9.351036e-16 9.425313e-16 9.508330e-16 9.600258e-16 ... 1.090104e-09 1.115556e-09 1.141601e-09 1.168254e-09 1.195530e-09 1.223442e-09 1.252005e-09 1.281235e-09 1.311147e-09 1.341756e-09 <p>5 rows \u00d7 500 columns</p> In\u00a0[4]: Copied! <pre># Generate a lognormal particle size distribution\n# This distribution is characterized by a mode (most probable size) of 100 nm,\n# a geometric standard deviation of 1.4, and a total number concentration of 1e6 particles per cm^3.\nconcentration_lognormal_0 = lognormal_pdf_distribution(\n    x_values=radius_bins,\n    mode=np.array(100e-9),  # Mode of the distribution (100 nm)\n    geometric_standard_deviation=np.array(1.4),  # Geometric standard deviation\n    number_of_particles=np.array(\n        1e6 * 1e6\n    ),  # Total concentration (1e6 cm^-3 converted to m^-3)\n)\n\n# Plot the lognormal concentration distribution\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(radius_bins, concentration_lognormal_0)\n\n# Set the x-axis to a logarithmic scale to capture the wide range of particle sizes\nax.set_xlabel(\"Particle radius (m)\")\n\n# Label the y-axis to show the concentration in particles per cubic meter per unit size\nax.set_ylabel(r\"Concentration $\\dfrac{1}{m^3 \\cdot m}$\")\n\n# Use a logarithmic scale for the x-axis to better visualize the distribution across particle sizes\nax.set_xscale(\"log\")\n\n# Display the plot\nplt.show()\n</pre> # Generate a lognormal particle size distribution # This distribution is characterized by a mode (most probable size) of 100 nm, # a geometric standard deviation of 1.4, and a total number concentration of 1e6 particles per cm^3. concentration_lognormal_0 = lognormal_pdf_distribution(     x_values=radius_bins,     mode=np.array(100e-9),  # Mode of the distribution (100 nm)     geometric_standard_deviation=np.array(1.4),  # Geometric standard deviation     number_of_particles=np.array(         1e6 * 1e6     ),  # Total concentration (1e6 cm^-3 converted to m^-3) )  # Plot the lognormal concentration distribution fig, ax = plt.subplots(figsize=(8, 6)) ax.plot(radius_bins, concentration_lognormal_0)  # Set the x-axis to a logarithmic scale to capture the wide range of particle sizes ax.set_xlabel(\"Particle radius (m)\")  # Label the y-axis to show the concentration in particles per cubic meter per unit size ax.set_ylabel(r\"Concentration $\\dfrac{1}{m^3 \\cdot m}$\")  # Use a logarithmic scale for the x-axis to better visualize the distribution across particle sizes ax.set_xscale(\"log\")  # Display the plot plt.show() In\u00a0[5]: Copied! <pre># Simulating the coagulation process over time for a lognormal distribution\n\n# Define the time step for the simulation\nTIME_STEP = 100  # seconds\n\n# Calculate the coagulation kernel\nkernel = brownian_kernel.brownian_coagulation_kernel_via_system_state(\n    radius_particle=radius_bins,\n    mass_particle=mass_bins,\n    temperature=293.15,  # Temperature in Kelvin\n    pressure=101325,  # Pressure in Pascals (1 atm)\n    alpha_collision_efficiency=1.0,  # Assume perfect collision efficiency\n)\n\n# Time step 1: Calculate gain, loss, and update concentration\ngain = rate.continuous_gain(radius=radius_bins, concentration=concentration_lognormal_0, kernel=kernel)\nloss = rate.continuous_loss(radius=radius_bins, concentration=concentration_lognormal_0, kernel=kernel)\nnet = gain - loss\nconcentration_lognormal_1 = concentration_lognormal_0 + net * TIME_STEP\nconcentration_lognormal_1[concentration_lognormal_1 &lt; 0] = (\n    0  # Ensure no negative concentrations\n)\n\n# Time step 2: Recalculate rates and update concentration\ngain = rate.continuous_gain(radius=radius_bins, concentration=concentration_lognormal_1, kernel=kernel)\nloss = rate.continuous_loss(radius=radius_bins, concentration=concentration_lognormal_1, kernel=kernel)\nnet = gain - loss\nconcentration_lognormal_2 = concentration_lognormal_1 + net * TIME_STEP\nconcentration_lognormal_2[concentration_lognormal_2 &lt; 0] = (\n    0  # Ensure no negative concentrations\n)\n\n# Time step 3: Recalculate rates and update concentration\ngain = rate.continuous_gain(radius=radius_bins, concentration=concentration_lognormal_2, kernel=kernel)\nloss = rate.continuous_loss(radius=radius_bins, concentration=concentration_lognormal_2, kernel=kernel)\nnet = gain - loss\nconcentration_lognormal_3 = concentration_lognormal_2 + net * TIME_STEP\nconcentration_lognormal_3[concentration_lognormal_3 &lt; 0] = (\n    0  # Ensure no negative concentrations\n)\n\n# Combine the concentrations at each time step into a DataFrame for easy comparison\ndf_concentration = pd.DataFrame(\n    {\n        \"0\": concentration_lognormal_0,\n        \"1\": concentration_lognormal_1,\n        \"2\": concentration_lognormal_2,\n        \"3\": concentration_lognormal_3,\n    },\n    index=radius_bins,\n)\n\n# Optional: Save the concentration data to a CSV file for further analysis\n# df_concentration.to_csv(\"concentration_lognormal_sim.csv\")\n</pre> # Simulating the coagulation process over time for a lognormal distribution  # Define the time step for the simulation TIME_STEP = 100  # seconds  # Calculate the coagulation kernel kernel = brownian_kernel.brownian_coagulation_kernel_via_system_state(     radius_particle=radius_bins,     mass_particle=mass_bins,     temperature=293.15,  # Temperature in Kelvin     pressure=101325,  # Pressure in Pascals (1 atm)     alpha_collision_efficiency=1.0,  # Assume perfect collision efficiency )  # Time step 1: Calculate gain, loss, and update concentration gain = rate.continuous_gain(radius=radius_bins, concentration=concentration_lognormal_0, kernel=kernel) loss = rate.continuous_loss(radius=radius_bins, concentration=concentration_lognormal_0, kernel=kernel) net = gain - loss concentration_lognormal_1 = concentration_lognormal_0 + net * TIME_STEP concentration_lognormal_1[concentration_lognormal_1 &lt; 0] = (     0  # Ensure no negative concentrations )  # Time step 2: Recalculate rates and update concentration gain = rate.continuous_gain(radius=radius_bins, concentration=concentration_lognormal_1, kernel=kernel) loss = rate.continuous_loss(radius=radius_bins, concentration=concentration_lognormal_1, kernel=kernel) net = gain - loss concentration_lognormal_2 = concentration_lognormal_1 + net * TIME_STEP concentration_lognormal_2[concentration_lognormal_2 &lt; 0] = (     0  # Ensure no negative concentrations )  # Time step 3: Recalculate rates and update concentration gain = rate.continuous_gain(radius=radius_bins, concentration=concentration_lognormal_2, kernel=kernel) loss = rate.continuous_loss(radius=radius_bins, concentration=concentration_lognormal_2, kernel=kernel) net = gain - loss concentration_lognormal_3 = concentration_lognormal_2 + net * TIME_STEP concentration_lognormal_3[concentration_lognormal_3 &lt; 0] = (     0  # Ensure no negative concentrations )  # Combine the concentrations at each time step into a DataFrame for easy comparison df_concentration = pd.DataFrame(     {         \"0\": concentration_lognormal_0,         \"1\": concentration_lognormal_1,         \"2\": concentration_lognormal_2,         \"3\": concentration_lognormal_3,     },     index=radius_bins, )  # Optional: Save the concentration data to a CSV file for further analysis # df_concentration.to_csv(\"concentration_lognormal_sim.csv\") In\u00a0[6]: Copied! <pre># Plot the coagulation gain, loss, and net rates for the lognormal distribution\n\n# Create a figure and axis object for the plot\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Plot the net coagulation rate\n# The net rate is plotted with a thicker gray line for emphasis\nax.plot(radius_bins, net, label=\"Net\", color=\"gray\", linewidth=4)\n\n# Plot the gain rate\n# The gain rate is plotted in dark green\nax.plot(radius_bins, gain, label=\"Gain\", color=\"darkgreen\")\n\n# Plot the loss rate\n# The loss rate is plotted in red, and multiplied by -1 for plotting to indicate that it's a removal process\nax.plot(radius_bins, -1 * loss, label=\"Loss\", color=\"red\")\n\n# Set the x-axis label to indicate the particle radius in meters\nax.set_xlabel(\"Particle radius (m)\")\n\n# Set the y-axis label to indicate the rate of change in concentration, with appropriate units\nax.set_ylabel(r\"Rate $\\dfrac{1}{m^{3} s^{1} \\cdot m}$\")\n\n# Use a logarithmic scale for the x-axis to account for the wide range of particle sizes\nax.set_xscale(\"log\")\n\n# title\nax.set_title(\"PDF: Coagulation Gain, Loss, and Net Rates\")\n\n# Add a legend to identify the gain, loss, and net lines\nplt.legend()    \n\n# Display the plot\nplt.show()\n</pre> # Plot the coagulation gain, loss, and net rates for the lognormal distribution  # Create a figure and axis object for the plot fig, ax = plt.subplots(figsize=(8, 6))  # Plot the net coagulation rate # The net rate is plotted with a thicker gray line for emphasis ax.plot(radius_bins, net, label=\"Net\", color=\"gray\", linewidth=4)  # Plot the gain rate # The gain rate is plotted in dark green ax.plot(radius_bins, gain, label=\"Gain\", color=\"darkgreen\")  # Plot the loss rate # The loss rate is plotted in red, and multiplied by -1 for plotting to indicate that it's a removal process ax.plot(radius_bins, -1 * loss, label=\"Loss\", color=\"red\")  # Set the x-axis label to indicate the particle radius in meters ax.set_xlabel(\"Particle radius (m)\")  # Set the y-axis label to indicate the rate of change in concentration, with appropriate units ax.set_ylabel(r\"Rate $\\dfrac{1}{m^{3} s^{1} \\cdot m}$\")  # Use a logarithmic scale for the x-axis to account for the wide range of particle sizes ax.set_xscale(\"log\")  # title ax.set_title(\"PDF: Coagulation Gain, Loss, and Net Rates\")  # Add a legend to identify the gain, loss, and net lines plt.legend()      # Display the plot plt.show() In\u00a0[7]: Copied! <pre># Plot the evolution of particle concentration over time for the lognormal distribution\n\n# Create a figure and axis object for the plot\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Plot the concentration distribution at each time step\nax.plot(\n    radius_bins,\n    concentration_lognormal_0,\n    label=\"t=0\",\n    linestyle=\"-\",\n    color=\"blue\",\n)\nax.plot(\n    radius_bins,\n    concentration_lognormal_1,\n    label=\"t=1\",\n    linestyle=\"--\",\n    color=\"green\",\n)\nax.plot(\n    radius_bins,\n    concentration_lognormal_2,\n    label=\"t=2\",\n    linestyle=\"-.\",\n    color=\"orange\",\n)\nax.plot(\n    radius_bins,\n    concentration_lognormal_3,\n    label=\"t=3\",\n    linestyle=\":\",\n    color=\"red\",\n)\n\n# Set the x-axis label to indicate the particle radius in meters\nax.set_xlabel(\"Particle radius (m)\")\n\n# Set the y-axis label to indicate the concentration in particles per cubic meter\nax.set_ylabel(r\"Concentration $\\dfrac{1}{m^3 \\cdot m}$\")\n\n# Set the title of the plot to describe the concentration evolution over time\nax.set_title(\"PDF: Particle concentration evolution over time\")\n\n# Use a logarithmic scale for both the x-axis and y-axis\n# This is essential for visualizing the wide range of particle sizes and concentration changes\nax.set_xscale(\"log\")\n# ax.set_yscale(\"log\")\n\n# Add a legend to differentiate between the time steps\nplt.legend()\n\n# Display the plot\nplt.show()\n</pre> # Plot the evolution of particle concentration over time for the lognormal distribution  # Create a figure and axis object for the plot fig, ax = plt.subplots(figsize=(8, 6))  # Plot the concentration distribution at each time step ax.plot(     radius_bins,     concentration_lognormal_0,     label=\"t=0\",     linestyle=\"-\",     color=\"blue\", ) ax.plot(     radius_bins,     concentration_lognormal_1,     label=\"t=1\",     linestyle=\"--\",     color=\"green\", ) ax.plot(     radius_bins,     concentration_lognormal_2,     label=\"t=2\",     linestyle=\"-.\",     color=\"orange\", ) ax.plot(     radius_bins,     concentration_lognormal_3,     label=\"t=3\",     linestyle=\":\",     color=\"red\", )  # Set the x-axis label to indicate the particle radius in meters ax.set_xlabel(\"Particle radius (m)\")  # Set the y-axis label to indicate the concentration in particles per cubic meter ax.set_ylabel(r\"Concentration $\\dfrac{1}{m^3 \\cdot m}$\")  # Set the title of the plot to describe the concentration evolution over time ax.set_title(\"PDF: Particle concentration evolution over time\")  # Use a logarithmic scale for both the x-axis and y-axis # This is essential for visualizing the wide range of particle sizes and concentration changes ax.set_xscale(\"log\") # ax.set_yscale(\"log\")  # Add a legend to differentiate between the time steps plt.legend()  # Display the plot plt.show() In\u00a0[9]: Copied! <pre># Integrate the concentration to calculate the total number of particles at each time step\ntotal_concentration_lognormal_0 = trapezoid(\n    concentration_lognormal_0, x=radius_bins\n)\ntotal_concentration_lognormal_1 = trapezoid(\n    concentration_lognormal_1, x=radius_bins\n)\ntotal_concentration_lognormal_2 = trapezoid(\n    concentration_lognormal_2, x=radius_bins\n)\ntotal_concentration_lognormal_3 = trapezoid(\n    concentration_lognormal_3, x=radius_bins\n)\n\n# Plot the total concentration at each time step for the lognormal distribution\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Plot the total concentration at each time step\nax.plot(\n    [\n        total_concentration_lognormal_0,\n        total_concentration_lognormal_1,\n        total_concentration_lognormal_2,\n        total_concentration_lognormal_3,\n    ],\n    label=\"Total concentration\",\n    marker=\"o\",  # Add markers to indicate each time step\n    linestyle=\"-\",  # Use a solid line to connect the markers\n    color=\"blue\",  # Set the line color to blue\n)\n\n# Set the x-axis label to indicate the time step\nax.set_xlabel(\"Time step\")\n\n# Set the y-axis label to indicate the total concentration in particles per cubic meter\nax.set_ylabel(r\"Total concentration $\\dfrac{1}{m^3}$\")\nax.set_ylim(bottom=0.84e12)\n\n# Set the title of the plot to describe the total concentration evolution over time\nax.set_title(\"Total concentration at each time step\")\n\n# Display the plot\nplt.show()\n</pre> # Integrate the concentration to calculate the total number of particles at each time step total_concentration_lognormal_0 = trapezoid(     concentration_lognormal_0, x=radius_bins ) total_concentration_lognormal_1 = trapezoid(     concentration_lognormal_1, x=radius_bins ) total_concentration_lognormal_2 = trapezoid(     concentration_lognormal_2, x=radius_bins ) total_concentration_lognormal_3 = trapezoid(     concentration_lognormal_3, x=radius_bins )  # Plot the total concentration at each time step for the lognormal distribution fig, ax = plt.subplots(figsize=(8, 6))  # Plot the total concentration at each time step ax.plot(     [         total_concentration_lognormal_0,         total_concentration_lognormal_1,         total_concentration_lognormal_2,         total_concentration_lognormal_3,     ],     label=\"Total concentration\",     marker=\"o\",  # Add markers to indicate each time step     linestyle=\"-\",  # Use a solid line to connect the markers     color=\"blue\",  # Set the line color to blue )  # Set the x-axis label to indicate the time step ax.set_xlabel(\"Time step\")  # Set the y-axis label to indicate the total concentration in particles per cubic meter ax.set_ylabel(r\"Total concentration $\\dfrac{1}{m^3}$\") ax.set_ylim(bottom=0.84e12)  # Set the title of the plot to describe the total concentration evolution over time ax.set_title(\"Total concentration at each time step\")  # Display the plot plt.show()"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#coagulation-basics-2-pdf-representation","title":"Coagulation Basics 2: PDF Representation\u00b6","text":""},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#continuous-particle-size-distributions","title":"Continuous Particle Size Distributions\u00b6","text":"<p>In this notebook, we implement the coagulation process for continuous particle size distributions, following the methodology outlined in Seinfeld and Pandis (2006). This work builds on concepts from <code>Coagulation Basics 1: PMF Representation</code> by extending the analysis to probability density function (PDF) representations of particle size distributions.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#objective","title":"Objective\u00b6","text":"<p>The primary objective is to demonstrate the calculation of the coagulation kernel and the resulting coagulation rates for a given particle size distribution. We will compare the PDF representation with the probability mass function (PMF) representation, highlighting how the PDF's continuous nature influences the coagulation process.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#approach","title":"Approach\u00b6","text":"<ol> <li><p>Uniform Distribution:</p> <ul> <li>We begin with a uniform particle size distribution to illustrate the fundamental mechanics of coagulation.</li> </ul> </li> <li><p>Lognormal Probability Density Function:</p> <ul> <li><p>After establishing the basics with a uniform distribution, we proceed to a lognormal size distribution, which more accurately reflects real-world aerosol size distributions. The PDF representation is continuous and describes the probability of finding particles within a specific size range. Integrating the PDF across the entire size range yields the total particle concentration.</p> </li> <li><p>Units:</p> <ul> <li>The units of the PDF are particles per unit volume per unit size, typically expressed as $\\dfrac{1}{m^3 \\cdot m}$ or $\\dfrac{1}{m^4}$. Integration of the PDF over the particle size range gives the total number concentration, expressed in $\\dfrac{1}{m^3}$.</li> </ul> </li> </ul> </li> </ol> <p>This step-by-step approach lays the groundwork for more advanced implementations, such as those in the <code>particula</code> library.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#required-libraries","title":"Required Libraries\u00b6","text":"<p>We will use common scientific libraries, including <code>numpy</code> for numerical calculations, <code>matplotlib</code> for visualization, and <code>pandas</code> for data manipulation. Additionally, we will leverage specific functions from the <code>particula</code> library to compute the coagulation kernel and generate size distributions.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#creating-a-size-distribution","title":"Creating a Size Distribution\u00b6","text":"<p>In this section, we define the size distribution for aerosol particles. The particle sizes are distributed across several fine-scale bins, allowing for detailed modeling of particle behavior over a wide size range.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#particle-size-bins","title":"Particle Size Bins\u00b6","text":"<ul> <li><code>radius_bins</code>: These bins represent particle radii, spanning from 1 nanometer (1e-9 m) to 10 micrometers (1e-5 m) on a logarithmic scale. Using fine-scale bins (500 in total) provides a more detailed resolution of the size distribution, which is crucial for accurate coagulation modeling.</li> <li><code>mass_bins</code>: For each radius bin, we calculate the corresponding particle mass, assuming a particle density of 1 g/cm\u00b3 (1000 kg/m\u00b3 in SI units). This mass calculation is essential for understanding how particles interact and coagulate over time.</li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#calculating-the-brownian-coagulation-kernel","title":"Calculating the Brownian Coagulation Kernel\u00b6","text":"<p>In this section, we calculate the Brownian coagulation kernel matrix, which quantifies the rate at which particles of different sizes collide and coagulate due to Brownian motion. Understanding the kernel matrix is crucial for analyzing the dynamics of particle coagulation.</p> <p>It's important to note that the kernel matrix itself remains consistent whether we're using a Probability Mass Function (PMF) or a Probability Density Function (PDF) representation. The difference lies in how we apply the kernel matrix\u2014using summations in the PMF case and integrations in the PDF case\u2014to calculate coagulation rates.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#generating-lognormal-pdf-size-distribution","title":"Generating Lognormal PDF Size Distribution\u00b6","text":"<p>In this section, we generate a lognormal particle size distribution and visualize it to understand the particle concentration across different sizes. A lognormal distribution is commonly used to represent aerosol particle size distributions due to its ability to model the skewness observed in real-world data.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#key-parameters","title":"Key Parameters\u00b6","text":"<ul> <li>Mode (Most Probable Size): The mode of the distribution is set at 100 nanometers (100 nm), representing the most common particle size within the distribution.</li> <li>Geometric Standard Deviation: A geometric standard deviation of 1.4 is used, which determines the spread of the distribution. This value reflects how broadly the particle sizes are distributed around the mode.</li> <li>Total Number Concentration: The total particle concentration is set at $1 \\times 10^6$ particles per cubic centimeter (cm\u00b3), which is converted to $1 \\times 10^{12}$ particles per cubic meter (m\u00b3) for the calculation.</li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#visualization","title":"Visualization\u00b6","text":"<p>The resulting distribution is plotted with particle radius on the x-axis and particle concentration on the y-axis. The x-axis is scaled logarithmically to effectively display the wide range of particle sizes. This plot helps in visualizing how particle concentration varies with size, providing insights into the distribution characteristics and potential behavior during coagulation processes.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#simulating-the-coagulation-process-for-a-lognormal-distribution","title":"Simulating the Coagulation Process for a Lognormal Distribution\u00b6","text":"<p>After establishing a lognormal particle size distribution, we now simulate the coagulation process over time to observe how the distribution evolves as particles collide and form larger particles.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#simulation-setup","title":"Simulation Setup\u00b6","text":"<ul> <li><p>Time Step: We use a time step of 100 seconds (<code>TIME_STEP = 100</code>). This interval determines the frequency at which particle concentrations are updated based on the calculated coagulation rates.</p> </li> <li><p>Coagulation Kernel: The coagulation kernel is computed using the same environmental parameters (temperature, pressure, and collision efficiency) as before. The kernel remains unchanged throughout the simulation, as it depends solely on the physical properties of the particles and the surrounding environment.</p> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#time-step-calculations","title":"Time Step Calculations\u00b6","text":"<p>For each time step, we perform the following calculations:</p> <ol> <li><p>Time Step 1:</p> <ul> <li>Gain and Loss Rates: Calculate the gain and loss rates for the initial concentration (<code>concentration_lognormal_0</code>) based on the coagulation kernel.</li> <li>Update Concentration: Apply the net rate of change to update the particle concentration to <code>concentration_lognormal_1</code>. Any negative concentrations, which may result from numerical errors, are set to zero.</li> </ul> </li> <li><p>Time Step 2:</p> <ul> <li>Recalculate Rates: Compute the gain and loss rates using the updated concentration (<code>concentration_lognormal_1</code>).</li> <li>Update Concentration: Update the concentration to <code>concentration_lognormal_2</code>, ensuring no negative values.</li> </ul> </li> <li><p>Time Step 3:</p> <ul> <li>Recalculate Rates: Calculate the rates again based on the most recent concentration (<code>concentration_lognormal_2</code>).</li> <li>Update Concentration: Update the concentration to <code>concentration_lognormal_3</code>, correcting any negative concentrations.</li> </ul> </li> </ol>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#combining-results","title":"Combining Results\u00b6","text":"<p>The concentrations at each time step are combined into a <code>pandas</code> DataFrame. This structure facilitates easy comparison of the particle size distribution changes over time, offering insights into the coagulation process.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#optional-saving-results","title":"Optional: Saving Results\u00b6","text":"<p>For further analysis or documentation, the concentration data can be saved to a CSV file. This step is optional but can be useful for detailed post-simulation analysis.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#plotting-the-coagulation-gain-loss-and-net-rates-for-lognormal-distribution","title":"Plotting the Coagulation Gain, Loss, and Net Rates for Lognormal Distribution\u00b6","text":"<p>To visualize the dynamics of coagulation for a lognormal particle size distribution, we plot the rates of gain, loss, and net change in concentration across the range of particle sizes. This plot provides insights into how particles are interacting during the coagulation process.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#plot-details","title":"Plot Details\u00b6","text":"<ul> <li><p>Net Rate: The net rate of change in particle concentration is plotted as a thick gray line. This line represents the overall effect of coagulation, indicating whether the concentration in each size bin is increasing or decreasing.</p> </li> <li><p>Gain Rate: The gain rate, plotted in dark green, shows how particles are being added to each size bin as smaller particles coagulate to form larger ones. This rate reflects the accumulation of particles in specific size bins.</p> </li> <li><p>Loss Rate: The loss rate is plotted in red, with the values multiplied by -1 to indicate that it represents a reduction in particle concentration. This line shows how particles are being depleted from each size bin due to coagulation.</p> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#axes-configuration","title":"Axes Configuration\u00b6","text":"<ul> <li><p>X-axis: The x-axis represents the particle radius in meters, plotted on a logarithmic scale to capture the wide range of particle sizes present in the distribution.</p> </li> <li><p>Y-axis: The y-axis shows the rate of change in concentration in units of particles per cubic meter per second ($\\dfrac{1}{m^{3} s^{1} \\cdot m}$), providing a clear view of how rapidly particles are being gained, lost, or changing net concentration in the system.</p> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#legend-and-interpretation","title":"Legend and Interpretation\u00b6","text":"<p>A legend is included to clearly differentiate between the net, gain, and loss lines on the plot. By analyzing these rates, we can determine the most active particle sizes in the coagulation process:</p> <ul> <li>Positive Net Rate: Indicates that the particle size bin is gaining particles, likely due to the aggregation of smaller particles.</li> <li>Negative Net Rate: Indicates that the particle size bin is losing particles, either because they are merging into larger particles or being depleted through other processes.</li> </ul> <p>This plot is essential for understanding the detailed behavior of the particle size distribution during coagulation, highlighting which sizes are most affected by the process.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#plotting-the-evolution-of-concentration-for-lognormal-distribution","title":"Plotting the Evolution of Concentration for Lognormal Distribution\u00b6","text":"<p>After simulating the coagulation process over several time steps, it is important to visualize how the particle concentration evolves. This plot shows the concentration distribution at different time steps, allowing us to observe the changes in the lognormal distribution as coagulation progresses.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#calculating-and-visualizing-total-particle-concentration-over-time","title":"Calculating and Visualizing Total Particle Concentration Over Time\u00b6","text":"<p>In this section, we calculate the total number of particles at each time step by integrating the particle concentration across the size distribution. This provides a clear view of how the total particle concentration evolves as coagulation progresses.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#integration-of-particle-concentration","title":"Integration of Particle Concentration\u00b6","text":"<p>To determine the total number of particles at each time step, we integrate the concentration across all particle sizes using the trapezoidal rule. This integration gives us the total particle concentration (in particles per cubic meter) at each specific time step.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#plotting-total-concentration-over-time","title":"Plotting Total Concentration Over Time\u00b6","text":"<p>We then plot the total particle concentration for each time step to visualize how the overall concentration decreases as particles coagulate into larger sizes. The x-axis represents the time steps, while the y-axis shows the total particle concentration in particles per cubic meter. Markers are used to highlight the concentration at each time step, connected by a solid line to indicate the trend over time.</p> <p>This plot provides a straightforward representation of the coagulation process's impact on the total number of particles, illustrating the decrease in concentration as particles merge and grow.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#note","title":"Note:\u00b6","text":"<p>You can compare the results obtained from the PDF representation with those from the PMF representation in the previous notebook to observe how similar the results are despite the different representations. They are not exactly equal.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#summary","title":"Summary\u00b6","text":"<p>In this notebook, we explored the process of particle coagulation in aerosols, with a particular focus on probability density function (PDF) representations of lognormal particle size distributions.</p> <p>We began by defining a lognormal distribution, which is commonly used to represent aerosol particle sizes due to its ability to model the skewed distributions observed in real-world scenarios. We then calculated the Brownian coagulation kernel, a crucial element that quantifies the rate at which particles of different sizes collide and coagulate due to Brownian motion.</p> <p>Through a series of simulations, we observed how the particle size distribution evolves over time as coagulation occurs. By applying the coagulation kernel to the initial distribution, we calculated the gain and loss rates for particles and updated the particle concentrations at each time step. This iterative process illustrated the gradual decrease in total particle concentration as smaller particles combined to form larger ones.</p> <p>Finally, we integrated the particle concentrations across the size distribution at each time step to determine the total number of particles present. This allowed us to visualize the overall reduction in particle concentration over time, providing a clear demonstration of the impact of coagulation on aerosol dynamics.</p> <p>This notebook not only highlights the fundamental principles of aerosol coagulation but also provides a practical framework for modeling and analyzing these processes using PDF representations. The methodologies and tools used here, such as the integration of concentration data and the use of a coagulation kernel, are essential for understanding the behavior of aerosols in various environmental and industrial contexts.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_3_compared/","title":"Coagulation Basic 3: PMF vs. PDF","text":"In\u00a0[1]: Copied! <pre># Import necessary libraries\n\nimport numpy as np  # For numerical operations and array manipulations\nimport matplotlib.pyplot as plt  # For plotting graphs and visualizations\nimport pandas as pd  # For data manipulation and analysis\nfrom scipy.integrate import (\n    trapezoid,\n)  # For numerical integration using the trapezoidal rule\n\n# Import specific modules from the particula package\nfrom particula.dynamics.coagulation import brownian_kernel, rate\n\n# The 'brownian_kernel' module calculates the Brownian coagulation kernel,\n# which is used to determine coagulation rates between particles.\n# The 'rate' module includes functions for calculating gain and loss rates during coagulation.\nfrom particula.particles.properties.lognormal_size_distribution import (\n    lognormal_pmf_distribution,\n    lognormal_pdf_distribution,\n)\n\n# The 'lognormal_pmf_distribution' function generates a lognormal distribution\n# represented as a Probability Mass Function (PMF).\n# The 'lognormal_pdf_distribution' function generates a lognormal distribution\n# represented as a Probability Density Function (PDF).\nfrom particula.util.convert import distribution_convert_pdf_pms\n\n# The 'distribution_convert_pdf_pms' function is used to convert PDF distributions\n# to PMS (Particle Mass Spectrum) or vice versa for comparison purposes.\n</pre> # Import necessary libraries  import numpy as np  # For numerical operations and array manipulations import matplotlib.pyplot as plt  # For plotting graphs and visualizations import pandas as pd  # For data manipulation and analysis from scipy.integrate import (     trapezoid, )  # For numerical integration using the trapezoidal rule  # Import specific modules from the particula package from particula.dynamics.coagulation import brownian_kernel, rate  # The 'brownian_kernel' module calculates the Brownian coagulation kernel, # which is used to determine coagulation rates between particles. # The 'rate' module includes functions for calculating gain and loss rates during coagulation. from particula.particles.properties.lognormal_size_distribution import (     lognormal_pmf_distribution,     lognormal_pdf_distribution, )  # The 'lognormal_pmf_distribution' function generates a lognormal distribution # represented as a Probability Mass Function (PMF). # The 'lognormal_pdf_distribution' function generates a lognormal distribution # represented as a Probability Density Function (PDF). from particula.util.convert import distribution_convert_pdf_pms  # The 'distribution_convert_pdf_pms' function is used to convert PDF distributions # to PMS (Particle Mass Spectrum) or vice versa for comparison purposes. In\u00a0[2]: Copied! <pre># Define distribution parameters\nmode = np.array([200e-9])  # Mode of the distribution (200 nm)\nstd = np.array([1.5])  # Geometric standard deviation\nnumber = np.array([1e6]) * 1e6  # 1e6 particles per cm^3 converted to m^3\n\n# Define radius bins on a logarithmic scale from 1 nm to 10 \u03bcm\nradius_bins = np.logspace(start=-9, stop=-4, num=500)\n\n# Create the lognormal PDF distribution\ndistribution_pdf = lognormal_pdf_distribution(\n    x_values=radius_bins,\n    mode=mode,\n    geometric_standard_deviation=std,\n    number_of_particles=number,\n)\n\n# Create the lognormal PMF distribution\ndistribution_pmf = lognormal_pmf_distribution(\n    x_values=radius_bins,\n    mode=mode,\n    geometric_standard_deviation=std,\n    number_of_particles=number,\n)\n\n# Plot the PDF and PMF distributions for comparison\nplt.figure(figsize=(8, 6))\nplt.plot(radius_bins, distribution_pdf, label=\"PDF\")\nplt.plot(radius_bins, distribution_pmf, label=\"PMF\")\nplt.xlabel(\"Particle Radius [m]\")\nplt.ylabel(r\"Concentration $\\dfrac{1}{m^3}$ or $\\dfrac{1}{m^3 \\cdot m}$\")\nplt.xscale(\n    \"log\"\n)  # Logarithmic scale for the x-axis to capture wide size range\nplt.yscale(\n    \"log\"\n)  # Logarithmic scale for the y-axis to highlight distribution differences\nplt.legend()\nplt.show()\n</pre> # Define distribution parameters mode = np.array([200e-9])  # Mode of the distribution (200 nm) std = np.array([1.5])  # Geometric standard deviation number = np.array([1e6]) * 1e6  # 1e6 particles per cm^3 converted to m^3  # Define radius bins on a logarithmic scale from 1 nm to 10 \u03bcm radius_bins = np.logspace(start=-9, stop=-4, num=500)  # Create the lognormal PDF distribution distribution_pdf = lognormal_pdf_distribution(     x_values=radius_bins,     mode=mode,     geometric_standard_deviation=std,     number_of_particles=number, )  # Create the lognormal PMF distribution distribution_pmf = lognormal_pmf_distribution(     x_values=radius_bins,     mode=mode,     geometric_standard_deviation=std,     number_of_particles=number, )  # Plot the PDF and PMF distributions for comparison plt.figure(figsize=(8, 6)) plt.plot(radius_bins, distribution_pdf, label=\"PDF\") plt.plot(radius_bins, distribution_pmf, label=\"PMF\") plt.xlabel(\"Particle Radius [m]\") plt.ylabel(r\"Concentration $\\dfrac{1}{m^3}$ or $\\dfrac{1}{m^3 \\cdot m}$\") plt.xscale(     \"log\" )  # Logarithmic scale for the x-axis to capture wide size range plt.yscale(     \"log\" )  # Logarithmic scale for the y-axis to highlight distribution differences plt.legend() plt.show() In\u00a0[16]: Copied! <pre># Rescale the PDF to PMF\ndistribution_pdf_rescaled = distribution_convert_pdf_pms(\n    x_array=radius_bins,\n    distribution=distribution_pdf,\n    to_pdf=False,  # Convert PDF to PMF\n)\n\n# Plot the rescaled PDF and the original PMF for comparison\nplt.figure(figsize=(8, 6))\nplt.plot(radius_bins, distribution_pdf_rescaled, label=\"PDF Rescaled to PMF\")\nplt.plot(radius_bins, distribution_pmf, label=\"PMF\")\nplt.xlabel(\"Particle Radius [m]\")\nplt.ylabel(r\"Concentration $\\dfrac{1}{m^3}$\")\nplt.xscale(\"log\")  # Use a logarithmic scale for the x-axis\n# plt.yscale('log')  # Optionally use a logarithmic scale for the y-axis\nplt.legend()\nplt.show()\n</pre> # Rescale the PDF to PMF distribution_pdf_rescaled = distribution_convert_pdf_pms(     x_array=radius_bins,     distribution=distribution_pdf,     to_pdf=False,  # Convert PDF to PMF )  # Plot the rescaled PDF and the original PMF for comparison plt.figure(figsize=(8, 6)) plt.plot(radius_bins, distribution_pdf_rescaled, label=\"PDF Rescaled to PMF\") plt.plot(radius_bins, distribution_pmf, label=\"PMF\") plt.xlabel(\"Particle Radius [m]\") plt.ylabel(r\"Concentration $\\dfrac{1}{m^3}$\") plt.xscale(\"log\")  # Use a logarithmic scale for the x-axis # plt.yscale('log')  # Optionally use a logarithmic scale for the y-axis plt.legend() plt.show() In\u00a0[4]: Copied! <pre># Rescale the PMF to PDF\ndistribution_pmf_rescaled = distribution_convert_pdf_pms(\n    x_array=radius_bins,\n    distribution=distribution_pmf,\n    to_pdf=True,  # Convert PMF to PDF\n)\n\n# Plot the original PDF and the rescaled PMF for comparison\nplt.figure()\nplt.plot(radius_bins, distribution_pdf, label=\"PDF\")\nplt.plot(radius_bins, distribution_pmf_rescaled, label=\"PMF Rescaled to PDF\")\nplt.xlabel(\"Particle Radius [m]\")\nplt.ylabel(r\"Concentration $\\dfrac{1}{m^3 \\cdot m}$\")\nplt.xscale(\"log\")  # Logarithmic scale for the x-axis to capture size range\nplt.legend()\nplt.show()\n</pre> # Rescale the PMF to PDF distribution_pmf_rescaled = distribution_convert_pdf_pms(     x_array=radius_bins,     distribution=distribution_pmf,     to_pdf=True,  # Convert PMF to PDF )  # Plot the original PDF and the rescaled PMF for comparison plt.figure() plt.plot(radius_bins, distribution_pdf, label=\"PDF\") plt.plot(radius_bins, distribution_pmf_rescaled, label=\"PMF Rescaled to PDF\") plt.xlabel(\"Particle Radius [m]\") plt.ylabel(r\"Concentration $\\dfrac{1}{m^3 \\cdot m}$\") plt.xscale(\"log\")  # Logarithmic scale for the x-axis to capture size range plt.legend() plt.show() <pre>&lt;&gt;:13: SyntaxWarning: invalid escape sequence '\\d'\n&lt;&gt;:13: SyntaxWarning: invalid escape sequence '\\d'\nC:\\Users\\kkgor\\AppData\\Local\\Temp\\ipykernel_4148\\1848083778.py:13: SyntaxWarning: invalid escape sequence '\\d'\n  plt.ylabel(\"Concentration $\\dfrac{1}{m^3 \\cdot m}$\")\n</pre> In\u00a0[5]: Copied! <pre># Integrate the original PDF to calculate the total number concentration\nnumber_concentration_pdf = trapezoid(distribution_pdf, x=radius_bins)\n\n# Integrate the PMF rescaled to PDF to calculate the total number concentration\nnumber_concentration_pmf_rescaled = trapezoid(\n    distribution_pmf_rescaled, x=radius_bins\n)\n\n# Print the results to compare\nprint(f\"Number concentration from PDF: {number_concentration_pdf}\")\nprint(\n    f\"Number concentration from PMF rescaled to PDF: {number_concentration_pmf_rescaled}\"\n)\n</pre> # Integrate the original PDF to calculate the total number concentration number_concentration_pdf = trapezoid(distribution_pdf, x=radius_bins)  # Integrate the PMF rescaled to PDF to calculate the total number concentration number_concentration_pmf_rescaled = trapezoid(     distribution_pmf_rescaled, x=radius_bins )  # Print the results to compare print(f\"Number concentration from PDF: {number_concentration_pdf}\") print(     f\"Number concentration from PMF rescaled to PDF: {number_concentration_pmf_rescaled}\" ) <pre>Number concentration from PDF: 1000000000000.0\nNumber concentration from PMF rescaled to PDF: 988596064185.8999\n</pre> <p>Verifying Number Concentration for PMF</p> <p>Next, we sum the original PMF distribution and the PDF that has been rescaled to a PMF. Summing these values directly gives the total number concentration, allowing us to verify consistency across the different representations.</p> In\u00a0[6]: Copied! <pre># Sum the original PMF to calculate the total number concentration\nnumber_concentration_pmf = distribution_pmf.sum()\n\n# Sum the PDF rescaled to PMF to calculate the total number concentration\nnumber_concentration_pdf_rescaled = distribution_pdf_rescaled.sum()\n\n# Print the results to compare\nprint(f\"Number concentration from PMF: {number_concentration_pmf}\")\nprint(\n    f\"Number concentration from PDF rescaled to PMF: {number_concentration_pdf_rescaled}\"\n)\n</pre> # Sum the original PMF to calculate the total number concentration number_concentration_pmf = distribution_pmf.sum()  # Sum the PDF rescaled to PMF to calculate the total number concentration number_concentration_pdf_rescaled = distribution_pdf_rescaled.sum()  # Print the results to compare print(f\"Number concentration from PMF: {number_concentration_pmf}\") print(     f\"Number concentration from PDF rescaled to PMF: {number_concentration_pdf_rescaled}\" ) <pre>Number concentration from PMF: 1000000000000.0\nNumber concentration from PDF rescaled to PMF: 1011535485753.2141\n</pre> In\u00a0[7]: Copied! <pre># Calculate the mass of particles for each size bin\nmass_bins = 4 / 3 * np.pi * radius_bins**3 * 1e3  # kg\n\n# Calculate the Brownian coagulation kernel matrix\nkernel = brownian_kernel.brownian_coagulation_kernel_via_system_state(\n    radius_particle=radius_bins,\n    mass_particle=mass_bins,\n    temperature=293.15,  # Temperature in Kelvin (20\u00b0C)\n    pressure=101325,  # Pressure in Pascals (1 atm)\n    alpha_collision_efficiency=1.0,  # Assume perfect collision efficiency\n)\n</pre> # Calculate the mass of particles for each size bin mass_bins = 4 / 3 * np.pi * radius_bins**3 * 1e3  # kg  # Calculate the Brownian coagulation kernel matrix kernel = brownian_kernel.brownian_coagulation_kernel_via_system_state(     radius_particle=radius_bins,     mass_particle=mass_bins,     temperature=293.15,  # Temperature in Kelvin (20\u00b0C)     pressure=101325,  # Pressure in Pascals (1 atm)     alpha_collision_efficiency=1.0,  # Assume perfect collision efficiency ) In\u00a0[8]: Copied! <pre>concentration_0 = distribution_pdf\n\n# Calculate gain and loss rates for the PDF\ngain_pdf = rate.continuous_gain(\n    radius=radius_bins,\n    concentration=concentration_0,\n    kernel=kernel,\n)\nloss_pdf = rate.continuous_loss(\n    radius=radius_bins, concentration=concentration_0, kernel=kernel\n)\nnet_pdf = gain_pdf - loss_pdf\n\n# Convert gain, loss, and net rates to volume distribution\ngain_volume = gain_pdf * 4 / 3 * np.pi * radius_bins**3\nloss_volume = loss_pdf * 4 / 3 * np.pi * radius_bins**3\nnet_volume = net_pdf * 4 / 3 * np.pi * radius_bins**3\n\n# Integrate the gain, loss, and net rates to get the total volume\ngain_total_volume = trapezoid(gain_volume, x=radius_bins)\nloss_total_volume = trapezoid(loss_volume, x=radius_bins)\nnet_total_volume = trapezoid(net_volume, x=radius_bins)\n\n# Print the results to verify volume conservation\nprint(f\"Gain total volume: {gain_total_volume}\")\nprint(f\"Loss total volume: {loss_total_volume}\")\nprint(f\"Net total volume: {net_total_volume}\")\n</pre> concentration_0 = distribution_pdf  # Calculate gain and loss rates for the PDF gain_pdf = rate.continuous_gain(     radius=radius_bins,     concentration=concentration_0,     kernel=kernel, ) loss_pdf = rate.continuous_loss(     radius=radius_bins, concentration=concentration_0, kernel=kernel ) net_pdf = gain_pdf - loss_pdf  # Convert gain, loss, and net rates to volume distribution gain_volume = gain_pdf * 4 / 3 * np.pi * radius_bins**3 loss_volume = loss_pdf * 4 / 3 * np.pi * radius_bins**3 net_volume = net_pdf * 4 / 3 * np.pi * radius_bins**3  # Integrate the gain, loss, and net rates to get the total volume gain_total_volume = trapezoid(gain_volume, x=radius_bins) loss_total_volume = trapezoid(loss_volume, x=radius_bins) net_total_volume = trapezoid(net_volume, x=radius_bins)  # Print the results to verify volume conservation print(f\"Gain total volume: {gain_total_volume}\") print(f\"Loss total volume: {loss_total_volume}\") print(f\"Net total volume: {net_total_volume}\") <pre>Gain total volume: 6.75165104833036e-11\nLoss total volume: 6.752244952802652e-11\nNet total volume: -5.9390447229141716e-15\n</pre> <p>Ensuring Volume Conservation in Coagulation Rates for PMF</p> <p>Similar to the PDF representation, it is essential to ensure that the total particle volume is conserved in the PMF (Probability Mass Function) representation during the coagulation process. The number of particles may decrease as they coagulate into larger particles, but the total volume of particles should remain constant if no other processes (like condensation or evaporation) are involved.</p> <p>Calculating Coagulation Rates for PMF</p> <p>We calculate the gain, loss, and net coagulation rates for the initial PMF concentration. These rates describe how particle concentrations change in each size bin due to coagulation.</p> In\u00a0[9]: Copied! <pre># Initial concentration for the PMF distribution\nconcentration_0_pmf = distribution_pmf\n\n# Calculate gain and loss rates for the PMF\ngain_pmf = rate.discrete_gain(\n    radius=radius_bins,\n    concentration=concentration_0_pmf,\n    kernel=kernel,\n)\nloss_pmf = rate.discrete_loss(concentration=concentration_0_pmf, kernel=kernel)\nnet_pmf = gain_pmf - loss_pmf\n\n# Convert gain, loss, and net rates to volume distribution\ngain_volume_pmf = gain_pmf * 4 / 3 * np.pi * radius_bins**3\nloss_volume_pmf = loss_pmf * 4 / 3 * np.pi * radius_bins**3\nnet_volume_pmf = net_pmf * 4 / 3 * np.pi * radius_bins**3\n\n# Sum the gain, loss, and net volumes\ngain_total_volume_pmf = gain_volume_pmf.sum()\nloss_total_volume_pmf = loss_volume_pmf.sum()\nnet_total_volume_pmf = net_volume_pmf.sum()\n\n# Print the results to verify volume conservation\nprint(f\"Gain total volume PMF: {gain_total_volume_pmf}\")\nprint(f\"Loss total volume PMF: {loss_total_volume_pmf}\")\nprint(f\"Net total volume PMF: {net_total_volume_pmf}\")\n</pre> # Initial concentration for the PMF distribution concentration_0_pmf = distribution_pmf  # Calculate gain and loss rates for the PMF gain_pmf = rate.discrete_gain(     radius=radius_bins,     concentration=concentration_0_pmf,     kernel=kernel, ) loss_pmf = rate.discrete_loss(concentration=concentration_0_pmf, kernel=kernel) net_pmf = gain_pmf - loss_pmf  # Convert gain, loss, and net rates to volume distribution gain_volume_pmf = gain_pmf * 4 / 3 * np.pi * radius_bins**3 loss_volume_pmf = loss_pmf * 4 / 3 * np.pi * radius_bins**3 net_volume_pmf = net_pmf * 4 / 3 * np.pi * radius_bins**3  # Sum the gain, loss, and net volumes gain_total_volume_pmf = gain_volume_pmf.sum() loss_total_volume_pmf = loss_volume_pmf.sum() net_total_volume_pmf = net_volume_pmf.sum()  # Print the results to verify volume conservation print(f\"Gain total volume PMF: {gain_total_volume_pmf}\") print(f\"Loss total volume PMF: {loss_total_volume_pmf}\") print(f\"Net total volume PMF: {net_total_volume_pmf}\") <pre>Gain total volume PMF: 6.674655653136e-11\nLoss total volume PMF: 6.75224495280265e-11\nNet total volume PMF: -7.758929966665061e-13\n</pre> In\u00a0[10]: Copied! <pre># Convert PMF gain and loss rates to PDF\ngain_pmf_to_pdf = distribution_convert_pdf_pms(\n    x_array=radius_bins, distribution=gain_pmf, to_pdf=True\n)\nloss_pmf_to_pdf = distribution_convert_pdf_pms(\n    x_array=radius_bins, distribution=loss_pmf, to_pdf=True\n)\nnet_pmf_to_pdf = gain_pmf_to_pdf - loss_pmf_to_pdf\n\n# Plot the gain and loss rates for both PDF and converted PMF\nplt.figure()\nplt.plot(radius_bins, gain_pdf, label=\"Gain (PDF)\", linewidth=4)\nplt.plot(radius_bins, -1 * loss_pdf, label=\"Loss (PDF)\", linewidth=4)\nplt.plot(radius_bins, gain_pmf_to_pdf, label=\"Gain (PMF to PDF)\", linestyle=\"--\")\nplt.plot(\n    radius_bins,\n    -1 * loss_pmf_to_pdf,\n    label=\"Loss (PMF to PDF)\",\n    linestyle=\"--\",\n)\nplt.xlabel(\"Particle Radius [m]\")\nplt.ylabel(r\"Rate $\\dfrac{1}{m^3 s \\cdot m}$\")\nplt.xscale(\"log\")\nplt.title(\"PDF: Gain and Loss Comparison\")\nplt.legend()\nplt.show()\n\n# Plot the net gain and loss rates for both PDF and converted PMF\nplt.figure()\nplt.plot(radius_bins, net_pdf, label=\"Net (PDF)\")\nplt.plot(radius_bins, net_pmf_to_pdf, label=\"Net (PMF to PDF)\")\nplt.xlabel(\"Particle Radius [m]\")\nplt.ylabel(r\"Rate $\\dfrac{1}{m^3 s \\cdot m}$\")\nplt.xscale(\"log\")\nplt.title(\"PDF: Net Gain and Loss Comparison\")\nplt.legend()\nplt.show()\n</pre> # Convert PMF gain and loss rates to PDF gain_pmf_to_pdf = distribution_convert_pdf_pms(     x_array=radius_bins, distribution=gain_pmf, to_pdf=True ) loss_pmf_to_pdf = distribution_convert_pdf_pms(     x_array=radius_bins, distribution=loss_pmf, to_pdf=True ) net_pmf_to_pdf = gain_pmf_to_pdf - loss_pmf_to_pdf  # Plot the gain and loss rates for both PDF and converted PMF plt.figure() plt.plot(radius_bins, gain_pdf, label=\"Gain (PDF)\", linewidth=4) plt.plot(radius_bins, -1 * loss_pdf, label=\"Loss (PDF)\", linewidth=4) plt.plot(radius_bins, gain_pmf_to_pdf, label=\"Gain (PMF to PDF)\", linestyle=\"--\") plt.plot(     radius_bins,     -1 * loss_pmf_to_pdf,     label=\"Loss (PMF to PDF)\",     linestyle=\"--\", ) plt.xlabel(\"Particle Radius [m]\") plt.ylabel(r\"Rate $\\dfrac{1}{m^3 s \\cdot m}$\") plt.xscale(\"log\") plt.title(\"PDF: Gain and Loss Comparison\") plt.legend() plt.show()  # Plot the net gain and loss rates for both PDF and converted PMF plt.figure() plt.plot(radius_bins, net_pdf, label=\"Net (PDF)\") plt.plot(radius_bins, net_pmf_to_pdf, label=\"Net (PMF to PDF)\") plt.xlabel(\"Particle Radius [m]\") plt.ylabel(r\"Rate $\\dfrac{1}{m^3 s \\cdot m}$\") plt.xscale(\"log\") plt.title(\"PDF: Net Gain and Loss Comparison\") plt.legend() plt.show() <pre>&lt;&gt;:22: SyntaxWarning: invalid escape sequence '\\d'\n&lt;&gt;:33: SyntaxWarning: invalid escape sequence '\\d'\n&lt;&gt;:22: SyntaxWarning: invalid escape sequence '\\d'\n&lt;&gt;:33: SyntaxWarning: invalid escape sequence '\\d'\nC:\\Users\\kkgor\\AppData\\Local\\Temp\\ipykernel_4148\\3143149477.py:22: SyntaxWarning: invalid escape sequence '\\d'\n  plt.ylabel(\"Rate $\\dfrac{1}{m^3 s \\cdot m}$\")\nC:\\Users\\kkgor\\AppData\\Local\\Temp\\ipykernel_4148\\3143149477.py:33: SyntaxWarning: invalid escape sequence '\\d'\n  plt.ylabel(\"Rate $\\dfrac{1}{m^3 s \\cdot m}$\")\n</pre> In\u00a0[11]: Copied! <pre># Initial distribution for the simulation\ndistribution_0 = distribution_pdf\ndistribution_i = distribution_0\n\n# Define the time array for the simulation\ntime_array = np.linspace(\n    start=0, stop=1000, num=50\n)  # Time span of 1000 seconds\ntime_interval = (\n    time_array[1] - time_array[0]\n)  # Time interval between each step\n\n# Array to store the distribution at each time step\ndistribution_time = np.zeros([len(time_array), len(distribution_0)])\n\n# Simulate the coagulation process over time\nfor i, dpa in enumerate(time_array):\n    if i &gt; 0:\n        # Calculate coagulation gain and loss at the current time step\n        coag_gain_i = rate.continuous_gain(\n            radius=radius_bins,\n            concentration=distribution_i,\n            kernel=kernel,\n        )\n        coag_loss_i = rate.continuous_loss(\n            radius=radius_bins, concentration=distribution_i, kernel=kernel\n        )\n\n        # Calculate the net change in distribution due to coagulation\n        net_change = (coag_gain_i - coag_loss_i) * time_interval\n        distribution_i = distribution_i + net_change\n\n        # Ensure no negative concentrations (set to zero if less than zero)\n        distribution_i[distribution_i &lt; 0] = 0\n\n    # Store the updated distribution for the current time step\n    distribution_time[i, :] = distribution_i\n</pre> # Initial distribution for the simulation distribution_0 = distribution_pdf distribution_i = distribution_0  # Define the time array for the simulation time_array = np.linspace(     start=0, stop=1000, num=50 )  # Time span of 1000 seconds time_interval = (     time_array[1] - time_array[0] )  # Time interval between each step  # Array to store the distribution at each time step distribution_time = np.zeros([len(time_array), len(distribution_0)])  # Simulate the coagulation process over time for i, dpa in enumerate(time_array):     if i &gt; 0:         # Calculate coagulation gain and loss at the current time step         coag_gain_i = rate.continuous_gain(             radius=radius_bins,             concentration=distribution_i,             kernel=kernel,         )         coag_loss_i = rate.continuous_loss(             radius=radius_bins, concentration=distribution_i, kernel=kernel         )          # Calculate the net change in distribution due to coagulation         net_change = (coag_gain_i - coag_loss_i) * time_interval         distribution_i = distribution_i + net_change          # Ensure no negative concentrations (set to zero if less than zero)         distribution_i[distribution_i &lt; 0] = 0      # Store the updated distribution for the current time step     distribution_time[i, :] = distribution_i <p>Visualizing the Evolution of the Particle Size Distribution</p> <p>After simulating the coagulation process over time, we can visualize how the particle size distribution evolves at different time steps. This plot compares the initial distribution with the distribution at a mid-point and at the end of the simulation, highlighting the changes that occur due to coagulation.</p> In\u00a0[12]: Copied! <pre># Set up the plot\nfig, ax = plt.subplots(1, 1, figsize=[9, 6])\n\n# Define the radius bins\nradius = radius_bins\n\n# Plot the initial distribution, mid-point distribution, and final distribution\nax.semilogx(\n    radius, distribution_0, \"-b\", label=\"Initial\"\n)  # Initial distribution\nax.semilogx(\n    radius, distribution_time[25, :], \"--\", label=\"t-step=25\"\n)  # Mid-point\nax.semilogx(\n    radius, distribution_time[-1, :], \"-r\", label=\"t=end\"\n)  # Final distribution\n\n# Set the limits for the x-axis to focus on the relevant size range\nax.set_xlim([2e-8, 1e-6])\n\n# Add legend to distinguish between different time steps\nax.legend()\n\n# Label the y-axis to indicate concentration units\nax.set_ylabel(r\"Concentration $\\dfrac{1}{m^3 \\cdot m}$\")\n\n# Label the x-axis for particle radius\nax.set_xlabel(\"Radius [m]\")\n\n# Add grid lines for better readability\nax.grid(True, alpha=0.5)\n\n# Show the plot\nplt.show()\n</pre> # Set up the plot fig, ax = plt.subplots(1, 1, figsize=[9, 6])  # Define the radius bins radius = radius_bins  # Plot the initial distribution, mid-point distribution, and final distribution ax.semilogx(     radius, distribution_0, \"-b\", label=\"Initial\" )  # Initial distribution ax.semilogx(     radius, distribution_time[25, :], \"--\", label=\"t-step=25\" )  # Mid-point ax.semilogx(     radius, distribution_time[-1, :], \"-r\", label=\"t=end\" )  # Final distribution  # Set the limits for the x-axis to focus on the relevant size range ax.set_xlim([2e-8, 1e-6])  # Add legend to distinguish between different time steps ax.legend()  # Label the y-axis to indicate concentration units ax.set_ylabel(r\"Concentration $\\dfrac{1}{m^3 \\cdot m}$\")  # Label the x-axis for particle radius ax.set_xlabel(\"Radius [m]\")  # Add grid lines for better readability ax.grid(True, alpha=0.5)  # Show the plot plt.show() <p>Visualizing Particle Size Distribution Evolution Over Time</p> <p>To further understand how the particle size distribution evolves during the coagulation process, we can create a 2D image plot. In this plot, time is represented on the x-axis, particle size (radius) on the y-axis, and the concentration is color-coded. This type of plot provides a comprehensive view of how both small and large particles change in concentration over the entire simulation period.</p> In\u00a0[13]: Copied! <pre># Set up the plot\nfig, ax = plt.subplots(figsize=(10, 6))\n\n# Create an image plot (2D histogram) with time on the x-axis, radius on the y-axis, and concentration as color\nc = ax.pcolormesh(\n    time_array,\n    radius_bins,\n    distribution_time.T,\n    shading=\"auto\",\n    cmap=\"viridis\",\n)\n\n# Set the y-axis to a logarithmic scale to capture the wide range of particle sizes\nax.set_ylim([5e-8, 1e-6])\nax.set_yscale(\"log\")\n\n# Label the axes\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(\"Particle Radius (m)\")\n\n# Add a color bar to indicate the concentration levels\ncbar = fig.colorbar(c, ax=ax)\ncbar.set_label(r\"Concentration $\\dfrac{1}{m^3 \\cdot m}$\")\n\n# Add a title to the plot\nax.set_title(\"Evolution of Particle Size Distribution Over Time\")\n\n# Show the plot\nplt.show()\n</pre> # Set up the plot fig, ax = plt.subplots(figsize=(10, 6))  # Create an image plot (2D histogram) with time on the x-axis, radius on the y-axis, and concentration as color c = ax.pcolormesh(     time_array,     radius_bins,     distribution_time.T,     shading=\"auto\",     cmap=\"viridis\", )  # Set the y-axis to a logarithmic scale to capture the wide range of particle sizes ax.set_ylim([5e-8, 1e-6]) ax.set_yscale(\"log\")  # Label the axes ax.set_xlabel(\"Time (s)\") ax.set_ylabel(\"Particle Radius (m)\")  # Add a color bar to indicate the concentration levels cbar = fig.colorbar(c, ax=ax) cbar.set_label(r\"Concentration $\\dfrac{1}{m^3 \\cdot m}$\")  # Add a title to the plot ax.set_title(\"Evolution of Particle Size Distribution Over Time\")  # Show the plot plt.show() In\u00a0[\u00a0]: Copied! <pre>from scipy.integrate import solve_ivp\nimport numpy as np\n\n\n# Define the coagulation ODE system\ndef coagulation_ode(t, distribution, radius_bins, kernel, rate):\n    \"\"\"\n    Compute the derivative of the distribution with respect to time\n    (i.e., the rate of change due to coagulation).\n\n    Arguments:\n        t: Time variable (not used explicitly here, but required by solve_ivp).\n        distribution: The current particle size distribution (array).\n        radius_bins: The bins for the particle radius.\n        kernel: The coagulation kernel.\n        rate: The object with methods for calculating coagulation gain and loss.\n\n    Returns:\n        The time derivative of the particle distribution.\n    \"\"\"\n    coag_gain = rate.continuous_gain(\n        radius=radius_bins, concentration=distribution, kernel=kernel\n    )\n    coag_loss = rate.continuous_loss(\n        radius=radius_bins, concentration=distribution, kernel=kernel\n    )\n\n    # Net change in distribution due to coagulation\n    net_change = coag_gain - coag_loss\n\n    return net_change\n\n\n# Initial distribution for the simulation\ndistribution_0 = distribution_pdf\n\n# Define the time array for the simulation\ntime_array = np.linspace(\n    start=0, stop=1000, num=50\n)  # Time span of 1000 seconds\n\n# Use scipy's solve_ivp to solve the ODE system\nsolution = solve_ivp(\n    fun=coagulation_ode,  # ODE function\n    t_span=(time_array[0], time_array[-1]),  # Time span\n    y0=distribution_0,  # Initial distribution\n    t_eval=time_array,  # Time points to store the solution\n    args=(\n        radius_bins,\n        kernel,\n        rate,\n    ),  # Additional arguments to coagulation_ode\n    method=\"BDF\",  # Integration method (default)\n    max_step=1e2,\n)\n\n# The solution is stored in solution.y (each column is a time step)\ndistribution_solver = solution.y.T  # Transpose to match original format\n</pre> from scipy.integrate import solve_ivp import numpy as np   # Define the coagulation ODE system def coagulation_ode(t, distribution, radius_bins, kernel, rate):     \"\"\"     Compute the derivative of the distribution with respect to time     (i.e., the rate of change due to coagulation).      Arguments:         t: Time variable (not used explicitly here, but required by solve_ivp).         distribution: The current particle size distribution (array).         radius_bins: The bins for the particle radius.         kernel: The coagulation kernel.         rate: The object with methods for calculating coagulation gain and loss.      Returns:         The time derivative of the particle distribution.     \"\"\"     coag_gain = rate.continuous_gain(         radius=radius_bins, concentration=distribution, kernel=kernel     )     coag_loss = rate.continuous_loss(         radius=radius_bins, concentration=distribution, kernel=kernel     )      # Net change in distribution due to coagulation     net_change = coag_gain - coag_loss      return net_change   # Initial distribution for the simulation distribution_0 = distribution_pdf  # Define the time array for the simulation time_array = np.linspace(     start=0, stop=1000, num=50 )  # Time span of 1000 seconds  # Use scipy's solve_ivp to solve the ODE system solution = solve_ivp(     fun=coagulation_ode,  # ODE function     t_span=(time_array[0], time_array[-1]),  # Time span     y0=distribution_0,  # Initial distribution     t_eval=time_array,  # Time points to store the solution     args=(         radius_bins,         kernel,         rate,     ),  # Additional arguments to coagulation_ode     method=\"BDF\",  # Integration method (default)     max_step=1e2, )  # The solution is stored in solution.y (each column is a time step) distribution_solver = solution.y.T  # Transpose to match original format In\u00a0[15]: Copied! <pre># Set up the plot\nfig, ax = plt.subplots(1, 1, figsize=[9, 6])\n\n# Define the radius bins\nradius = radius_bins\n\n# Plot the initial distribution, mid-point distribution, and final distribution\nax.semilogx(\n    radius, distribution_solver[0, :], \"-b\", label=\"Initial\"\n)  # Initial distribution\nax.semilogx(\n    radius, distribution_solver[25, :], \"--\", label=\"t-step=25\"\n)  # Mid-point\nax.semilogx(\n    radius, distribution_solver[-1, :], \"-r\", label=\"t=end\"\n)  # Final distribution\n\n# Plot the initial distribution, mid-point distribution, and final distribution\nax.semilogx(\n    radius, distribution_0, \"-b\", label=\"Initial-loop\"\n)  # Initial distribution\nax.semilogx(\n    radius, distribution_time[25, :], \"--\", label=\"t-step=25 loop\"\n)  # Mid-point\nax.semilogx(\n    radius, distribution_time[-1, :], \"-r\", label=\"t=end loop\"\n)  # Final distribution\n\n# Set the limits for the x-axis to focus on the relevant size range\nax.set_xlim([2e-8, 1e-6])\n\n# Add legend to distinguish between different time steps\nax.legend()\n\n# Label the y-axis to indicate concentration units\nax.set_ylabel(r\"Concentration $\\dfrac{1}{m^3 \\cdot m}$\")\n\n# Label the x-axis for particle radius\nax.set_xlabel(\"Radius [m]\")\n\n# Add grid lines for better readability\nax.grid(True, alpha=0.5)\n\n# Show the plot\nplt.show()\n</pre> # Set up the plot fig, ax = plt.subplots(1, 1, figsize=[9, 6])  # Define the radius bins radius = radius_bins  # Plot the initial distribution, mid-point distribution, and final distribution ax.semilogx(     radius, distribution_solver[0, :], \"-b\", label=\"Initial\" )  # Initial distribution ax.semilogx(     radius, distribution_solver[25, :], \"--\", label=\"t-step=25\" )  # Mid-point ax.semilogx(     radius, distribution_solver[-1, :], \"-r\", label=\"t=end\" )  # Final distribution  # Plot the initial distribution, mid-point distribution, and final distribution ax.semilogx(     radius, distribution_0, \"-b\", label=\"Initial-loop\" )  # Initial distribution ax.semilogx(     radius, distribution_time[25, :], \"--\", label=\"t-step=25 loop\" )  # Mid-point ax.semilogx(     radius, distribution_time[-1, :], \"-r\", label=\"t=end loop\" )  # Final distribution  # Set the limits for the x-axis to focus on the relevant size range ax.set_xlim([2e-8, 1e-6])  # Add legend to distinguish between different time steps ax.legend()  # Label the y-axis to indicate concentration units ax.set_ylabel(r\"Concentration $\\dfrac{1}{m^3 \\cdot m}$\")  # Label the x-axis for particle radius ax.set_xlabel(\"Radius [m]\")  # Add grid lines for better readability ax.grid(True, alpha=0.5)  # Show the plot plt.show()"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_3_compared/#coagulation-basic-3-pmf-vs-pdf","title":"Coagulation Basic 3: PMF vs. PDF\u00b6","text":"<p>In this section, we will compare two fundamental approaches to modeling aerosol particle coagulation: the Probability Mass Function (PMF) and the Probability Density Function (PDF) methods. Both methods offer different perspectives on representing particle size distributions and calculating coagulation rates, which are critical for understanding how particles in aerosols interact and evolve over time.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_3_compared/#probability-mass-function-pmf-vs-probability-density-function-pdf","title":"Probability Mass Function (PMF) vs. Probability Density Function (PDF)\u00b6","text":"<ul> <li><p>PMF Representation: The PMF method discretizes the particle size distribution into distinct bins, each representing a specific particle size or mass. This approach counts the number of particles within each bin, making it a straightforward method for tracking how particle populations change due to coagulation. PMF is particularly useful when dealing with discrete particle sizes or when particle number concentrations are of primary interest.</p> </li> <li><p>PDF Representation: In contrast, the PDF method provides a continuous representation of the particle size distribution. Instead of counting particles in discrete bins, PDF describes the likelihood of finding particles within a given size range. This approach is well-suited for scenarios where a smooth distribution of particle sizes is expected or when dealing with very fine size resolutions.</p> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_3_compared/#comparison-objectives","title":"Comparison Objectives\u00b6","text":"<p>The objective of this comparison is to demonstrate how the choice between PMF and PDF representations affects the calculation of coagulation rates and the resulting particle size distributions. By applying both methods to a lognormal size distribution, we will analyze the differences in how each method handles the evolution of particle populations during coagulation.</p> <p>To facilitate this comparison, we will:</p> <ol> <li><p>Initialize Lognormal Distributions: Generate lognormal particle size distributions using both PMF and PDF methods, ensuring that both distributions share the same initial parameters (e.g., mode, geometric standard deviation, and total particle concentration).</p> </li> <li><p>Calculate Coagulation Kernel: Compute the Brownian coagulation kernel using identical environmental conditions (e.g., temperature, pressure, collision efficiency) for both methods. This will allow us to isolate the effect of the distribution representation on the coagulation rates.</p> </li> <li><p>Simulate Coagulation: Simulate the coagulation process over several time steps for both PMF and PDF representations, tracking how the particle size distributions evolve and comparing the results.</p> </li> </ol> <p>By the end of this section, we aim to highlight the strengths and limitations of each method, providing insights into when and why one approach might be preferred over the other in aerosol research and modeling.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_3_compared/#setting-up-and-visualizing","title":"Setting Up and Visualizing\u00b6","text":"<p>In this section, we define the parameters for a lognormal particle size distribution and generate both Probability Density Function (PDF) and Probability Mass Function (PMF) representations. We then visualize these distributions to compare how each method represents particle concentrations across different size ranges.</p> <p>Distribution Parameters</p> <p>We start by defining the key parameters for the lognormal distribution:</p> <ul> <li>Mode: The most probable particle size is set to 200 nanometers (200 nm or (200 \\times 10^{-9}) meters).</li> <li>Geometric Standard Deviation: The spread of the distribution is controlled by a geometric standard deviation of 1.5.</li> <li>Total Number Concentration: The total concentration of particles is (1 \\times 10^6) particles per cubic centimeter (cm\u00b3), which we convert to (1 \\times 10^{12}) particles per cubic meter (m\u00b3) for our calculations.</li> </ul> <p>We also define the radius bins, which span a wide range from 1 nanometer to 10 micrometers, using a logarithmic scale to capture the distribution across different particle sizes.</p> <p>Explanation</p> <ul> <li>Parameter Definitions: The mode, geometric standard deviation, and number concentration are clearly defined to set up the lognormal distribution.</li> <li>Distribution Creation: We generate both PDF and PMF representations of the distribution using the defined parameters and radius bins. This allows us to see how each method captures the particle concentrations.</li> <li>Visualization: The plot compares the PDF and PMF distributions on a logarithmic scale, which is essential for accurately displaying the wide range of particle sizes and concentrations. The use of log scales on both axes helps to highlight the differences between the two methods.</li> </ul> <p>By visualizing these distributions side by side, we gain a better understanding of how the PDF and PMF methods differ in representing aerosol particle sizes and concentrations.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_3_compared/#rescaling-pdf","title":"Rescaling PDF\u00b6","text":"<p>In this section, we convert the previously generated Probability Density Function (PDF) into a Probability Mass Function (PMF) to directly compare it with the original PMF distribution. This rescaling is necessary because PDF and PMF represent the distribution in different ways, and aligning them allows for a more accurate comparison.</p> <p>Rescaling the PDF</p> <p>The conversion from PDF to PMF involves rescaling the distribution so that the integral of the PDF over each bin corresponds to the particle count in that bin, similar to what is represented in the PMF. This is done using the <code>distribution_convert_pdf_pms</code> function.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_3_compared/#rescaling-pmf","title":"Rescaling PMF\u00b6","text":"<p>After converting the PDF to a PMF for direct comparison, we now perform the reverse operation: rescaling the PMF to a PDF. This allows us to compare the original PDF with the PMF that has been adjusted to match the continuous representation of particle concentrations.</p> <p>Rescaling the PMF</p> <p>To rescale the PMF to a PDF, we use the <code>distribution_convert_pdf_pms</code> function. This conversion ensures that the PMF, which originally represented discrete particle counts in each bin, is transformed into a continuous probability density function, aligning it with the original PDF format.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_3_compared/#verifying-number-concentration","title":"Verifying Number Concentration\u00b6","text":"<p>In this section, we validate the consistency of the number concentration across different representations (PDF and PMF) by performing numerical integrations and summations. This step ensures that the transformations between PDF and PMF maintain the expected total particle concentrations.</p> <p>Integrating Number Concentration for PDF</p> <p>We first integrate the original PDF distribution and the PMF that has been rescaled to a PDF to check if they yield the same total number concentration. The trapezoidal rule is used for this integration.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_3_compared/#small-errors","title":"Small Errors\u00b6","text":"<p>When comparing the total number concentrations derived from the PDF and PMF representations, as well as their rescaled versions, we observe small discrepancies between the values.</p> <p>Sources of Error</p> <p>These small differences arise from several factors inherent in the process of transforming and integrating discrete and continuous distributions:</p> <ol> <li><p>Numerical Approximation:</p> <ul> <li>The integration of the PDF and the summation of the PMF involve numerical approximations, which can introduce small errors. The trapezoidal rule, used for integrating the PDF, is an approximation method that may not perfectly capture the area under the curve, especially when dealing with finely spaced bins or distributions that change rapidly in certain regions.</li> </ul> </li> <li><p>Discretization of Continuous Distributions:</p> <ul> <li>When rescaling a PDF to a PMF or vice versa, we are essentially converting a continuous function into a discrete one, or vice versa. This discretization process can lead to slight inconsistencies because the continuous distribution is approximated by a finite number of bins. The exact alignment of these bins with the underlying distribution is rarely perfect, leading to small errors.</li> </ul> </li> <li><p>Cumulative Effect of Small Differences:</p> <ul> <li>Small differences across many bins can accumulate, resulting in a noticeable discrepancy when summing or integrating over the entire distribution. Even if each individual difference is minute, the total error can be more significant when considering the entire size range.</li> </ul> </li> </ol> <p>Significance of the Errors</p> <p>While these errors are small relative to the total number concentration (less than 1% in this case), they are important to acknowledge when performing precision calculations. In practical applications, these discrepancies are often considered acceptable, but they highlight the importance of understanding the limitations of numerical methods and transformations between different types of distributions.</p> <p>Mitigating the Errors</p> <ul> <li>Increasing the Number of Bins: Using a higher resolution (more bins) can help reduce the error by more closely approximating the continuous distribution.</li> <li>Refining the Interpolation Method: More sophisticated interpolation methods may provide better alignment between the PDF and PMF during the rescaling process, further minimizing errors.</li> <li>Error Analysis: Incorporating error analysis into the calculations can help quantify and understand the impact of these discrepancies on the overall results.</li> </ul> <p>Overall, these small errors are a natural consequence of the numerical techniques used and do not significantly detract from the accuracy of the coagulation modeling. However, being aware of their existence is crucial for interpreting results with a full understanding of the underlying processes.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_3_compared/#brownian-coagulation-kernel","title":"Brownian Coagulation Kernel\u00b6","text":"<p>Before comparing the coagulation rates between the Probability Mass Function (PMF) and Probability Density Function (PDF) representations, it is essential to calculate the Brownian coagulation kernel. The kernel quantifies the rate at which particles of different sizes collide and coagulate due to Brownian motion. This matrix is a key component in determining how quickly particles in an aerosol system merge to form larger particles.</p> <p>Calculation of Particle Masses</p> <p>To calculate the coagulation kernel, we first need to determine the mass of particles in each size bin. The mass of a particle is calculated using the formula for the volume of a sphere:</p> <p>$$ m = \\frac{4}{3} \\pi r^3 \\times 1000 \\, \\text{kg/m}^3 $$</p> <p>where $r$  is the particle radius and 1000 kg/m\u00b3 is the assumed density of the particles.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_3_compared/#volume-conservation","title":"Volume Conservation\u00b6","text":"<p>In aerosol coagulation processes, one check is to ensure that the total particle volume is conserved. While the number of particles decreases as they coagulate to form larger particles, the total volume of material should remain constant (assuming no other processes such as condensation or evaporation are occurring).</p> <p>In this section, we calculate the gain, loss, and net coagulation rates using the PDF representation and verify that the total volume remains consistent.</p> <p>Calculating Coagulation Rates</p> <p>We start by calculating the gain, loss, and net coagulation rates based on the initial PDF concentration. These rates describe how particles in different size bins gain or lose mass due to coagulation.</p> <p>**Converting to Volume Distribution ** To verify volume conservation, we convert the particle concentration rates (gain, loss, and net) into volume rates by multiplying them by the volume of particles in each size bin. The volume of a particle is given by:</p> <p>$$ V = \\frac{4}{3} \\pi r^3 $$</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_3_compared/#gain-and-loss-rates-comparison","title":"Gain and Loss Rates Comparison\u00b6","text":"<p>To understand the differences and similarities between the PDF and PMF representations in the context of particle coagulation, we convert the PMF gain and loss rates to their corresponding PDF forms. This allows for a direct comparison of how each representation handles particle concentration changes across different size ranges.</p> <p>Converting PMF to PDF</p> <p>The gain and loss rates calculated for the PMF representation are converted to PDF using the <code>distribution_convert_pdf_pms</code> function. This conversion enables us to plot and compare the results on the same scale and with the same units as the original PDF.</p> <p>Explanation</p> <ul> <li><p>Comparison of Gain and Loss Rates: The first plot compares the gain and loss rates between the original PDF and the converted PMF. By plotting these on the same axes, we can observe how closely the PMF (when converted to PDF) matches the behavior of the original PDF. The solid lines represent the PDF results, while the dashed lines represent the PMF converted to PDF.</p> </li> <li><p>Comparison of Net Rates: The second plot focuses on the net gain and loss rates, which are calculated as the difference between the gain and loss rates. This plot helps in understanding whether the differences in the gain and loss rates between the PDF and converted PMF lead to any significant discrepancies in the overall net rate of particle concentration change.</p> </li> </ul> <p>Interpretation</p> <ul> <li><p>Matching Behavior: Ideally, the converted PMF should closely match the original PDF, indicating that both representations handle coagulation rates similarly. Any differences observed in the plots can provide insights into the nuances of each method, such as how they handle small particle sizes or how numerical approximations might affect the results.</p> </li> <li><p>Significance of Differences: While small differences between the PDF and converted PMF may arise due to numerical methods, these differences can highlight the strengths and limitations of each approach in representing particle size distributions and their evolution during coagulation.</p> </li> </ul> <p>PMF Gain Error</p> <p>The PMF gain rate is slightly off, and we are still looking into the issue. We will update this section once we have resolved the discrepancy.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_3_compared/#simulating-pdf-coagulation","title":"Simulating PDF Coagulation\u00b6","text":"<p>In this section, we simulate the evolution of a particle size distribution over time as particles undergo coagulation, using the Probability Density Function (PDF) representation. The simulation tracks how the distribution changes at different time steps, providing insight into how the particle population evolves under the influence of Brownian coagulation.</p> <p>Simulation Setup</p> <ul> <li>Initial Distribution: The simulation begins with the initial particle size distribution (<code>distribution_0</code>), which is based on the PDF calculated earlier.</li> <li>Time Array: The simulation runs over a time span from 0 to 1000 seconds, with 50 discrete time steps. The time interval between each step is calculated to update the distribution as coagulation progresses.</li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_3_compared/#ode-solver","title":"ODE solver\u00b6","text":"<p>In this section, we simulate the coagulation process using an ordinary differential equation (ODE) solver to track the evolution of particle concentrations in different size bins over time.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_3_compared/#add-pmf-simulation-comparison-and-summary","title":"Add PMF simulation, comparison, and summary\u00b6","text":""},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_4_ParticleResolved/","title":"Coagulation Basic 4: Particle Resolved","text":"In\u00a0[47]: Copied! <pre># %% particle resolved coagulation example\nimport numpy as np  # For numerical operations and array manipulations\nimport matplotlib.pyplot as plt  # For plotting graphs and visualizations\n\n# Import specific modules from the particula package\nfrom particula.dynamics.coagulation import brownian_kernel\nfrom particula.dynamics.coagulation import particle_resolved_method\n\nfrom particula.particles.properties.lognormal_size_distribution import (\n    lognormal_sample_distribution,\n)\n</pre> # %% particle resolved coagulation example import numpy as np  # For numerical operations and array manipulations import matplotlib.pyplot as plt  # For plotting graphs and visualizations  # Import specific modules from the particula package from particula.dynamics.coagulation import brownian_kernel from particula.dynamics.coagulation import particle_resolved_method  from particula.particles.properties.lognormal_size_distribution import (     lognormal_sample_distribution, ) In\u00a0[48]: Copied! <pre># lognormal spacing\n\nradius_bins = np.logspace(\n    -9, -6, num=20\n)  # Define the radius bins for the distribution\nmass_bins = (\n    4 / 3 * np.pi * radius_bins**3 * 1000\n)  # Calculate the mass of the particles in the bins\n\nkernel = brownian_kernel.brownian_coagulation_kernel_via_system_state(\n    radius_particle=radius_bins,\n    mass_particle=mass_bins,\n    temperature=298.15,\n    pressure=101325,\n)  # Calculate the Brownian coagulation kernel for the radius bins\n\nrandom_generator = np.random.default_rng(12345)\n</pre> # lognormal spacing  radius_bins = np.logspace(     -9, -6, num=20 )  # Define the radius bins for the distribution mass_bins = (     4 / 3 * np.pi * radius_bins**3 * 1000 )  # Calculate the mass of the particles in the bins  kernel = brownian_kernel.brownian_coagulation_kernel_via_system_state(     radius_particle=radius_bins,     mass_particle=mass_bins,     temperature=298.15,     pressure=101325, )  # Calculate the Brownian coagulation kernel for the radius bins  random_generator = np.random.default_rng(12345) <p>Sampling the Particle Distribution</p> <p>We then sample particles from the lognormal distribution. These particles will be sorted by size to prepare for the coagulation step.</p> In\u00a0[49]: Copied! <pre># %% sample particle distribution\nparticle_radius = lognormal_sample_distribution(\n    mode=np.array([1e-8, 1e-7]),\n    geometric_standard_deviation=np.array([1.4, 1.4]),\n    number_of_particles=np.array([5000, 1000]),\n    number_of_samples=10_000,\n)\n# particle_radius = np.sort(particle_radius)\nparticles_original = particle_radius.copy()\n</pre> # %% sample particle distribution particle_radius = lognormal_sample_distribution(     mode=np.array([1e-8, 1e-7]),     geometric_standard_deviation=np.array([1.4, 1.4]),     number_of_particles=np.array([5000, 1000]),     number_of_samples=10_000, ) # particle_radius = np.sort(particle_radius) particles_original = particle_radius.copy() In\u00a0[50]: Copied! <pre># %% Coagulation step\n\ndelta_t = 100  # time step in seconds\ntotal_number_concentration = 1_000_000 * 1e6  # particles per m^3\ntotal_number_tracked = len(particle_radius)\nvolume_sim = total_number_tracked / total_number_concentration\n\nloss_gain_index = particle_resolved_method.particle_resolved_coagulation_step(\n    particle_radius=particle_radius,\n    kernel=kernel,\n    kernel_radius=radius_bins,\n    volume=volume_sim,\n    time_step=delta_t,\n    random_generator=random_generator,\n)\nparticle_radius, gain, loss = particle_resolved_method.particle_resolved_update_step(\n    particle_radius=particle_radius,\n    gain=np.zeros_like(particle_radius),\n    loss=np.zeros_like(particle_radius),\n    small_index=loss_gain_index[:, 0],\n    large_index=loss_gain_index[:, 1],\n)\n\nprint(loss_gain_index.shape)\nprint(loss_gain_index)\n</pre> # %% Coagulation step  delta_t = 100  # time step in seconds total_number_concentration = 1_000_000 * 1e6  # particles per m^3 total_number_tracked = len(particle_radius) volume_sim = total_number_tracked / total_number_concentration  loss_gain_index = particle_resolved_method.particle_resolved_coagulation_step(     particle_radius=particle_radius,     kernel=kernel,     kernel_radius=radius_bins,     volume=volume_sim,     time_step=delta_t,     random_generator=random_generator, ) particle_radius, gain, loss = particle_resolved_method.particle_resolved_update_step(     particle_radius=particle_radius,     gain=np.zeros_like(particle_radius),     loss=np.zeros_like(particle_radius),     small_index=loss_gain_index[:, 0],     large_index=loss_gain_index[:, 1], )  print(loss_gain_index.shape) print(loss_gain_index) <pre>(3039, 2)\n[[ 759 9538]\n [3153 9522]\n [5383 9599]\n ...\n [9152 9417]\n [9173 9734]\n [8997 9213]]\n</pre> <p>Plotting the New Distribution</p> <p>Finally, we plot the particle size distribution before and after coagulation. This visualization helps us understand the effect of the coagulation process on the particle size distribution.</p> In\u00a0[51]: Copied! <pre># %% plot new distribution\nfig, ax = plt.subplots()\nax.hist(\n    particles_original, bins=100, histtype=\"step\", color=\"black\", density=True\n)\nax.hist(\n    particle_radius[particle_radius&gt;0], bins=100, histtype=\"step\", color=\"blue\", density=True\n)\nax.set_xscale(\"log\")\nax.set_yscale(\"log\")\nax.set_xlabel(\"Particle radius (m)\")\nax.set_ylabel(\"Frequency\")\nplt.show()\n</pre> # %% plot new distribution fig, ax = plt.subplots() ax.hist(     particles_original, bins=100, histtype=\"step\", color=\"black\", density=True ) ax.hist(     particle_radius[particle_radius&gt;0], bins=100, histtype=\"step\", color=\"blue\", density=True ) ax.set_xscale(\"log\") ax.set_yscale(\"log\") ax.set_xlabel(\"Particle radius (m)\") ax.set_ylabel(\"Frequency\") plt.show() <p>Plotting the Loss and Gain of Particles</p> <p>We also plot the loss and gain of particles due to coagulation. This visualization provides insights into the coagulation process and how it affects the particle population.</p> In\u00a0[52]: Copied! <pre>fig, ax = plt.subplots()\nax.hist(loss[loss&gt;0], bins=100, histtype=\"step\", color=\"red\", density=True)\nax.hist(gain[gain&gt;0], bins=100, histtype=\"step\", color=\"green\", density=True)\nax.set_xscale(\"log\")\n# ax.set_yscale(\"log\")\nax.set_xlabel(\"Particle radius (m)\")\nax.set_ylabel(\"Frequency\")\nplt.show()\n</pre> fig, ax = plt.subplots() ax.hist(loss[loss&gt;0], bins=100, histtype=\"step\", color=\"red\", density=True) ax.hist(gain[gain&gt;0], bins=100, histtype=\"step\", color=\"green\", density=True) ax.set_xscale(\"log\") # ax.set_yscale(\"log\") ax.set_xlabel(\"Particle radius (m)\") ax.set_ylabel(\"Frequency\") plt.show() In\u00a0[53]: Copied! <pre># Initial distribution for the simulation\nparticles_0 = particles_original\nparticles_i = particles_0\n\n# Define the time array for the simulation\ntime_array = np.linspace(\n    start=0, stop=1000, num=100\n)  # Time span of 1000 seconds\ntime_interval = (\n    time_array[1] - time_array[0]\n)  # Time interval between each step\n\n# Array to store the distribution at each time step\nparticles_matrix = np.zeros([len(time_array), len(particles_0)])\n\n# Simulate the coagulation process over time\nfor i, dpa in enumerate(time_array):\n    if i &gt; 0:\n\n        loss_gain_index = particle_resolved_method.particle_resolved_coagulation_step(\n            particle_radius=particles_i,\n            kernel=kernel,\n            kernel_radius=radius_bins,\n            volume=volume_sim,\n            time_step=time_interval,\n            random_generator=random_generator,\n        )\n        particles_i, _, _ = particle_resolved_method.particle_resolved_update_step(\n            particle_radius=particles_i,\n            gain=np.zeros_like(particles_i),\n            loss=np.zeros_like(particles_i),\n            small_index=loss_gain_index[:, 0],\n            large_index=loss_gain_index[:, 1],\n        )\n\n        # Ensure no negative concentrations (set to zero if less than zero)\n        particles_i[particles_i &lt; 0] = 0\n\n    # Store the updated distribution for the current time step\n    particles_matrix[i, :] = particles_i\n</pre> # Initial distribution for the simulation particles_0 = particles_original particles_i = particles_0  # Define the time array for the simulation time_array = np.linspace(     start=0, stop=1000, num=100 )  # Time span of 1000 seconds time_interval = (     time_array[1] - time_array[0] )  # Time interval between each step  # Array to store the distribution at each time step particles_matrix = np.zeros([len(time_array), len(particles_0)])  # Simulate the coagulation process over time for i, dpa in enumerate(time_array):     if i &gt; 0:          loss_gain_index = particle_resolved_method.particle_resolved_coagulation_step(             particle_radius=particles_i,             kernel=kernel,             kernel_radius=radius_bins,             volume=volume_sim,             time_step=time_interval,             random_generator=random_generator,         )         particles_i, _, _ = particle_resolved_method.particle_resolved_update_step(             particle_radius=particles_i,             gain=np.zeros_like(particles_i),             loss=np.zeros_like(particles_i),             small_index=loss_gain_index[:, 0],             large_index=loss_gain_index[:, 1],         )          # Ensure no negative concentrations (set to zero if less than zero)         particles_i[particles_i &lt; 0] = 0      # Store the updated distribution for the current time step     particles_matrix[i, :] = particles_i <p>Plotting the Final Distribution</p> <p>Finally, we plot the final particle size distribution after multiple coagulation steps. This visualization shows how the particle size distribution evolves over time due to coagulation.</p> In\u00a0[54]: Copied! <pre>filtered = particles_matrix[-1, :]&gt;0\n\nfig, ax = plt.subplots()\nax.hist(\n    particles_original, bins=100, histtype=\"step\", color=\"black\", density=True\n)\nax.hist(\n    particles_matrix[-1, filtered],\n    bins=100,\n    histtype=\"step\",\n    color=\"blue\",\n    density=True,\n)\nax.set_xscale(\"log\")\nax.set_yscale(\"log\")\nax.set_xlabel(\"Particle radius (m)\")\nax.set_ylabel(\"Frequency\")\nplt.show()\n</pre> filtered = particles_matrix[-1, :]&gt;0  fig, ax = plt.subplots() ax.hist(     particles_original, bins=100, histtype=\"step\", color=\"black\", density=True ) ax.hist(     particles_matrix[-1, filtered],     bins=100,     histtype=\"step\",     color=\"blue\",     density=True, ) ax.set_xscale(\"log\") ax.set_yscale(\"log\") ax.set_xlabel(\"Particle radius (m)\") ax.set_ylabel(\"Frequency\") plt.show() In\u00a0[55]: Copied! <pre># plot total number of particles\ntotal_number = np.sum(particles_matrix&gt;0, axis=1)\n\nfig, ax = plt.subplots()\nax.plot(time_array, total_number)\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(\"Number of particles\")\nplt.show()\n</pre> # plot total number of particles total_number = np.sum(particles_matrix&gt;0, axis=1)  fig, ax = plt.subplots() ax.plot(time_array, total_number) ax.set_xlabel(\"Time (s)\") ax.set_ylabel(\"Number of particles\") plt.show() In\u00a0[56]: Copied! <pre># convert to concentration\ntotal_concentration = total_number / volume_sim\n\nfig, ax = plt.subplots()\nax.plot(time_array, total_concentration)\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(r\"Concentration $(m^{-3})$\")\nplt.show()\n</pre> # convert to concentration total_concentration = total_number / volume_sim  fig, ax = plt.subplots() ax.plot(time_array, total_concentration) ax.set_xlabel(\"Time (s)\") ax.set_ylabel(r\"Concentration $(m^{-3})$\") plt.show() In\u00a0[\u00a0]: Copied! <pre>\"\"\"coagulation rewirte\"\"\"\n\nimport numpy as np\n\nfrom particula import particles\nfrom particula.dynamics import coagulation\nfrom particula.dynamics.coagulation import (\n    particle_resolved_method,\n    super_droplet_method,\n)\nfrom scipy.interpolate import RectBivariateSpline\nfrom particula.util.input_handling import convert_units\n\n# %%\n\n\nparticle_radius = particles.properties.lognormal_sample_distribution(\n    mode=np.array([100e-9]),\n    geometric_standard_deviation=np.array([1.3]),\n    number_of_particles=np.array([1]),\n    number_of_samples=100_000,\n)\n\nkernel_radius = np.logspace(-8, -6, 50)\n\n\n# calc mass of particle from density 1000\nmass_particles = 4 / 3 * np.pi * kernel_radius**3 * 1000\nkernel = coagulation.brownian_coagulation_kernel_via_system_state(\n    radius_particle=kernel_radius,\n    mass_particle=mass_particles,\n    temperature=300,\n    pressure=101325,\n)\n# Step 4: Initialize a bivariate spline for interpolating kernel\n# values between bin radii\ninterp_kernel = RectBivariateSpline(x=kernel_radius, y=kernel_radius, z=kernel)\n\nrandom_generator = np.random.default_rng()\n\nvolume = 1 * convert_units(\"cm^3\", \"m^3\")\ntime_step = 100\n# %%\n\ntotal_steps = 100\nprint(f\"total time: {total_steps*time_step:.2f}\")\n\ngain_radius = np.zeros_like(particle_radius, dtype=np.float64)\nloss_radius = np.zeros_like(particle_radius, dtype=np.float64)\nfor time_i in range(total_steps):\n    number_in_bins, bin_indices = super_droplet_method.bin_particles(\n        particle_radius, kernel_radius\n    )\n    # Step 3: Precompute unique bin pairs for efficient coagulation\n    pair_indices = super_droplet_method.get_bin_pairs(bin_indices=bin_indices)\n\n    small_index_total0 = np.array([], dtype=np.int64)\n    large_index_total0 = np.array([], dtype=np.int64)\n\n    # Iterate over each bin pair to calculate potential coagulation events\n    for lower_bin, upper_bin in pair_indices:\n        # get raidius indexes and filter out zeros\n        small_indices = np.flatnonzero(\n            (bin_indices == lower_bin) &amp; (particle_radius &gt; 0)\n        )\n        # filter small indices that are in small indices total\n        small_indices = np.setdiff1d(small_indices, small_index_total0)\n\n        large_indices = np.flatnonzero(\n            (bin_indices == upper_bin) &amp; (particle_radius &gt; 0)\n        )\n        if np.size(small_indices) == 0 or np.size(large_indices) == 0:\n            continue  # Skip to the next bin pair if no particles are present\n        small_count = np.size(small_indices)\n        large_count = np.size(large_indices)\n        # print(f\"small count: {small_count}, large count: {large_count}\")\n\n        # Retrieve the maximum kernel value for the current bin pair\n        kernel_values = interp_kernel.ev(\n            np.min(particle_radius[small_indices]),\n            np.max(particle_radius[large_indices]),\n        )\n        # print(f\"kernel max values: {kernel_values}\")\n\n        # Number of coagulation events\n        if lower_bin == upper_bin:\n            events = small_count * (large_count) / 2\n        events = small_count * large_count\n\n        # events = random_generator.poisson(events)\n        tests = np.ceil(kernel_values * time_step * events / volume).astype(\n            int\n        )\n        # print(f\"events: {events}, tests: {tests}\")\n\n        if tests == 0:\n            continue\n\n        # Randomly select indices of particles involved in the coagulation\n        small_replace = False if small_count &gt; tests else True\n        small_index = random_generator.choice(\n            small_indices, tests, replace=small_replace\n        )\n        large_index = random_generator.choice(large_indices, tests)\n        kernel_value = interp_kernel.ev(\n            particle_radius[small_index], particle_radius[large_index]\n        )\n        # select diagonal\n        if kernel_value.ndim &gt; 1:\n            kernel_value = np.diagonal(kernel_value)\n        # print(f\"kernel value: {kernel_value}\")\n\n        # Determine which coagulation events actually occur based on\n        # interpolated kernel probabilities\n        coagulation_probabilities = (\n            kernel_value * time_step * events / (tests * volume)\n        )\n        # random number\n        r = random_generator.uniform(size=tests)\n        valid_indices = np.flatnonzero(r &lt; coagulation_probabilities)\n        # check if any valid indices are duplicate in small index\n        # error of same small particle going to two different large particles\n        _, unique_index = np.unique(\n            small_index[valid_indices], return_index=True\n        )\n        small_index = small_index[valid_indices][unique_index]\n        large_index = large_index[valid_indices][unique_index]\n\n        # save the coagulation events\n        small_index_total0 = np.append(small_index_total0, small_index)\n        large_index_total0 = np.append(large_index_total0, large_index)\n\n    commons, small_index_in_common, large_index_in_common = np.intersect1d(\n        small_index_total0, large_index_total0, return_indices=True\n    )\n    # sort based on radius\n    radius_argsort = np.argsort(particle_radius[commons])\n    commons = commons[radius_argsort]\n    small_index_in_common = small_index_in_common[radius_argsort]\n    large_index_in_common = large_index_in_common[radius_argsort]\n\n    # remap to largest particle in common\n    for i, common in enumerate(commons):\n        final_value = large_index_total0[small_index_in_common[i]]\n        remap_index = np.flatnonzero(large_index_total0 == common)\n        large_index_total0[remap_index] = final_value\n\n    # update particle radius\n    particle_radius, _, _ = (\n        particle_resolved_method.particle_resolved_update_step(\n            particle_radius=particle_radius,\n            gain=gain_radius,\n            loss=loss_radius,\n            small_index=small_index_total0,\n            large_index=large_index_total0,\n        )\n    )\n\nprint(f\"concenration: {np.sum(number_in_bins) / volume:.4e}\")\n</pre> \"\"\"coagulation rewirte\"\"\"  import numpy as np  from particula import particles from particula.dynamics import coagulation from particula.dynamics.coagulation import (     particle_resolved_method,     super_droplet_method, ) from scipy.interpolate import RectBivariateSpline from particula.util.input_handling import convert_units  # %%   particle_radius = particles.properties.lognormal_sample_distribution(     mode=np.array([100e-9]),     geometric_standard_deviation=np.array([1.3]),     number_of_particles=np.array([1]),     number_of_samples=100_000, )  kernel_radius = np.logspace(-8, -6, 50)   # calc mass of particle from density 1000 mass_particles = 4 / 3 * np.pi * kernel_radius**3 * 1000 kernel = coagulation.brownian_coagulation_kernel_via_system_state(     radius_particle=kernel_radius,     mass_particle=mass_particles,     temperature=300,     pressure=101325, ) # Step 4: Initialize a bivariate spline for interpolating kernel # values between bin radii interp_kernel = RectBivariateSpline(x=kernel_radius, y=kernel_radius, z=kernel)  random_generator = np.random.default_rng()  volume = 1 * convert_units(\"cm^3\", \"m^3\") time_step = 100 # %%  total_steps = 100 print(f\"total time: {total_steps*time_step:.2f}\")  gain_radius = np.zeros_like(particle_radius, dtype=np.float64) loss_radius = np.zeros_like(particle_radius, dtype=np.float64) for time_i in range(total_steps):     number_in_bins, bin_indices = super_droplet_method.bin_particles(         particle_radius, kernel_radius     )     # Step 3: Precompute unique bin pairs for efficient coagulation     pair_indices = super_droplet_method.get_bin_pairs(bin_indices=bin_indices)      small_index_total0 = np.array([], dtype=np.int64)     large_index_total0 = np.array([], dtype=np.int64)      # Iterate over each bin pair to calculate potential coagulation events     for lower_bin, upper_bin in pair_indices:         # get raidius indexes and filter out zeros         small_indices = np.flatnonzero(             (bin_indices == lower_bin) &amp; (particle_radius &gt; 0)         )         # filter small indices that are in small indices total         small_indices = np.setdiff1d(small_indices, small_index_total0)          large_indices = np.flatnonzero(             (bin_indices == upper_bin) &amp; (particle_radius &gt; 0)         )         if np.size(small_indices) == 0 or np.size(large_indices) == 0:             continue  # Skip to the next bin pair if no particles are present         small_count = np.size(small_indices)         large_count = np.size(large_indices)         # print(f\"small count: {small_count}, large count: {large_count}\")          # Retrieve the maximum kernel value for the current bin pair         kernel_values = interp_kernel.ev(             np.min(particle_radius[small_indices]),             np.max(particle_radius[large_indices]),         )         # print(f\"kernel max values: {kernel_values}\")          # Number of coagulation events         if lower_bin == upper_bin:             events = small_count * (large_count) / 2         events = small_count * large_count          # events = random_generator.poisson(events)         tests = np.ceil(kernel_values * time_step * events / volume).astype(             int         )         # print(f\"events: {events}, tests: {tests}\")          if tests == 0:             continue          # Randomly select indices of particles involved in the coagulation         small_replace = False if small_count &gt; tests else True         small_index = random_generator.choice(             small_indices, tests, replace=small_replace         )         large_index = random_generator.choice(large_indices, tests)         kernel_value = interp_kernel.ev(             particle_radius[small_index], particle_radius[large_index]         )         # select diagonal         if kernel_value.ndim &gt; 1:             kernel_value = np.diagonal(kernel_value)         # print(f\"kernel value: {kernel_value}\")          # Determine which coagulation events actually occur based on         # interpolated kernel probabilities         coagulation_probabilities = (             kernel_value * time_step * events / (tests * volume)         )         # random number         r = random_generator.uniform(size=tests)         valid_indices = np.flatnonzero(r &lt; coagulation_probabilities)         # check if any valid indices are duplicate in small index         # error of same small particle going to two different large particles         _, unique_index = np.unique(             small_index[valid_indices], return_index=True         )         small_index = small_index[valid_indices][unique_index]         large_index = large_index[valid_indices][unique_index]          # save the coagulation events         small_index_total0 = np.append(small_index_total0, small_index)         large_index_total0 = np.append(large_index_total0, large_index)      commons, small_index_in_common, large_index_in_common = np.intersect1d(         small_index_total0, large_index_total0, return_indices=True     )     # sort based on radius     radius_argsort = np.argsort(particle_radius[commons])     commons = commons[radius_argsort]     small_index_in_common = small_index_in_common[radius_argsort]     large_index_in_common = large_index_in_common[radius_argsort]      # remap to largest particle in common     for i, common in enumerate(commons):         final_value = large_index_total0[small_index_in_common[i]]         remap_index = np.flatnonzero(large_index_total0 == common)         large_index_total0[remap_index] = final_value      # update particle radius     particle_radius, _, _ = (         particle_resolved_method.particle_resolved_update_step(             particle_radius=particle_radius,             gain=gain_radius,             loss=loss_radius,             small_index=small_index_total0,             large_index=large_index_total0,         )     )  print(f\"concenration: {np.sum(number_in_bins) / volume:.4e}\")"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_4_ParticleResolved/#coagulation-basic-4-particle-resolved","title":"Coagulation Basic 4: Particle Resolved\u00b6","text":"<p>Introduction</p> <p>In aerosol science, understanding particle-particle interactions is crucial for predicting the evolution of particle size distributions. One such interaction is coagulation, where two particles collide and merge into a larger particle. Accurately modeling coagulation at the level of individual particles is known as the particle-resolved method.</p> <p>The particle-resolved method tracks each particle individually, considering its unique properties and interactions. This method provides the most detailed representation of aerosol dynamics, making it ideal for cases where precision is paramount, such as in cloud microphysics or laboratory-scale studies.</p> <p>However, this approach is computationally intensive because it requires simulating every individual particle and its interactions. Unlike the super droplet method, which uses statistical representations to reduce computational load, the direct particle-resolved method does not aggregate particles into larger groups. Instead, every particle is treated independently, ensuring that every interaction is explicitly modeled.</p> <p>This notebook provides a step-by-step guide to simulating coagulation using a pure particle-resolved approach, demonstrating how individual particles evolve over time without any simplifications or approximations in particle grouping.</p> <p>Setup and Imports</p> <p>We'll start by importing the necessary libraries and setting up the environment.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_4_ParticleResolved/#generating-distribution","title":"Generating Distribution\u00b6","text":"<p>In this section, we generate a sample particle size distribution following a lognormal distribution. The lognormal distribution is commonly used in aerosol science to describe particle size distributions.</p> <p>Coagulation Kernel</p> <p>We also calculate the Brownian coagulation kernel for these particles, which quantifies the probability of coagulation between particles of different sizes.</p> <p>Random seed</p> <p>We set a random seed to ensure reproducibility of the results.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_4_ParticleResolved/#coagulation-step","title":"Coagulation Step\u00b6","text":"<p>In the coagulation step, particles collide and merge over a given time step. The super droplet method efficiently simulates this process by adjusting the particle sizes and concentrations based on the calculated kernel and the specified volume and time step.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_4_ParticleResolved/#direct-time-stepping","title":"Direct Time Stepping\u00b6","text":"<p>With the first coagulation step completed, we can now proceed to the next time step. We repeat the coagulation process for the new particle distribution, updating the particle sizes and concentrations accordingly. This iterative approach allows us to simulate the evolution of the particle size distribution over time.</p> <p>Here we use a simple for loop to perform multiple coagulation steps. In practice, more sophisticated time-stepping methods may be used to improve efficiency and accuracy.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_4_ParticleResolved/#conclusion","title":"Conclusion\u00b6","text":"<p>This notebook demonstrated the use of the particle resolved coagulation method to simulate particle coagulation.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_4_ParticleResolved/#to-be-revise-below","title":"To be revise below\u00b6","text":""},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_5_SDM/","title":"Coagulation Basic 5: Super Droplet Method","text":"In\u00a0[22]: Copied! <pre># %% particle resolved coagulation example\nimport numpy as np  # For numerical operations and array manipulations\nimport matplotlib.pyplot as plt  # For plotting graphs and visualizations\n\n# Import specific modules from the particula package\nfrom particula.dynamics.coagulation import brownian_kernel\nfrom particula.dynamics.coagulation import super_droplet_method\n\nfrom particula.particles.properties.lognormal_size_distribution import (\n    lognormal_sample_distribution,\n)\n</pre> # %% particle resolved coagulation example import numpy as np  # For numerical operations and array manipulations import matplotlib.pyplot as plt  # For plotting graphs and visualizations  # Import specific modules from the particula package from particula.dynamics.coagulation import brownian_kernel from particula.dynamics.coagulation import super_droplet_method  from particula.particles.properties.lognormal_size_distribution import (     lognormal_sample_distribution, ) In\u00a0[23]: Copied! <pre># lognormal spacing\n\nradius_bins = np.logspace(\n    -9, -6, num=20\n)  # Define the radius bins for the distribution\nmass_bins = (\n    4 / 3 * np.pi * radius_bins**3 * 1000\n)  # Calculate the mass of the particles in the bins\n\nkernel = brownian_kernel.brownian_coagulation_kernel_via_system_state(\n    radius_particle=radius_bins,\n    mass_particle=mass_bins,\n    temperature=298.15,\n    pressure=101325,\n)  # Calculate the Brownian coagulation kernel for the radius bins\n\nrandom_generator = np.random.default_rng(12345)\n</pre> # lognormal spacing  radius_bins = np.logspace(     -9, -6, num=20 )  # Define the radius bins for the distribution mass_bins = (     4 / 3 * np.pi * radius_bins**3 * 1000 )  # Calculate the mass of the particles in the bins  kernel = brownian_kernel.brownian_coagulation_kernel_via_system_state(     radius_particle=radius_bins,     mass_particle=mass_bins,     temperature=298.15,     pressure=101325, )  # Calculate the Brownian coagulation kernel for the radius bins  random_generator = np.random.default_rng(12345) <p>Sampling the Particle Distribution</p> <p>We then sample particles from the lognormal distribution. These particles will be sorted by size to prepare for the coagulation step.</p> In\u00a0[24]: Copied! <pre># %% sample particle distribution\nparticle_radius = lognormal_sample_distribution(\n    mode=np.array([1e-8, 1e-7]),\n    geometric_standard_deviation=np.array([1.4, 1.4]),\n    number_of_particles=np.array([5000, 1000]),\n    number_of_samples=10000,\n)\nparticle_radius = np.sort(particle_radius)\nparticles_original = particle_radius.copy()\n</pre> # %% sample particle distribution particle_radius = lognormal_sample_distribution(     mode=np.array([1e-8, 1e-7]),     geometric_standard_deviation=np.array([1.4, 1.4]),     number_of_particles=np.array([5000, 1000]),     number_of_samples=10000, ) particle_radius = np.sort(particle_radius) particles_original = particle_radius.copy() In\u00a0[25]: Copied! <pre># %% Coagulation step\n\ndelta_t = 1  # time step in seconds\n\nrandom_concentration = np.random.uniform(1, 10, size=particle_radius.size)\nparticle_concentration = (\n    np.ones_like(particle_radius) * random_concentration * 1e6\n)  # particles per m^3\nparticle_concentration = particle_concentration.astype(np.float64)\nvolume_sim = 1  # m^3\n\nparticle_radius_1, particle_concentration_1 = (\n    super_droplet_method.super_droplet_coagulation_step(\n        particle_radius=particle_radius,\n        particle_concentration=particle_concentration,\n        kernel=kernel,\n        kernel_radius=radius_bins,\n        volume=volume_sim,\n        time_step=delta_t,\n        random_generator=random_generator,\n    )\n)\n\nvolume_final = np.power(particle_radius_1, 3)\nvolume_concentration_final = volume_final * particle_concentration_1\nvolume_total_final = np.sum(volume_concentration_final)\n\nprint(f\"Final volume: {volume_total_final}\")\nprint(f\"Final number of particles: {np.sum(particle_concentration_1)}\")\n</pre> # %% Coagulation step  delta_t = 1  # time step in seconds  random_concentration = np.random.uniform(1, 10, size=particle_radius.size) particle_concentration = (     np.ones_like(particle_radius) * random_concentration * 1e6 )  # particles per m^3 particle_concentration = particle_concentration.astype(np.float64) volume_sim = 1  # m^3  particle_radius_1, particle_concentration_1 = (     super_droplet_method.super_droplet_coagulation_step(         particle_radius=particle_radius,         particle_concentration=particle_concentration,         kernel=kernel,         kernel_radius=radius_bins,         volume=volume_sim,         time_step=delta_t,         random_generator=random_generator,     ) )  volume_final = np.power(particle_radius_1, 3) volume_concentration_final = volume_final * particle_concentration_1 volume_total_final = np.sum(volume_concentration_final)  print(f\"Final volume: {volume_total_final}\") print(f\"Final number of particles: {np.sum(particle_concentration_1)}\") <pre>Final volume: 1.6866138333522715e-11\nFinal number of particles: 39420946809.99734\n</pre> <p>Plotting the New Distribution</p> <p>Finally, we plot the particle size distribution before and after coagulation. This visualization helps us understand the effect of the coagulation process on the particle size distribution.</p> <p>The histogram bins are weighted by the number of particles in each bin to reflect the super droplet method's representation of real particles.</p> In\u00a0[26]: Copied! <pre># %% plot new distribution\nfig, ax = plt.subplots()\nax.hist(\n    particles_original,\n    weights=particle_concentration,\n    bins=100, histtype=\"step\", color=\"black\", density=True\n)\nax.hist(\n    particle_radius,\n    weights=particle_concentration_1,\n    bins=100, histtype=\"step\", color=\"blue\", density=True\n)\nax.set_xscale(\"log\")\nax.set_yscale(\"log\")\nax.set_xlabel(\"Particle radius (m)\")\nax.set_ylabel(\"Frequency\")\nplt.show()\n</pre> # %% plot new distribution fig, ax = plt.subplots() ax.hist(     particles_original,     weights=particle_concentration,     bins=100, histtype=\"step\", color=\"black\", density=True ) ax.hist(     particle_radius,     weights=particle_concentration_1,     bins=100, histtype=\"step\", color=\"blue\", density=True ) ax.set_xscale(\"log\") ax.set_yscale(\"log\") ax.set_xlabel(\"Particle radius (m)\") ax.set_ylabel(\"Frequency\") plt.show() In\u00a0[27]: Copied! <pre># Initial distribution for the simulation\nparticles_i = particle_radius\n\nparticle_concentration_i = particle_concentration\n\n# Define the time array for the simulation\ntime_array = np.linspace(\n    start=0, stop=1000, num=100\n)  # Time span of 1000 seconds\ntime_interval = (\n    time_array[1] - time_array[0]\n)  # Time interval between each step\n\n# Array to store the distribution at each time step\nparticles_matrix = np.zeros([len(time_array), len(particles_i)])\nconcentration_matrix = np.zeros([len(time_array), len(particles_i)])\n\nparticles_matrix[0, :] = particles_i\nconcentration_matrix[0, :] = particle_concentration_i\n# Simulate the coagulation process over time\nfor i, dpa in enumerate(time_array):\n    if i &gt; 0:\n\n        particles_i, particle_concentration_i = (\n            super_droplet_method.super_droplet_coagulation_step(\n                particle_radius=particles_i,\n                particle_concentration=particle_concentration_i,\n                kernel=kernel,\n                kernel_radius=radius_bins,\n                volume=volume_sim,\n                time_step=time_interval,\n                random_generator=random_generator,\n            )\n        )\n        # Ensure no negative concentrations (set to zero if less than zero)\n        particles_i[particles_i &lt; 0] = 0\n\n    # Store the updated distribution for the current time step\n    particles_matrix[i, :] = particles_i\n    concentration_matrix[i, :] = particle_concentration_i\n</pre> # Initial distribution for the simulation particles_i = particle_radius  particle_concentration_i = particle_concentration  # Define the time array for the simulation time_array = np.linspace(     start=0, stop=1000, num=100 )  # Time span of 1000 seconds time_interval = (     time_array[1] - time_array[0] )  # Time interval between each step  # Array to store the distribution at each time step particles_matrix = np.zeros([len(time_array), len(particles_i)]) concentration_matrix = np.zeros([len(time_array), len(particles_i)])  particles_matrix[0, :] = particles_i concentration_matrix[0, :] = particle_concentration_i # Simulate the coagulation process over time for i, dpa in enumerate(time_array):     if i &gt; 0:          particles_i, particle_concentration_i = (             super_droplet_method.super_droplet_coagulation_step(                 particle_radius=particles_i,                 particle_concentration=particle_concentration_i,                 kernel=kernel,                 kernel_radius=radius_bins,                 volume=volume_sim,                 time_step=time_interval,                 random_generator=random_generator,             )         )         # Ensure no negative concentrations (set to zero if less than zero)         particles_i[particles_i &lt; 0] = 0      # Store the updated distribution for the current time step     particles_matrix[i, :] = particles_i     concentration_matrix[i, :] = particle_concentration_i <p>Plotting the Final Distribution</p> <p>Finally, we plot the particle size distribution at the end of the simulation. This visualization provides insights into how the particle size distribution evolves over time due to coagulation.</p> In\u00a0[28]: Copied! <pre>fig, ax = plt.subplots()\nax.hist(\n    particles_original,\n    weights=particle_concentration,\n    bins=100,\n    histtype=\"step\",\n    color=\"black\",\n    density=True,\n)\nax.hist(\n    particles_matrix[-1, :],\n    weights=concentration_matrix[-1, :],\n    bins=100,\n    histtype=\"step\",\n    color=\"blue\",\n    density=True,\n)\nax.set_xscale(\"log\")\nax.set_yscale(\"log\")\nax.set_xlabel(\"Particle radius (m)\")\nax.set_ylabel(\"Frequency\")\nplt.show()\n</pre> fig, ax = plt.subplots() ax.hist(     particles_original,     weights=particle_concentration,     bins=100,     histtype=\"step\",     color=\"black\",     density=True, ) ax.hist(     particles_matrix[-1, :],     weights=concentration_matrix[-1, :],     bins=100,     histtype=\"step\",     color=\"blue\",     density=True, ) ax.set_xscale(\"log\") ax.set_yscale(\"log\") ax.set_xlabel(\"Particle radius (m)\") ax.set_ylabel(\"Frequency\") plt.show() In\u00a0[29]: Copied! <pre># total number of particles\ntotal_concentration = np.sum(concentration_matrix, axis=1)\n\nfig, ax = plt.subplots()\nax.plot(time_array, total_concentration)\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(r\"Concentration (m$^{-3}$)\")\nplt.show()\n</pre> # total number of particles total_concentration = np.sum(concentration_matrix, axis=1)  fig, ax = plt.subplots() ax.plot(time_array, total_concentration) ax.set_xlabel(\"Time (s)\") ax.set_ylabel(r\"Concentration (m$^{-3}$)\") plt.show()"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_5_SDM/#coagulation-basic-5-super-droplet-method","title":"Coagulation Basic 5: Super Droplet Method\u00b6","text":"<p>BETA VERSION</p> <p>*It seems like the underlying SDM method is wrong**</p> <p>Introduction</p> <p>In aerosol science, understanding particle-particle interactions is crucial for predicting the evolution of particle size distributions. One such interaction is coagulation, where two particles collide and merge into a larger particle. Modeling coagulation accurately can be computationally expensive, especially when tracking individual particles.</p> <p>The super droplet method is a technique that allows for the efficient simulation of coagulation in a computationally feasible manner. It represents a large number of real particles with a smaller number of computational particles (super droplets), each carrying a statistical weight that reflects the number of real particles it represents.</p> <p>This notebook provides a step-by-step guide to simulating coagulation using the super droplet method with a particle-resolved approach.</p> <p>Setup and Imports</p> <p>We'll start by importing the necessary libraries and setting up the environment.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_5_SDM/#generating-distribution","title":"Generating Distribution\u00b6","text":"<p>In this section, we generate a sample particle size distribution following a lognormal distribution. The lognormal distribution is commonly used in aerosol science to describe particle size distributions.</p> <p>Coagulation Kernel</p> <p>We also calculate the Brownian coagulation kernel for these particles, which quantifies the probability of coagulation between particles of different sizes.</p> <p>Random seed</p> <p>We set a random seed to ensure reproducibility of the results.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_5_SDM/#coagulation-step","title":"Coagulation Step\u00b6","text":"<p>In the coagulation step, particles collide and merge over a given time step. The super droplet method efficiently simulates this process by adjusting the particle sizes and concentrations based on the calculated kernel and the specified volume and time step.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_5_SDM/#direct-time-stepping","title":"Direct Time Stepping\u00b6","text":"<p>With the first coagulation step completed, we can now proceed to the next time step. We repeat the coagulation process for the new particle distribution, updating the particle sizes and concentrations accordingly. This iterative approach allows us to simulate the evolution of the particle size distribution over time.</p> <p>Here we use a simple for loop to perform multiple coagulation steps. In practice, more sophisticated time-stepping methods may be used to improve efficiency and accuracy.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_5_SDM/#conclusion","title":"Conclusion\u00b6","text":"<p>This notebook demonstrated the use of the super droplet method to simulate particle coagulation in a computationally efficient manner. By representing multiple real particles with fewer computational particles, we can model complex aerosol dynamics over time without the need for excessive computational resources.</p> <p>Seems like it is over estimating the coagulation rate. Need to follow-up</p>"},{"location":"Tutorials/Dynamics/Condensation/Condensation_1_Bin/","title":"Condensation Tutorial: Radius Bin","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# particula imports\nfrom particula import particles\nfrom particula.gas import AtmosphereBuilder, VaporPressureFactory, GasSpeciesBuilder\nfrom particula.aerosol import Aerosol\nfrom particula.dynamics import MassCondensation\nfrom particula.dynamics.condensation import CondensationIsothermal\n</pre> import numpy as np import matplotlib.pyplot as plt  # particula imports from particula import particles from particula.gas import AtmosphereBuilder, VaporPressureFactory, GasSpeciesBuilder from particula.aerosol import Aerosol from particula.dynamics import MassCondensation from particula.dynamics.condensation import CondensationIsothermal In\u00a0[2]: Copied! <pre># Glycerol gas\nmolar_mass_glycerol = 92.09382e-3  # kg/mol\nparameters_clausius = {\n    \"latent_heat\": 71.5 * molar_mass_glycerol,\n    \"latent_heat_units\": \"kJ/kg\",\n    \"temperature_initial\": 125.5,\n    \"temperature_initial_units\": \"degC\",\n    \"pressure_initial\": 1,\n    \"pressure_initial_units\": \"mmHg\",\n}\nvapor_pressure_strategy = VaporPressureFactory().get_strategy(\n    \"clausius_clapeyron\", parameters_clausius\n)\n\nsat_concentration = vapor_pressure_strategy.saturation_concentration(\n    molar_mass_glycerol, 298.15\n)\nprint(f\"Saturation concentration: {sat_concentration:.2e} kg/m^3\")\n\nsat_factor = 0.01  # 50% of saturation concentration\nglycerol_gas = (\n    GasSpeciesBuilder()\n    .set_molar_mass(molar_mass_glycerol, \"kg/mol\")\n    .set_vapor_pressure_strategy(vapor_pressure_strategy)\n    .set_concentration(sat_concentration * sat_factor, \"kg/m^3\")\n    .set_name(\"Glycerol\")\n    .set_condensable(True)\n    .build()\n)\n\natmosphere = (\n    AtmosphereBuilder()\n    .add_species(glycerol_gas)\n    .set_temperature(25, temperature_units=\"degC\")\n    .set_pressure(1, pressure_units=\"atm\")\n    .build()\n)\n\n# Glycerol particle distribution\nbins = np.logspace(-8, -5, 500)\nlognormal_rep = (\n    particles.PresetParticleRadiusBuilder()\n    .set_mode(np.array([100]), \"nm\")\n    .set_geometric_standard_deviation(np.array([1.3]))\n    .set_number_concentration(np.array([1e4]), \"1/cm^3\")\n    .set_density(1.26, \"g/cm^3\")\n    .set_distribution_type(\"pmf\")\n    .set_radius_bins(bins, \"m\")\n    .build()\n)\n\naerosol = Aerosol(atmosphere=atmosphere, particles=lognormal_rep)\n\nprint(aerosol)\n</pre> # Glycerol gas molar_mass_glycerol = 92.09382e-3  # kg/mol parameters_clausius = {     \"latent_heat\": 71.5 * molar_mass_glycerol,     \"latent_heat_units\": \"kJ/kg\",     \"temperature_initial\": 125.5,     \"temperature_initial_units\": \"degC\",     \"pressure_initial\": 1,     \"pressure_initial_units\": \"mmHg\", } vapor_pressure_strategy = VaporPressureFactory().get_strategy(     \"clausius_clapeyron\", parameters_clausius )  sat_concentration = vapor_pressure_strategy.saturation_concentration(     molar_mass_glycerol, 298.15 ) print(f\"Saturation concentration: {sat_concentration:.2e} kg/m^3\")  sat_factor = 0.01  # 50% of saturation concentration glycerol_gas = (     GasSpeciesBuilder()     .set_molar_mass(molar_mass_glycerol, \"kg/mol\")     .set_vapor_pressure_strategy(vapor_pressure_strategy)     .set_concentration(sat_concentration * sat_factor, \"kg/m^3\")     .set_name(\"Glycerol\")     .set_condensable(True)     .build() )  atmosphere = (     AtmosphereBuilder()     .add_species(glycerol_gas)     .set_temperature(25, temperature_units=\"degC\")     .set_pressure(1, pressure_units=\"atm\")     .build() )  # Glycerol particle distribution bins = np.logspace(-8, -5, 500) lognormal_rep = (     particles.PresetParticleRadiusBuilder()     .set_mode(np.array([100]), \"nm\")     .set_geometric_standard_deviation(np.array([1.3]))     .set_number_concentration(np.array([1e4]), \"1/cm^3\")     .set_density(1.26, \"g/cm^3\")     .set_distribution_type(\"pmf\")     .set_radius_bins(bins, \"m\")     .build() )  aerosol = Aerosol(atmosphere=atmosphere, particles=lognormal_rep)  print(aerosol) <pre>Saturation concentration: 2.54e-03 kg/m^3\nGas mixture at 298.15 K and 101325.0 Pa consisting of ['Glycerol']\n[0]: Particle Representation:\n\tStrategy: RadiiBasedMovingBin\n\tActivity: ActivityIdealMass\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 7.194e-08 [kg/m^3]\n\tNumber Concentration: 1.000e+10 [#/m^3]\n</pre> In\u00a0[3]: Copied! <pre># define the condensation process\ncondensation_isothermal = CondensationIsothermal(\n    molar_mass=molar_mass_glycerol,\n    diffusion_coefficient=2e-5,\n    accommodation_coefficient=0.1,  #makes things go slower/faster\n)\ncondensation_process = MassCondensation(condensation_strategy=condensation_isothermal)\n\n# define the time array in seconds\ntime_step = 0.5\ntime_array = np.arange(0, 10, time_step)\ntotal_mass = np.zeros_like(time_array)\n\n# output arrays\naerosol_sim = []\n\nrate = condensation_process.rate(aerosol)\n\n# print(f\"Inital rate: {rate[:5]}...\")\n# print(f\"Initial rate shape: {rate.shape}\")\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.semilogx(aerosol.particles[0].get_radius()*1e9, aerosol.particles[0].concentration, label=\"Initial\")\n# singe step\naerosol = condensation_process.execute(aerosol, time_step)\nax.semilogx(aerosol.particles[0].get_radius()*1e9, aerosol.particles[0].concentration, label=\"After 1 step\")\n# second step\naerosol = condensation_process.execute(aerosol, time_step)\nax.semilogx(aerosol.particles[0].get_radius()*1e9, aerosol.particles[0].concentration, label=\"After 2 steps\")\n# 5th step\naerosol = condensation_process.execute(aerosol, time_step)\naerosol = condensation_process.execute(aerosol, time_step)\naerosol = condensation_process.execute(aerosol, time_step)\nax.semilogx(aerosol.particles[0].get_radius()*1e9, aerosol.particles[0].concentration, label=\"After 5 steps\")\nplt.legend()\nax.set_xlabel(\"Radius (nm)\")\nax.set_ylabel(\"Concentration (1/m^3)\")\nplt.show()\n</pre> # define the condensation process condensation_isothermal = CondensationIsothermal(     molar_mass=molar_mass_glycerol,     diffusion_coefficient=2e-5,     accommodation_coefficient=0.1,  #makes things go slower/faster ) condensation_process = MassCondensation(condensation_strategy=condensation_isothermal)  # define the time array in seconds time_step = 0.5 time_array = np.arange(0, 10, time_step) total_mass = np.zeros_like(time_array)  # output arrays aerosol_sim = []  rate = condensation_process.rate(aerosol)  # print(f\"Inital rate: {rate[:5]}...\") # print(f\"Initial rate shape: {rate.shape}\")  fig, ax = plt.subplots(figsize=(8, 6)) ax.semilogx(aerosol.particles[0].get_radius()*1e9, aerosol.particles[0].concentration, label=\"Initial\") # singe step aerosol = condensation_process.execute(aerosol, time_step) ax.semilogx(aerosol.particles[0].get_radius()*1e9, aerosol.particles[0].concentration, label=\"After 1 step\") # second step aerosol = condensation_process.execute(aerosol, time_step) ax.semilogx(aerosol.particles[0].get_radius()*1e9, aerosol.particles[0].concentration, label=\"After 2 steps\") # 5th step aerosol = condensation_process.execute(aerosol, time_step) aerosol = condensation_process.execute(aerosol, time_step) aerosol = condensation_process.execute(aerosol, time_step) ax.semilogx(aerosol.particles[0].get_radius()*1e9, aerosol.particles[0].concentration, label=\"After 5 steps\") plt.legend() ax.set_xlabel(\"Radius (nm)\") ax.set_ylabel(\"Concentration (1/m^3)\") plt.show()"},{"location":"Tutorials/Dynamics/Condensation/Condensation_1_Bin/#condensation-tutorial-radius-bin","title":"Condensation Tutorial: Radius Bin\u00b6","text":"<p>Work in progress, probably split into multiple notebooks, need to find a model system to test this on</p> <p>Condensation, is the first process where this framework we have been building up is applied. Here we need to account for the gas phase, and the particle phase. Then ensure that the partial pressures of species at the surface of the particle are equal to the partial pressure in the gas.</p> <p>Core Concepts:</p> <ul> <li>Runnable: An abstract base class defining the interface for aerosol transformation processes.<ul> <li>Here and aerosol object is passed to the process, and the process is expected to modify the aerosol object in place, returning the modified object.</li> </ul> </li> <li>MassCondensation: A concrete class implementing the RunnableProcess interface for the condensation process. Is an implementation of a <code>Runnable</code> process that adds mass to the aerosol object based on the partial pressures of the gas phase and the particle phase. Then removes the mass from the gas phase.</li> </ul>"},{"location":"Tutorials/Dynamics/Condensation/Condensation_1_Bin/#setup-aerosol","title":"Setup Aerosol\u00b6","text":"<p>First we will repeat the aerosol object that we have been using in the previous notebooks. This object will be passed to the <code>Runnable</code> processes <code>MassCondensation</code>, and modified in place.</p>"},{"location":"Tutorials/Dynamics/Condensation/Condensation_1_Bin/#condensation-process-isothermal","title":"Condensation Process (Isothermal)\u00b6","text":"<p>In code this process is implemented as a <code>Runnable</code> process. This means that the process is expected to modify the aerosol object in place, returning the modified aerosol object. This is defined in <code>Particle_processes.py</code> as the <code>MassCondensation</code> class.</p> <p>The <code>MassCondensation</code> class takes a <code>CondensationStrategy</code> object as an input. This object defines and evaluates the $dm_{i}/dt$ equation for the condensation process. More strategies can be added into the <code>condensation.py</code> file.</p> <p>For now, let's just run it for a few time steps and see what happens.</p> <p>Note: We have a moving bin particle representation, so we would expect all the bins to move.</p>"},{"location":"Tutorials/Dynamics/Condensation/Condensation_1_Bin/#summary","title":"Summary\u00b6","text":"<p>We built out the condensation process, and the equations that define the process. We also defined the inputs and outputs of the process. Next we will build out coagulation and nucleation processes, to complete the aerosol dynamics framework.</p>"},{"location":"Tutorials/Dynamics/Condensation/Condensation_2_MassBin/","title":"Condensation Tutorial: Mass Binned","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# particula imports\nfrom particula import particles\nfrom particula.gas import AtmosphereBuilder, VaporPressureFactory, GasSpeciesBuilder\nfrom particula.aerosol import Aerosol\nfrom particula.dynamics.particle_process import MassCondensation\nfrom particula.dynamics.condensation.condensation_strategies import CondensationIsothermal\n</pre> import numpy as np import matplotlib.pyplot as plt  # particula imports from particula import particles from particula.gas import AtmosphereBuilder, VaporPressureFactory, GasSpeciesBuilder from particula.aerosol import Aerosol from particula.dynamics.particle_process import MassCondensation from particula.dynamics.condensation.condensation_strategies import CondensationIsothermal In\u00a0[2]: Copied! <pre># Ammonium sulfate and water vapor pressure\nmolar_mass_ammonium_sulfate = 132.14e-3  # kg/mol\nmolar_mass_water = 18.015e-3  # kg/mol\nparameters_vapor = {\n    \"vapor_pressure\": 1e-20,\n}\nvapor_pressure_ammonium = VaporPressureFactory().get_strategy(\n    \"constant\", parameters_vapor\n)\nvapor_pressure_water = VaporPressureFactory().get_strategy(\n    \"water_buck\"\n)\n\nwater_sat = vapor_pressure_water.saturation_concentration(molar_mass=molar_mass_water, temperature=298.15)\nwater_concentration = 0.8 * water_sat\n\nglycerol_gas = (\n    GasSpeciesBuilder()\n    .set_molar_mass(np.array([molar_mass_water, molar_mass_ammonium_sulfate]), \"kg/mol\")\n    .set_vapor_pressure_strategy([vapor_pressure_water, vapor_pressure_ammonium])\n    .set_concentration(np.array([water_concentration, 0.0]), \"kg/m^3\")\n    .set_name([\"H2O\", \"NH4HSO4\"])\n    .set_condensable([True, True])\n    .build()\n)\n\natmosphere = (\n    AtmosphereBuilder()\n    .add_species(glycerol_gas)\n    .set_temperature(25, temperature_units=\"degC\")\n    .set_pressure(1, pressure_units=\"atm\")\n    .build()\n)\n</pre> # Ammonium sulfate and water vapor pressure molar_mass_ammonium_sulfate = 132.14e-3  # kg/mol molar_mass_water = 18.015e-3  # kg/mol parameters_vapor = {     \"vapor_pressure\": 1e-20, } vapor_pressure_ammonium = VaporPressureFactory().get_strategy(     \"constant\", parameters_vapor ) vapor_pressure_water = VaporPressureFactory().get_strategy(     \"water_buck\" )  water_sat = vapor_pressure_water.saturation_concentration(molar_mass=molar_mass_water, temperature=298.15) water_concentration = 0.8 * water_sat  glycerol_gas = (     GasSpeciesBuilder()     .set_molar_mass(np.array([molar_mass_water, molar_mass_ammonium_sulfate]), \"kg/mol\")     .set_vapor_pressure_strategy([vapor_pressure_water, vapor_pressure_ammonium])     .set_concentration(np.array([water_concentration, 0.0]), \"kg/m^3\")     .set_name([\"H2O\", \"NH4HSO4\"])     .set_condensable([True, True])     .build() )  atmosphere = (     AtmosphereBuilder()     .add_species(glycerol_gas)     .set_temperature(25, temperature_units=\"degC\")     .set_pressure(1, pressure_units=\"atm\")     .build() )    <p>Sample Distribution</p> <p>Next we'll sample the distribution to get a set of particles. We'll then build an aerosol object to represent the aerosol population.</p> In\u00a0[3]: Copied! <pre># sample\nparticles_sample = particles.properties.lognormal_sample_distribution(\n    mode=np.array([100, 1000])*1e-9,\n    geometric_standard_deviation=np.array([1.3, 1.5]),\n    number_of_particles=np.array([1e3, 1e2]),\n    number_of_samples=1000,\n)\n\n# histogram lognormal\nbins_lognormal = np.logspace(-8, -4, 100)\nbins, edges = np.histogram(particles_sample, bins=bins_lognormal, density=True)\n# plot\nfig, ax = plt.subplots(figsize=(8, 6))\nax.bar(edges[:-1], bins, width=np.diff(edges), align=\"edge\")\nax.set_xscale(\"log\")\nax.set_xlabel(\"Diameter (m)\")\nax.set_ylabel(\"Count\")\nplt.show()\n</pre> # sample particles_sample = particles.properties.lognormal_sample_distribution(     mode=np.array([100, 1000])*1e-9,     geometric_standard_deviation=np.array([1.3, 1.5]),     number_of_particles=np.array([1e3, 1e2]),     number_of_samples=1000, )  # histogram lognormal bins_lognormal = np.logspace(-8, -4, 100) bins, edges = np.histogram(particles_sample, bins=bins_lognormal, density=True) # plot fig, ax = plt.subplots(figsize=(8, 6)) ax.bar(edges[:-1], bins, width=np.diff(edges), align=\"edge\") ax.set_xscale(\"log\") ax.set_xlabel(\"Diameter (m)\") ax.set_ylabel(\"Count\") plt.show() In\u00a0[4]: Copied! <pre># particle radis to mass\ndensity = 1.26e3  # kg/m^3\nparticle_mass = density * 4 / 3 * np.pi * particles_sample ** 3\nmass_speciation = np.array([particle_mass*0, particle_mass]).T  # water, ammonium sulfate\nconcentration = np.ones_like(particles_sample) * 1e1\ndensities = np.array([1000, 1.26e3])  # kg/m^3\n\nprint(mass_speciation.shape)\n\nactivity_strat = (\n    particles.ActivityKappaParameterBuilder()\n    .set_density(densities)\n    .set_kappa(np.array([0.0, 0.61]))\n    .set_molar_mass(np.array([molar_mass_water, molar_mass_ammonium_sulfate]))\n    .set_water_index(0)\n    .build()\n)\n\nsurface_strat = (\n    particles.SurfaceStrategyVolumeBuilder()\n    .set_density(densities)\n    .set_surface_tension(np.array([0.072, 0.092]))\n    .build()\n)\n\nparitcle_rep = (\n    particles.ParticleMassRepresentationBuilder()\n    .set_distribution_strategy(particles.SpeciatedMassMovingBinBuilder().build())\n    .set_surface_strategy(surface_strat)\n    .set_activity_strategy(activity_strat)\n    .set_density(densities)\n    .set_charge(0.0)\n    .set_mass(mass_speciation)\n    .set_concentration(concentration, \"1/cm^3\")\n    .build()\n)\n\naerosol = Aerosol(atmosphere=atmosphere, particles=paritcle_rep)\n\nprint(aerosol)\n</pre> # particle radis to mass density = 1.26e3  # kg/m^3 particle_mass = density * 4 / 3 * np.pi * particles_sample ** 3 mass_speciation = np.array([particle_mass*0, particle_mass]).T  # water, ammonium sulfate concentration = np.ones_like(particles_sample) * 1e1 densities = np.array([1000, 1.26e3])  # kg/m^3  print(mass_speciation.shape)  activity_strat = (     particles.ActivityKappaParameterBuilder()     .set_density(densities)     .set_kappa(np.array([0.0, 0.61]))     .set_molar_mass(np.array([molar_mass_water, molar_mass_ammonium_sulfate]))     .set_water_index(0)     .build() )  surface_strat = (     particles.SurfaceStrategyVolumeBuilder()     .set_density(densities)     .set_surface_tension(np.array([0.072, 0.092]))     .build() )  paritcle_rep = (     particles.ParticleMassRepresentationBuilder()     .set_distribution_strategy(particles.SpeciatedMassMovingBinBuilder().build())     .set_surface_strategy(surface_strat)     .set_activity_strategy(activity_strat)     .set_density(densities)     .set_charge(0.0)     .set_mass(mass_speciation)     .set_concentration(concentration, \"1/cm^3\")     .build() )  aerosol = Aerosol(atmosphere=atmosphere, particles=paritcle_rep)  print(aerosol) <pre>(1000, 2)\nGas mixture at 298.15 K and 101325.0 Pa consisting of [\"['H2O', 'NH4HSO4']\"]\n[0]: Particle Representation:\n\tStrategy: SpeciatedMassMovingBin\n\tActivity: ActivityKappaParameter\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 9.586e-06 [kg/m^3]\n\tNumber Concentration: 1.000e+10 [#/m^3]\n</pre> In\u00a0[5]: Copied! <pre># define the condensation process\ncondensation_isothermal = CondensationIsothermal(\n    molar_mass=np.array([molar_mass_water, molar_mass_ammonium_sulfate]),  # kg/mol\n    accommodation_coefficient=0.1,  #makes things go slower/faster\n    update_gases=False,\n)\ncondensation_process = MassCondensation(condensation_strategy=condensation_isothermal)\n\n# define the time array in seconds\ntime_step = 11\nsub_steps = 10000\ntime_array = np.arange(0, 5, time_step)\ntotal_mass = np.zeros_like(time_array)\n\n# output arrays\naerosol_sim = []\n\n\nfig, ax = plt.subplots(figsize=(8, 6))\nbins, edges = np.histogram(\n    aerosol.particles[0].get_radius(), bins=bins_lognormal\n)\nax.bar(edges[:-1], bins, width=np.diff(edges), align=\"edge\", label=\"Initial\")\n\nprint(aerosol)\n# one step\naerosol = condensation_process.execute(aerosol, time_step, sub_steps)\nbins, edges = np.histogram(\n    aerosol.particles[0].get_radius(), bins=bins_lognormal\n)\nax.bar(edges[:-1], bins, width=np.diff(edges), align=\"edge\", label=\"After 1 step\", alpha=0.8)\n\nprint(aerosol)\n# 10 seconds\naerosol = condensation_process.execute(aerosol, time_step, sub_steps)\nbins, edges = np.histogram(\n    aerosol.particles[0].get_radius(), bins=bins_lognormal\n)\nax.bar(edges[:-1], bins, width=np.diff(edges), align=\"edge\", label=\"After 2 steps\", alpha=0.7)\nprint(aerosol)\n\nax.set_xscale(\"log\")\n# ax.set_yscale(\"log\")\nplt.legend()\nax.set_xlabel(\"Radius (m)\")\nax.set_ylabel(\"Concentration (1/m^3)\")\nplt.show()\n</pre> # define the condensation process condensation_isothermal = CondensationIsothermal(     molar_mass=np.array([molar_mass_water, molar_mass_ammonium_sulfate]),  # kg/mol     accommodation_coefficient=0.1,  #makes things go slower/faster     update_gases=False, ) condensation_process = MassCondensation(condensation_strategy=condensation_isothermal)  # define the time array in seconds time_step = 11 sub_steps = 10000 time_array = np.arange(0, 5, time_step) total_mass = np.zeros_like(time_array)  # output arrays aerosol_sim = []   fig, ax = plt.subplots(figsize=(8, 6)) bins, edges = np.histogram(     aerosol.particles[0].get_radius(), bins=bins_lognormal ) ax.bar(edges[:-1], bins, width=np.diff(edges), align=\"edge\", label=\"Initial\")  print(aerosol) # one step aerosol = condensation_process.execute(aerosol, time_step, sub_steps) bins, edges = np.histogram(     aerosol.particles[0].get_radius(), bins=bins_lognormal ) ax.bar(edges[:-1], bins, width=np.diff(edges), align=\"edge\", label=\"After 1 step\", alpha=0.8)  print(aerosol) # 10 seconds aerosol = condensation_process.execute(aerosol, time_step, sub_steps) bins, edges = np.histogram(     aerosol.particles[0].get_radius(), bins=bins_lognormal ) ax.bar(edges[:-1], bins, width=np.diff(edges), align=\"edge\", label=\"After 2 steps\", alpha=0.7) print(aerosol)  ax.set_xscale(\"log\") # ax.set_yscale(\"log\") plt.legend() ax.set_xlabel(\"Radius (m)\") ax.set_ylabel(\"Concentration (1/m^3)\") plt.show() <pre>Gas mixture at 298.15 K and 101325.0 Pa consisting of [\"['H2O', 'NH4HSO4']\"]\n[0]: Particle Representation:\n\tStrategy: SpeciatedMassMovingBin\n\tActivity: ActivityKappaParameter\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 9.586e-06 [kg/m^3]\n\tNumber Concentration: 1.000e+10 [#/m^3]\nGas mixture at 298.15 K and 101325.0 Pa consisting of [\"['H2O', 'NH4HSO4']\"]\n[0]: Particle Representation:\n\tStrategy: SpeciatedMassMovingBin\n\tActivity: ActivityKappaParameter\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 2.808e-05 [kg/m^3]\n\tNumber Concentration: 1.000e+10 [#/m^3]\nGas mixture at 298.15 K and 101325.0 Pa consisting of [\"['H2O', 'NH4HSO4']\"]\n[0]: Particle Representation:\n\tStrategy: SpeciatedMassMovingBin\n\tActivity: ActivityKappaParameter\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 2.808e-05 [kg/m^3]\n\tNumber Concentration: 1.000e+10 [#/m^3]\n</pre>"},{"location":"Tutorials/Dynamics/Condensation/Condensation_2_MassBin/#condensation-tutorial-mass-binned","title":"Condensation Tutorial: Mass Binned\u00b6","text":"<p>NEEDS REVISION: integration unstable</p> <p>A mass binned model is relaxes the assumption of a single composition for all particles in a given bin. Instead, it allows for a distribution of compositions within each bin. This is useful when the composition of particles is separated by masses. This does not account for the same sized particles having different compositions, but rather different sized particles having different compositions.</p>"},{"location":"Tutorials/Dynamics/Condensation/Condensation_2_MassBin/#aerosol-setup","title":"Aerosol Setup\u00b6","text":"<p>First we'll draw from a lognormal distribution to create a set of particles. We'll will then build an aerosol object to represent the aerosol population.</p>"},{"location":"Tutorials/Dynamics/Condensation/Condensation_2_MassBin/#condensation-process","title":"Condensation Process\u00b6","text":"<p>Using the same iso thermal condensation process as in the bulk model, we'll update the properties of the particles in the aerosol object. In this cas we will change the water saturation ratio to be 80% and simulate the condensation process.</p>"},{"location":"Tutorials/Dynamics/Condensation/Condensation_2_MassBin/#summary","title":"Summary\u00b6","text":"<p>We built out the condensation process, and the equations that define the process. We also defined the inputs and outputs of the process. Next we will build out coagulation and nucleation processes, to complete the aerosol dynamics framework.</p>"},{"location":"Tutorials/Dynamics/Condensation/Condensation_3_MassResolved/","title":"Condensation Tutorial: Particle Resolved","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# particula imports\nfrom particula import particles\nfrom particula.gas import AtmosphereBuilder, VaporPressureFactory, GasSpeciesBuilder\nfrom particula.aerosol import Aerosol\nfrom particula.dynamics.particle_process import MassCondensation\nfrom particula.dynamics.condensation.condensation_strategies import CondensationIsothermal\n\nfrom particula.util.input_handling import convert_units\n</pre> import numpy as np import matplotlib.pyplot as plt  # particula imports from particula import particles from particula.gas import AtmosphereBuilder, VaporPressureFactory, GasSpeciesBuilder from particula.aerosol import Aerosol from particula.dynamics.particle_process import MassCondensation from particula.dynamics.condensation.condensation_strategies import CondensationIsothermal  from particula.util.input_handling import convert_units In\u00a0[2]: Copied! <pre>initial_water_vapor_activity = 1.025  # Relative humidity/100\n\n# Ammonium sulfate and water vapor pressure\nmolar_mass_ammonium_sulfate = 132.14e-3  # kg/mol\nmolar_mass_water = 18.015e-3  # kg/mol\nparameters_vapor = {\n    \"vapor_pressure\": 1e-24,\n}\nvapor_pressure_ammonium = VaporPressureFactory().get_strategy(\n    \"constant\", parameters_vapor\n)\nvapor_pressure_water = VaporPressureFactory().get_strategy(\n    \"water_buck\"\n)\n\nwater_sat = vapor_pressure_water.saturation_concentration(molar_mass=molar_mass_water, temperature=298.15)\nwater_concentration = water_sat * initial_water_vapor_activity\n\ngas_phase = (\n    GasSpeciesBuilder()\n    .set_molar_mass(np.array([molar_mass_water, molar_mass_ammonium_sulfate]), \"kg/mol\")\n    .set_vapor_pressure_strategy([vapor_pressure_water, vapor_pressure_ammonium])\n    .set_concentration(np.array([water_concentration, 1e-30]), \"kg/m^3\")\n    .set_name([\"H2O\", \"NH4HSO4\"])\n    .set_condensable([True, True])\n    .build()\n)\n\natmosphere = (\n    AtmosphereBuilder()\n    .add_species(gas_phase)\n    .set_temperature(25, temperature_units=\"degC\")\n    .set_pressure(1, pressure_units=\"atm\")\n    .build()\n)\n</pre> initial_water_vapor_activity = 1.025  # Relative humidity/100  # Ammonium sulfate and water vapor pressure molar_mass_ammonium_sulfate = 132.14e-3  # kg/mol molar_mass_water = 18.015e-3  # kg/mol parameters_vapor = {     \"vapor_pressure\": 1e-24, } vapor_pressure_ammonium = VaporPressureFactory().get_strategy(     \"constant\", parameters_vapor ) vapor_pressure_water = VaporPressureFactory().get_strategy(     \"water_buck\" )  water_sat = vapor_pressure_water.saturation_concentration(molar_mass=molar_mass_water, temperature=298.15) water_concentration = water_sat * initial_water_vapor_activity  gas_phase = (     GasSpeciesBuilder()     .set_molar_mass(np.array([molar_mass_water, molar_mass_ammonium_sulfate]), \"kg/mol\")     .set_vapor_pressure_strategy([vapor_pressure_water, vapor_pressure_ammonium])     .set_concentration(np.array([water_concentration, 1e-30]), \"kg/m^3\")     .set_name([\"H2O\", \"NH4HSO4\"])     .set_condensable([True, True])     .build() )  atmosphere = (     AtmosphereBuilder()     .add_species(gas_phase)     .set_temperature(25, temperature_units=\"degC\")     .set_pressure(1, pressure_units=\"atm\")     .build() )  <p>Sample Distribution</p> <p>Next we'll sample the distribution to get a set of particles. We'll then build an aerosol object to represent the aerosol population.</p> In\u00a0[3]: Copied! <pre>density = 1.77e3  # kg/m^3\nvolume_sim = 1 * convert_units(\"cm^3\", \"m^3\")  # m^3\nnumber_of_samples = 10_000\n\n# Generate a particle distribution using a lognormal sample distribution\n# This distribution has a mean particle diameter (mode) and geometric standard deviation (GSD)\nparticle_sample = particles.properties.lognormal_sample_distribution(\n    mode=np.array([100, 400]) * 1e-9,\n    geometric_standard_deviation=np.array([1.3, 1.4]),\n    number_of_particles=np.array([1, 0.5]),  # relative to each mode\n    number_of_samples=number_of_samples,  # Number of samples for particle distribution\n)\n\n# Calculate the mass of each particle in the sample, assuming density of 1500 kg/m^3\nparticle_mass = (\n    4 / 3 * np.pi * particle_sample**3 * density\n)  # Particle mass in kg\n\nmass_speciation = np.column_stack(\n    [particle_mass * 0, particle_mass]\n)  # water, ammonium sulfate\ndensities = np.array([1000, density])  # kg/m^3\n\n# kappa activity\nactivity_strat = (\n    particles.ActivityKappaParameterBuilder()\n    .set_density(densities)\n    .set_kappa(np.array([0.0, 0.61]))\n    .set_molar_mass(np.array([molar_mass_water, molar_mass_ammonium_sulfate]))\n    .set_water_index(0)\n    .build()\n)\n\nsurface_strat = (\n    particles.SurfaceStrategyVolumeBuilder()\n    .set_density(densities)\n    .set_surface_tension(np.array([0.072, 0.092]))\n    .build()\n)\n\n\n# Build a resolved mass representation for each particle\n# This defines how particle mass, activity, and surface are represented\nresolved_masses = (\n    particles.ResolvedParticleMassRepresentationBuilder()\n    .set_distribution_strategy(\n        particles.ParticleResolvedSpeciatedMass()\n    )  # Use speciated mass distribution\n    .set_activity_strategy(\n        activity_strat\n    )  # Define activity based on ideal mass\n    .set_surface_strategy(\n        surface_strat\n    )  # Define surface area based on particle volume\n    .set_mass(mass_speciation, \"kg\")  # Assign mass of particles (in kg)\n    .set_density(densities, \"kg/m^3\")  # Set particle density to 1500 kg/m^3\n    .set_charge(0)  # Assume neutral particles with no charge\n    .set_volume(volume_sim)  # Set volume of particle distribution\n    .build()  # Finalize the resolved mass representation\n)\n\n# Create an aerosol object with the defined atmosphere and resolved particles\naerosol_resolved = Aerosol(atmosphere=atmosphere, particles=resolved_masses)\n\n# Print the properties of the atmosphere\nprint(aerosol_resolved)\n</pre> density = 1.77e3  # kg/m^3 volume_sim = 1 * convert_units(\"cm^3\", \"m^3\")  # m^3 number_of_samples = 10_000  # Generate a particle distribution using a lognormal sample distribution # This distribution has a mean particle diameter (mode) and geometric standard deviation (GSD) particle_sample = particles.properties.lognormal_sample_distribution(     mode=np.array([100, 400]) * 1e-9,     geometric_standard_deviation=np.array([1.3, 1.4]),     number_of_particles=np.array([1, 0.5]),  # relative to each mode     number_of_samples=number_of_samples,  # Number of samples for particle distribution )  # Calculate the mass of each particle in the sample, assuming density of 1500 kg/m^3 particle_mass = (     4 / 3 * np.pi * particle_sample**3 * density )  # Particle mass in kg  mass_speciation = np.column_stack(     [particle_mass * 0, particle_mass] )  # water, ammonium sulfate densities = np.array([1000, density])  # kg/m^3  # kappa activity activity_strat = (     particles.ActivityKappaParameterBuilder()     .set_density(densities)     .set_kappa(np.array([0.0, 0.61]))     .set_molar_mass(np.array([molar_mass_water, molar_mass_ammonium_sulfate]))     .set_water_index(0)     .build() )  surface_strat = (     particles.SurfaceStrategyVolumeBuilder()     .set_density(densities)     .set_surface_tension(np.array([0.072, 0.092]))     .build() )   # Build a resolved mass representation for each particle # This defines how particle mass, activity, and surface are represented resolved_masses = (     particles.ResolvedParticleMassRepresentationBuilder()     .set_distribution_strategy(         particles.ParticleResolvedSpeciatedMass()     )  # Use speciated mass distribution     .set_activity_strategy(         activity_strat     )  # Define activity based on ideal mass     .set_surface_strategy(         surface_strat     )  # Define surface area based on particle volume     .set_mass(mass_speciation, \"kg\")  # Assign mass of particles (in kg)     .set_density(densities, \"kg/m^3\")  # Set particle density to 1500 kg/m^3     .set_charge(0)  # Assume neutral particles with no charge     .set_volume(volume_sim)  # Set volume of particle distribution     .build()  # Finalize the resolved mass representation )  # Create an aerosol object with the defined atmosphere and resolved particles aerosol_resolved = Aerosol(atmosphere=atmosphere, particles=resolved_masses)  # Print the properties of the atmosphere print(aerosol_resolved) <pre>Gas mixture at 298.15 K and 101325.0 Pa consisting of [\"['H2O', 'NH4HSO4']\"]\n[0]: Particle Representation:\n\tStrategy: ParticleResolvedSpeciatedMass\n\tActivity: ActivityKappaParameter\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 2.667e-06 [kg/m^3]\n\tNumber Concentration: 1.000e+10 [#/m^3]\n</pre> In\u00a0[4]: Copied! <pre># define the condensation process\ncondensation_isothermal = CondensationIsothermal(\n    molar_mass=np.array(\n        [molar_mass_water, molar_mass_ammonium_sulfate]\n    ),  # kg/mol\n    diffusion_coefficient=2e-5,  # m^2/s\n    accommodation_coefficient=1,  # makes things go slower/faster\n    update_gases=True,\n)\ncondensation_process = MassCondensation(\n    condensation_strategy=condensation_isothermal\n)\n\n# Set up time and sub-steps for the coagulation process\ntotal_time = 10\ntime_step = 0.01\nsub_steps = 10\n\n# bins\nbins_lognormal = np.logspace(-8, -4, 200)\n\n\n# output arrays\ntime = np.arange(0, total_time, time_step)\ntotal_mass_resolved = np.ones_like(time, dtype=np.float64)\nnumber_distribution_resolved = np.zeros((len(time), number_of_samples))\nnumber_distribution_binned = np.zeros((len(time), len(bins_lognormal) - 1))\ntotal_number_resolved = np.ones_like(time, dtype=np.float64)\nwater_saturation_in_time = np.ones_like(time, dtype=np.float64)\n\nprint(f\"Total iterations to do: {len(time)*sub_steps}\")\n</pre> # define the condensation process condensation_isothermal = CondensationIsothermal(     molar_mass=np.array(         [molar_mass_water, molar_mass_ammonium_sulfate]     ),  # kg/mol     diffusion_coefficient=2e-5,  # m^2/s     accommodation_coefficient=1,  # makes things go slower/faster     update_gases=True, ) condensation_process = MassCondensation(     condensation_strategy=condensation_isothermal )  # Set up time and sub-steps for the coagulation process total_time = 10 time_step = 0.01 sub_steps = 10  # bins bins_lognormal = np.logspace(-8, -4, 200)   # output arrays time = np.arange(0, total_time, time_step) total_mass_resolved = np.ones_like(time, dtype=np.float64) number_distribution_resolved = np.zeros((len(time), number_of_samples)) number_distribution_binned = np.zeros((len(time), len(bins_lognormal) - 1)) total_number_resolved = np.ones_like(time, dtype=np.float64) water_saturation_in_time = np.ones_like(time, dtype=np.float64)  print(f\"Total iterations to do: {len(time)*sub_steps}\") <pre>Total iterations to do: 10000\n</pre> In\u00a0[5]: Copied! <pre># Simulation loop\nfor i, t in enumerate(time):\n    if i &gt; 0:\n        # Perform condensation for the resolved aerosol\n        aerosol_resolved = condensation_process.execute(aerosol_resolved, time_step, sub_steps)\n\n    total_mass_resolved[i] = aerosol_resolved.particles[0].get_mass_concentration()\n    number_distribution_resolved[i, :] = aerosol_resolved.particles[0].get_radius(clone=True)\n    number_distribution_binned[i, :], edges = np.histogram(number_distribution_resolved[i, :], bins=bins_lognormal)\n    total_number_resolved[i] = np.sum(number_distribution_resolved[i, :]&gt;0)\n    water_saturation_in_time[i] = aerosol_resolved.atmosphere.species[0].get_saturation_ratio(\n        temperature=298.15)[0]\n\n\nnumber_distribution_binned = number_distribution_binned / volume_sim\n\nprint(aerosol_resolved)\n</pre> # Simulation loop for i, t in enumerate(time):     if i &gt; 0:         # Perform condensation for the resolved aerosol         aerosol_resolved = condensation_process.execute(aerosol_resolved, time_step, sub_steps)      total_mass_resolved[i] = aerosol_resolved.particles[0].get_mass_concentration()     number_distribution_resolved[i, :] = aerosol_resolved.particles[0].get_radius(clone=True)     number_distribution_binned[i, :], edges = np.histogram(number_distribution_resolved[i, :], bins=bins_lognormal)     total_number_resolved[i] = np.sum(number_distribution_resolved[i, :]&gt;0)     water_saturation_in_time[i] = aerosol_resolved.atmosphere.species[0].get_saturation_ratio(         temperature=298.15)[0]   number_distribution_binned = number_distribution_binned / volume_sim  print(aerosol_resolved) <pre>Gas mixture at 298.15 K and 101325.0 Pa consisting of [\"['H2O', 'NH4HSO4']\"]\n[0]: Particle Representation:\n\tStrategy: ParticleResolvedSpeciatedMass\n\tActivity: ActivityKappaParameter\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 6.032e-04 [kg/m^3]\n\tNumber Concentration: 1.000e+10 [#/m^3]\n</pre> In\u00a0[6]: Copied! <pre># plot the initial and final distributions\nfig, ax = plt.subplots(figsize=(8, 5))\n\nax.bar(\n    edges[:-1],\n    number_distribution_binned[0, :],\n    width=np.diff(edges),\n    align=\"edge\",\n    label=\"Resolved initial\",\n    color=\"red\",\n    alpha=0.7,\n)\nplot_index = 100\nax.bar(\n    edges[:-1],\n    number_distribution_binned[plot_index, :],\n    width=np.diff(edges),\n    align=\"edge\",\n    label=\"CCN overshoot time: {:.1f} s\".format(time[plot_index]),\n    color=\"purple\",\n    alpha=0.5,\n)\nax.bar(\n    edges[:-1],\n    number_distribution_binned[-1, :],\n    width=np.diff(edges),\n    align=\"edge\",\n    label=\"Resolved final\",\n    color=\"blue\",\n    alpha=0.7,\n)\nax.set_yscale(\"log\")\nax.set_xscale(\"log\")\nax.set_xlabel(\"Particle radius (m)\")\nax.set_ylabel(\"Number concentration (m^-3)\")\nax.legend()\nplt.show()\n</pre> # plot the initial and final distributions fig, ax = plt.subplots(figsize=(8, 5))  ax.bar(     edges[:-1],     number_distribution_binned[0, :],     width=np.diff(edges),     align=\"edge\",     label=\"Resolved initial\",     color=\"red\",     alpha=0.7, ) plot_index = 100 ax.bar(     edges[:-1],     number_distribution_binned[plot_index, :],     width=np.diff(edges),     align=\"edge\",     label=\"CCN overshoot time: {:.1f} s\".format(time[plot_index]),     color=\"purple\",     alpha=0.5, ) ax.bar(     edges[:-1],     number_distribution_binned[-1, :],     width=np.diff(edges),     align=\"edge\",     label=\"Resolved final\",     color=\"blue\",     alpha=0.7, ) ax.set_yscale(\"log\") ax.set_xscale(\"log\") ax.set_xlabel(\"Particle radius (m)\") ax.set_ylabel(\"Number concentration (m^-3)\") ax.legend() plt.show() In\u00a0[7]: Copied! <pre>fig, ax = plt.subplots(figsize=(8, 5))\n\n# Swap X and Y to reverse axes\nX, Y = np.meshgrid(\n    time, edges[:-1]\n)  # Now time is on the x-axis and edges on the y-axis\n\n# Plot the contour with updated X and Y\nlog_of_number_distribution_binned = np.log10(\n    number_distribution_binned,\n    out=np.nan * np.ones_like(number_distribution_binned),\n    where=number_distribution_binned &gt; 0\n)\ncontour = ax.contourf(\n    X, Y, log_of_number_distribution_binned.T, cmap=\"viridis\", vmin=5,\n)\n\n# Add the color bar\ncbar = fig.colorbar(contour)\ncbar.set_label(\"Log10 of Number concentration (m^-3)\")\n\nax.set_ylim([1e-8, 1e-5])  # Set limits for y-axis\n\n# Set axis labels\nax.set_yscale(\"log\")  # Log scale for particle radius on y-axis\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(\"Particle radius (m)\")\nfig.tight_layout()\nplt.show()\n</pre> fig, ax = plt.subplots(figsize=(8, 5))  # Swap X and Y to reverse axes X, Y = np.meshgrid(     time, edges[:-1] )  # Now time is on the x-axis and edges on the y-axis  # Plot the contour with updated X and Y log_of_number_distribution_binned = np.log10(     number_distribution_binned,     out=np.nan * np.ones_like(number_distribution_binned),     where=number_distribution_binned &gt; 0 ) contour = ax.contourf(     X, Y, log_of_number_distribution_binned.T, cmap=\"viridis\", vmin=5, )  # Add the color bar cbar = fig.colorbar(contour) cbar.set_label(\"Log10 of Number concentration (m^-3)\")  ax.set_ylim([1e-8, 1e-5])  # Set limits for y-axis  # Set axis labels ax.set_yscale(\"log\")  # Log scale for particle radius on y-axis ax.set_xlabel(\"Time (s)\") ax.set_ylabel(\"Particle radius (m)\") fig.tight_layout() plt.show() In\u00a0[8]: Copied! <pre># plot the total mass and water saturation on twin y-axis\nfig, ax1 = plt.subplots(figsize=(8, 5))\n\nax1.plot(time, total_mass_resolved, label=\"Total mass\", color=\"blue\")\nax1.set_xlabel(\"Time (s)\")\nax1.set_ylabel(\"Total Particle mass (kg/m^3)\", color=\"blue\")\nax1.tick_params(axis=\"y\", labelcolor=\"blue\")\n\nax2 = ax1.twinx()\nax2.plot(time, water_saturation_in_time, label=\"Water saturation\", color=\"red\")\nax2.set_ylabel(\"Water saturation\", color=\"red\")\nax2.tick_params(axis=\"y\", labelcolor=\"red\")\n\nfig.tight_layout()\nplt.show()\n</pre> # plot the total mass and water saturation on twin y-axis fig, ax1 = plt.subplots(figsize=(8, 5))  ax1.plot(time, total_mass_resolved, label=\"Total mass\", color=\"blue\") ax1.set_xlabel(\"Time (s)\") ax1.set_ylabel(\"Total Particle mass (kg/m^3)\", color=\"blue\") ax1.tick_params(axis=\"y\", labelcolor=\"blue\")  ax2 = ax1.twinx() ax2.plot(time, water_saturation_in_time, label=\"Water saturation\", color=\"red\") ax2.set_ylabel(\"Water saturation\", color=\"red\") ax2.tick_params(axis=\"y\", labelcolor=\"red\")  fig.tight_layout() plt.show()"},{"location":"Tutorials/Dynamics/Condensation/Condensation_3_MassResolved/#condensation-tutorial-particle-resolved","title":"Condensation Tutorial: Particle Resolved\u00b6","text":"<p>A particle resolved model is a model that tracks the properties of individual particles or collection of particles (e.g., super droplets). This is in contrast to a bulk model, which tracks the properties of the entire aerosol population. The particle resolved model can be more computationally expensive, but can provide more detailed information about the aerosol population.</p> <p>To run this type of model we will need to use a speciated distribution representation. This is so that we can track the properties of individual particles.</p>"},{"location":"Tutorials/Dynamics/Condensation/Condensation_3_MassResolved/#setup-aerosol","title":"Setup Aerosol\u00b6","text":"<p>First we'll draw from a lognormal distribution to create a set of particles. We'll will then build an aerosol object to represent the aerosol population.</p>"},{"location":"Tutorials/Dynamics/Condensation/Condensation_3_MassResolved/#condensation-process","title":"Condensation Process\u00b6","text":"<p>Using the same iso thermal condensation process we now setup the particle resolved simulation. We'll track the properties of each particle as they grow.</p>"},{"location":"Tutorials/Dynamics/Condensation/Condensation_3_MassResolved/#visualization","title":"Visualization\u00b6","text":"<p>Finally we'll visualize the results of the simulation. The first plot is a histogram of the particle size distribution. The second plot is 2D distribution plot vs time. Third is our limiting varible of water vapor saturation ratio, and the mass transferred to the particles.</p>"},{"location":"Tutorials/Dynamics/Condensation/Condensation_3_MassResolved/#summary","title":"Summary\u00b6","text":"<p>This tutorial demonstrates how to run a particle resolved model. We performed a cloud condensation simulation and visualized the results. We can see once the aerosol particles activate there is a redistribution of water vapor to the larger particles as the smaller ones are out of equilibrium and evaporate.</p>"},{"location":"Tutorials/Dynamics/Customization/Adding_Particles_During_Simulation/","title":"Adding Particles During Simulation","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# particula imports\nfrom particula import particles\nfrom particula.aerosol import Aerosol\nfrom particula.gas import PresetGasSpeciesBuilder, AtmosphereBuilder\n</pre> import numpy as np import matplotlib.pyplot as plt  # particula imports from particula import particles from particula.aerosol import Aerosol from particula.gas import PresetGasSpeciesBuilder, AtmosphereBuilder In\u00a0[2]: Copied! <pre># Preset gas species that does not condense in the atmosphere\n# AtmosphereBuilder constructs the atmosphere with predefined species\natmosphere = (\n    AtmosphereBuilder()\n    .add_species(PresetGasSpeciesBuilder().build())  # Add a preset gas species\n    .set_temperature(25, temperature_units=\"degC\")  # Set temperature to 25\u00b0C\n    .set_pressure(1, pressure_units=\"atm\")  # Set pressure to 1 atmosphere\n    .build()  # Finalize the atmosphere object\n)\n\n# Generate a particle distribution using a lognormal sample distribution\n# This distribution has a mean particle diameter (mode) and geometric standard deviation (GSD)\nparticle_sample = particles.properties.lognormal_sample_distribution(\n    mode=np.array([100e-9]),  # Mean particle diameter of 100 nm\n    geometric_standard_deviation=np.array([1.3]),  # GSD of 1.3\n    number_of_particles=np.array([1e4]),  # Total number of particles\n    number_of_samples=100_000,  # Number of samples for particle distribution\n)\n\n# Calculate the mass of each particle in the sample, assuming density of 1500 kg/m^3\nparticle_mass_sample = (\n    4 / 3 * np.pi * particle_sample**3 * 1500\n)  # Particle mass in kg\n\n# Build a resolved mass representation for each particle\n# This defines how particle mass, activity, and surface are represented\nresolved_masses = (\n    particles.ResolvedParticleMassRepresentationBuilder()\n    .set_distribution_strategy(particles.ParticleResolvedSpeciatedMass())  # Use speciated mass distribution\n    .set_activity_strategy(particles.ActivityIdealMass())  # Define activity based on ideal mass\n    .set_surface_strategy(particles.SurfaceStrategyVolume())  # Define surface area based on particle volume\n    .set_mass(particle_mass_sample, \"kg\")  # Assign mass of particles (in kg)\n    .set_density(1500, \"kg/m^3\")  # Set particle density to 1500 kg/m^3\n    .set_charge(0)  # Assume neutral particles with no charge\n    .set_volume(1, \"cm^3\")  # Set volume of particle distribution\n    .build()  # Finalize the resolved mass representation\n)\n\n# Create an aerosol object with the defined atmosphere and resolved particles\naerosol = Aerosol(atmosphere=atmosphere, particles=resolved_masses)\n\n# Print the properties of the atmosphere\nprint(aerosol)\n</pre> # Preset gas species that does not condense in the atmosphere # AtmosphereBuilder constructs the atmosphere with predefined species atmosphere = (     AtmosphereBuilder()     .add_species(PresetGasSpeciesBuilder().build())  # Add a preset gas species     .set_temperature(25, temperature_units=\"degC\")  # Set temperature to 25\u00b0C     .set_pressure(1, pressure_units=\"atm\")  # Set pressure to 1 atmosphere     .build()  # Finalize the atmosphere object )  # Generate a particle distribution using a lognormal sample distribution # This distribution has a mean particle diameter (mode) and geometric standard deviation (GSD) particle_sample = particles.properties.lognormal_sample_distribution(     mode=np.array([100e-9]),  # Mean particle diameter of 100 nm     geometric_standard_deviation=np.array([1.3]),  # GSD of 1.3     number_of_particles=np.array([1e4]),  # Total number of particles     number_of_samples=100_000,  # Number of samples for particle distribution )  # Calculate the mass of each particle in the sample, assuming density of 1500 kg/m^3 particle_mass_sample = (     4 / 3 * np.pi * particle_sample**3 * 1500 )  # Particle mass in kg  # Build a resolved mass representation for each particle # This defines how particle mass, activity, and surface are represented resolved_masses = (     particles.ResolvedParticleMassRepresentationBuilder()     .set_distribution_strategy(particles.ParticleResolvedSpeciatedMass())  # Use speciated mass distribution     .set_activity_strategy(particles.ActivityIdealMass())  # Define activity based on ideal mass     .set_surface_strategy(particles.SurfaceStrategyVolume())  # Define surface area based on particle volume     .set_mass(particle_mass_sample, \"kg\")  # Assign mass of particles (in kg)     .set_density(1500, \"kg/m^3\")  # Set particle density to 1500 kg/m^3     .set_charge(0)  # Assume neutral particles with no charge     .set_volume(1, \"cm^3\")  # Set volume of particle distribution     .build()  # Finalize the resolved mass representation )  # Create an aerosol object with the defined atmosphere and resolved particles aerosol = Aerosol(atmosphere=atmosphere, particles=resolved_masses)  # Print the properties of the atmosphere print(aerosol) <pre>Gas mixture at 298.15 K and 101325.0 Pa consisting of ['Preset100']\n[0]: Particle Representation:\n\tStrategy: ParticleResolvedSpeciatedMass\n\tActivity: ActivityIdealMass\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 8.599e-07 [kg/m^3]\n\tNumber Concentration: 1.000e+11 [#/m^3]\n</pre> In\u00a0[3]: Copied! <pre># particles to add\n\n# Generate a particle distribution using a lognormal sample distribution\n# This distribution has a mean particle diameter (mode) and geometric standard deviation (GSD)\nparticles_to_add = particles.properties.lognormal_sample_distribution(\n    mode=np.array([1e-9]),  # Mean particle diameter of 100 nm\n    geometric_standard_deviation=np.array([1.1]),  # GSD of 1.3\n    number_of_particles=np.array([1e4]),  # Total number of particles\n    number_of_samples=10_000,  # Number of samples for particle distribution\n)\n\n# Calculate the mass of each particle in the sample, assuming density of 1500 kg/m^3\nparticle_mass_add = (\n    4 / 3 * np.pi * particles_to_add**3 * 1500\n)  # Particle mass in kg\nconcentration_add = np.ones_like(particle_mass_add)\n\n\n# print shapes\nprint(f\"Particles to add: {particle_mass_add.shape}\")\n</pre> # particles to add  # Generate a particle distribution using a lognormal sample distribution # This distribution has a mean particle diameter (mode) and geometric standard deviation (GSD) particles_to_add = particles.properties.lognormal_sample_distribution(     mode=np.array([1e-9]),  # Mean particle diameter of 100 nm     geometric_standard_deviation=np.array([1.1]),  # GSD of 1.3     number_of_particles=np.array([1e4]),  # Total number of particles     number_of_samples=10_000,  # Number of samples for particle distribution )  # Calculate the mass of each particle in the sample, assuming density of 1500 kg/m^3 particle_mass_add = (     4 / 3 * np.pi * particles_to_add**3 * 1500 )  # Particle mass in kg concentration_add = np.ones_like(particle_mass_add)   # print shapes print(f\"Particles to add: {particle_mass_add.shape}\")  <pre>Particles to add: (10000,)\n</pre> In\u00a0[\u00a0]: Copied! <pre># Get initial particle radii before adding particle\ninitial_radii = aerosol.particles[0].get_radius(clone=True)\nprint(f\"Initial concentration: {aerosol.particles[0].get_total_concentration()}\")\n\n# Perform the add process\naerosol.particles[0].add_concentration(  # select the particle representation and call add_concentration\n    added_concentration=concentration_add,\n    added_distribution=particle_mass_add,\n)\nradii_after_step_1 = aerosol.particles[0].get_radius(clone=True)\nprint(f\"Concentration after step 1: {aerosol.particles[0].get_total_concentration()}\")\n\n# Perform the add process\naerosol.particles[0].add_concentration(\n    added_concentration=concentration_add,\n    added_distribution=particle_mass_add,\n)\nradii_after_step_2 = aerosol.particles[0].get_radius(clone=True)\n\nprint(f\"Concentration after step 2: {aerosol.particles[0].get_total_concentration()}\")\nconcentration_value = aerosol.particles[0].concentration\n</pre> # Get initial particle radii before adding particle initial_radii = aerosol.particles[0].get_radius(clone=True) print(f\"Initial concentration: {aerosol.particles[0].get_total_concentration()}\")  # Perform the add process aerosol.particles[0].add_concentration(  # select the particle representation and call add_concentration     added_concentration=concentration_add,     added_distribution=particle_mass_add, ) radii_after_step_1 = aerosol.particles[0].get_radius(clone=True) print(f\"Concentration after step 1: {aerosol.particles[0].get_total_concentration()}\")  # Perform the add process aerosol.particles[0].add_concentration(     added_concentration=concentration_add,     added_distribution=particle_mass_add, ) radii_after_step_2 = aerosol.particles[0].get_radius(clone=True)  print(f\"Concentration after step 2: {aerosol.particles[0].get_total_concentration()}\") concentration_value = aerosol.particles[0].concentration <pre>Initial concentration: 99999999999.99998\nConcentration after step 1: 109999999999.99998\nConcentration after step 2: 119999999999.99998\n</pre> In\u00a0[5]: Copied! <pre># Define lognormal bins for particle radius histogram\nbins_lognormal = np.logspace(-10, -6, 100)\n\n# Create figure for visualizing the histogram of particle radii\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Plot radii distribution after step 2\nbins, edges = np.histogram(radii_after_step_2, bins=bins_lognormal)\nax.bar(\n    edges[:-1],\n    bins,\n    width=np.diff(edges),\n    align=\"edge\",\n    label=\"After 2 steps\",\n    alpha=0.6,\n)\n# Plot radii distribution after step 1\n\nbins, edges = np.histogram(radii_after_step_1, bins=bins_lognormal)\nax.bar(\n    edges[:-1],\n    bins,\n    width=np.diff(edges),\n    align=\"edge\",\n    label=\"After 1 step\",\n    alpha=0.5,\n)\n\n# Plot initial radii distribution\nbins, edges = np.histogram(initial_radii, bins=bins_lognormal)\nax.bar(\n    edges[:-1],\n    bins,\n    width=np.diff(edges),\n    align=\"edge\",\n    label=\"Initial\",\n    alpha=0.4,\n    edgecolor=\"black\")\n\n# Set axes to logarithmic scale for x-axis (particle radius)\nax.set_xscale(\"log\")\nax.set_yscale(\"log\")\n\n# Add labels and legend\nax.set_xlabel(\"Radius (m)\")\nax.set_ylabel(\"Number of particles\")\nplt.legend()\n\n# Show the plot\nplt.show()\n</pre> # Define lognormal bins for particle radius histogram bins_lognormal = np.logspace(-10, -6, 100)  # Create figure for visualizing the histogram of particle radii fig, ax = plt.subplots(figsize=(8, 6))  # Plot radii distribution after step 2 bins, edges = np.histogram(radii_after_step_2, bins=bins_lognormal) ax.bar(     edges[:-1],     bins,     width=np.diff(edges),     align=\"edge\",     label=\"After 2 steps\",     alpha=0.6, ) # Plot radii distribution after step 1  bins, edges = np.histogram(radii_after_step_1, bins=bins_lognormal) ax.bar(     edges[:-1],     bins,     width=np.diff(edges),     align=\"edge\",     label=\"After 1 step\",     alpha=0.5, )  # Plot initial radii distribution bins, edges = np.histogram(initial_radii, bins=bins_lognormal) ax.bar(     edges[:-1],     bins,     width=np.diff(edges),     align=\"edge\",     label=\"Initial\",     alpha=0.4,     edgecolor=\"black\")  # Set axes to logarithmic scale for x-axis (particle radius) ax.set_xscale(\"log\") ax.set_yscale(\"log\")  # Add labels and legend ax.set_xlabel(\"Radius (m)\") ax.set_ylabel(\"Number of particles\") plt.legend()  # Show the plot plt.show()"},{"location":"Tutorials/Dynamics/Customization/Adding_Particles_During_Simulation/#adding-particles-during-simulation","title":"Adding Particles During Simulation\u00b6","text":"<p>In this tutorial, we demonstrate how add particles to an aerosol object. This is useful when you want to modify a custom aerosol process during a simulation.</p> <p>The example is for a particle resolved simulation, the same approach can be used for the other types of particle representations (but it has not been tested yet).</p> <p>Imports</p>"},{"location":"Tutorials/Dynamics/Customization/Adding_Particles_During_Simulation/#aerosol-setup","title":"Aerosol Setup\u00b6","text":"<p>We need to first make the aerosol object. Details on this can be found in the Aerosol Tutorial.</p>"},{"location":"Tutorials/Dynamics/Customization/Adding_Particles_During_Simulation/#particles-to-add","title":"Particles to Add\u00b6","text":"<p>For the particle resolved representation, the particles to add must be the provide an array of new particle masses and the concentrations.</p> <p>Currently the concentrations should all be one, as this is the particle resolved representation.</p> <p>If you have multiple species, then the shape of the <code>added_distribution</code> should be <code>(number of particles, number of species)</code>. But <code>added_concentration</code> is still <code>(number of particles,)</code>.</p>"},{"location":"Tutorials/Dynamics/Customization/Adding_Particles_During_Simulation/#graphing","title":"Graphing\u00b6","text":"<p>We now visualize the two particle add steps</p>"},{"location":"Tutorials/Dynamics/Customization/Adding_Particles_During_Simulation/#conclusion","title":"Conclusion\u00b6","text":"<p>We have demonstrated how to add particles to an aerosol object. This is useful when you want to modify a aerosol object with a custom process during a simulation.</p>"},{"location":"Tutorials/Gas_Phase/","title":"Gas Phase","text":""},{"location":"Tutorials/Gas_Phase/#notebooks","title":"Notebooks","text":"<ul> <li>Vapor Pressure Tutorial</li> <li>Gas Species Tutorial</li> <li>Atmosphere Tutorial</li> </ul>"},{"location":"Tutorials/Gas_Phase/Notebooks/AtmosphereTutorial/","title":"Atmosphere Tutorial","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# From particula\nfrom particula.gas import AtmosphereBuilder, VaporPressureFactory, GasSpeciesBuilder\n# from particula.gas.vapor_pressure_factories import VaporPressureFactory\n# from particula.gas.species_builders import GasSpeciesBuilder\n</pre> import numpy as np import matplotlib.pyplot as plt  # From particula from particula.gas import AtmosphereBuilder, VaporPressureFactory, GasSpeciesBuilder # from particula.gas.vapor_pressure_factories import VaporPressureFactory # from particula.gas.species_builders import GasSpeciesBuilder In\u00a0[2]: Copied! <pre># Define the coefficients for Butanol using the Antoine equation.\nbutanol_coefficients = {'a': 7.838, 'b': 1558.19, 'c': 196.881}\nbutanol_antione = VaporPressureFactory().get_strategy(\n    'antoine', butanol_coefficients)\nstyrene_coefficients = {'a': 6.924, 'b': 1420, 'c': 226}\nstyrene_antione = VaporPressureFactory().get_strategy(\n    'antoine', styrene_coefficients)\n\n# Water uses a different model for vapor pressure calculation called the Buck equation.\nwater_buck = VaporPressureFactory().get_strategy(\n    'water_buck')\n\n# Create the GasSpecies using the GasSpeciesBuilder\n# water species\nwater_species = (\n    GasSpeciesBuilder()\n    .set_name(\"water\")\n    .set_molar_mass(18.01528e-3)\n    .set_vapor_pressure_strategy(water_buck)\n    .set_condensable(True)\n    .set_concentration(1e-3)\n    .build()\n)\n\n# organic species\norganic_molar_mass = np.array([0.074121, 104.15e-3])\norganic_vapor_pressure = [butanol_antione, styrene_antione]\norganic_concentration = np.array([2e-6, 1e-9])\norganic_names = np.array([\"butanol\", \"styrene\"])\norganic_species = (\n    GasSpeciesBuilder()\n    .set_name(organic_names)\n    .set_molar_mass(organic_molar_mass)\n    .set_vapor_pressure_strategy(organic_vapor_pressure)\n    .set_condensable(True)\n    .set_concentration(organic_concentration)\n    .build()\n)\n\n# Print the species\nprint(water_species)\nprint(organic_species)\n</pre>  # Define the coefficients for Butanol using the Antoine equation. butanol_coefficients = {'a': 7.838, 'b': 1558.19, 'c': 196.881} butanol_antione = VaporPressureFactory().get_strategy(     'antoine', butanol_coefficients) styrene_coefficients = {'a': 6.924, 'b': 1420, 'c': 226} styrene_antione = VaporPressureFactory().get_strategy(     'antoine', styrene_coefficients)  # Water uses a different model for vapor pressure calculation called the Buck equation. water_buck = VaporPressureFactory().get_strategy(     'water_buck')  # Create the GasSpecies using the GasSpeciesBuilder # water species water_species = (     GasSpeciesBuilder()     .set_name(\"water\")     .set_molar_mass(18.01528e-3)     .set_vapor_pressure_strategy(water_buck)     .set_condensable(True)     .set_concentration(1e-3)     .build() )  # organic species organic_molar_mass = np.array([0.074121, 104.15e-3]) organic_vapor_pressure = [butanol_antione, styrene_antione] organic_concentration = np.array([2e-6, 1e-9]) organic_names = np.array([\"butanol\", \"styrene\"]) organic_species = (     GasSpeciesBuilder()     .set_name(organic_names)     .set_molar_mass(organic_molar_mass)     .set_vapor_pressure_strategy(organic_vapor_pressure)     .set_condensable(True)     .set_concentration(organic_concentration)     .build() )  # Print the species print(water_species) print(organic_species) <pre>water\n['butanol' 'styrene']\n</pre> In\u00a0[3]: Copied! <pre>gas_mixture = (\n    AtmosphereBuilder()\n    .add_species(water_species)\n    .add_species(organic_species)\n    .set_temperature(25, temperature_units='degC')\n    .set_pressure(1, pressure_units='atm')\n    .build()\n)\n\nprint('Notice the units conversion to base SI:')\nprint(gas_mixture)\n</pre> gas_mixture = (     AtmosphereBuilder()     .add_species(water_species)     .add_species(organic_species)     .set_temperature(25, temperature_units='degC')     .set_pressure(1, pressure_units='atm')     .build() )  print('Notice the units conversion to base SI:') print(gas_mixture) <pre>Notice the units conversion to base SI:\nGas mixture at 298.15 K and 101325.0 Pa consisting of ['water', \"['butanol' 'styrene']\"]\n</pre> In\u00a0[4]: Copied! <pre># Constants for calculations\nsea_level_pressure = 101325  # Reference pressure at sea level (Pa)\nsea_level_temperature = 330  # Reference temperature at sea level (K)\ngravity = 9.80665  # Acceleration due to gravity (m/s^2)\nmolar_mass_air = 0.0289644  # Molar mass of Earth's air (kg/mol)\nuniversal_gas_constant = 8.314    # Universal gas constant (J/(mol\u00b7K))\ntemperature_lapse_rate = 0.0065   # Standard temperature lapse rate (K/m)\n\n# Generate an array of altitudes from sea level (0 meters) to 10 km (10000 meters), divided into 100 intervals\naltitude_range = np.linspace(0, 10000, 100)\n\n# Calculate the temperature at each altitude based on the linear temperature lapse rate\ntemperature_at_altitudes = sea_level_temperature - temperature_lapse_rate * altitude_range\n\n# Calculate the pressure at each altitude using the barometric formula\npressure_at_altitudes = sea_level_pressure * (\n    (1 - temperature_lapse_rate * altitude_range / sea_level_temperature)\n    ** (gravity * molar_mass_air / (universal_gas_constant * temperature_lapse_rate)))\n\n\n# Initialize a matrix to hold saturation ratios for each species at each\n# altitude\nsaturation_ratio = np.zeros(len(altitude_range))\n\n# Loop over each altitude's temperature and pressure\nfor index, (temperature, pressure) in enumerate(zip(temperature_at_altitudes, pressure_at_altitudes)):\n    # Set the current temperature and pressure of the gas mixture\n    gas_mixture.temperature = temperature\n    gas_mixture.total_pressure = pressure\n\n    # Loop over water\n    saturation_ratio[index] = gas_mixture.species[0].get_saturation_ratio(gas_mixture.temperature)\n\n\n# Plot the saturation ratio of water vapor at each altitude\nfig, ax = plt.subplots()\nax.plot(saturation_ratio, altitude_range, label='Water')\nax.set_xscale('log')\nax.set_ylabel('Altitude (m)')\nax.set_xlabel('Water Saturation Ratio')\nax.set_title('Saturation Ratio of Water Vapor at Different Altitudes')\nax.legend()\nplt.show()\n</pre> # Constants for calculations sea_level_pressure = 101325  # Reference pressure at sea level (Pa) sea_level_temperature = 330  # Reference temperature at sea level (K) gravity = 9.80665  # Acceleration due to gravity (m/s^2) molar_mass_air = 0.0289644  # Molar mass of Earth's air (kg/mol) universal_gas_constant = 8.314    # Universal gas constant (J/(mol\u00b7K)) temperature_lapse_rate = 0.0065   # Standard temperature lapse rate (K/m)  # Generate an array of altitudes from sea level (0 meters) to 10 km (10000 meters), divided into 100 intervals altitude_range = np.linspace(0, 10000, 100)  # Calculate the temperature at each altitude based on the linear temperature lapse rate temperature_at_altitudes = sea_level_temperature - temperature_lapse_rate * altitude_range  # Calculate the pressure at each altitude using the barometric formula pressure_at_altitudes = sea_level_pressure * (     (1 - temperature_lapse_rate * altitude_range / sea_level_temperature)     ** (gravity * molar_mass_air / (universal_gas_constant * temperature_lapse_rate)))   # Initialize a matrix to hold saturation ratios for each species at each # altitude saturation_ratio = np.zeros(len(altitude_range))  # Loop over each altitude's temperature and pressure for index, (temperature, pressure) in enumerate(zip(temperature_at_altitudes, pressure_at_altitudes)):     # Set the current temperature and pressure of the gas mixture     gas_mixture.temperature = temperature     gas_mixture.total_pressure = pressure      # Loop over water     saturation_ratio[index] = gas_mixture.species[0].get_saturation_ratio(gas_mixture.temperature)   # Plot the saturation ratio of water vapor at each altitude fig, ax = plt.subplots() ax.plot(saturation_ratio, altitude_range, label='Water') ax.set_xscale('log') ax.set_ylabel('Altitude (m)') ax.set_xlabel('Water Saturation Ratio') ax.set_title('Saturation Ratio of Water Vapor at Different Altitudes') ax.legend() plt.show()"},{"location":"Tutorials/Gas_Phase/Notebooks/AtmosphereTutorial/#atmosphere-tutorial","title":"Atmosphere Tutorial\u00b6","text":"<p>Gases, alongside particles, constitute the essential components of an aerosol system. In their natural state, gases are collections of molecules that move freely, not bound to one another. We introduce the <code>Atmosphere</code> class, a composite that encapsolate <code>GasSpecies</code>, with addition parameters for the atmospheric state.</p> <ul> <li><code>Atmosphere</code>: This class represents the atmospheric environment by detailing properties such as temperature and pressure, alongside a dynamic list of gas species present.</li> <li><code>AtmosphericBuilder</code>: A builder class that simplifies the creation of <code>Atmosphere</code> objects.</li> </ul> <p>We'll continue with our organics and water example, combining the two into a single <code>Atmosphere</code> object.</p>"},{"location":"Tutorials/Gas_Phase/Notebooks/AtmosphereTutorial/#build-gas-species","title":"Build Gas Species\u00b6","text":"<p>First we will build the, <code>GasSpecies</code> objects for the organics and water. Following the same procedure from previously in <code>Gas Species</code>.</p>"},{"location":"Tutorials/Gas_Phase/Notebooks/AtmosphereTutorial/#atmosphere-builder","title":"Atmosphere Builder\u00b6","text":"<p>The <code>AtmosphereBuilder</code> class is a builder class that simplifies the creation of <code>Atmosphere</code> objects. It provides a fluent interface for adding <code>GasSpecies</code> objects to the <code>Atmosphere</code> object. We will use it to build the <code>Atmosphere</code> object for the organics and water. The builder requries the following parameters:</p> <ul> <li><code>pressure</code>: The total pressure of the gas mixture, in Pascals, or provided pressure_units string for conversion.</li> <li><code>temperature</code>: The temperature of the gas mixture, in Kelvin, or provided temperature_units string for conversion.</li> <li><code>species</code>: A list of <code>GasSpecies</code> objects, representing the gases in the mixture. This can be added one by one using the <code>add_species</code> method.</li> </ul>"},{"location":"Tutorials/Gas_Phase/Notebooks/AtmosphereTutorial/#air","title":"Air\u00b6","text":"<p>Air is assumed to be the non-specified component of the gas mixture, making up the remainder of the gas mixture. We do not explicitly add air to the gas mixture, but it is implicitly included in most calculations.</p>"},{"location":"Tutorials/Gas_Phase/Notebooks/AtmosphereTutorial/#iterating-over-gas-species","title":"Iterating Over Gas Species\u00b6","text":"<p>Once the <code>Gas</code> object has been established, it enables us to iterate over each <code>GasSpecies</code> within the mixture. This functionality is particularly valuable for evaluating and adjusting properties dynamically, such as when changes in temperature and pressure occur due to environmental alterations.</p>"},{"location":"Tutorials/Gas_Phase/Notebooks/AtmosphereTutorial/#practical-example-altitude-impact","title":"Practical Example: Altitude Impact\u00b6","text":"<p>Consider a scenario where our gas mixture is transported from sea level to an altitude of 10 kilometers. Such a change in altitude significantly impacts both temperature and pressure, which in turn affects the behavior of each gas species in the mixture.</p>"},{"location":"Tutorials/Gas_Phase/Notebooks/AtmosphereTutorial/#geopotential-height-equation","title":"Geopotential Height Equation\u00b6","text":"<p>The pressure and temperature changes with altitude can be approximated by using the geopotential height equation. Here's how you can calculate these changes:</p> <ol> <li>Pressure Change: The pressure at a given altitude can be estimated by:</li> </ol> <p>$$    P = P_0 \\left(1 - \\frac{L \\cdot h}{T_0}\\right)^{\\frac{g \\cdot M}{R \\cdot L}} $$</p> <p>where:</p> <ul> <li>$ P $ is the pressure at altitude $ h $,</li> <li>$ P_0 $ is the reference pressure at sea level (101325 Pa),</li> <li>$ L $ is the standard temperature lapse rate (approximately 0.0065 K/m),</li> <li>$ h $ is the altitude in meters (10000 m for 10 km),</li> <li>$ T_0 $ is the reference temperature at sea level (288.15 K),</li> <li>$ g $ is the acceleration due to gravity (9.80665 m/s\u00b2),</li> <li>$ M $ is the molar mass of Earth's air (0.0289644 kg/mol),</li> <li>$ R $ is the universal gas constant (8.314 J/(mol\u00b7K)).</li> </ul> <ol> <li><p>Temperature Change: The temperature decreases linearly with altitude at the lapse rate $ L $:</p> <p>$$ T = T_0 - L h $$</p> <p>Using this formula, we can estimate the temperature at an altitude of 10 km:</p> <ul> <li>$T$ = 288.15 K</li> <li>$L$ 0.0065 K/m</li> <li>$h$ = 10000 m</li> </ul> </li> </ol>"},{"location":"Tutorials/Gas_Phase/Notebooks/AtmosphereTutorial/#application","title":"Application\u00b6","text":"<p>By iterating through each <code>GasSpecies</code>, we can apply these formulas to adjust their properties based on the calculated pressure and temperature at 10 km altitude, aiding in simulations or real-world applications where altitude plays a crucial role in gas behavior.</p>"},{"location":"Tutorials/Gas_Phase/Notebooks/AtmosphereTutorial/#summary","title":"Summary\u00b6","text":"<p>In this notebook, we learned how to create an <code>Atmosphere</code> object using the <code>AtmosphereBuilder</code> class. We also explored how to iterate over each <code>GasSpecies</code> within the mixture, enabling us to adjust properties dynamically based on environmental changes. This functionality is particularly useful for simulating real-world scenarios where temperature and pressure variations significantly impact gas behavior.</p> <p>We now need to build the particle representation, so that combined with the <code>Atmosphere</code>, we can create an aerosol system.</p>"},{"location":"Tutorials/Gas_Phase/Notebooks/Gas_Species/","title":"Gas Species Tutorial","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# Particula imports\nfrom particula.gas import VaporPressureFactory, GasSpeciesBuilder\n</pre> import numpy as np import matplotlib.pyplot as plt  # Particula imports from particula.gas import VaporPressureFactory, GasSpeciesBuilder In\u00a0[2]: Copied! <pre># Define the coefficients for Butanol using the Antoine equation.\n# 'a', 'b', and 'c' are coefficients specific to the Antoine equation used to calculate vapor pressure.\nbutanol_coefficients = {'a': 7.838, 'b': 1558.19, 'c': 196.881}\n# Create a vapor pressure strategy for Butanol using the Antoine equation.\nbutanol_antione = VaporPressureFactory().get_strategy(\n    strategy_type='antoine', parameters=butanol_coefficients)\n\n# Define the coefficients for Styrene, similar to Butanol, using the\n# Antoine equation.\nstyrene_coefficients = {'a': 6.924, 'b': 1420, 'c': 226}\n# Create a vapor pressure strategy for Styrene using the Antoine equation.\nstyrene_antione = VaporPressureFactory().get_strategy(\n    strategy_type='antoine', parameters=styrene_coefficients)\n\n# Water uses a different model for vapor pressure calculation called the Buck equation.\n# The Buck equation is particularly suited for water vapor calculations.\n# No additional parameters are required to be passed for the Buck equation\n# in this instance.\nwater_buck = VaporPressureFactory().get_strategy(\n    strategy_type='water_buck')\n</pre> # Define the coefficients for Butanol using the Antoine equation. # 'a', 'b', and 'c' are coefficients specific to the Antoine equation used to calculate vapor pressure. butanol_coefficients = {'a': 7.838, 'b': 1558.19, 'c': 196.881} # Create a vapor pressure strategy for Butanol using the Antoine equation. butanol_antione = VaporPressureFactory().get_strategy(     strategy_type='antoine', parameters=butanol_coefficients)  # Define the coefficients for Styrene, similar to Butanol, using the # Antoine equation. styrene_coefficients = {'a': 6.924, 'b': 1420, 'c': 226} # Create a vapor pressure strategy for Styrene using the Antoine equation. styrene_antione = VaporPressureFactory().get_strategy(     strategy_type='antoine', parameters=styrene_coefficients)  # Water uses a different model for vapor pressure calculation called the Buck equation. # The Buck equation is particularly suited for water vapor calculations. # No additional parameters are required to be passed for the Buck equation # in this instance. water_buck = VaporPressureFactory().get_strategy(     strategy_type='water_buck') In\u00a0[3]: Copied! <pre># Configure the builder with the necessary properties\nwater_species = (\n    GasSpeciesBuilder()\n    .set_name(\"Water\")\n    .set_molar_mass(18.01528, molar_mass_units=\"g/mol\")\n    .set_vapor_pressure_strategy(water_buck)\n    .set_condensable(True)\n    .set_concentration(1e2, concentration_units=\"ug/m^3\")\n    .build()\n)\n\n\n# molar mass in kg/mol, concentration in kg/m3\n\nprint(water_species)\nprint(f\"Notice the units of the concentration are now in kg/m^3: {water_species.concentration}\")\nprint(f\"Also the units of the molar mass are now in kg/mol: {water_species.molar_mass}\")\n</pre> # Configure the builder with the necessary properties water_species = (     GasSpeciesBuilder()     .set_name(\"Water\")     .set_molar_mass(18.01528, molar_mass_units=\"g/mol\")     .set_vapor_pressure_strategy(water_buck)     .set_condensable(True)     .set_concentration(1e2, concentration_units=\"ug/m^3\")     .build() )   # molar mass in kg/mol, concentration in kg/m3  print(water_species) print(f\"Notice the units of the concentration are now in kg/m^3: {water_species.concentration}\") print(f\"Also the units of the molar mass are now in kg/mol: {water_species.molar_mass}\") <pre>Water\nNotice the units of the concentration are now in kg/m^3: 1.0000000000000001e-07\nAlso the units of the molar mass are now in kg/mol: 0.01801528\n</pre> In\u00a0[4]: Copied! <pre># Define molar masses for organic species (Butanol and Styrene) in kilograms per mole (kg/mol).\norganic_molar_mass = np.array([0.074121, 104.15e-3])  # Molar mass for Butanol and Styrene respectively.\n\n# List of vapor pressure strategies assigned to each organic species.\norganic_vapor_pressure = [butanol_antione, styrene_antione]  # Using Antoine's equation for both.\n\n# Define concentrations for each organic species in the mixture, in kilograms per cubic meter (kg/m^3).\norganic_concentration = np.array([2e-6, 1e-9])  # Concentration values for Butanol and Styrene respectively.\n\n# Names of the organic species.\norganic_names = np.array([\"butanol\", \"styrene\"])\n\n# Using GasSpeciesBuilder to construct a GasSpecies object for organics.\n# Notice how we can directly use arrays to set properties for multiple species.\norganic_species = (\n    GasSpeciesBuilder()\n    .set_name(organic_names)\n    .set_molar_mass(organic_molar_mass)\n    .set_vapor_pressure_strategy(organic_vapor_pressure)\n    .set_condensable([True, True])\n    .set_concentration(organic_concentration)\n    .build()\n)\n\n# The `build()` method validates all the properties are set and returns the constructed GasSpecies object(s).\n# Here, organic_species will contain the built GasSpecies instances for Butanol and Styrene.\nprint(organic_species)\n</pre> # Define molar masses for organic species (Butanol and Styrene) in kilograms per mole (kg/mol). organic_molar_mass = np.array([0.074121, 104.15e-3])  # Molar mass for Butanol and Styrene respectively.  # List of vapor pressure strategies assigned to each organic species. organic_vapor_pressure = [butanol_antione, styrene_antione]  # Using Antoine's equation for both.  # Define concentrations for each organic species in the mixture, in kilograms per cubic meter (kg/m^3). organic_concentration = np.array([2e-6, 1e-9])  # Concentration values for Butanol and Styrene respectively.  # Names of the organic species. organic_names = np.array([\"butanol\", \"styrene\"])  # Using GasSpeciesBuilder to construct a GasSpecies object for organics. # Notice how we can directly use arrays to set properties for multiple species. organic_species = (     GasSpeciesBuilder()     .set_name(organic_names)     .set_molar_mass(organic_molar_mass)     .set_vapor_pressure_strategy(organic_vapor_pressure)     .set_condensable([True, True])     .set_concentration(organic_concentration)     .build() )  # The `build()` method validates all the properties are set and returns the constructed GasSpecies object(s). # Here, organic_species will contain the built GasSpecies instances for Butanol and Styrene. print(organic_species) <pre>['butanol' 'styrene']\n</pre> In\u00a0[5]: Copied! <pre>temperature_range = np.linspace(273.15, 373.15, 100)  # Temperature range from 0 to 100 degrees Celsius.\n\norganic_pure_vapor_pressure = organic_species.get_pure_vapor_pressure(temperature_range)\nwater_pure_vapor_pressure = water_species.get_pure_vapor_pressure(temperature_range)\n\n# Plotting the vapor pressure curves for the organic species.\nfig, ax = plt.subplots(figsize=(8, 6))\nfor i in range(len(organic_names)):\n    ax.plot(temperature_range, organic_pure_vapor_pressure[i], label=organic_names[i])\nax.plot(temperature_range, water_pure_vapor_pressure, label=\"Water\")\nax.set_xlabel(\"Temperature (K)\")\nax.set_ylabel(\"Vapor Pressure (Pa)\")\nax.set_yscale('log')\nax.legend()\nplt.show()\n</pre> temperature_range = np.linspace(273.15, 373.15, 100)  # Temperature range from 0 to 100 degrees Celsius.  organic_pure_vapor_pressure = organic_species.get_pure_vapor_pressure(temperature_range) water_pure_vapor_pressure = water_species.get_pure_vapor_pressure(temperature_range)  # Plotting the vapor pressure curves for the organic species. fig, ax = plt.subplots(figsize=(8, 6)) for i in range(len(organic_names)):     ax.plot(temperature_range, organic_pure_vapor_pressure[i], label=organic_names[i]) ax.plot(temperature_range, water_pure_vapor_pressure, label=\"Water\") ax.set_xlabel(\"Temperature (K)\") ax.set_ylabel(\"Vapor Pressure (Pa)\") ax.set_yscale('log') ax.legend() plt.show() In\u00a0[6]: Copied! <pre># Saturation ratio calculation\norganic_saturation_ratio = organic_species.get_saturation_ratio(temperature_range)\nwater_saturation_ratio = water_species.get_saturation_ratio(temperature_range)\n\n# Plotting the saturation ratio curves for the organic species.\nfig, ax = plt.subplots(figsize=(8, 6))\nfor i in range(len(organic_names)):\n    ax.plot(temperature_range, organic_saturation_ratio[i], label=organic_names[i])\nax.plot(temperature_range, water_saturation_ratio, label=\"Water\")\nax.set_ylim(0, 5)\nax.set_xlabel(\"Temperature (K)\")\nax.set_ylabel(\"Saturation Ratio\")\nax.legend()\nplt.show()\n</pre> # Saturation ratio calculation organic_saturation_ratio = organic_species.get_saturation_ratio(temperature_range) water_saturation_ratio = water_species.get_saturation_ratio(temperature_range)  # Plotting the saturation ratio curves for the organic species. fig, ax = plt.subplots(figsize=(8, 6)) for i in range(len(organic_names)):     ax.plot(temperature_range, organic_saturation_ratio[i], label=organic_names[i]) ax.plot(temperature_range, water_saturation_ratio, label=\"Water\") ax.set_ylim(0, 5) ax.set_xlabel(\"Temperature (K)\") ax.set_ylabel(\"Saturation Ratio\") ax.legend() plt.show()"},{"location":"Tutorials/Gas_Phase/Notebooks/Gas_Species/#gas-species-tutorial","title":"Gas Species Tutorial\u00b6","text":"<p>The <code>GasSpecies</code> is a class that represents a gas species in a simulation or calculation. It includes properties such as the species' name, molar mass, vapor pressure, and whether it is condensable. The class provides methods to set and retrieve these properties, ensuring that each species is fully defined and manageable within simulations.</p> <p>In this notebook, we will demonstrate how to use the <code>GasSpecies</code> class to create and manage gas species. This includes creating new species, setting their properties, and retrieving vapor pressure, concentration, and other properties.</p>"},{"location":"Tutorials/Gas_Phase/Notebooks/Gas_Species/#key-classes","title":"Key Classes\u00b6","text":"<ul> <li><code>GasSpecies</code>: Represents a gas species in a simulation or calculation.</li> <li><code>GasSpeciesBuilder</code>: A builder class that constructs instances of <code>GasSpecies</code> with well-defined properties.</li> </ul>"},{"location":"Tutorials/Gas_Phase/Notebooks/Gas_Species/#define-vapor-pressure-strategies","title":"Define Vapor Pressure Strategies\u00b6","text":"<p>In this section, we'll focus on defining vapor pressure strategies for gas species, specifically Butanol, Styrene, and Water, which were used in our previous examples. To streamline our analysis, we will group Butanol and Styrene into a single organic category, and consider Water separately.</p>"},{"location":"Tutorials/Gas_Phase/Notebooks/Gas_Species/#strategy-assignment","title":"Strategy Assignment\u00b6","text":"<p>For calculating vapor pressures:</p> <ul> <li>Organics (Butanol and Styrene): We will utilize the Antoine equation, a widely recognized method for estimating the vapor pressure of organic compounds based on temperature.</li> <li>Water: We will apply the Buck equation, which is specifically tailored to accurately calculate the vapor pressure of water across a range of temperatures.</li> </ul>"},{"location":"Tutorials/Gas_Phase/Notebooks/Gas_Species/#using-gasspeciesbuilder-to-construct-gas-species","title":"Using <code>GasSpeciesBuilder</code> to Construct Gas Species\u00b6","text":"<p>Now that we have defined the appropriate vapor pressure strategies for our gas species, we can proceed to construct the individual species using the <code>GasSpeciesBuilder</code>. This builder simplifies the process of defining and validating the properties of each gas species before their creation. We'll begin with Water, as it involves a straightforward application of the Buck equation.</p>"},{"location":"Tutorials/Gas_Phase/Notebooks/Gas_Species/#building-the-water-gas-species","title":"Building the Water Gas Species\u00b6","text":"<p>The <code>GasSpeciesBuilder</code> facilitates a structured approach to setting up a gas species. To build a Water gas species, the builder requires the following properties to be set:</p> <ol> <li>Name: Identifies the species, which in this case is \"Water\".</li> <li>Molar Mass: The molar mass of water, essential for calculations involving mass and moles.</li> <li>Vapor Pressure Strategy: The specific strategy used to calculate vapor pressure; for Water, we use the Buck equation.</li> <li>Condensability: Indicates whether the species can condense under certain atmospheric conditions. For Water, this is typically true.</li> <li>Concentration: The initial concentration of Water in the mixture, which could vary based on the scenario.</li> </ol> <p>Here is how you can use the <code>GasSpeciesBuilder</code> to set up Water:</p>"},{"location":"Tutorials/Gas_Phase/Notebooks/Gas_Species/#building-gas-species-for-organics","title":"Building Gas Species for Organics\u00b6","text":"<p>Following Water, you can apply a similar process to build gas species for Organics like Butanol and Styrene. Each will have its set of properties based on the chemical's nature and the desired simulation context.</p> <p>When calling <code>.build()</code>, it checks that all required properties are set correctly, raising an error if any essential attribute is missing or improperly configured. This ensures that each <code>GasSpecies</code> instance is valid and ready usage.</p>"},{"location":"Tutorials/Gas_Phase/Notebooks/Gas_Species/#pure-vapor-pressures","title":"Pure Vapor Pressures\u00b6","text":"<p>With the gas species defined, we can now calculate the pure vapor pressures of Butanol, Styrene, and Water using the respective strategies we assigned earlier. This will help us understand the vapor pressure behavior of each species individually, which is crucial for predicting their behavior in mixtures and under varying conditions.</p>"},{"location":"Tutorials/Gas_Phase/Notebooks/Gas_Species/#saturation-ratios","title":"Saturation Ratios\u00b6","text":"<p>Now that we have established the concentration of each gas species within the mixture, we can proceed to calculate the saturation ratio for each species. The saturation ratio is an essential parameter in determining the condensation behavior of gas species within a mixture.</p> <ul> <li>Above 1: A saturation ratio greater than 1 indicates that the species is supersaturated and is likely to condense.</li> <li>Below 1: Conversely, a saturation ratio below 1 suggests that the species will likely remain in the gas phase.</li> </ul>"},{"location":"Tutorials/Gas_Phase/Notebooks/Gas_Species/#future-exploration","title":"Future Exploration\u00b6","text":"<p>In subsequent sections of this notebook series, we will delve deeper into how these saturation ratios reach equilibrium with a liquid phase, enhancing our understanding of the phase behavior under different conditions.</p>"},{"location":"Tutorials/Gas_Phase/Notebooks/Gas_Species/#summary","title":"Summary\u00b6","text":"<p>The <code>GasSpecies</code> module, along with the <code>GasSpeciesBuilder</code>, provides a robust framework for defining and managing gas species within a mixture. By assigning specific vapor pressure strategies and other essential properties, we can accurately model the behavior of individual species and their interactions in various scenarios. This module serves as a foundational component for more advanced simulations and analyses involving gas mixtures, condensation, and phase equilibrium.</p> <p>The next section is one more layer of abstraction, where we will define the <code>GasMixture</code> class to manage multiple gas species within a single mixture. This class will enable us to handle complex gas mixtures effectively and efficiently, paving the way particle to gas interactions.</p>"},{"location":"Tutorials/Gas_Phase/Notebooks/Vapor_Pressure/","title":"Vapor Pressure Tutorial","text":"In\u00a0[5]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# Import the functions from the particula package\nfrom particula.gas import AntoineVaporPressureStrategy, AntoineBuilder, VaporPressureFactory\n</pre> import numpy as np import matplotlib.pyplot as plt  # Import the functions from the particula package from particula.gas import AntoineVaporPressureStrategy, AntoineBuilder, VaporPressureFactory In\u00a0[6]: Copied! <pre># Direct instantiation of an AntoineVaporPressureStrategy for butanol.\n# This approach directly sets the coefficients 'a', 'b', and 'c' specific\n# to butanol for calculating its vapor pressure.\nbutanol_antione = AntoineVaporPressureStrategy(\n    a=7.838, b=1558.19, c=196.881)\n\n# Use the Builder pattern to create a vapor pressure strategy for styrene.\n# The Builder pattern allows for more flexible object creation by setting properties step-by-step.\n# This approach, also validates the input parameters and ensures the object is fully defined.\n# Here, coefficients are set individually using setter methods provided by\n# the AntoineBuilder.\nstyrene_coefficients = {'a': 6.924, 'b': 1420, 'c': 226}\nstyrene_antione = (\n    AntoineBuilder()\n    .set_a(styrene_coefficients['a'])\n    .set_b(styrene_coefficients['b'])\n    .set_c(styrene_coefficients['c'])\n    .build()\n)\n\n# Initialize a vapor pressure strategy for water using the factory method.\n# The factory method abstracts the creation logic of the builder and can instantiate different builder strategies based on the input strategy.\n# This approach ensures that object creation is centralized and consistent across the application.\n# Note: The strategy name provided to the factory method is case-insensitive.\nwater_coefficients = {'a': 7.949017, 'b': 1657.462, 'c': 227.02}\nwater_antione = VaporPressureFactory().get_strategy(\n    strategy_type='Antoine',\n    parameters=water_coefficients\n)\n\n\n# Calculate and print the vapor pressures at 300 Kelvin for each substance using the initialized strategies.\n# The function 'pure_vapor_pressure' is used here, which calculates the\n# vapor pressure based on the provided temperature.\n\nprint(f'Butanol Antoine vapor pressure at 300 K: {butanol_antione.pure_vapor_pressure(300)} Pa')\nprint(f'Styrene Antoine vapor pressure at 300 K: {styrene_antione.pure_vapor_pressure(300)} Pa')\nprint(f'Water Antoine vapor pressure at 300 K: {water_antione.pure_vapor_pressure(300)} Pa')\n</pre> # Direct instantiation of an AntoineVaporPressureStrategy for butanol. # This approach directly sets the coefficients 'a', 'b', and 'c' specific # to butanol for calculating its vapor pressure. butanol_antione = AntoineVaporPressureStrategy(     a=7.838, b=1558.19, c=196.881)  # Use the Builder pattern to create a vapor pressure strategy for styrene. # The Builder pattern allows for more flexible object creation by setting properties step-by-step. # This approach, also validates the input parameters and ensures the object is fully defined. # Here, coefficients are set individually using setter methods provided by # the AntoineBuilder. styrene_coefficients = {'a': 6.924, 'b': 1420, 'c': 226} styrene_antione = (     AntoineBuilder()     .set_a(styrene_coefficients['a'])     .set_b(styrene_coefficients['b'])     .set_c(styrene_coefficients['c'])     .build() )  # Initialize a vapor pressure strategy for water using the factory method. # The factory method abstracts the creation logic of the builder and can instantiate different builder strategies based on the input strategy. # This approach ensures that object creation is centralized and consistent across the application. # Note: The strategy name provided to the factory method is case-insensitive. water_coefficients = {'a': 7.949017, 'b': 1657.462, 'c': 227.02} water_antione = VaporPressureFactory().get_strategy(     strategy_type='Antoine',     parameters=water_coefficients )   # Calculate and print the vapor pressures at 300 Kelvin for each substance using the initialized strategies. # The function 'pure_vapor_pressure' is used here, which calculates the # vapor pressure based on the provided temperature.  print(f'Butanol Antoine vapor pressure at 300 K: {butanol_antione.pure_vapor_pressure(300)} Pa') print(f'Styrene Antoine vapor pressure at 300 K: {styrene_antione.pure_vapor_pressure(300)} Pa') print(f'Water Antoine vapor pressure at 300 K: {water_antione.pure_vapor_pressure(300)} Pa') <pre>Butanol Antoine vapor pressure at 300 K: 7.1170940952359955e-06 Pa\nStyrene Antoine vapor pressure at 300 K: 7.239588688753633e-11 Pa\nWater Antoine vapor pressure at 300 K: 2.305360971329159e-13 Pa\n</pre> In\u00a0[7]: Copied! <pre># failed build due to missing parameters\ntry:\n    styrene_fail = (\n        AntoineBuilder()\n        .set_a(styrene_coefficients['a'])\n        .build()\n    )\nexcept ValueError as e:\n    print(e)  # prints error message\n</pre> # failed build due to missing parameters try:     styrene_fail = (         AntoineBuilder()         .set_a(styrene_coefficients['a'])         .build()     ) except ValueError as e:     print(e)  # prints error message <pre>[ERROR|abc_builder|L130]: Required parameter(s) not set: b, c\n</pre> <pre>Required parameter(s) not set: b, c\n</pre> In\u00a0[8]: Copied! <pre># create a range of temperatures from 200 to 400 Kelvin\ntemperatures = np.linspace(300, 500, 100)\n\n# Calculate the vapor pressures for each substance at the range of temperatures.\nbutanol_vapor_pressure = butanol_antione.pure_vapor_pressure(temperatures)\nstyrene_vapor_pressure = styrene_antione.pure_vapor_pressure(temperatures)\nwater_vapor_pressure = water_antione.pure_vapor_pressure(temperatures)\n\n# Plot the vapor pressures for each substance.\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(temperatures, butanol_vapor_pressure, label='Butanol')\nax.plot(temperatures, styrene_vapor_pressure, label='Styrene', linestyle='--')\nax.plot(temperatures, water_vapor_pressure, label='Water', linestyle='-.')\nax.set_yscale('log')\nax.set_xlabel('Temperature (K)')\nax.set_ylabel('Pure Vapor Pressure (Pa)')\nax.set_title('Pure Vapor Pressure vs Temperature')\nax.legend()\nplt.show()\n</pre> # create a range of temperatures from 200 to 400 Kelvin temperatures = np.linspace(300, 500, 100)  # Calculate the vapor pressures for each substance at the range of temperatures. butanol_vapor_pressure = butanol_antione.pure_vapor_pressure(temperatures) styrene_vapor_pressure = styrene_antione.pure_vapor_pressure(temperatures) water_vapor_pressure = water_antione.pure_vapor_pressure(temperatures)  # Plot the vapor pressures for each substance. fig, ax = plt.subplots(figsize=(8, 6)) ax.plot(temperatures, butanol_vapor_pressure, label='Butanol') ax.plot(temperatures, styrene_vapor_pressure, label='Styrene', linestyle='--') ax.plot(temperatures, water_vapor_pressure, label='Water', linestyle='-.') ax.set_yscale('log') ax.set_xlabel('Temperature (K)') ax.set_ylabel('Pure Vapor Pressure (Pa)') ax.set_title('Pure Vapor Pressure vs Temperature') ax.legend() plt.show() In\u00a0[9]: Copied! <pre># Define the molar mass of each substance in kg/mol\nbutanol_molar_mass = 74.12e-3\nstyrene_molar_mass = 104.15e-3\nwater_molar_mass = 18.015e-3\n\n# calculate the concentration pressure vs temperature\nbutanol_saturation_concentration = butanol_antione.saturation_concentration(\n    molar_mass=butanol_molar_mass,\n    temperature=temperatures)\nstyrene_saturation_concentration = styrene_antione.saturation_concentration(\n    molar_mass=styrene_molar_mass,\n    temperature=temperatures)\nwater_saturation_concentration = water_antione.saturation_concentration(\n    molar_mass=water_molar_mass,\n    temperature=temperatures)\n\n# Plot the saturation concentrations for each substance.\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(temperatures, butanol_saturation_concentration, label='Butanol')\nax.plot(temperatures, styrene_saturation_concentration, label='Styrene', linestyle='--')\nax.plot(temperatures, water_saturation_concentration, label='Water', linestyle='-.')\nax.set_yscale('log')\nax.set_xlabel('Temperature (K)')\nax.set_ylabel('Saturation Concentration (kg/m^3)')\nax.set_title('Saturation Concentration vs Temperature')\nax.legend()\nplt.show()\n</pre> # Define the molar mass of each substance in kg/mol butanol_molar_mass = 74.12e-3 styrene_molar_mass = 104.15e-3 water_molar_mass = 18.015e-3  # calculate the concentration pressure vs temperature butanol_saturation_concentration = butanol_antione.saturation_concentration(     molar_mass=butanol_molar_mass,     temperature=temperatures) styrene_saturation_concentration = styrene_antione.saturation_concentration(     molar_mass=styrene_molar_mass,     temperature=temperatures) water_saturation_concentration = water_antione.saturation_concentration(     molar_mass=water_molar_mass,     temperature=temperatures)  # Plot the saturation concentrations for each substance. fig, ax = plt.subplots(figsize=(8, 6)) ax.plot(temperatures, butanol_saturation_concentration, label='Butanol') ax.plot(temperatures, styrene_saturation_concentration, label='Styrene', linestyle='--') ax.plot(temperatures, water_saturation_concentration, label='Water', linestyle='-.') ax.set_yscale('log') ax.set_xlabel('Temperature (K)') ax.set_ylabel('Saturation Concentration (kg/m^3)') ax.set_title('Saturation Concentration vs Temperature') ax.legend() plt.show() In\u00a0[10]: Copied! <pre># saturation concentration at 300 K\nbutanol_300K_concentration = butanol_saturation_concentration[0]\nstyrene_300K_concentration = styrene_saturation_concentration[0]\nwater_300K_concentration = water_saturation_concentration[0]\n\n# caculate the partial pressure of each substance at 300 K\nbutanol_partial_pressure = butanol_antione.partial_pressure(\n    concentration=butanol_300K_concentration,\n    molar_mass=butanol_molar_mass,\n    temperature=temperatures)\nstyrene_partial_pressure = styrene_antione.partial_pressure(\n    concentration=styrene_300K_concentration,\n    molar_mass=styrene_molar_mass,\n    temperature=temperatures)\nwater_partial_pressure = water_antione.partial_pressure(\n    concentration=water_300K_concentration,\n    molar_mass=water_molar_mass,\n    temperature=temperatures)\n\n# Plot the partial pressures for each substance.\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(temperatures, butanol_partial_pressure, label='Butanol')\nax.plot(temperatures, styrene_partial_pressure, label='Styrene', linestyle='--')\nax.plot(temperatures, water_partial_pressure, label='Water', linestyle='-.')\nax.set_yscale('log')\nax.set_xlabel('Temperature (K)')\nax.set_ylabel('Partial Pressure (Pa)')\nax.set_title('Partial Pressure vs Temperature')\nax.legend()\nplt.show()\n</pre> # saturation concentration at 300 K butanol_300K_concentration = butanol_saturation_concentration[0] styrene_300K_concentration = styrene_saturation_concentration[0] water_300K_concentration = water_saturation_concentration[0]  # caculate the partial pressure of each substance at 300 K butanol_partial_pressure = butanol_antione.partial_pressure(     concentration=butanol_300K_concentration,     molar_mass=butanol_molar_mass,     temperature=temperatures) styrene_partial_pressure = styrene_antione.partial_pressure(     concentration=styrene_300K_concentration,     molar_mass=styrene_molar_mass,     temperature=temperatures) water_partial_pressure = water_antione.partial_pressure(     concentration=water_300K_concentration,     molar_mass=water_molar_mass,     temperature=temperatures)  # Plot the partial pressures for each substance. fig, ax = plt.subplots(figsize=(8, 6)) ax.plot(temperatures, butanol_partial_pressure, label='Butanol') ax.plot(temperatures, styrene_partial_pressure, label='Styrene', linestyle='--') ax.plot(temperatures, water_partial_pressure, label='Water', linestyle='-.') ax.set_yscale('log') ax.set_xlabel('Temperature (K)') ax.set_ylabel('Partial Pressure (Pa)') ax.set_title('Partial Pressure vs Temperature') ax.legend() plt.show() In\u00a0[11]: Copied! <pre># caculate the saturation ratio\nbutanol_saturation_ratio = butanol_antione.saturation_ratio(\n    concentration=butanol_300K_concentration,\n    molar_mass=butanol_molar_mass,\n    temperature=temperatures)\nstyrene_saturation_ratio = styrene_antione.saturation_ratio(\n    concentration=styrene_300K_concentration,\n    molar_mass=styrene_molar_mass,\n    temperature=temperatures)\nwater_saturation_ratio = water_antione.saturation_ratio(\n    concentration=water_300K_concentration,\n    molar_mass=water_molar_mass,\n    temperature=temperatures)\n\n# Plot the saturation ratios for each substance.\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(temperatures, butanol_saturation_ratio, label='Butanol')\nax.plot(temperatures, styrene_saturation_ratio, label='Styrene', linestyle='--')\nax.plot(temperatures, water_saturation_ratio, label='Water', linestyle='-.')\nax.set_xlabel('Temperature (K)')\nax.set_ylabel('Saturation Ratio')\nax.set_title('Saturation Ratio vs Temperature')\nax.legend()\nplt.show()\n</pre> # caculate the saturation ratio butanol_saturation_ratio = butanol_antione.saturation_ratio(     concentration=butanol_300K_concentration,     molar_mass=butanol_molar_mass,     temperature=temperatures) styrene_saturation_ratio = styrene_antione.saturation_ratio(     concentration=styrene_300K_concentration,     molar_mass=styrene_molar_mass,     temperature=temperatures) water_saturation_ratio = water_antione.saturation_ratio(     concentration=water_300K_concentration,     molar_mass=water_molar_mass,     temperature=temperatures)  # Plot the saturation ratios for each substance. fig, ax = plt.subplots(figsize=(8, 6)) ax.plot(temperatures, butanol_saturation_ratio, label='Butanol') ax.plot(temperatures, styrene_saturation_ratio, label='Styrene', linestyle='--') ax.plot(temperatures, water_saturation_ratio, label='Water', linestyle='-.') ax.set_xlabel('Temperature (K)') ax.set_ylabel('Saturation Ratio') ax.set_title('Saturation Ratio vs Temperature') ax.legend() plt.show() In\u00a0[12]: Copied! <pre># Setting a constant vapor pressure at 300 K for water\nwater_pure_at_300K = {'vapor_pressure': 1234.56}  # in Pascals (Pa)\nwater_constant_strategy = VaporPressureFactory().get_strategy(\n    strategy_type='constant', parameters=water_pure_at_300K)\n\n# Setting parameters for the Clausius-Clapeyron equation for water\nwater_clausius_clapeyron_parameters = {\n    'latent_heat': 40.7e3,  # specific latent heat J/mol\n    'temperature_initial': 300,  # Initial temperature in Kelvin\n    'pressure_initial': 1234.56  # Initial pressure in Pascals\n}\nwater_clausius_clapeyron_strategy = VaporPressureFactory().get_strategy(\n    strategy_type='clausius_clapeyron', parameters=water_clausius_clapeyron_parameters)\n\n# Using the Water Buck strategy, no additional parameters needed\nwater_buck_strategy = VaporPressureFactory().get_strategy(\n    strategy_type='water_buck')\n\n# Define a range of temperatures for which to calculate vapor pressures\ntemperatures = range(250, 500)  # From 280 K to 320 K\n\n# Calculate the pure vapor pressure at different temperatures using\n# various strategies\nwater_pure_constant = [water_constant_strategy.pure_vapor_pressure(\n    temp) for temp in temperatures]\nwater_pure_antione = [water_antione.pure_vapor_pressure(\n    temp) for temp in temperatures]\nwater_pure_clausius_clapeyron = [\n    water_clausius_clapeyron_strategy.pure_vapor_pressure(temp) for temp in temperatures]\nwater_pure_buck = [water_buck_strategy.pure_vapor_pressure(\n    temp) for temp in temperatures]\n\n# Plotting the results using Matplotlib\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(temperatures, water_pure_constant, label='Constant', linestyle='-')\nax.plot(temperatures, water_pure_antione, label='Antoine', linestyle='--')\nax.plot(temperatures, water_pure_clausius_clapeyron,\n        label='Clausius-Clapeyron', linestyle='-.')\nax.plot(temperatures, water_pure_buck, label='Buck', linestyle=':')\nax.set_yscale('log')\nax.set_ylim(bottom=1e-10)\nax.set_xlabel('Temperature (K)')\nax.set_ylabel('Pure Vapor Pressure (Pa)')\nax.set_title('Comparison of Water Vapor Pressure Calculations')\nax.legend(loc='lower right')\nplt.show()\n</pre> # Setting a constant vapor pressure at 300 K for water water_pure_at_300K = {'vapor_pressure': 1234.56}  # in Pascals (Pa) water_constant_strategy = VaporPressureFactory().get_strategy(     strategy_type='constant', parameters=water_pure_at_300K)  # Setting parameters for the Clausius-Clapeyron equation for water water_clausius_clapeyron_parameters = {     'latent_heat': 40.7e3,  # specific latent heat J/mol     'temperature_initial': 300,  # Initial temperature in Kelvin     'pressure_initial': 1234.56  # Initial pressure in Pascals } water_clausius_clapeyron_strategy = VaporPressureFactory().get_strategy(     strategy_type='clausius_clapeyron', parameters=water_clausius_clapeyron_parameters)  # Using the Water Buck strategy, no additional parameters needed water_buck_strategy = VaporPressureFactory().get_strategy(     strategy_type='water_buck')  # Define a range of temperatures for which to calculate vapor pressures temperatures = range(250, 500)  # From 280 K to 320 K  # Calculate the pure vapor pressure at different temperatures using # various strategies water_pure_constant = [water_constant_strategy.pure_vapor_pressure(     temp) for temp in temperatures] water_pure_antione = [water_antione.pure_vapor_pressure(     temp) for temp in temperatures] water_pure_clausius_clapeyron = [     water_clausius_clapeyron_strategy.pure_vapor_pressure(temp) for temp in temperatures] water_pure_buck = [water_buck_strategy.pure_vapor_pressure(     temp) for temp in temperatures]  # Plotting the results using Matplotlib fig, ax = plt.subplots(figsize=(8, 6)) ax.plot(temperatures, water_pure_constant, label='Constant', linestyle='-') ax.plot(temperatures, water_pure_antione, label='Antoine', linestyle='--') ax.plot(temperatures, water_pure_clausius_clapeyron,         label='Clausius-Clapeyron', linestyle='-.') ax.plot(temperatures, water_pure_buck, label='Buck', linestyle=':') ax.set_yscale('log') ax.set_ylim(bottom=1e-10) ax.set_xlabel('Temperature (K)') ax.set_ylabel('Pure Vapor Pressure (Pa)') ax.set_title('Comparison of Water Vapor Pressure Calculations') ax.legend(loc='lower right') plt.show() <p>The source code documentation is described under Gas</p>"},{"location":"Tutorials/Gas_Phase/Notebooks/Vapor_Pressure/#vapor-pressure-tutorial","title":"Vapor Pressure Tutorial\u00b6","text":"<p>Vapor pressure is defined as the pressure exerted by a vapor in equilibrium with its liquid or solid phase. It is a crucial measure for understanding the tendency of molecules to transition from the liquid phase to the gas phase. This property is particularly important in systems where an aerosol (gas phase + particle phase) is in equilibrium with both phases.</p> <p>The vapor pressure varies with temperature, and this variation can manifest in several forms. Understanding these changes is key to predicting how substances will behave under different temperature conditions.</p> <p>In this notebook, we will explore the strategies for calculating vapor pressure as implemented in the <code>vapor_pressure</code> module. These strategies are essential for accurately modeling and understanding the behavior of aerosols in equilibrium with a liquid phase.</p> <p>Wikipedia: Vapor Pressure</p>"},{"location":"Tutorials/Gas_Phase/Notebooks/Vapor_Pressure/#units","title":"Units\u00b6","text":"<p>All measurements and calculations in this module adhere to the base SI units:</p> <ul> <li>Molar mass is in kilograms per mole (kg/mol).</li> <li>Concentration is in kilograms per cubic meter (kg/m^3).</li> <li>Temperature is in Kelvin (K).</li> <li>Pressure is in Pascals (Pa).</li> </ul>"},{"location":"Tutorials/Gas_Phase/Notebooks/Vapor_Pressure/#strategies-for-vapor-pressure-calculations","title":"Strategies for Vapor Pressure Calculations\u00b6","text":"<p>In our framework, all strategies for calculating vapor pressure are encapsulated within classes that inherit from the <code>VaporPressureStrategy</code> abstract base class. This design ensures that each strategy conforms to a standardized interface, making them interchangeable and simplifying integration with other components of our modular framework.</p>"},{"location":"Tutorials/Gas_Phase/Notebooks/Vapor_Pressure/#core-functions","title":"Core Functions\u00b6","text":"<p>We define two primary functions that form the backbone of our vapor pressure calculations:</p> <ul> <li><p><code>calculate_partial_pressure</code>: This function computes the partial pressure of a gas given its concentration, molar mass, and temperature. It applies the ideal gas law to derive the partial pressure in Pascals (Pa).</p> </li> <li><p><code>calculate_concentration</code>: This function inversely calculates the concentration of a gas from its partial pressure, molar mass, and temperature, also using the ideal gas law.</p> </li> </ul> <p>These functions can be reused for different strategies.</p>"},{"location":"Tutorials/Gas_Phase/Notebooks/Vapor_Pressure/#abstract-base-class","title":"Abstract Base Class\u00b6","text":"<p>The <code>VaporPressureStrategy</code> class serves as an abstract base class that outlines the necessary methods for vapor pressure calculations:</p> <ul> <li><p><code>partial_pressure</code>: Calculates the partial pressure of a gas based on its concentration, molar mass, and temperature.</p> </li> <li><p><code>concentration</code>: Calculates the concentration of a gas based on its partial pressure, temperature, and molar mass.</p> </li> <li><p><code>saturation_ratio</code>: Computes the ratio of the current vapor pressure to the saturation vapor pressure, which indicates how \"saturated\" the gas is with respect to a given temperature.</p> </li> <li><p><code>saturation_concentration</code>: Determines the maximum concentration of a gas at saturation at a given temperature.</p> </li> <li><p><code>pure_vapor_pressure</code>: This abstract method must be implemented by each subclass to calculate the pure (saturation) vapor pressure of a gas at specific temperatures.</p> </li> </ul> <p>By structuring our vapor pressure strategies around this abstract base class, we maintain high flexibility and robustness in our approach. Each subclass can implement specific behaviors for different gases or conditions, while relying on a common set of tools and interfaces provided by the base class.</p>"},{"location":"Tutorials/Gas_Phase/Notebooks/Vapor_Pressure/#example-antoine-equation-vapor-pressure-strategy","title":"Example: Antoine Equation Vapor Pressure Strategy\u00b6","text":"<p>The Antoine equation is a widely used empirical formula for estimating the vapor pressure of a substance over a range of temperatures. It takes the form:</p> <p>$$ \\log_{10}(P) = A - \\frac{B}{T - C} $$</p> <p>where:</p> <ul> <li>$P$ is the vapor pressure in mmHg,</li> <li>$T$ is the temperature in Kelvin,</li> <li>$A$, $B$, and $C$ are substance-specific constants.<ul> <li>These constants are typically determined experimentally and can vary for different substances.</li> <li>The Antoine equation is often used for organic compounds and provides a good approximation of vapor pressure behavior, over a limited temperature range.</li> </ul> </li> </ul> <p>We will implement this for the following substances, using constants from link:</p> <ul> <li><p>n-Butanol: \"Formula\": \"C4H10O\", \"A\": 7.838, \"B\": 1558.190, \"C\": 196.881</p> </li> <li><p>Styrene: \"Formula\": \"C8H8\", \"A\": 6.92409, \"B\": 1420, \"C\": 226</p> </li> <li><p>Water: \"Formula\": \"H2O\", \"A\": 7.94917, \"B\": 1657.462, \"C\": 227.02</p> </li> </ul>"},{"location":"Tutorials/Gas_Phase/Notebooks/Vapor_Pressure/#direct-strategy-builder-and-factory-patterns","title":"Direct Strategy, Builder, and Factory Patterns\u00b6","text":"<p>We will demonstrate the use of the direct, builder, and factory patterns to create instances of the <code>AntoineVaporPressure</code> strategy. These patterns provide different levels of abstraction and flexibility in object creation, catering to various use cases and design requirements.</p> <ul> <li>Direct Strategy: This involves directly creating instances of the <code>AntoineVaporPressure</code> class with the required parameters. It is straightforward but may be less flexible when dealing with complex object creation or configuration.</li> <li>Builder Pattern: The builder pattern separates the construction of a complex object from its representation, allowing for more flexible and readable object creation. We will use a <code>VaporPressureBuilder</code> class to construct instances of the <code>AntoineVaporPressure</code> strategy with different parameters. The parameters can be set in any order, and the builder provides a clear and intuitive way to create objects.</li> <li>Factory Pattern: The factory pattern provides an interface for creating objects without specifying the exact class of the object to be created. We will use a <code>VaporPressureFactory</code> class to create instances of the <code>AntoineVaporPressure</code> strategy based on the substance name. This pattern allows for dynamic object creation based on input parameters, enhancing flexibility and extensibility.</li> </ul>"},{"location":"Tutorials/Gas_Phase/Notebooks/Vapor_Pressure/#builder-validation","title":"Builder Validation\u00b6","text":"<p>Here we call the <code>AntoineBuilder</code> pattern, with incomplete parameters, to demonstrate the error handling mechanism.</p>"},{"location":"Tutorials/Gas_Phase/Notebooks/Vapor_Pressure/#temperature-variation","title":"Temperature Variation\u00b6","text":"<p>With the vapor pressure strategy implemented, we can now explore how the vapor pressure of these substances varies with temperature. We will plot the vapor pressure curves for n-Butanol, Styrene, and Water over a range of temperatures to observe their behavior.</p>"},{"location":"Tutorials/Gas_Phase/Notebooks/Vapor_Pressure/#saturation-concentration","title":"Saturation Concentration\u00b6","text":"<p>We will also calculate the concentration of these substances at different temperatures. The saturation concentration represents the maximum amount of a substance that can be in a gas at a given temperature. By examining how the saturation concentration changes with temperature, we can gain insights into the solubility and volatility of these substances.</p> <p>$$ C = \\frac{P_{pure}M}{RT} $$</p> <p>where:</p> <ul> <li>$C$ is the concentration in kg/m^3,</li> <li>$P_{pure}$ is the pure vapor pressure in Pa, (also known as $P_{sat}$, or $P_{0}$),</li> <li>$M$ is the molar mass in kg/mol,</li> <li>$R$ is the ideal gas constant (8.314 J/(mol K)),</li> <li>$T$ is the temperature in Kelvin.</li> </ul> <p>In the case of water, the saturation ratio can be used to determine the relative humidity of the air, as it is a key factor in weather and climate models.</p> <p>We can do this calculation from the directly from the vapor pressure strategy, as it is a common in the abstract base class. So even if we change how the vapor pressure is calculated, we can still use the same method to calculate the saturation concentration.</p>"},{"location":"Tutorials/Gas_Phase/Notebooks/Vapor_Pressure/#partial-pressure","title":"Partial Pressure\u00b6","text":"<p>The partial pressure of a gas is the pressure that the gas would exert if it occupied the entire volume alone. It is a key concept in understanding gas mixtures and the behavior of gases in equilibrium. The partial pressure of a gas is proportional to its concentration and temperature, as described by the ideal gas law.</p> <p>$$ P_{partial} = \\frac{C R T}{M} $$</p> <p>where:</p> <ul> <li>$P_{partial}$ is the partial pressure in Pascals (Pa),</li> <li>$C$ is the concentration of the gas in kg/m^3,</li> <li>$R$ is the ideal gas constant (8.314 J/(mol K)),</li> <li>$T$ is the temperature in Kelvin,</li> <li>$M$ is the molar mass of the gas in kg/mol.</li> </ul> <p>We can use the <code>calculate_partial_pressure</code> method from the vapor pressure strategy to calculate the partial pressure of a gas given its concentration, molar mass, and temperature. This calculation is essential for understanding the behavior of gas mixtures and the distribution of gases in a system.</p> <p>We will use the partial pressure at 300 K and calculate how it changes with temperature for the three substances.</p>"},{"location":"Tutorials/Gas_Phase/Notebooks/Vapor_Pressure/#saturation-ratio","title":"Saturation Ratio\u00b6","text":"<p>The saturation ratio is the ratio of a gas's current vapor pressure to its saturation vapor pressure at a specific temperature. This ratio helps determine how \"saturated\" the gas is with respect to the substance it is in equilibrium with. A saturation ratio of 1 implies that the gas is at equilibrium with the liquid phase. Values less than 1 indicate that the gas is sub-saturated (less than equilibrium), and values greater than 1 indicate supersaturation (more than equilibrium).</p> <p>$$ SR = \\frac{P}{P_{sat}} $$</p> <p>where:</p> <ul> <li>$SR$ is the saturation ratio,</li> <li>$P$ is the partial pressure of the gas,</li> <li>$P_{sat}$ is the saturation vapor pressure of the gas at the given temperature.</li> </ul> <p>To calculate the saturation ratio, we use the concentration of the gas and compare it to the saturation concentration. We calculate the partial pressure from the concentration and the saturation concentration, and then calculate the saturation ratio.</p> <p>We will start with the gas's initial concentration at 300K and calculate the saturation ratio at various temperatures while keeping the concentration constant.</p> <p>This method simulates the behavior of a gas that is initially at equilibrium with its liquid phase at 300K. If the temperature changes but the concentration remains constant, the saturation ratio will begin at 1 and typically decrease as the temperature increases. This decrease reflects the gas moving from a state of equilibrium to a state of sub-saturation as it becomes less capable of remaining in the liquid phase at higher temperatures.</p>"},{"location":"Tutorials/Gas_Phase/Notebooks/Vapor_Pressure/#other-strategies","title":"Other Strategies\u00b6","text":"<p>In addition to the common methods shared across all vapor pressure strategies, we have several specialized strategies that can be employed to calculate vapor pressure based on different principles:</p> <ul> <li>Constant: This strategy applies a fixed value for the vapor pressure, regardless of external conditions.</li> <li>Antoine: Utilizes the Antoine equation to determine the vapor pressure of a substance, adjusting based on temperature changes.</li> <li>Clausius_Clapeyron: Employs the Clausius-Clapeyron equation to estimate changes in vapor pressure in response to temperature variations.</li> <li>Water_Buck: Specifically designed for water, this strategy uses the Buck equation to calculate vapor pressure accurately.</li> </ul> <p>We will apply these different strategies to calculate the pure vapor pressure of water and observe how the values vary with temperature.</p>"},{"location":"Tutorials/Gas_Phase/Notebooks/Vapor_Pressure/#consistency-across-methods","title":"Consistency Across Methods\u00b6","text":"<p>Despite using different calculation strategies, the method calls remain consistent. This uniformity allows for straightforward substitutions between methods without altering the structure of the code.</p>"},{"location":"Tutorials/Gas_Phase/Notebooks/Vapor_Pressure/#summary","title":"Summary\u00b6","text":"<p>In this notebook, we covered how the strategies for vapor pressure calculations are implemented in our system. By using an abstract base class and common core functions, we ensure that each strategy adheres to a standardized interface and can be easily integrated into our framework. We explored the Antoine equation vapor pressure strategy for n-Butanol, Styrene, and Water, examining how their vapor pressures and saturation concentrations change with temperature. We calculated the partial pressure, saturation ratio, and saturation concentration for these substances, providing insights into their behavior in gas-phase systems. Finally, we demonstrated the consistency and flexibility of our approach by applying different vapor pressure strategies to calculate the vapor pressure of water and observing how the values vary with temperature.</p> <p>This modular and extensible design allows us to incorporate various vapor pressure calculation methods while maintaining a consistent interface and ensuring robustness and flexibility in our system.</p>"},{"location":"Tutorials/Particle_Phase/","title":"Index: Particle Phase","text":""},{"location":"Tutorials/Particle_Phase/#notebooks","title":"Notebooks","text":"<ul> <li>Aerosol Surface Tutorial</li> <li>Activity Tutorial</li> <li>Distribution Tutorial</li> <li>Types of Distributions Tutorial</li> <li>Particle Representation Tutorial</li> </ul>"},{"location":"Tutorials/Particle_Phase/#functional-representation","title":"Functional Representation","text":"<ul> <li>Activity Functions</li> </ul>"},{"location":"Tutorials/Particle_Phase/Notebooks/Activity_Tutorial/","title":"Activity Tutorial","text":"In\u00a0[4]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\nfrom particula.particles import ActivityIdealMass, ActivityIdealMolarBuilder, ActivityFactory\n</pre> import numpy as np import matplotlib.pyplot as plt  from particula.particles import ActivityIdealMass, ActivityIdealMolarBuilder, ActivityFactory In\u00a0[5]: Copied! <pre>activity_mass = ActivityIdealMass()  # no parameters needed\n\n# mixture\nmass_mixture = np.array([0.2, 0.8])  # water, sucrose\n\nactivities = activity_mass.activity(mass_concentration=mass_mixture)\nprint(f\"Activities: {activities}\")\n\n# partial pressures\npure_pressure = np.array([100, 10])  # water, sucrose\npartial_pressures = activity_mass.partial_pressure(pure_vapor_pressure=pure_pressure, mass_concentration=mass_mixture)\n\nprint(f\"Partial pressures: {partial_pressures}\")\n</pre> activity_mass = ActivityIdealMass()  # no parameters needed  # mixture mass_mixture = np.array([0.2, 0.8])  # water, sucrose  activities = activity_mass.activity(mass_concentration=mass_mixture) print(f\"Activities: {activities}\")  # partial pressures pure_pressure = np.array([100, 10])  # water, sucrose partial_pressures = activity_mass.partial_pressure(pure_vapor_pressure=pure_pressure, mass_concentration=mass_mixture)  print(f\"Partial pressures: {partial_pressures}\") <pre>Activities: [0.2 0.8]\nPartial pressures: [20.  8.]\n</pre> In\u00a0[6]: Copied! <pre>activity_molar = (\n    ActivityIdealMolarBuilder()\n    .set_molar_mass(np.array([18.01528, 342.29648]))  # water, sucrose\n    .build()\n)\n\n# mixture\nactivities = activity_molar.activity(mass_concentration=mass_mixture)\nprint(f\"Activities: {activities}\")\n\n# partial pressures\npure_pressure = np.array([100, 10])  # water, sucrose\npartial_pressures = activity_molar.partial_pressure(pure_vapor_pressure=pure_pressure, mass_concentration=mass_mixture)\n\nprint(f\"Partial pressures: {partial_pressures}\")\n</pre> activity_molar = (     ActivityIdealMolarBuilder()     .set_molar_mass(np.array([18.01528, 342.29648]))  # water, sucrose     .build() )  # mixture activities = activity_molar.activity(mass_concentration=mass_mixture) print(f\"Activities: {activities}\")  # partial pressures pure_pressure = np.array([100, 10])  # water, sucrose partial_pressures = activity_molar.partial_pressure(pure_vapor_pressure=pure_pressure, mass_concentration=mass_mixture)  print(f\"Partial pressures: {partial_pressures}\") <pre>Activities: [0.82608954 0.17391046]\nPartial pressures: [82.6089542   1.73910458]\n</pre> In\u00a0[7]: Copied! <pre>parameters_input={\n    \"density\": np.array([1000, 1500]),  # water, sucrose, kg/m^3 are the base SI default units\n    \"molar_mass\": np.array([18.01528, 342.29648]),  # water, sucrose\n    \"molar_mass_units\": \"g/mol\",  # this tells the factory what the input units are so it can convert to kg/mol\n    \"kappa\": np.array([0, 0.3]),  # water, sucrose\n    \"water_index\": 0  # water is the first component\n}\n\nactivity_kappa = ActivityFactory().get_strategy(\n    strategy_type=\"kappa\",\n    parameters=parameters_input\n)\n\n# mixture\nactivities = activity_kappa.activity(mass_concentration=mass_mixture)\nprint(f\"Activities: {activities}\")\n\n# partial pressures\npure_pressure = np.array([100, 10])  # water, sucrose\npartial_pressures = activity_kappa.partial_pressure(pure_vapor_pressure=pure_pressure, mass_concentration=mass_mixture)\n\nprint(f\"Partial pressures: {partial_pressures}\")\n</pre> parameters_input={     \"density\": np.array([1000, 1500]),  # water, sucrose, kg/m^3 are the base SI default units     \"molar_mass\": np.array([18.01528, 342.29648]),  # water, sucrose     \"molar_mass_units\": \"g/mol\",  # this tells the factory what the input units are so it can convert to kg/mol     \"kappa\": np.array([0, 0.3]),  # water, sucrose     \"water_index\": 0  # water is the first component }  activity_kappa = ActivityFactory().get_strategy(     strategy_type=\"kappa\",     parameters=parameters_input )  # mixture activities = activity_kappa.activity(mass_concentration=mass_mixture) print(f\"Activities: {activities}\")  # partial pressures pure_pressure = np.array([100, 10])  # water, sucrose partial_pressures = activity_kappa.partial_pressure(pure_vapor_pressure=pure_pressure, mass_concentration=mass_mixture)  print(f\"Partial pressures: {partial_pressures}\") <pre>Activities: [0.55555556 0.17391046]\nPartial pressures: [55.55555556  1.73910458]\n</pre> In\u00a0[8]: Copied! <pre>mass_water = np.linspace(0.001, 0.9999, 100)\nmass_sucrose = 1 - mass_water\nmass_mixture = np.array([mass_water, mass_sucrose]).T\n\nactivities_mass = np.zeros_like(mass_mixture)\nactivities_molar = np.zeros_like(mass_mixture)\nactivities_kappa = np.zeros_like(mass_mixture)\n\n\nfor i, mass in enumerate(mass_mixture):\n    activities_mass[i] = activity_mass.activity(mass_concentration=mass)\n    activities_molar[i] = activity_molar.activity(mass_concentration=mass)\n    activities_kappa[i] = activity_kappa.activity(mass_concentration=mass)\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(mass_water, activities_mass[:, 0], label=\"Mass: Water\")\nax.plot(mass_water, activities_mass[:, 1], label=\"Mass: Sucrose\", linestyle=\"--\")\nax.plot(mass_water, activities_molar[:, 0], label=\"Molar: Water\")\nax.plot(mass_water, activities_molar[:, 1], label=\"Molar: Sucrose\", linestyle=\"--\", linewidth=3, alpha=0.85)\nax.plot(mass_water, activities_kappa[:, 0], label=\"Kappa: Water\")\nax.plot(mass_water, activities_kappa[:, 1], label=\"Kappa: Sucrose\", linestyle=\"--\")\nax.set_xlabel(\"Mass fraction water\")\nax.set_ylabel(\"Activity\")\nax.legend()\nplt.show()\n</pre> mass_water = np.linspace(0.001, 0.9999, 100) mass_sucrose = 1 - mass_water mass_mixture = np.array([mass_water, mass_sucrose]).T  activities_mass = np.zeros_like(mass_mixture) activities_molar = np.zeros_like(mass_mixture) activities_kappa = np.zeros_like(mass_mixture)   for i, mass in enumerate(mass_mixture):     activities_mass[i] = activity_mass.activity(mass_concentration=mass)     activities_molar[i] = activity_molar.activity(mass_concentration=mass)     activities_kappa[i] = activity_kappa.activity(mass_concentration=mass)  fig, ax = plt.subplots(figsize=(8, 6)) ax.plot(mass_water, activities_mass[:, 0], label=\"Mass: Water\") ax.plot(mass_water, activities_mass[:, 1], label=\"Mass: Sucrose\", linestyle=\"--\") ax.plot(mass_water, activities_molar[:, 0], label=\"Molar: Water\") ax.plot(mass_water, activities_molar[:, 1], label=\"Molar: Sucrose\", linestyle=\"--\", linewidth=3, alpha=0.85) ax.plot(mass_water, activities_kappa[:, 0], label=\"Kappa: Water\") ax.plot(mass_water, activities_kappa[:, 1], label=\"Kappa: Sucrose\", linestyle=\"--\") ax.set_xlabel(\"Mass fraction water\") ax.set_ylabel(\"Activity\") ax.legend() plt.show()"},{"location":"Tutorials/Particle_Phase/Notebooks/Activity_Tutorial/#activity-tutorial","title":"Activity Tutorial\u00b6","text":"<p>This Jupyter notebook is designed to deepen your understanding of mixing behaviors in solutions, focusing on both theoretical models and practical applications. We will explore ideal and non-ideal mixing rules, differentiate between mass-based and molar-based approaches, and introduce the kappa value parameterization for predicting water activity.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Activity_Tutorial/#introduction-to-mixing-rules","title":"Introduction to Mixing Rules\u00b6","text":"<p>Mixing rules are essential for predicting the properties of solutions, including their thermodynamic behavior and phase equilibria. In this notebook, we will:</p> <ul> <li>Define and compare different mixing rules: Understand how various rules apply to different types of solutions.</li> <li>Mass-Based vs. Molar-Based Mixing: Discuss the implications of choosing mass-based or molar-based calculations for different applications.</li> <li>Kappa Value based Activity: Learn about the kappa value parameterization and its role in modeling water activity in non-ideal solutions.</li> </ul>"},{"location":"Tutorials/Particle_Phase/Notebooks/Activity_Tutorial/#structure-of-the-notebook","title":"Structure of the Notebook\u00b6","text":"<ol> <li><p>Mass-Based vs. Molar-Based Mixing</p> <ul> <li>Definitions and when to use each method</li> <li>Examples and comparative analysis</li> </ul> </li> <li><p>Kappa Value Parameterization</p> <ul> <li>Theory behind kappa values</li> <li>Practical exercises on calculating water activity</li> </ul> </li> </ol>"},{"location":"Tutorials/Particle_Phase/Notebooks/Activity_Tutorial/#strategies-builders-and-factories","title":"Strategies, Builders, and Factories\u00b6","text":"<p>We'll show examples for getting the strategy directly, form a builder, and from a factory.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Activity_Tutorial/#strategy-ideal-activity-mass-based-mixing","title":"Strategy: Ideal Activity Mass-Based Mixing\u00b6","text":"<p>The ideal in this context refers to all the activity coefficients being equal to 1. This is the simplest case and is often used as a reference point for more complex models. In this case, then we are just mixing based on mass fractions in the solution. Let's start witha mixture of water and sucrose.</p> <p>With an Ideal mass based mixing rule, the activity and partial pressure reduction is just the mass fraction of the component in the mixture.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Activity_Tutorial/#builder-molar-based-mixing","title":"Builder: Molar-Based Mixing\u00b6","text":"<p>All strategies have a builder method that can be used to create a new strategy with different parameters. In this case, we will create a molar-based mixing rule using the builder method.</p> <p>Using the same mixture of water and sucrose, we will now calculate the activity and partial pressure reduction based on molar fractions in the solution. We should see a large effect due to the difference in molecular weight between water and sucrose.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Activity_Tutorial/#factory-kappa-value-parameterization","title":"Factory: Kappa Value Parameterization\u00b6","text":"<p>Lastly, we will use the factory method to create a kappa value parameterization for predicting water activity in non-ideal solutions. This method is more complex and requires additional parameters to be defined. We will use the same water-sucrose mixture to demonstrate the kappa value approach.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Activity_Tutorial/#plotting-mixing-rules","title":"Plotting Mixing Rules\u00b6","text":"<p>We will plot the activity and partial pressure reduction for the water-sucrose mixture using the ideal mass-based mixing rule, molar-based mixing rule, and kappa value parameterization. This will help us visualize the differences between the three methods and understand how they affect the prediction of water activity in the solution.</p> <p>Note: Only water is treated non-ideally in the kappa value parameterization. The other species are treated in a molar-based ideal mixing rule.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Activity_Tutorial/#summary","title":"Summary\u00b6","text":"<p>By the end of this notebook, you should have a better understanding of mixing rules, mass-based vs. molar-based calculations, and the kappa value parameterization for predicting water activity in non-ideal solutions. You will also have learned how to apply these concepts to practical examples and visualize the results using plots.</p> <p>You saw how different mixing rules can be used to predict the properties of solutions and how they can affect the accuracy of the predictions. You also learned about the kappa value parameterization and how it can be used to model water activity in non-ideal solutions. These concepts are essential for condensation and phase equilibrium calculations when aerosol particles are present in the atmosphere.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Aerosol_Distributions/","title":"Size Distributions Tutorial","text":"In\u00a0[10]: Copied! <pre># %%\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom particula.particles.properties import (\n    lognormal_pdf_distribution,\n    lognormal_pmf_distribution,\n)\n</pre> # %% import numpy as np import matplotlib.pyplot as plt  from particula.particles.properties import (     lognormal_pdf_distribution,     lognormal_pmf_distribution, ) In\u00a0[11]: Copied! <pre># Define the x_values as a range of particle diameters\nx_values = np.logspace(-3, 1, 2000)  # From 0.001 to 10 microns\n</pre> # Define the x_values as a range of particle diameters x_values = np.logspace(-3, 1, 2000)  # From 0.001 to 10 microns In\u00a0[12]: Copied! <pre># %%\n# Single mode distribution\nsingle_mode_gsd = np.array([1.4])\nsingle_mode = np.array([0.02])\nsingle_mode_nparticles = np.array([1e3])\n\nsingle_mode_distribution = lognormal_pdf_distribution(\n    x_values, single_mode, single_mode_gsd, single_mode_nparticles\n)\n</pre> # %% # Single mode distribution single_mode_gsd = np.array([1.4]) single_mode = np.array([0.02]) single_mode_nparticles = np.array([1e3])  single_mode_distribution = lognormal_pdf_distribution(     x_values, single_mode, single_mode_gsd, single_mode_nparticles ) In\u00a0[13]: Copied! <pre># %%\n# Multi-mode distribution\nmulti_mode_gsd = np.array([1.4, 1.8])\nmulti_mode = np.array([0.02, 1.0])\nmulti_mode_nparticles = np.array([1e3, 1e3])\n\nmulti_mode_distribution = lognormal_pdf_distribution(\n    x_values, multi_mode, multi_mode_gsd, multi_mode_nparticles\n)\n</pre> # %% # Multi-mode distribution multi_mode_gsd = np.array([1.4, 1.8]) multi_mode = np.array([0.02, 1.0]) multi_mode_nparticles = np.array([1e3, 1e3])  multi_mode_distribution = lognormal_pdf_distribution(     x_values, multi_mode, multi_mode_gsd, multi_mode_nparticles ) In\u00a0[14]: Copied! <pre># %%\nplt.figure(figsize=(10, 6))\nplt.plot(x_values, single_mode_distribution, label=\"Single Mode\", linewidth=4)\nplt.plot(x_values, multi_mode_distribution, label=\"Multi Mode\")\nplt.title(\"Lognormal Particle Size Distribution\")\nplt.xlabel(\"Particle Diameter (\u03bcm)\")\nplt.ylabel(\"Frequency\")\nplt.xscale(\"log\")\nplt.legend()\nplt.grid(True)\nplt.show()\n</pre> # %% plt.figure(figsize=(10, 6)) plt.plot(x_values, single_mode_distribution, label=\"Single Mode\", linewidth=4) plt.plot(x_values, multi_mode_distribution, label=\"Multi Mode\") plt.title(\"Lognormal Particle Size Distribution\") plt.xlabel(\"Particle Diameter (\u03bcm)\") plt.ylabel(\"Frequency\") plt.xscale(\"log\") plt.legend() plt.grid(True) plt.show() In\u00a0[15]: Copied! <pre># %%\nsingle_mode_total_concentration = np.trapezoid(single_mode_distribution, x_values)\nmulti_mode_total_concentration = np.trapezoid(multi_mode_distribution, x_values)\n\nprint(\n    f\"Total Concentration for Single Mode: {single_mode_total_concentration}\"\n)\nprint(f\"Total Concentration for Multi Mode: {multi_mode_total_concentration}\")\n</pre> # %% single_mode_total_concentration = np.trapezoid(single_mode_distribution, x_values) multi_mode_total_concentration = np.trapezoid(multi_mode_distribution, x_values)  print(     f\"Total Concentration for Single Mode: {single_mode_total_concentration}\" ) print(f\"Total Concentration for Multi Mode: {multi_mode_total_concentration}\") <pre>Total Concentration for Single Mode: 1000.0\nTotal Concentration for Multi Mode: 2000.000000000001\n</pre> In\u00a0[16]: Copied! <pre>single_pmf_distribution = lognormal_pmf_distribution(\n    x_values, single_mode, single_mode_gsd, single_mode_nparticles\n)\nmulti_pmf_distribution = lognormal_pmf_distribution(\n    x_values, multi_mode, multi_mode_gsd, multi_mode_nparticles\n)\n</pre> single_pmf_distribution = lognormal_pmf_distribution(     x_values, single_mode, single_mode_gsd, single_mode_nparticles ) multi_pmf_distribution = lognormal_pmf_distribution(     x_values, multi_mode, multi_mode_gsd, multi_mode_nparticles ) In\u00a0[17]: Copied! <pre>plt.figure(figsize=(10, 6))\nplt.plot(x_values, single_pmf_distribution, label=\"Single Mode\", linewidth=4)\nplt.plot(x_values, multi_pmf_distribution, label=\"Multi Mode\")\nplt.title(\"Lognormal PMF Particle Size Distribution\")\nplt.xlabel(\"Particle Diameter (\u03bcm)\")\nplt.ylabel(\"Number of Particles\")\nplt.xscale(\"log\")\nplt.legend()\nplt.grid(True)\nplt.show()\n</pre> plt.figure(figsize=(10, 6)) plt.plot(x_values, single_pmf_distribution, label=\"Single Mode\", linewidth=4) plt.plot(x_values, multi_pmf_distribution, label=\"Multi Mode\") plt.title(\"Lognormal PMF Particle Size Distribution\") plt.xlabel(\"Particle Diameter (\u03bcm)\") plt.ylabel(\"Number of Particles\") plt.xscale(\"log\") plt.legend() plt.grid(True) plt.show() In\u00a0[18]: Copied! <pre># %%\nsingle_mode_total_concentration = single_pmf_distribution.sum()\nmulti_mode_total_concentration = multi_pmf_distribution.sum()\n\nprint(\n    f\"Total Concentration for Single Mode: {single_mode_total_concentration}\"\n)\nprint(f\"Total Concentration for Multi Mode: {multi_mode_total_concentration}\")\n</pre> # %% single_mode_total_concentration = single_pmf_distribution.sum() multi_mode_total_concentration = multi_pmf_distribution.sum()  print(     f\"Total Concentration for Single Mode: {single_mode_total_concentration}\" ) print(f\"Total Concentration for Multi Mode: {multi_mode_total_concentration}\") <pre>Total Concentration for Single Mode: 1000.0000000000001\nTotal Concentration for Multi Mode: 2000.0\n</pre>"},{"location":"Tutorials/Particle_Phase/Notebooks/Aerosol_Distributions/#size-distributions-tutorial","title":"Size Distributions Tutorial\u00b6","text":"<p>In this tutorial, we will explore how to calculate and plot lognormal distributions for aerosol particles. This is commonly used in aerosol science to model the size distribution of particles in different environmental or experimental conditions.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Aerosol_Distributions/#probability-density-function","title":"Probability Density Function\u00b6","text":"<p>(fix this, more details for aerosol science)</p> <p>The probability density function (PDF) of a lognormal distribution is given by:</p> <p>$$ f(x, s) = \\frac{1}{s x \\sqrt{2\\pi}} \\exp\\left(-\\frac{\\log^2(x)}{2s^2}\\right)  $$</p> <p>where $x$ is the particle diameter, and $s$ is the standard deviation of the distribution. $$ for x &gt; 0, s &gt; 0 $$</p> <p>The <code>scale</code> parameter is defined as the mode of the distribution.</p> <p>The probability density above is defined in the \u201cstandardized\u201d form. To shift and/or scale the distribution use the loc and scale parameters. Specifically, <code>lognorm.pdf(x, s, loc, scale)</code> is identically equivalent to <code>lognorm.pdf(y, s) / scale</code> with <code>y = (x - loc) / scale</code>. Note that shifting the location of a distribution does not make it a \u201cnoncentral\u201d distribution; noncentral generalizations of some distributions are available in separate classes.</p> <ul> <li>PDF Wikipedia</li> <li>Log-normal Wikipedia</li> <li>Log-normal Scipy</li> </ul>"},{"location":"Tutorials/Particle_Phase/Notebooks/Aerosol_Distributions/#define-particle-size-ranges","title":"Define Particle Size Ranges\u00b6","text":"<p>We use logarithmic spacing for particle diameters to cover a broad size range typically observed in aerosol particles.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Aerosol_Distributions/#single-mode-pdf-particle-size-distribution","title":"Single Mode PDF Particle Size Distribution\u00b6","text":"<p>In this section, we explore modeling a distribution with a single mode, typical for scenarios where particle populations are relatively uniform. The single mode represents a common characteristic size (mode) and spread (geometric standard deviation) of aerosol particles. We utilize parameters for the geometric standard deviation and the modal particle diameter to define this distribution. The distribution is scaled such that the area under the probability density function (PDF) equals the total number of particles, ensuring that it accurately reflects the particle count in terms of probability across different sizes. This method is particularly useful for representing aerosol populations where a single predominant size class exists, making it easier to analyze and predict aerosol behavior in environmental or laboratory settings.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Aerosol_Distributions/#multi-mode-pdf-particle-distribution","title":"Multi-Mode PDF Particle Distribution\u00b6","text":"<p>For more complex scenarios, such as urban air samples, we often observe multiple modes. Here we define and calculate distributions for a two-mode system.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Aerosol_Distributions/#plotting-the-pdfs-of-particle-size-distributions","title":"Plotting the PDFs of Particle Size Distributions\u00b6","text":"<p>Visualizing the probability density functions (PDFs) helps in understanding the frequency of different particle sizes.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Aerosol_Distributions/#calculate-and-display-total-concentration-from-pdfs","title":"Calculate and Display Total Concentration from PDFs\u00b6","text":"<p>Total concentration is important for understanding the overall particle load in a sample.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Aerosol_Distributions/#probability-mass-function-pmf-for-aerosol-distributions","title":"Probability Mass Function (PMF) for Aerosol Distributions\u00b6","text":"<p>The Probability Mass Function (PMF) of aerosol distributions provides a distinct perspective compared to the Probability Density Function (PDF). While the PDF represents the probability of particle sizes occurring within a continuous range, ensuring that the integral over all sizes equals the total number of particles, the PMF deals directly with discrete particle counts.</p> <p>In PMF, each value represents the actual number of particles expected at a specific size interval, rather than the probability density. This approach is particularly advantageous when quantifying and visualizing the actual particle counts across various size classes, making it ideal for detailed statistical analysis and practical applications like filter testing or health impact studies.</p> <p>Unlike the PDF, where the area under the curve corresponds to the total number of particles (when scaled appropriately), the PMF sums directly to the total number of particles without needing any integral calculation. Each point on the PMF curve directly indicates the number of particles in that particular size class, thus providing a more intuitive grasp of the size distribution's impact, especially in contexts where the exact count of particles is more relevant than their probability density.</p> <p>PMF Wikipedia</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Aerosol_Distributions/#plotting-the-pmfs-of-particle-size-distributions","title":"Plotting the PMFs of Particle Size Distributions\u00b6","text":"<p>Particle mass functions (PMFs) tell us about the actual number of particles at different sizes.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Aerosol_Distributions/#calculate-and-display-total-number-of-particles-from-pmfs","title":"Calculate and Display Total Number of Particles from PMFs\u00b6","text":"<p>This helps quantify the actual particle count in different modes.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Aerosol_Distributions/#summary-of-pdf-vs-pmf-in-aerosol-distributions","title":"Summary of PDF vs. PMF in Aerosol Distributions\u00b6","text":"<p>In this tutorial, we explored two fundamental representations of aerosol size distributions: the Probability Density Function (PDF) and the Particle Mass Function (PMF). Both offer valuable insights into aerosol characteristics but serve different analytical purposes:</p> <ul> <li><p>Probability Density Function (PDF): The PDF provides a normalized view of particle size distribution where the area under the curve represents the total number of particles. It is ideal for understanding the relative frequency of different particle sizes within a continuous range and for conducting probability-based analyses. The PDF is particularly useful in theoretical studies and simulations where understanding the likelihood of particle sizes is crucial.</p> </li> <li><p>Particle Mass Function (PMF): Conversely, the PMF directly quantifies the actual number of particles in each size interval. This discrete representation is especially useful for practical applications such as air quality monitoring and aerosol delivery systems where knowing the exact count of particles at different sizes is necessary. The PMF is straightforward as it adds up to the total particle count directly, providing a more tangible grasp of particle distribution without requiring integration.</p> </li> </ul> <p>Both methods play critical roles in aerosol science, each complementing the other by offering different perspectives on particle size distributions. Understanding when to use each can significantly enhance the accuracy and relevance of aerosol studies.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Aerosol_Distributions/#looking-ahead","title":"Looking Ahead\u00b6","text":"<p>In the upcoming tutorial, we will delve into another essential concept in aerosol science: the scaling and measurement of aerosol distributions using ( \\frac{dN}{d\\log D_p} ) (number concentration per unit of log-diameter interval). This approach provides a deeper understanding of how particle sizes are distributed across logarithmic size intervals, which is crucial for comparing aerosol measurements obtained from different instruments and studies. Stay tuned to explore how this scaling method enhances our ability to characterize and compare aerosol distributions effectively.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Distribution_Tutorial/","title":"Distribution Strategy Tutorial","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\nfrom particula.particles import MassBasedMovingBin, RadiiBasedMovingBinBuilder, DistributionFactory\n</pre> import numpy as np import matplotlib.pyplot as plt  from particula.particles import MassBasedMovingBin, RadiiBasedMovingBinBuilder, DistributionFactory In\u00a0[2]: Copied! <pre>mass_distribution = np.linspace(0, 10, 5)  # kg\ndensity = 1000  # kg/m^3\n\nradius = MassBasedMovingBin().get_radius(mass_distribution, density)\nprint(f\"Radius of the particles: {radius} m\")\n\ntotal_mass = MassBasedMovingBin().get_total_mass(\n    mass_distribution, concentration=np.ones_like(mass_distribution), density=density)\nprint(f\"Total mass of the particles: {total_mass} kg\")\nprint(f\"Same as the sum*concentration: {np.sum(mass_distribution)} kg\")\n</pre> mass_distribution = np.linspace(0, 10, 5)  # kg density = 1000  # kg/m^3  radius = MassBasedMovingBin().get_radius(mass_distribution, density) print(f\"Radius of the particles: {radius} m\")  total_mass = MassBasedMovingBin().get_total_mass(     mass_distribution, concentration=np.ones_like(mass_distribution), density=density) print(f\"Total mass of the particles: {total_mass} kg\") print(f\"Same as the sum*concentration: {np.sum(mass_distribution)} kg\") <pre>Radius of the particles: [0.         0.08419452 0.10607844 0.1214295  0.13365046] m\nTotal mass of the particles: 25.0 kg\nSame as the sum*concentration: 25.0 kg\n</pre> In\u00a0[3]: Copied! <pre>radii_distribution = np.linspace(0, 0.1, 5)  # m\ndensity = 1000  # kg/m^3\n\nradii_strategy = RadiiBasedMovingBinBuilder().build()\n\nmass_distribution = radii_strategy.get_mass(radii_distribution, density)\nprint(f\"Mass of the particles: {mass_distribution} kg\")\n\ntotal_mass = radii_strategy.get_total_mass(\n    radii_distribution, concentration=np.ones_like(radii_distribution), density=density)\nprint(f\"Total mass of the particles: {total_mass} kg\")\n</pre> radii_distribution = np.linspace(0, 0.1, 5)  # m density = 1000  # kg/m^3  radii_strategy = RadiiBasedMovingBinBuilder().build()  mass_distribution = radii_strategy.get_mass(radii_distribution, density) print(f\"Mass of the particles: {mass_distribution} kg\")  total_mass = radii_strategy.get_total_mass(     radii_distribution, concentration=np.ones_like(radii_distribution), density=density) print(f\"Total mass of the particles: {total_mass} kg\") <pre>Mass of the particles: [0.         0.06544985 0.52359878 1.76714587 4.1887902 ] kg\nTotal mass of the particles: 6.544984694978737 kg\n</pre> In\u00a0[4]: Copied! <pre>mass_distribution1 = np.linspace(0, 10, 5)  # kg\nmass_distribution2 = np.linspace(0, 10, 5)  # kg\nmasses_combined = np.vstack((mass_distribution1, mass_distribution2)).T\ndensity = np.array([1000.0, 2000.0])  # kg/m^3\n\nspeciated_mass = DistributionFactory().get_strategy(\"speciated_mass_moving_bin\")\n\nradius = speciated_mass.get_radius(masses_combined, density)\n\nprint(f\"Radius of the particles: {radius} m\")\n\ntotal_mass = speciated_mass.get_total_mass(\n    masses_combined, concentration=np.ones_like(mass_distribution1), density=density)\nprint(f\"Total mass of the particles: {total_mass} kg\")\n</pre> mass_distribution1 = np.linspace(0, 10, 5)  # kg mass_distribution2 = np.linspace(0, 10, 5)  # kg masses_combined = np.vstack((mass_distribution1, mass_distribution2)).T density = np.array([1000.0, 2000.0])  # kg/m^3  speciated_mass = DistributionFactory().get_strategy(\"speciated_mass_moving_bin\")  radius = speciated_mass.get_radius(masses_combined, density)  print(f\"Radius of the particles: {radius} m\")  total_mass = speciated_mass.get_total_mass(     masses_combined, concentration=np.ones_like(mass_distribution1), density=density) print(f\"Total mass of the particles: {total_mass} kg\") <pre>Radius of the particles: [0.         0.09637866 0.1214295  0.13900208 0.15299159] m\nTotal mass of the particles: 50.0 kg\n</pre>"},{"location":"Tutorials/Particle_Phase/Notebooks/Distribution_Tutorial/#distribution-strategy-tutorial","title":"Distribution Strategy Tutorial\u00b6","text":"<p>The representation of particle distributions is core to the simulation, but it can vary depending on what you are trying to achieve. In this tutorial, we will cover the  distribution strategies currently implemented.</p> <p>The distribution strategies, define how to calculate properties derived from the particle distribution. These include particle mass, radius, and total mass. All of which can have different methods depending if the distribution is mass-based, radius-based, or speciated-mass based.</p> <p>We will cover the following distribution strategies:</p> <ul> <li><code>MassBasedMovingBin</code></li> <li><code>RadiiBasedMovingBin</code></li> <li><code>SpeciatedMassMovingBin</code></li> </ul> <p>As they are just operational strategies, they do not have any specific parameters to be set. They are just used to calculate the properties of the particles.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Distribution_Tutorial/#strategy-massbasedmovingbin","title":"Strategy: MassBasedMovingBin\u00b6","text":"<p>The <code>MassBasedMovingBin</code> strategy is used when the distribution is mass-based. This means that the mass of the particles is known and the radius is calculated from the mass. The <code>MassBasedMovingBin</code> strategy calculates the radius of the particles using the following equation:</p> <p>$$ r = \\left(\\frac{3m}{4\\pi\\rho}\\right)^{1/3} $$</p> <p>where $r$ is the radius of the particle, $m$ is the mass of the particle, and $\\rho$ is the density of the particle.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Distribution_Tutorial/#builder-radiibasedmovingbin","title":"Builder: RadiiBasedMovingBin\u00b6","text":"<p>The <code>RadiiBasedMovingBin</code> strategy is used when the distribution is radius-based. This means that the radius of the particles is known and the mass is calculated from the radius. The <code>RadiiBasedMovingBin</code> strategy calculates the mass of the particles using the following equation:</p> <p>$$ m = \\frac{4\\pi\\rho r^3}{3} $$</p> <p>where $m$ is the mass of the particle, $r$ is the radius of the particle, and $\\rho$ is the density of the particle.</p> <p>The builder does nothing in this case, as we just have no parameters to set. We use the builder pattern here to keep the code consistent with the other strategies.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Distribution_Tutorial/#factory-speciatedmassmovingbin","title":"Factory: SpeciatedMassMovingBin\u00b6","text":"<p>The <code>SpeciatedMassMovingBin</code> strategy is used when the distribution is speciated-mass based. This means that the mass of the particles is known and the radius is calculated from the mass. The <code>SpeciatedMassMovingBin</code> has multiple species, and the mass of each species is known for that given bin or particle.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Distribution_Tutorial/#summary","title":"Summary\u00b6","text":"<p>In this tutorial, we covered the distribution strategies implemented in the simulation. We covered the <code>MassBasedMovingBin</code>, <code>RadiiBasedMovingBin</code>, and <code>SpeciatedMassMovingBin</code> strategies. These strategies are used to calculate the properties of the particles based on the distribution type.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Particle_Representation_Tutorial/","title":"Particle Representation","text":"In\u00a0[6]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\nfrom particula import particles\n</pre> import numpy as np import matplotlib.pyplot as plt  from particula import particles In\u00a0[7]: Copied! <pre># Creating particle distribution examples\nradius = np.array([100, 200, 300], dtype=np.float64)  # in nm\ndensity = 2.5\nconcentration = np.array([1e2, 1e3, 1e4], dtype=np.float64)\n\n# parameters\nsufrace_tension_strategy = (\n    particles.SurfaceStrategyMassBuilder()\n    .set_surface_tension(0.072)\n    .set_density(2.5, \"g/cm^3\")\n)\n\n# Create a Particle instance using the RadiusParticleRepresentationBuilder\nparticle_rep_mass = (\n    particles.ParticleRadiusRepresentationBuilder()\n    .set_distribution_strategy(particles.RadiiBasedMovingBin())\n    .set_activity_strategy(particles.ActivityIdealMass())\n    .set_surface_strategy(sufrace_tension_strategy)\n    .set_concentration(concentration=concentration, concentration_units=\"1/cm^3\")\n    .set_density(density=density, density_units=\"g/cm^3\")\n    .set_radius(radius=radius, radius_units=\"nm\")\n    .set_charge(charge=0)\n    .build()\n)\n\n#Accessing calculated properties\nprint(\"Mass of particles:\", particle_rep_mass.get_mass())\nprint(\"Radius of particles:\", particle_rep_mass.get_radius())\nprint(\"Total mass of the particle distribution:\", particle_rep_mass.get_mass_concentration())\n</pre> # Creating particle distribution examples radius = np.array([100, 200, 300], dtype=np.float64)  # in nm density = 2.5 concentration = np.array([1e2, 1e3, 1e4], dtype=np.float64)  # parameters sufrace_tension_strategy = (     particles.SurfaceStrategyMassBuilder()     .set_surface_tension(0.072)     .set_density(2.5, \"g/cm^3\") )  # Create a Particle instance using the RadiusParticleRepresentationBuilder particle_rep_mass = (     particles.ParticleRadiusRepresentationBuilder()     .set_distribution_strategy(particles.RadiiBasedMovingBin())     .set_activity_strategy(particles.ActivityIdealMass())     .set_surface_strategy(sufrace_tension_strategy)     .set_concentration(concentration=concentration, concentration_units=\"1/cm^3\")     .set_density(density=density, density_units=\"g/cm^3\")     .set_radius(radius=radius, radius_units=\"nm\")     .set_charge(charge=0)     .build() )  #Accessing calculated properties print(\"Mass of particles:\", particle_rep_mass.get_mass()) print(\"Radius of particles:\", particle_rep_mass.get_radius()) print(\"Total mass of the particle distribution:\", particle_rep_mass.get_mass_concentration()) <pre>Mass of particles: [1.04719755e-17 8.37758041e-17 2.82743339e-16]\nRadius of particles: [1.e-07 2.e-07 3.e-07]\nTotal mass of the particle distribution: 2.912256389877738e-06\n</pre> In\u00a0[8]: Copied! <pre># Generating random properties for speciated particles\nmass_distribution = (\n    np.random.rand(500, 3).astype(np.float64)\n)\nconcentration = (\n    np.random.rand(500, 1).astype(np.float64) * 1e3\n)\n\n# Defining surface tension parameters\nsurface_tension_parameter = {\n    \"surface_tension\": 0.072,  # in N/m\n    \"density\": 2.5,  # Density in g/cm^3\n    \"density_units\": \"g/cm^3\",\n}\nsurface_strategy = particles.SurfaceFactory().get_strategy('mass', surface_tension_parameter)\ndistribution_strategy = particles.DistributionFactory().get_strategy('speciated_mass_moving_bin')\nactivity_strategy = particles.ActivityFactory().get_strategy('mass_ideal')\n\n# Setting up parameters for the particle representation factory\nparameters = {\n    \"distribution_strategy\": distribution_strategy,\n    \"activity_strategy\": activity_strategy,\n    \"surface_strategy\": surface_strategy,\n    \"density\": 2.5,\n    \"density_units\": \"g/cm^3\",\n    \"concentration\": concentration,\n    \"concentration_units\": \"1/cm^3\",\n    \"mass\": mass_distribution,\n    \"mass_units\": \"pg\",  # picograms\n    \"charge\": 0,\n}\n\n# Using the factory to create a speciated particle representation\nspeciated_mass_rep = particles.ParticleRepresentationFactory().get_strategy(\n    \"mass\", parameters\n)\n\n# Outputting the total mass of the particle distribution\nprint(\n    f\"Total mass of the particle distribution: {speciated_mass_rep.get_mass_concentration()}\"\n)\n\n# Plot histogram of the mass distribution and number distribution vs radius\nradius = speciated_mass_rep.get_radius()\nmasses = speciated_mass_rep.get_mass()\nconcentration = speciated_mass_rep.get_concentration(clone=True)\n\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.hist(masses*1e6, bins=20, color=\"blue\", alpha=0.7)\nax.set_xlabel(\"Mass (ug)\")\nax.set_ylabel(\"Number of Particles (Droplets)\")\nax.set_title(\"Mass Distribution Particles\")\nplt.show()\n\nfig, ax2 = plt.subplots(figsize=(8, 6))\nax2.hist(radius*1e9, bins=20, color=\"red\", alpha=0.7)\nax2.set_ylabel(\"Concentration (1/m^3)\")\nax2.set_xlabel(\"Radius (nm)\")\nax2.set_title(\"Number Distribution Particles\")\nplt.show()\n</pre> # Generating random properties for speciated particles mass_distribution = (     np.random.rand(500, 3).astype(np.float64) ) concentration = (     np.random.rand(500, 1).astype(np.float64) * 1e3 )  # Defining surface tension parameters surface_tension_parameter = {     \"surface_tension\": 0.072,  # in N/m     \"density\": 2.5,  # Density in g/cm^3     \"density_units\": \"g/cm^3\", } surface_strategy = particles.SurfaceFactory().get_strategy('mass', surface_tension_parameter) distribution_strategy = particles.DistributionFactory().get_strategy('speciated_mass_moving_bin') activity_strategy = particles.ActivityFactory().get_strategy('mass_ideal')  # Setting up parameters for the particle representation factory parameters = {     \"distribution_strategy\": distribution_strategy,     \"activity_strategy\": activity_strategy,     \"surface_strategy\": surface_strategy,     \"density\": 2.5,     \"density_units\": \"g/cm^3\",     \"concentration\": concentration,     \"concentration_units\": \"1/cm^3\",     \"mass\": mass_distribution,     \"mass_units\": \"pg\",  # picograms     \"charge\": 0, }  # Using the factory to create a speciated particle representation speciated_mass_rep = particles.ParticleRepresentationFactory().get_strategy(     \"mass\", parameters )  # Outputting the total mass of the particle distribution print(     f\"Total mass of the particle distribution: {speciated_mass_rep.get_mass_concentration()}\" )  # Plot histogram of the mass distribution and number distribution vs radius radius = speciated_mass_rep.get_radius() masses = speciated_mass_rep.get_mass() concentration = speciated_mass_rep.get_concentration(clone=True)   fig, ax = plt.subplots(figsize=(8, 6)) ax.hist(masses*1e6, bins=20, color=\"blue\", alpha=0.7) ax.set_xlabel(\"Mass (ug)\") ax.set_ylabel(\"Number of Particles (Droplets)\") ax.set_title(\"Mass Distribution Particles\") plt.show()  fig, ax2 = plt.subplots(figsize=(8, 6)) ax2.hist(radius*1e9, bins=20, color=\"red\", alpha=0.7) ax2.set_ylabel(\"Concentration (1/m^3)\") ax2.set_xlabel(\"Radius (nm)\") ax2.set_title(\"Number Distribution Particles\") plt.show() <pre>Total mass of the particle distribution: 0.19117129911971042\n</pre> In\u00a0[9]: Copied! <pre>lognormal_rep = (\n    particles.PresetParticleRadiusBuilder()\n    .set_mode(np.array([100, 2000]), \"nm\")\n    .set_geometric_standard_deviation(np.array([1.5, 2.0]))\n    .set_number_concentration(np.array([1e4, 1e4]), \"1/cm^3\")\n    .set_distribution_type(\"pmf\")\n    .build()\n)\n\n# plot\nfig, ax = plt.subplots(figsize=(8, 6))\nax.semilogx(lognormal_rep.get_radius(), lognormal_rep.get_concentration(), label=\"Number Distribution\", color=\"blue\")\nax.set_xlabel(\"Radius (m)\")\nax.set_ylabel(\"Concentration (1/m^3)\")\nax.set_title(\"Number Distribution of Particles\")\nplt.legend()\nplt.show()\n</pre>  lognormal_rep = (     particles.PresetParticleRadiusBuilder()     .set_mode(np.array([100, 2000]), \"nm\")     .set_geometric_standard_deviation(np.array([1.5, 2.0]))     .set_number_concentration(np.array([1e4, 1e4]), \"1/cm^3\")     .set_distribution_type(\"pmf\")     .build() )  # plot fig, ax = plt.subplots(figsize=(8, 6)) ax.semilogx(lognormal_rep.get_radius(), lognormal_rep.get_concentration(), label=\"Number Distribution\", color=\"blue\") ax.set_xlabel(\"Radius (m)\") ax.set_ylabel(\"Concentration (1/m^3)\") ax.set_title(\"Number Distribution of Particles\") plt.legend() plt.show()"},{"location":"Tutorials/Particle_Phase/Notebooks/Particle_Representation_Tutorial/#particle-representation","title":"Particle Representation\u00b6","text":"<p>With the different aspects of particles laid out in the previous sections, we can now focus on how to represent them in a simulation. The representation of particles is crucial for having a unified way to handle particles in a system. This section will discuss building a particle representation that can be used in simulations and analyses.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Particle_Representation_Tutorial/#builder-particle-representation","title":"Builder: Particle Representation\u00b6","text":"<p>In this section, we will demonstrate how to create a particle distribution using specific particle properties such as radius, density, and concentration. This example will help illustrate the practical application of object-oriented programming in simulating and analyzing particle systems in scientific research. We'll utilize a builder pattern to construct an instance of a Particle class, allowing for flexible configuration of particle characteristics and behaviors.</p> <p>Key Components:</p> <ul> <li>Radius and Concentration: Define the size and number of particles in nanometers and their concentration per cubic centimeter, respectively. Density and Surface Tension: Specify the material's density and the surface tension for the particles, which are critical for calculating various physical and chemical properties.</li> <li>Builder Pattern: Use a builder pattern for creating a particle representation, which facilitates the step-by-step configuration of different strategies for distribution, activity, and surface approximations.</li> </ul> <p>The code snippet below sets up a particle distribution with defined properties using multiple factory methods to specify behavior strategies for distribution, activity, and surface interactions. The use of a builder pattern enhances readability and maintainability of the code by separating the construction of a complex object from its representation.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Particle_Representation_Tutorial/#factory-particle-representation-implementation","title":"Factory: Particle Representation Implementation\u00b6","text":"<p>The factory pattern plays a crucial role in the flexibility and extensibility of particle property computations, such as mass, radius, and total mass, within different computational models. It allows for dynamic selection of computational strategies based on the scenario, facilitating accurate and tailored simulations of real-world conditions.</p> <p>In this section, we'll demonstrate how to use a factory to construct speciated particles characterized by varied properties, enhancing our ability to simulate diverse environmental scenarios. Initially, it's beneficial to directly manipulate builders to familiarize yourself with various strategies. Subsequently, parameters can be saved in JSON format. In future iterations, these saved configurations can be rapidly deployed through the factory, streamlining particle creation and modification.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Particle_Representation_Tutorial/#limited-representation-builder","title":"Limited Representation Builder\u00b6","text":"<p>The last representation, is a modification of the radii builder, where we can specify a lognomal distribution parameters. This is useful when we want a to start a simulation quick and are not trying to explicitly reproduce a specific system.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Particle_Representation_Tutorial/#summary","title":"Summary\u00b6","text":"<p>In this notebook, we have discussed the importance of particle representation in simulations and analyses. We have demonstrated how to create a particle distribution using specific particle properties such as radius, density, and concentration. We have also shown how to use a builder pattern to construct an instance of a Particle class, allowing for flexible configuration of particle characteristics and behaviors. Finally, we have discussed the factory pattern and how it can be used to construct speciated particles characterized by varied properties.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Particle_Surface_Tutorial/","title":"Particle Surface Tutorial","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\nfrom particula.particles import SurfaceStrategyMolar, SurfaceStrategyMassBuilder, SurfaceFactory\n</pre> import numpy as np import matplotlib.pyplot as plt  from particula.particles import SurfaceStrategyMolar, SurfaceStrategyMassBuilder, SurfaceFactory In\u00a0[2]: Copied! <pre>glycerol_molar_mass = 0.092093 # kg/mol\nglycerol_density = 1261 # kg/m^3\nglycerol_surface_tension = 0.063 # N/m\n\n# Create a surface strategy\nglycerol_surface_strategy = SurfaceStrategyMolar(\n    glycerol_molar_mass, glycerol_density, glycerol_surface_tension\n)\n\nglycerol_kelvin_radius = glycerol_surface_strategy.kelvin_radius(\n    molar_mass=glycerol_molar_mass,\n    mass_concentration=0.1,  # not this doesn't not matter for a single species mixture\n    temperature=300\n)\n\nprint(f\"kelvin radius of glycerol {glycerol_kelvin_radius} m\")\n</pre> glycerol_molar_mass = 0.092093 # kg/mol glycerol_density = 1261 # kg/m^3 glycerol_surface_tension = 0.063 # N/m  # Create a surface strategy glycerol_surface_strategy = SurfaceStrategyMolar(     glycerol_molar_mass, glycerol_density, glycerol_surface_tension )  glycerol_kelvin_radius = glycerol_surface_strategy.kelvin_radius(     molar_mass=glycerol_molar_mass,     mass_concentration=0.1,  # not this doesn't not matter for a single species mixture     temperature=300 )  print(f\"kelvin radius of glycerol {glycerol_kelvin_radius} m\") <pre>kelvin radius of glycerol 5.392780089118282e-09 m\n</pre> In\u00a0[3]: Copied! <pre>radii = np.logspace(-10, -6, 100)\n\nglycerol_kevlin_term = glycerol_surface_strategy.kelvin_term(\n    radius=radii,\n    molar_mass=glycerol_molar_mass,\n    mass_concentration=0.1,\n    temperature=300\n)\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(radii, glycerol_kevlin_term)\nax.plot([glycerol_kelvin_radius, glycerol_kelvin_radius], [min(glycerol_kevlin_term), max(glycerol_kevlin_term)], color=\"red\", linestyle=\"--\")\nax.set_yscale(\"log\")\nax.set_xscale(\"log\")\nax.set_title(\"Kelvin term of glycerol\")\nax.set_xlabel(\"radius (m)\")\nax.set_ylabel(\"Kelvin term\")\nax.legend([\"Kelvin term\", \"Kelvin radius\"])\nplt.show()\n</pre> radii = np.logspace(-10, -6, 100)  glycerol_kevlin_term = glycerol_surface_strategy.kelvin_term(     radius=radii,     molar_mass=glycerol_molar_mass,     mass_concentration=0.1,     temperature=300 )  fig, ax = plt.subplots(figsize=(8, 6)) ax.plot(radii, glycerol_kevlin_term) ax.plot([glycerol_kelvin_radius, glycerol_kelvin_radius], [min(glycerol_kevlin_term), max(glycerol_kevlin_term)], color=\"red\", linestyle=\"--\") ax.set_yscale(\"log\") ax.set_xscale(\"log\") ax.set_title(\"Kelvin term of glycerol\") ax.set_xlabel(\"radius (m)\") ax.set_ylabel(\"Kelvin term\") ax.legend([\"Kelvin term\", \"Kelvin radius\"]) plt.show() In\u00a0[4]: Copied! <pre>squalane_surface = (\n    SurfaceStrategyMassBuilder()\n    .set_density(0.81, density_units=\"g/cm^3\")  # call with parameter name\n    .set_surface_tension(28, \"mN/m\")  # call without parameter name\n    .build()\n)\n\n# create plot\nsqualane_kelvin_radius = squalane_surface.kelvin_radius(\n    molar_mass=0.422, mass_concentration=0.1, temperature=300\n)\nsqualane_kelvin_term = squalane_surface.kelvin_term(\n    radius=radii, molar_mass=0.422, mass_concentration=0.1, temperature=300\n)\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(radii, squalane_kelvin_term)\nax.plot([squalane_kelvin_radius, squalane_kelvin_radius], [min(squalane_kelvin_term), max(squalane_kelvin_term)], color=\"red\", linestyle=\"--\")\nax.set_yscale(\"log\")\nax.set_xscale(\"log\")\nax.set_title(\"Kelvin term of squalane\")\nax.set_xlabel(\"radius (m)\")\nax.set_ylabel(\"Kelvin term\")\nax.legend([\"Kelvin term\", \"Kelvin radius\"])\nplt.show()\n</pre> squalane_surface = (     SurfaceStrategyMassBuilder()     .set_density(0.81, density_units=\"g/cm^3\")  # call with parameter name     .set_surface_tension(28, \"mN/m\")  # call without parameter name     .build() )  # create plot squalane_kelvin_radius = squalane_surface.kelvin_radius(     molar_mass=0.422, mass_concentration=0.1, temperature=300 ) squalane_kelvin_term = squalane_surface.kelvin_term(     radius=radii, molar_mass=0.422, mass_concentration=0.1, temperature=300 )  fig, ax = plt.subplots(figsize=(8, 6)) ax.plot(radii, squalane_kelvin_term) ax.plot([squalane_kelvin_radius, squalane_kelvin_radius], [min(squalane_kelvin_term), max(squalane_kelvin_term)], color=\"red\", linestyle=\"--\") ax.set_yscale(\"log\") ax.set_xscale(\"log\") ax.set_title(\"Kelvin term of squalane\") ax.set_xlabel(\"radius (m)\") ax.set_ylabel(\"Kelvin term\") ax.legend([\"Kelvin term\", \"Kelvin radius\"]) plt.show()   In\u00a0[5]: Copied! <pre>parameters = {  # glycerol, squalane\n        \"density\": np.array([1261, 810]),  # kg/m^3\n        \"surface_tension\": np.array([0.063, 0.028]),  # N/m\n}\n\nmixture_surface = SurfaceFactory().get_strategy(\n    strategy_type=\"volume\",\n    parameters=parameters,\n)\n\nmixture_kelvin_radius = mixture_surface.kelvin_radius(\n    molar_mass=0.092093,\n    mass_concentration=np.array([0.1, 0.1]),\n    temperature=300\n)\nprint(f\"kelvin radius of mixture {mixture_kelvin_radius} m\")\n\nmixture_kelvin_term = mixture_surface.kelvin_term(\n    radius=radii,\n    molar_mass=0.092093,\n    mass_concentration=np.array([0.1, 0.1]),\n    temperature=300\n)\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(radii, mixture_kelvin_term, label=\"Mixure\")\nax.plot([mixture_kelvin_radius, mixture_kelvin_radius], [min(mixture_kelvin_term), max(mixture_kelvin_term)], color=\"red\", linestyle=\"--\")\nax.plot(radii, glycerol_kevlin_term, label=\"Glycerol\")\nax.plot([glycerol_kelvin_radius, glycerol_kelvin_radius], [min(glycerol_kevlin_term), max(glycerol_kevlin_term)], color=\"red\", linestyle=\"--\")\nax.plot(radii, squalane_kelvin_term, label=\"Squalane\")\nax.plot([squalane_kelvin_radius, squalane_kelvin_radius], [min(squalane_kelvin_term), max(squalane_kelvin_term)], color=\"red\", linestyle=\"--\")\nax.set_yscale(\"log\")\nax.set_xscale(\"log\")\nax.set_title(\"Kelvin term of mixture\")\nax.set_xlabel(\"radius (m)\")\nax.set_ylabel(\"Kelvin term\")\nax.legend()\nplt.show()\n</pre> parameters = {  # glycerol, squalane         \"density\": np.array([1261, 810]),  # kg/m^3         \"surface_tension\": np.array([0.063, 0.028]),  # N/m }  mixture_surface = SurfaceFactory().get_strategy(     strategy_type=\"volume\",     parameters=parameters, )  mixture_kelvin_radius = mixture_surface.kelvin_radius(     molar_mass=0.092093,     mass_concentration=np.array([0.1, 0.1]),     temperature=300 ) print(f\"kelvin radius of mixture {mixture_kelvin_radius} m\")  mixture_kelvin_term = mixture_surface.kelvin_term(     radius=radii,     molar_mass=0.092093,     mass_concentration=np.array([0.1, 0.1]),     temperature=300 )  fig, ax = plt.subplots(figsize=(8, 6)) ax.plot(radii, mixture_kelvin_term, label=\"Mixure\") ax.plot([mixture_kelvin_radius, mixture_kelvin_radius], [min(mixture_kelvin_term), max(mixture_kelvin_term)], color=\"red\", linestyle=\"--\") ax.plot(radii, glycerol_kevlin_term, label=\"Glycerol\") ax.plot([glycerol_kelvin_radius, glycerol_kelvin_radius], [min(glycerol_kevlin_term), max(glycerol_kevlin_term)], color=\"red\", linestyle=\"--\") ax.plot(radii, squalane_kelvin_term, label=\"Squalane\") ax.plot([squalane_kelvin_radius, squalane_kelvin_radius], [min(squalane_kelvin_term), max(squalane_kelvin_term)], color=\"red\", linestyle=\"--\") ax.set_yscale(\"log\") ax.set_xscale(\"log\") ax.set_title(\"Kelvin term of mixture\") ax.set_xlabel(\"radius (m)\") ax.set_ylabel(\"Kelvin term\") ax.legend() plt.show()  <pre>kelvin radius of mixture 3.1208511801897936e-09 m\n</pre>"},{"location":"Tutorials/Particle_Phase/Notebooks/Particle_Surface_Tutorial/#particle-surface-tutorial","title":"Particle Surface Tutorial\u00b6","text":"<p>Understanding how particle surfaces are represented is crucial in the study of condensation processes involving water and organic molecules. This is primarily influenced by the Kelvin curvature effect, which describes how the saturation vapor pressure of a liquid droplet varies with its size. This tutorial will introduce the fundamental approaches to modeling the particle surface in aerosol particle simulations.</p> <p>Kelvin Curvature Effect</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Particle_Surface_Tutorial/#strategies-for-surface-representation","title":"Strategies for Surface Representation\u00b6","text":"<p>To accurately simulate particle surfaces, one must adhere to the <code>SurfaceStrategy</code> abstract base class. This class outlines common methods required for all surface representation strategies:</p> <ul> <li><code>kelvin_radius</code>: Calculates the particle radius that corresponds to the Kelvin curvature effect.</li> <li><code>kelvin_term</code>: Computes the Kelvin term, defined as exp(kelvin_radius / particle_radius).</li> </ul> <p>Specifically, the strategies differ in how they calculate:</p> <ul> <li><code>effective_surface_tension</code>: Determines the effective surface tension of species based on their concentration.</li> <li><code>effective_density</code>: Computes the effective density of species based on their concentration.</li> </ul> <p>While each strategy may require additional parameters, defining surface tension is essential for all. The primary strategies include:</p> <ul> <li><code>SurfaceStrategyMolar</code>: Uses mole fraction weighted values to determine surface tension and density.</li> <li><code>SurfaceStrategyMass</code>: Uses mass fraction weighted values to determine surface tension and density.</li> <li><code>SurfaceStrategyVolume</code>: Uses volume fraction weighted values to determine surface tension and density.</li> </ul> <p>Each strategy is interchangeable and suitable for use in aerosol particle simulations. The choice of strategy should be guided by the available data and the level of detail required for the simulation.</p> <p>In this tutorial, we will demonstrate how to create and use these strategies, employing builders and factories to instantiate them and calculate both the Kelvin radius and term.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Particle_Surface_Tutorial/#direct-strategy-creation","title":"Direct Strategy Creation\u00b6","text":"<p>The following code demonstrates how directly create and instance of a molar surface strategy and calculate the Kelvin radius and term.</p> <p>Note this approach assumes base SI units, if you want conversions on the inputs and data validation checks then use the subsequent builder and factory methods.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Particle_Surface_Tutorial/#kelvin-term","title":"Kelvin term\u00b6","text":"<p>To see the Kelvin term in action, we will calculate the Kelvin term for an array of glycerol particles. The Kelvin term is a dimensionless quantity that describes the effect of the Kelvin curvature on the saturation vapor pressure of a liquid droplet. It is defined as exp(kelvin_radius / particle_radius).</p> <p>So values of the Kelvin term greater than 1 indicate that the saturation vapor pressure required to maintain the particle's size is higher than the saturation vapor pressure of the bulk liquid (flat surface). This is due to the increased in curvature of the particle surface.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Particle_Surface_Tutorial/#builder-for-squalane","title":"Builder for Squalane\u00b6","text":"<p>The following code demonstrates how to use the builder to create a surface strategy for squalane particles. The builder allows for the specification of the surface tension and density of the species, as well as the concentration of the species in the particle.</p> <p>Squalane is a larger molecule with a lower surface tension than glycerol, so the Kelvin term will be lower for the same particle size.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Particle_Surface_Tutorial/#factory-approach","title":"Factory Approach\u00b6","text":"<p>Next example is the creation using a factory method, which is more flexible and allows for the use of different units and conversions. The factory method also performs data validation checks to ensure the input values are within the expected range. As the factory is just a wrapper around the builder, the same parameters can/must be used.</p> <p>Here we'll create a mixture of glycerol and squalane particles, and calculate the Kelvin term for a range of particle sizes for a volume fraction of 0.5 for each species. And assume glycerol is the condensing species.</p> <p>[double check the graph output, if the mixture should be lower than the pure or not]</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Particle_Surface_Tutorial/#summary","title":"Summary\u00b6","text":"<p>This tutorial has demonstrated the fundamental approaches to modeling particle surfaces in aerosol particle simulations. By using the <code>SurfaceStrategy</code> abstract base class, we can create and use different strategies to calculate the Kelvin radius and term. The choice of strategy should be guided by the available data and the level of detail required for the simulation.</p> <p>The <code>SurfaceStrategyMolar</code>, <code>SurfaceStrategyMass</code>, and <code>SurfaceStrategyVolume</code> strategies provide flexibility in determining the effective surface tension and density of species based on their concentration. By using builders and factories, we can create surface strategies with the necessary parameters and perform data validation checks to ensure the input values are within the expected range.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Functional/Activity_Functions/","title":"Activity Tutorial","text":"In\u00a0[7]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\nfrom particula.particles import properties\nfrom particula.util.converting import convert_mass_concentration\n</pre> import numpy as np import matplotlib.pyplot as plt  from particula.particles import properties from particula.util.converting import convert_mass_concentration In\u00a0[8]: Copied! <pre>masses_1 = np.linspace(0, 100, 1000)\nmasses_2 = np.full_like(masses_1, 30)\nmasses_3 = np.linspace(150, 10, 1000)\n\ndensity_1 = 1000  # kg/m^3\ndensity_2 = 2000  # kg/m^3\ndensity_3 = 1500  # kg/m^3\n\nmolar_mass_1 = 18.01528e-3  # g/mol\nmolar_mass_2 = 200e-3  # g/mol\nmolar_mass_3 = 150e-3  # g/mol\n\nmass_2component = np.column_stack((masses_1, masses_2))\nmass_3component = np.column_stack((masses_1, masses_2, masses_3))\n\ndensity_2component = np.array([density_1, density_2])\ndensity_3component = np.array([density_1, density_2, density_3])\n\n# get mass fractions\nmass_fractions_2component = convert_mass_concentration.to_mole_fraction(\n    mass_2component,\n    molar_masses=np.array([molar_mass_1, molar_mass_2])\n)\nmass_fractions_3component = convert_mass_concentration.to_mole_fraction(\n    mass_3component,\n    molar_masses=np.array([molar_mass_1, molar_mass_2, molar_mass_3])\n)\n</pre> masses_1 = np.linspace(0, 100, 1000) masses_2 = np.full_like(masses_1, 30) masses_3 = np.linspace(150, 10, 1000)  density_1 = 1000  # kg/m^3 density_2 = 2000  # kg/m^3 density_3 = 1500  # kg/m^3  molar_mass_1 = 18.01528e-3  # g/mol molar_mass_2 = 200e-3  # g/mol molar_mass_3 = 150e-3  # g/mol  mass_2component = np.column_stack((masses_1, masses_2)) mass_3component = np.column_stack((masses_1, masses_2, masses_3))  density_2component = np.array([density_1, density_2]) density_3component = np.array([density_1, density_2, density_3])  # get mass fractions mass_fractions_2component = convert_mass_concentration.to_mole_fraction(     mass_2component,     molar_masses=np.array([molar_mass_1, molar_mass_2]) ) mass_fractions_3component = convert_mass_concentration.to_mole_fraction(     mass_3component,     molar_masses=np.array([molar_mass_1, molar_mass_2, molar_mass_3]) )  In\u00a0[9]: Copied! <pre>activity_2component_molar = properties.ideal_activity_molar(\n    mass_concentration=mass_2component,\n    molar_mass=np.array([molar_mass_1, molar_mass_2]),\n)\n\n\nactivity_3component_molar = properties.ideal_activity_molar(\n    mass_concentration=mass_3component,\n    molar_mass=np.array([molar_mass_1, molar_mass_2, molar_mass_3]),\n)\n\n\n\n# Create the figure and axis objects\nfig, ax = plt.subplots(2, 1, figsize=(5, 8))\n\n# Plot each component in the 2-component system with separate colors\nax[0].plot(\n    mass_fractions_2component[:, 0],\n    activity_2component_molar[:, 0],\n    color=\"blue\",\n    label=\"Water (1)\",\n)\nax[0].plot(\n    mass_fractions_2component[:, 0],\n    activity_2component_molar[:, 1],\n    color=\"green\",\n    label=\"Component 2\",\n)\nax[0].set_xlabel(\"Water Mole Fraction\")\nax[0].set_ylabel(\"Activity coefficient\")\nax[0].set_title(\"Activity coefficient vs mass fraction for 2 components\")\nax[0].legend()\n\n# Plot the 3-component system without setting specific colors\nax[1].plot(\n    mass_fractions_3component[:, 0],\n    activity_3component_molar[:, 0],\n    label=\"Water (1)\",\n    color=\"blue\",\n)\nax[1].plot(\n    mass_fractions_3component[:, 0],\n    activity_3component_molar[:, 1],\n    label=\"Component 2\",\n    color=\"green\",\n)\nax[1].plot(\n    mass_fractions_3component[:, 0],\n    activity_3component_molar[:, 2],\n    label=\"Component 3\",\n    color=\"red\",\n)\nax[1].set_xlabel(\"Water Mole Fraction\")\nax[1].set_ylabel(\"Activity coefficient\")\nax[1].set_title(\"Activity coefficient vs mass fraction for 3 components\")\nax[1].legend()\n\n# Display the plot\nplt.tight_layout()\nplt.show()\n</pre> activity_2component_molar = properties.ideal_activity_molar(     mass_concentration=mass_2component,     molar_mass=np.array([molar_mass_1, molar_mass_2]), )   activity_3component_molar = properties.ideal_activity_molar(     mass_concentration=mass_3component,     molar_mass=np.array([molar_mass_1, molar_mass_2, molar_mass_3]), )    # Create the figure and axis objects fig, ax = plt.subplots(2, 1, figsize=(5, 8))  # Plot each component in the 2-component system with separate colors ax[0].plot(     mass_fractions_2component[:, 0],     activity_2component_molar[:, 0],     color=\"blue\",     label=\"Water (1)\", ) ax[0].plot(     mass_fractions_2component[:, 0],     activity_2component_molar[:, 1],     color=\"green\",     label=\"Component 2\", ) ax[0].set_xlabel(\"Water Mole Fraction\") ax[0].set_ylabel(\"Activity coefficient\") ax[0].set_title(\"Activity coefficient vs mass fraction for 2 components\") ax[0].legend()  # Plot the 3-component system without setting specific colors ax[1].plot(     mass_fractions_3component[:, 0],     activity_3component_molar[:, 0],     label=\"Water (1)\",     color=\"blue\", ) ax[1].plot(     mass_fractions_3component[:, 0],     activity_3component_molar[:, 1],     label=\"Component 2\",     color=\"green\", ) ax[1].plot(     mass_fractions_3component[:, 0],     activity_3component_molar[:, 2],     label=\"Component 3\",     color=\"red\", ) ax[1].set_xlabel(\"Water Mole Fraction\") ax[1].set_ylabel(\"Activity coefficient\") ax[1].set_title(\"Activity coefficient vs mass fraction for 3 components\") ax[1].legend()  # Display the plot plt.tight_layout() plt.show() In\u00a0[10]: Copied! <pre># Volume activity coefficient\nactivity_2component_volume = properties.ideal_activity_volume(\n    mass_concentration=mass_2component,\n    density=density_2component,\n)\n\nactivity_3component_volume = properties.ideal_activity_volume(\n    mass_concentration=mass_3component,\n    density=density_3component,\n)\n\n# Create the figure and axis objects\nfig, ax = plt.subplots(2, 1, figsize=(5, 8))\n\n# Plot each component in the 2-component system with separate colors\nax[0].plot(\n    mass_fractions_2component[:, 0],\n    activity_2component_volume[:, 0],\n    color=\"blue\",\n    label=\"Water (1)\",\n)\nax[0].plot(\n    mass_fractions_2component[:, 0],\n    activity_2component_volume[:, 1],\n    color=\"green\",\n    label=\"Component 2\",\n)\nax[0].set_xlabel(\"Water Mole Fraction\")\nax[0].set_ylabel(\"Activity coefficient\")\nax[0].set_title(\"Activity coefficient vs mass fraction for 2 components\")\nax[0].legend()\n\n# Plot the 3-component system without setting specific colors\nax[1].plot(\n    mass_fractions_3component[:, 0],\n    activity_3component_volume[:, 0],\n    label=\"Water (1)\",\n    color=\"blue\",\n)\nax[1].plot(\n    mass_fractions_3component[:, 0],\n    activity_3component_volume[:, 1],\n    label=\"Component 2\",\n    color=\"green\",\n)\nax[1].plot(\n    mass_fractions_3component[:, 0],\n    activity_3component_volume[:, 2],\n    label=\"Component 3\",\n    color=\"red\",\n)\nax[1].set_xlabel(\"Water Mole Fraction\")\nax[1].set_ylabel(\"Activity coefficient\")\nax[1].set_title(\"Activity coefficient vs mass fraction for 3 components\")\nax[1].legend()\n\n# Display the plot\nplt.tight_layout()\nplt.show()\n</pre> # Volume activity coefficient activity_2component_volume = properties.ideal_activity_volume(     mass_concentration=mass_2component,     density=density_2component, )  activity_3component_volume = properties.ideal_activity_volume(     mass_concentration=mass_3component,     density=density_3component, )  # Create the figure and axis objects fig, ax = plt.subplots(2, 1, figsize=(5, 8))  # Plot each component in the 2-component system with separate colors ax[0].plot(     mass_fractions_2component[:, 0],     activity_2component_volume[:, 0],     color=\"blue\",     label=\"Water (1)\", ) ax[0].plot(     mass_fractions_2component[:, 0],     activity_2component_volume[:, 1],     color=\"green\",     label=\"Component 2\", ) ax[0].set_xlabel(\"Water Mole Fraction\") ax[0].set_ylabel(\"Activity coefficient\") ax[0].set_title(\"Activity coefficient vs mass fraction for 2 components\") ax[0].legend()  # Plot the 3-component system without setting specific colors ax[1].plot(     mass_fractions_3component[:, 0],     activity_3component_volume[:, 0],     label=\"Water (1)\",     color=\"blue\", ) ax[1].plot(     mass_fractions_3component[:, 0],     activity_3component_volume[:, 1],     label=\"Component 2\",     color=\"green\", ) ax[1].plot(     mass_fractions_3component[:, 0],     activity_3component_volume[:, 2],     label=\"Component 3\",     color=\"red\", ) ax[1].set_xlabel(\"Water Mole Fraction\") ax[1].set_ylabel(\"Activity coefficient\") ax[1].set_title(\"Activity coefficient vs mass fraction for 3 components\") ax[1].legend()  # Display the plot plt.tight_layout() plt.show() In\u00a0[11]: Copied! <pre># Mass activity coefficient\nactivity_2component_mass = properties.ideal_activity_mass(\n    mass_concentration=mass_2component,\n)\nactivity_3component_mass = properties.ideal_activity_mass(\n    mass_concentration=mass_3component,\n)\n\n# Create the figure and axis objects\nfig, ax = plt.subplots(2, 1, figsize=(5, 8))\n\n# Plot each component in the 2-component system with separate colors\nax[0].plot(\n    mass_fractions_2component[:, 0],\n    activity_2component_mass[:, 0],\n    color=\"blue\",\n    label=\"Water (1)\",\n    linewidth=4,\n    linestyle=\"--\",\n)\nax[0].plot(\n    mass_fractions_2component[:, 0],\n    activity_2component_mass[:, 1],\n    color=\"green\",\n    label=\"Component 2\",\n)\nax[0].set_xlabel(\"Water Mole Fraction\")\nax[0].set_ylabel(\"Activity coefficient\")\nax[0].set_title(\"Activity coefficient vs mass fraction for 2 components\")\nax[0].legend()\n\n# Plot the 3-component system without setting specific colors\nax[1].plot(\n    mass_fractions_3component[:, 0],\n    activity_3component_mass[:, 0],\n    label=\"Water (1)\",\n    color=\"blue\",\n    linewidth=4,\n    linestyle=\"--\",\n)\nax[1].plot(\n    mass_fractions_3component[:, 0],\n    activity_3component_mass[:, 1],\n    label=\"Component 2\",\n    color=\"green\",\n    linewidth=3,\n)\nax[1].plot(\n    mass_fractions_3component[:, 0],\n    activity_3component_mass[:, 2],\n    label=\"Component 3\",\n    color=\"red\",\n)\nax[1].set_xlabel(\"Water Mole Fraction\")\nax[1].set_ylabel(\"Activity coefficient\")\nax[1].set_title(\"Activity coefficient vs mass fraction for 3 components\")\nax[1].legend()\n\n# Display the plot\nplt.tight_layout()\nplt.show()\n</pre> # Mass activity coefficient activity_2component_mass = properties.ideal_activity_mass(     mass_concentration=mass_2component, ) activity_3component_mass = properties.ideal_activity_mass(     mass_concentration=mass_3component, )  # Create the figure and axis objects fig, ax = plt.subplots(2, 1, figsize=(5, 8))  # Plot each component in the 2-component system with separate colors ax[0].plot(     mass_fractions_2component[:, 0],     activity_2component_mass[:, 0],     color=\"blue\",     label=\"Water (1)\",     linewidth=4,     linestyle=\"--\", ) ax[0].plot(     mass_fractions_2component[:, 0],     activity_2component_mass[:, 1],     color=\"green\",     label=\"Component 2\", ) ax[0].set_xlabel(\"Water Mole Fraction\") ax[0].set_ylabel(\"Activity coefficient\") ax[0].set_title(\"Activity coefficient vs mass fraction for 2 components\") ax[0].legend()  # Plot the 3-component system without setting specific colors ax[1].plot(     mass_fractions_3component[:, 0],     activity_3component_mass[:, 0],     label=\"Water (1)\",     color=\"blue\",     linewidth=4,     linestyle=\"--\", ) ax[1].plot(     mass_fractions_3component[:, 0],     activity_3component_mass[:, 1],     label=\"Component 2\",     color=\"green\",     linewidth=3, ) ax[1].plot(     mass_fractions_3component[:, 0],     activity_3component_mass[:, 2],     label=\"Component 3\",     color=\"red\", ) ax[1].set_xlabel(\"Water Mole Fraction\") ax[1].set_ylabel(\"Activity coefficient\") ax[1].set_title(\"Activity coefficient vs mass fraction for 3 components\") ax[1].legend()  # Display the plot plt.tight_layout() plt.show() In\u00a0[12]: Copied! <pre># kappa activity coefficient\n\nkappa_1 = 0.0 # kappa of water\nkappa_2 = 0.6 # kappa of component 2\nkappa_3 = 1.2 # kappa of component 3\n\nwater_index = 0\n\nactivity_2component_kappa = properties.kappa_activity(\n    mass_concentration=mass_2component,\n    kappa=np.array([kappa_1, kappa_2]),\n    density=density_2component,\n    molar_mass=np.array([molar_mass_1, molar_mass_2]),\n    water_index=water_index,\n)\nactivity_3component_kappa = properties.kappa_activity(\n    mass_concentration=mass_3component,\n    kappa=np.array([kappa_1, kappa_2, kappa_3]),\n    density=density_3component,\n    molar_mass=np.array([molar_mass_1, molar_mass_2, molar_mass_3]),\n    water_index=water_index,\n)\n\n# Create the figure and axis objects\nfig, ax = plt.subplots(2, 1, figsize=(5, 8))\n\n# Plot each component in the 2-component system with separate colors\nax[0].plot(\n    mass_fractions_2component[:, 0],\n    activity_2component_kappa[:, 0],\n    color=\"blue\",\n    label=\"Water (1)\",\n)\nax[0].plot(\n    mass_fractions_2component[:, 0],\n    activity_2component_kappa[:, 1],\n    color=\"green\",\n    label=\"Component 2\",\n)\nax[0].set_xlabel(\"Water Mole Fraction\")\nax[0].set_ylabel(\"Activity coefficient\")\nax[0].set_title(\"Kappa Activity coefficient vs mass fraction for 2 components\")\nax[0].legend()\n\n# Plot the 3-component system without setting specific colors\nax[1].plot(\n    mass_fractions_3component[:, 0],\n    activity_3component_kappa[:, 0],\n    label=\"Water (1)\",\n    color=\"blue\",\n)\nax[1].plot(\n    mass_fractions_3component[:, 0],\n    activity_3component_kappa[:, 1],\n    label=\"Component 2\",\n    color=\"green\",\n)\nax[1].plot(\n    mass_fractions_3component[:, 0],\n    activity_3component_kappa[:, 2],\n    label=\"Component 3\",\n    color=\"red\",\n)\nax[1].set_xlabel(\"Water Mole Fraction\")\nax[1].set_ylabel(\"Activity coefficient\")\nax[1].set_title(\"Kappa Activity coefficient vs mass fraction for 3 components\")\nax[1].legend()\n\n# Display the plot\nplt.tight_layout()\nplt.show()\n</pre> # kappa activity coefficient  kappa_1 = 0.0 # kappa of water kappa_2 = 0.6 # kappa of component 2 kappa_3 = 1.2 # kappa of component 3  water_index = 0  activity_2component_kappa = properties.kappa_activity(     mass_concentration=mass_2component,     kappa=np.array([kappa_1, kappa_2]),     density=density_2component,     molar_mass=np.array([molar_mass_1, molar_mass_2]),     water_index=water_index, ) activity_3component_kappa = properties.kappa_activity(     mass_concentration=mass_3component,     kappa=np.array([kappa_1, kappa_2, kappa_3]),     density=density_3component,     molar_mass=np.array([molar_mass_1, molar_mass_2, molar_mass_3]),     water_index=water_index, )  # Create the figure and axis objects fig, ax = plt.subplots(2, 1, figsize=(5, 8))  # Plot each component in the 2-component system with separate colors ax[0].plot(     mass_fractions_2component[:, 0],     activity_2component_kappa[:, 0],     color=\"blue\",     label=\"Water (1)\", ) ax[0].plot(     mass_fractions_2component[:, 0],     activity_2component_kappa[:, 1],     color=\"green\",     label=\"Component 2\", ) ax[0].set_xlabel(\"Water Mole Fraction\") ax[0].set_ylabel(\"Activity coefficient\") ax[0].set_title(\"Kappa Activity coefficient vs mass fraction for 2 components\") ax[0].legend()  # Plot the 3-component system without setting specific colors ax[1].plot(     mass_fractions_3component[:, 0],     activity_3component_kappa[:, 0],     label=\"Water (1)\",     color=\"blue\", ) ax[1].plot(     mass_fractions_3component[:, 0],     activity_3component_kappa[:, 1],     label=\"Component 2\",     color=\"green\", ) ax[1].plot(     mass_fractions_3component[:, 0],     activity_3component_kappa[:, 2],     label=\"Component 3\",     color=\"red\", ) ax[1].set_xlabel(\"Water Mole Fraction\") ax[1].set_ylabel(\"Activity coefficient\") ax[1].set_title(\"Kappa Activity coefficient vs mass fraction for 3 components\") ax[1].legend()  # Display the plot plt.tight_layout() plt.show()"},{"location":"Tutorials/Particle_Phase/Notebooks/Functional/Activity_Functions/#activity-tutorial","title":"Activity Tutorial\u00b6","text":"<p>This Jupyter notebook is designed to deepen your understanding of mixing behaviors in solutions, focusing on both theoretical models and practical applications. We will explore ideal and non-ideal mixing rules, differentiate between mass-based and molar-based approaches, and introduce the kappa value parameterization for predicting water activity.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Functional/Activity_Functions/#introduction-to-mixing-rules","title":"Introduction to Mixing Rules\u00b6","text":"<p>Mixing rules are essential for predicting the properties of solutions, including their thermodynamic behavior and phase equilibria. In this notebook, we will:</p> <ul> <li>Define and compare different mixing rules: Understand how various rules apply to different types of solutions.</li> <li>Mass-Based vs. Molar-Based Mixing: Discuss the implications of choosing mass-based or molar-based calculations for different applications.</li> <li>Kappa Value based Activity: Learn about the kappa value parameterization and its role in modeling water activity in non-ideal solutions.</li> </ul>"},{"location":"Tutorials/Particle_Phase/Notebooks/Functional/Activity_Functions/#structure-of-the-notebook","title":"Structure of the Notebook\u00b6","text":"<ol> <li><p>Mass-Based vs. Molar-Based vs. Volueme-Based</p> <ul> <li>Definitions and when to use each method</li> <li>Examples and comparative analysis</li> </ul> </li> <li><p>Kappa Value Parameterization</p> <ul> <li>Theory behind kappa values</li> <li>Practical exercises on calculating water activity</li> </ul> </li> </ol>"},{"location":"Tutorials/Particle_Phase/Notebooks/Functional/Activity_Functions/#mass-arrays","title":"Mass Arrays\u00b6","text":"<p>First we'll need to create some mass concentration arrays to use in our examples. We will use a 2-component and 3-component system for demonstration purposes.</p> <p>In each the first component is water and the second component is a solute. The mass fractions of the solute will be varied to demonstrate the different mixing rules.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Functional/Activity_Functions/#molar-based-mixing","title":"Molar-Based Mixing\u00b6","text":"<p>The ideal in this context refers to all the activity coefficients being equal to 1. This is the simplest case and is often used as a reference point for more complex models. In this case, then we are just mixing based on molar fractions.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Functional/Activity_Functions/#volume-based-mixing","title":"Volume-Based Mixing\u00b6","text":"<p>In this next example, we will use volume-based mixing. This is common for use with liquid mixtures, where the volume of the solution is the sum of the volumes of the components. This is a simple way to mix solutions, but it is not always accurate.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Functional/Activity_Functions/#mass-based-mixing","title":"Mass-Based Mixing\u00b6","text":"<p>In this example, we will use mass-based mixing. This is the simplest, as our mass fractions are directly proportional to the mass of the components.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Functional/Activity_Functions/#kappa-activity","title":"Kappa-Activity\u00b6","text":"<p>The kappa value parameterization is a simple way to model non-ideal water interactions in solutions.</p>"},{"location":"Tutorials/Particle_Phase/Notebooks/Functional/Activity_Functions/#summary","title":"Summary\u00b6","text":"<p>By the end of this notebook, you should have a better understanding of mixing rules, mass-based vs. molar-based calculations, and the kappa value parameterization for predicting water activity in non-ideal solutions. You will also have learned how to apply these concepts to practical examples and visualize the results using plots.</p> <p>You saw how different mixing rules can be used to predict the properties of solutions and how they can affect the accuracy of the predictions. You also learned about the kappa value parameterization and how it can be used to model water activity in non-ideal solutions. These concepts are essential for condensation and phase equilibrium calculations when aerosol particles are present in the atmosphere.</p>"},{"location":"contribute/","title":"Contribute","text":"<p>Here we have summary and links to the different ways you can contribute to the project.</p>"},{"location":"contribute/#contents","title":"Contents","text":"<ul> <li>Code of Conduct</li> <li>Contributing Guidelines</li> <li>Style Guide (Google)</li> </ul>"},{"location":"contribute/CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"contribute/CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"contribute/CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or   advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"contribute/CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"contribute/CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"contribute/CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at . All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"contribute/CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"contribute/CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"contribute/CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"contribute/CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"contribute/CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"contribute/CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"contribute/CONTRIBUTING/","title":"Contributor Guidelines","text":"<p>First of all, thank you for considering contributing to this project! While we have specific guidelines below, we also encourage you to contribute to the best of your ability and not let these guidelines hinder your productivity and creativity. We are open to any contribution, and we are always looking for new ways to improve the project. We are also open to any feedback, however small or large, and in any area (from documentation to calculation to presentation).</p> <p>The cycle of contribution goes something like this:</p> <ol> <li> <p>See if there is an issue open that you can help with. If there is not one, please open one.</p> </li> <li> <p>Create a personal fork of this repository; and in it, create a branch (from <code>uncscode:main</code>) with the <code>issue000</code> in the name of the branch (e.g. <code>username/issue000</code> or <code>issue000</code>), where <code>000</code> is the number of the issue from step 1.</p> </li> <li> <p>Set up an appropriate environment:</p> <ul> <li>an easy option is just to use the <code>.devcontainer</code> in root</li> <li>another option is to either <code>pip install</code> or <code>conda install</code> the packages required for development in <code>requirements.txt</code> in root.</li> </ul> </li> <li> <p>Write your code in the branch. This usually includes the following.</p> <p>a. Code to be implemented.</p> <p>b. Documentation associated with added code in a.</p> <p>c. Tests associated with added code in a.</p> <p>d. Ideally, you'd also add a Jupyter notebook to showcase your work (if applicable).</p> </li> <li> <p>Optionally, you can run standard linting and testing calls on your code locally to make sure it works as expected. This can be done in several ways, for example the <code>pylint</code>, <code>flake8</code>, and <code>pytest</code> calls below. These calls will be run once you submit your pull request.</p> </li> <li> <p>Submit a pull request to the <code>main</code> branch of this repository. Upon submission, standard automated tests will be run on your code.</p> </li> <li> <p>If you don't hear back from maintainers, feel free to mention one of us directly in the comments of the PR. Expect to have speedy feedback and help from us to finalize the PR.</p> </li> </ol> <pre><code>pylint $(find particula/ -name \"*.py\" | xargs)\n</code></pre> <pre><code>flake8 particula/ --count\n</code></pre> <pre><code>pytest particula/\n</code></pre> <p>More information about contributing to this project can be found below. We are excited and looking forward to your contribution!</p>"},{"location":"contribute/CONTRIBUTING/#github","title":"GitHub","text":"<p>We use GitHub to develop <code>particula</code> completely in the open. Our repository is available here: https://uncscode.github.io/particula/. There are several ways to use GitHub: through the command line via <code>git</code> and/or <code>gh</code>, through the web interface and/or the GitHub web editor, or through an IDE like PyCharm or a code editor like Visual Studio Code. In general, we recommend that you fork our repository, that you work with VS Code, and that submit a pull request based on an issue. If any of these sound unfamiliar or if you need help, please see more information below and feel free to contact us directly to discuss options. We look forward to getting you started and up to speed on this project with us!</p> <p>Links: https://docs.github.com/en/get-started</p>"},{"location":"contribute/CONTRIBUTING/#vs-code","title":"VS Code","text":"<p>Visual Studio Code is a free and open-source code editor for writing code and it has a rich ecosystem of extensions that allow you to write code in a variety of languages with a lot of helpful features and tools.</p> <p>Links: https://code.visualstudio.com/</p>"},{"location":"contribute/CONTRIBUTING/#python-code-style","title":"Python code style","text":"<p>We follow the Google's Python style guide. We encourage you to follow it too, but we also encourage you to contribute to the best of your ability and not let these guidelines hinder your productivity and creativity.</p> <p>Links: https://google.github.io/styleguide/pyguide.html</p>"},{"location":"contribute/CONTRIBUTING/#running-particula-locally","title":"Running <code>particula</code> locally","text":"<p>Once you are in the root directory, you will be able to import <code>particula</code> as a package/model and thus all documentation on website applies. You must be in the root directory.</p>"},{"location":"contribute/CONTRIBUTING/#writing-tests","title":"Writing tests","text":"<p>It is essential that every piece of code has an associated test. This is a good way to ensure that the code is working as intended. It also ensures that the code is not broken and that the code is not too complex. However small or big, a test is always required.</p>"},{"location":"contribute/CONTRIBUTING/#running-testinglinting-locally","title":"Running testing/linting locally","text":"<p>We use <code>pytest</code>, <code>pylint</code>, and <code>flake8</code> to run tests and linting. The command below can be run in the root directory like you'd run the package above.</p> <pre><code>pylint $(find particula/ -name \"*.py\" | xargs)\n</code></pre> <pre><code>flake8 particula/ --count\n</code></pre> <pre><code>pytest particula/\n</code></pre>"},{"location":"contribute/CONTRIBUTING/#building-particula-locally","title":"Building <code>particula</code> locally","text":"<p>To build <code>particula</code> locally, you must be in the root directory. You have two options, depending on your usage case.</p> <ol> <li>You can use <code>python -m build</code> to build the package wheels locally (note: you will need to install <code>build</code> too, via <code>pip install build</code>).</li> <li>You can build the conda recipe available at https://github.com/conda-forge/particula-feedstock either via <code>python build-locally.py</code> in the root of <code>particula-feedstock</code> or via <code>conda build recipe</code> (equivalently, but faster, <code>mamba build recipe</code>). For the latter, you will need to have <code>conda-build</code> installed (for <code>conda build</code> to work) or <code>boa</code> (for <code>mamba build</code> to work). In either case, you can install package with conda via, <code>conda install conda-build</code> or <code>mamba install boa</code>.</li> </ol> <p>Links: https://packaging.python.org/en/latest/tutorials/packaging-projects/ and https://docs.conda.io/projects/conda-build/en/latest/user-guide/index.html</p>"},{"location":"contribute/CONTRIBUTING/#documentation-writing","title":"Documentation writing","text":"<p>We prefer that the tutorials are written in the form of Jupyter notebooks after the package is released and published. A convenient option is using Google's Colaboratory to write the notebooks.</p> <p>Links: https://colab.research.google.com/</p>"},{"location":"contribute/CONTRIBUTING/#more-information","title":"More information","text":"<p>We will update this regularly with more information, but in the meanwhile, please feel free to contact us directly on GitHub.</p>"},{"location":"development/","title":"Particula Core Development","text":""},{"location":"development/#continuous-particle-pdf-and-pmf","title":"Continuous Particle PDF and PMF","text":"<ul> <li> Bin Remapping after condensation and evaporation is needed, or dr/dt method</li> </ul>"},{"location":"development/#scavenging","title":"Scavenging","text":"<ul> <li> Scavenging needs to be implemented for Particle Resolved</li> </ul>"},{"location":"development/#activity-coefficients","title":"Activity Coefficients","text":"<ul> <li> BAT model needs to be added to activity coefficient calculation.</li> </ul>"},{"location":"development/#guides-for-new-users","title":"Guides for New Users","text":"<ul> <li> Improved Documentation for new users</li> </ul>"},{"location":"development/#beta-features","title":"Beta Features","text":"<p>For beta features, find them at the Particula-Beta</p>"},{"location":"development/#guide-for-developers","title":"Guide for Developers","text":""}]}