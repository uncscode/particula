{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Particula is a Python-based aerosol particle simulator. Its goal is to provide a robust aerosol simulation (including both gas and particle phases) that can be used to answer scientific questions arising from experiments and research endeavors.</p>"},{"location":"#pypi-installation","title":"PyPi Installation","text":"<p>If your Python environment is already set up, you can install <code>Particula</code> via pip using the following command:</p> <pre><code>pip install particula\n</code></pre> <p>Setup Particula How to Guides Tutorials API Reference</p>"},{"location":"#contributing-to-particula","title":"Contributing to <code>Particula</code>","text":"<p>We are open to and we welcome contributions from anyone who wants to contribute to this project. We have a short contributing document in the root of the repository, which you can read. However, feel free to reach out with any questions or comments!</p>"},{"location":"API/","title":"Particula Index","text":"<p>Auto-generated documentation index.</p> <p>A full list of Particula project modules.</p> <ul> <li>Particula<ul> <li>Activity<ul> <li>Binary Activity</li> <li>Gibbs</li> <li>Phase Separation</li> <li>Ratio</li> <li>Species Density</li> </ul> </li> <li>Constants</li> <li>Data<ul> <li>Lake</li> <li>Lake Stats</li> <li>Loader</li> <li>Loader Interface</li> <li>Loader Setting Builders</li> <li>Merger</li> <li>Mixin</li> <li>Process<ul> <li>Aerodynamic Convert</li> <li>Chamber Rate Fitting</li> <li>Kappa Via Extinction</li> <li>Lognormal 2mode</li> <li>Mie Angular</li> <li>Mie Bulk</li> <li>Ml Analysis<ul> <li>Generate And Train 2mode Sizer</li> <li>Get Ml Folder</li> <li>Run Ml Trainings</li> </ul> </li> <li>Optical Instrument</li> <li>Scattering Truncation</li> <li>Size Distribution</li> </ul> </li> <li>Settings Generator</li> <li>Stream</li> <li>Stream Stats</li> </ul> </li> <li>Dynamics</li> <li>Environment</li> <li>Equilibria<ul> <li>Partitioning</li> </ul> </li> <li>Lagrangian<ul> <li>Boundary</li> <li>Collisions</li> <li>Integration</li> <li>Particle Pairs</li> <li>Particle Property</li> </ul> </li> <li>Logger Setup</li> <li>Next<ul> <li>Abc Builder</li> <li>Abc Factory</li> <li>Aerosol</li> <li>Builder Mixin</li> <li>Dynamics<ul> <li>Coagulation<ul> <li>Brownian Kernel</li> <li>Kernel</li> <li>Particle Resolved Method</li> <li>Rate</li> <li>Strategy</li> <li>Super Droplet Method</li> <li>Transition Regime</li> </ul> </li> <li>Condensation<ul> <li>Condensation Strategies</li> <li>Mass Transfer</li> </ul> </li> <li>Dilution</li> <li>Particle Process</li> <li>Properties<ul> <li>Wall Loss Coefficient</li> </ul> </li> <li>Wall Loss</li> </ul> </li> <li>Gas<ul> <li>Atmosphere</li> <li>Atmosphere Builders</li> <li>Properties<ul> <li>Concentration Function</li> <li>Dynamic Viscosity</li> <li>Mean Free Path</li> <li>Pressure Function</li> <li>Thermal Conductivity</li> <li>Vapor Pressure Module</li> </ul> </li> <li>Species</li> <li>Species Builders</li> <li>Species Factories</li> <li>Vapor Pressure Builders</li> <li>Vapor Pressure Factories</li> <li>Vapor Pressure Strategies</li> </ul> </li> <li>Particles<ul> <li>Activity Builders</li> <li>Activity Factories</li> <li>Activity Strategies</li> <li>Distribution Builders</li> <li>Distribution Factories</li> <li>Distribution Strategies</li> <li>Properties<ul> <li>Activity Module</li> <li>Aerodynamic Mobility Module</li> <li>Aerodynamic Size</li> <li>Coulomb Enhancement</li> <li>Diffusion Coefficient</li> <li>Diffusive Knudsen Module</li> <li>Friction Factor Module</li> <li>Kelvin Effect Module</li> <li>Knudsen Number Module</li> <li>Lognormal Size Distribution</li> <li>Mean Thermal Speed Module</li> <li>Partial Pressure Module</li> <li>Settling Velocity</li> <li>Slip Correction Module</li> <li>Special Functions</li> <li>Vapor Correction Module</li> </ul> </li> <li>Representation</li> <li>Representation Builders</li> <li>Representation Factories</li> <li>Surface Builders</li> <li>Surface Factories</li> <li>Surface Strategies</li> </ul> </li> <li>Runnable</li> </ul> </li> <li>Particle</li> <li>Rates</li> <li>Util<ul> <li>Aerodynamic Mobility</li> <li>Approx Coagulation</li> <li>CoagulationRate</li> <li>Colors</li> <li>Condensation Force</li> <li>Convert</li> <li>Converting<ul> <li>Convert Mass Concentration</li> </ul> </li> <li>CoulombEnhancement</li> <li>Debye Function</li> <li>Diffusion Coefficient</li> <li>DiffusiveKnudsen</li> <li>Dilution Loss</li> <li>DimensionlessCoagulation</li> <li>Distribution Discretization</li> <li>Dynamic Viscosity</li> <li>Friction Factor</li> <li>Fuchs Sutugin</li> <li>Input Handling</li> <li>Kelvin Correction</li> <li>Knudsen Number</li> <li>Lf2013 Coagulation<ul> <li>Src Lf2013 Coagulation</li> </ul> </li> <li>Machine Limit</li> <li>Mean Free Path</li> <li>Molecular Enhancement</li> <li>Particle Mass</li> <li>Particle Surface</li> <li>Radius Cutoff</li> <li>Reduced Quantity</li> <li>Rms Speed</li> <li>Settling Velocity</li> <li>SimpleSolver</li> <li>Size Distribution Convert</li> <li>Slip Correction</li> <li>Species Properties</li> <li>Stats</li> <li>Surface Tension</li> <li>Time Manage</li> <li>Vapor Flux</li> <li>Wall Loss</li> </ul> </li> <li>Vapor</li> </ul> </li> </ul>"},{"location":"API/particula/","title":"Particula","text":"<p>Particula Index / Particula</p> <p>Auto-generated documentation for particula module.</p>"},{"location":"API/particula/#attributes","title":"Attributes","text":"<ul> <li> <p><code>u</code> - u is the unit registry name.: UnitRegistry(force_ndarray=True)</p> </li> <li> <p><code>logger</code> - setup the logger: setup()</p> </li> </ul>"},{"location":"API/particula/#modules","title":"Modules","text":"<ul> <li>Activity</li> <li>Constants</li> <li>Data</li> <li>Dynamics</li> <li>Environment</li> <li>Equilibria</li> <li>Lagrangian</li> <li>Logger Setup</li> <li>Next</li> <li>Particle</li> <li>Rates</li> <li>Util</li> <li>Vapor</li> </ul>"},{"location":"API/particula/constants/","title":"Constants","text":"<p>Particula Index / Particula / Constants</p> <p>Auto-generated documentation for particula.constants module.</p>"},{"location":"API/particula/constants/#attributes","title":"Attributes","text":"<ul> <li> <p><code>GAS_CONSTANT</code> - Gas constant in J mol^-1 K^-1 = m^2 kg mol^-1 s^-2 K^-1   J = kg m^2 s^-2   or (1*u.molar_gas_constant).to_base_units(): BOLTZMANN_CONSTANT * AVOGADRO_NUMBER</p> </li> <li> <p><code>RELATIVE_PERMITTIVITY_AIR_ROOM</code> - Relative permittivity of air at approx.   296.15 K and 101325 Pa and 40% RH   See https://www.osti.gov/servlets/purl/1504063   Previously known as the \"dielectric constant\"   Often denoted as epsilon: 1.000530569</p> </li> <li> <p><code>RELATIVE_PERMITTIVITY_AIR_STP</code> - At STP (273.15 K, 1 atm):   see: https://en.wikipedia.org/wiki/Relative_permittivity: 1.00058986</p> </li> <li> <p><code>RELATIVE_PERMITTIVITY_AIR</code> - select one of the two:: RELATIVE_PERMITTIVITY_AIR_ROOM</p> </li> <li> <p><code>VACUUM_PERMITTIVITY</code> - Permittivity of free space in F/m   Also known as the electric constant, permittivity of free space   Often denoted by epsilon_0: 1 * u.vacuum_permittivity.to_base_units()</p> </li> <li> <p><code>REF_VISCOSITY_AIR_STP</code> - These values are used to calculate the dynamic viscosity of air   Here, REF temperature and viscosity are at STP:   Standard temperature and pressure (273.15 K and 101325 Pa): 1.716e-05 * u.Pa * u.s</p> </li> </ul>"},{"location":"API/particula/dynamics/","title":"Dynamics","text":"<p>Particula Index / Particula / Dynamics</p> <p>Auto-generated documentation for particula.dynamics module.</p>"},{"location":"API/particula/dynamics/#solver","title":"Solver","text":"<p>Show source in dynamics.py:9</p> <p>dynamic solver</p>"},{"location":"API/particula/dynamics/#signature","title":"Signature","text":"<pre><code>class Solver(Rates):\n    def __init__(\n        self,\n        time_span=None,\n        do_coagulation=True,\n        do_condensation=True,\n        do_nucleation=True,\n        do_dilution=False,\n        do_wall_loss=False,\n        **kwargs\n    ): ...\n</code></pre>"},{"location":"API/particula/dynamics/#see-also","title":"See also","text":"<ul> <li>Rates</li> </ul>"},{"location":"API/particula/dynamics/#solver_ode_func","title":"Solver()._ode_func","text":"<p>Show source in dynamics.py:35</p> <p>ode_func</p>"},{"location":"API/particula/dynamics/#signature_1","title":"Signature","text":"<pre><code>def _ode_func(self, _nums, _): ...\n</code></pre>"},{"location":"API/particula/dynamics/#solversolution","title":"Solver().solution","text":"<p>Show source in dynamics.py:53</p> <p>solve the equation</p>"},{"location":"API/particula/dynamics/#signature_2","title":"Signature","text":"<pre><code>def solution(self, method=\"odeint\", **kwargs_ode): ...\n</code></pre>"},{"location":"API/particula/environment/","title":"Environment","text":"<p>Particula Index / Particula / Environment</p> <p>Auto-generated documentation for particula.environment module.</p>"},{"location":"API/particula/environment/#environment_1","title":"Environment","text":"<p>Show source in environment.py:67</p> <p>creating the environment class</p> <p>For now, the environment class takes properties such as temperature and pressure to calculate derived properties such as viscosity and mean free path.</p>"},{"location":"API/particula/environment/#signature","title":"Signature","text":"<pre><code>class Environment(SharedProperties):\n    def __init__(self, **kwargs): ...\n</code></pre>"},{"location":"API/particula/environment/#see-also","title":"See also","text":"<ul> <li>SharedProperties</li> </ul>"},{"location":"API/particula/environment/#environmentdynamic_viscosity","title":"Environment().dynamic_viscosity","text":"<p>Show source in environment.py:110</p> <p>Returns the dynamic viscosity in Pa*s.</p>"},{"location":"API/particula/environment/#signature_1","title":"Signature","text":"<pre><code>def dynamic_viscosity(self): ...\n</code></pre>"},{"location":"API/particula/environment/#environmentmean_free_path","title":"Environment().mean_free_path","text":"<p>Show source in environment.py:120</p> <p>Returns the mean free path in m.</p>"},{"location":"API/particula/environment/#signature_2","title":"Signature","text":"<pre><code>def mean_free_path(self): ...\n</code></pre>"},{"location":"API/particula/environment/#environmentwater_vapor_concentration","title":"Environment().water_vapor_concentration","text":"<p>Show source in environment.py:131</p> <p>Returns the water vapor concentration in kg/m^3.</p>"},{"location":"API/particula/environment/#signature_3","title":"Signature","text":"<pre><code>def water_vapor_concentration(self): ...\n</code></pre>"},{"location":"API/particula/environment/#sharedproperties","title":"SharedProperties","text":"<p>Show source in environment.py:41</p> <p>a hidden class for sharing properties like coagulation_approximation</p>"},{"location":"API/particula/environment/#signature_4","title":"Signature","text":"<pre><code>class SharedProperties:\n    def __init__(self, **kwargs): ...\n</code></pre>"},{"location":"API/particula/environment/#sharedpropertiesdilution_rate_coefficient","title":"SharedProperties().dilution_rate_coefficient","text":"<p>Show source in environment.py:58</p> <p>get the dilution rate coefficient</p>"},{"location":"API/particula/environment/#signature_5","title":"Signature","text":"<pre><code>def dilution_rate_coefficient(self): ...\n</code></pre>"},{"location":"API/particula/logger_setup/","title":"Logger Setup","text":"<p>Particula Index / Particula / Logger Setup</p> <p>Auto-generated documentation for particula.logger_setup module.</p>"},{"location":"API/particula/logger_setup/#attributes","title":"Attributes","text":"<ul> <li> <p><code>current_dir</code> - get path of the current directory: os.path.dirname(os.path.abspath(file))</p> </li> <li> <p><code>log_dir</code> - add the logging directory to the path: os.path.join(current_dir, 'logging')</p> </li> </ul>"},{"location":"API/particula/logger_setup/#setup","title":"setup","text":"<p>Show source in logger_setup.py:65</p> <p>Setup for logging in the particula package.</p>"},{"location":"API/particula/logger_setup/#signature","title":"Signature","text":"<pre><code>def setup(): ...\n</code></pre>"},{"location":"API/particula/particle/","title":"Particle","text":"<p>Particula Index / Particula / Particle</p> <p>Auto-generated documentation for particula.particle module.</p>"},{"location":"API/particula/particle/#particle_1","title":"Particle","text":"<p>Show source in particle.py:386</p> <p>the Particle class!</p>"},{"location":"API/particula/particle/#signature","title":"Signature","text":"<pre><code>class Particle(ParticleWallLoss):\n    def __init__(self, **kwargs): ...\n</code></pre>"},{"location":"API/particula/particle/#see-also","title":"See also","text":"<ul> <li>ParticleWallLoss</li> </ul>"},{"location":"API/particula/particle/#particle_coag_prep","title":"Particle()._coag_prep","text":"<p>Show source in particle.py:410</p> <p>get all related quantities to coulomb enhancement</p>"},{"location":"API/particula/particle/#signature_1","title":"Signature","text":"<pre><code>def _coag_prep(self, other: \"Particle\"): ...\n</code></pre>"},{"location":"API/particula/particle/#particlecoagulation","title":"Particle().coagulation","text":"<p>Show source in particle.py:464</p> <p>Dimensioned particle--particle coagulation kernel</p>"},{"location":"API/particula/particle/#signature_2","title":"Signature","text":"<pre><code>def coagulation(self, other: \"Particle\" = None): ...\n</code></pre>"},{"location":"API/particula/particle/#particlecoulomb_enhancement_continuum_limit","title":"Particle().coulomb_enhancement_continuum_limit","text":"<p>Show source in particle.py:448</p> <p>Continuum limit of Coulomb enhancement for particle--particle coagulation.</p>"},{"location":"API/particula/particle/#signature_3","title":"Signature","text":"<pre><code>def coulomb_enhancement_continuum_limit(self, other: \"Particle\" = None): ...\n</code></pre>"},{"location":"API/particula/particle/#particlecoulomb_enhancement_kinetic_limit","title":"Particle().coulomb_enhancement_kinetic_limit","text":"<p>Show source in particle.py:442</p> <p>Kinetic limit of Coulomb enhancement for particle--particle cooagulation.</p>"},{"location":"API/particula/particle/#signature_4","title":"Signature","text":"<pre><code>def coulomb_enhancement_kinetic_limit(self, other: \"Particle\" = None): ...\n</code></pre>"},{"location":"API/particula/particle/#particlecoulomb_potential_ratio","title":"Particle().coulomb_potential_ratio","text":"<p>Show source in particle.py:437</p> <p>Calculates the Coulomb potential ratio.</p>"},{"location":"API/particula/particle/#signature_5","title":"Signature","text":"<pre><code>def coulomb_potential_ratio(self, other: \"Particle\" = None): ...\n</code></pre>"},{"location":"API/particula/particle/#particlediffusive_knudsen_number","title":"Particle().diffusive_knudsen_number","text":"<p>Show source in particle.py:454</p> <p>Diffusive Knudsen number.</p>"},{"location":"API/particula/particle/#signature_6","title":"Signature","text":"<pre><code>def diffusive_knudsen_number(self, other: \"Particle\" = None): ...\n</code></pre>"},{"location":"API/particula/particle/#particledimensionless_coagulation","title":"Particle().dimensionless_coagulation","text":"<p>Show source in particle.py:459</p> <p>Dimensionless particle--particle coagulation kernel.</p>"},{"location":"API/particula/particle/#signature_7","title":"Signature","text":"<pre><code>def dimensionless_coagulation(self, other: \"Particle\" = None): ...\n</code></pre>"},{"location":"API/particula/particle/#particlereduced_friction_factor","title":"Particle().reduced_friction_factor","text":"<p>Show source in particle.py:432</p> <p>Returns the reduced friction factor between two particles.</p>"},{"location":"API/particula/particle/#signature_8","title":"Signature","text":"<pre><code>def reduced_friction_factor(self, other: \"Particle\" = None): ...\n</code></pre>"},{"location":"API/particula/particle/#particlereduced_mass","title":"Particle().reduced_mass","text":"<p>Show source in particle.py:427</p> <p>Returns the reduced mass.</p>"},{"location":"API/particula/particle/#signature_9","title":"Signature","text":"<pre><code>def reduced_mass(self, other: \"Particle\" = None): ...\n</code></pre>"},{"location":"API/particula/particle/#particlecondensation","title":"ParticleCondensation","text":"<p>Show source in particle.py:255</p> <p>calculate some condensation stuff</p>"},{"location":"API/particula/particle/#signature_10","title":"Signature","text":"<pre><code>class ParticleCondensation(ParticleInstances):\n    def __init__(self, **kwargs): ...\n</code></pre>"},{"location":"API/particula/particle/#see-also_1","title":"See also","text":"<ul> <li>ParticleInstances</li> </ul>"},{"location":"API/particula/particle/#particlecondensationcondensation_redmass","title":"ParticleCondensation().condensation_redmass","text":"<p>Show source in particle.py:280</p> <p>red mass</p>"},{"location":"API/particula/particle/#signature_11","title":"Signature","text":"<pre><code>def condensation_redmass(self): ...\n</code></pre>"},{"location":"API/particula/particle/#particlecondensationfuchs_sutugin","title":"ParticleCondensation().fuchs_sutugin","text":"<p>Show source in particle.py:298</p> <p>the fuchs-sutugin correction</p>"},{"location":"API/particula/particle/#signature_12","title":"Signature","text":"<pre><code>def fuchs_sutugin(self): ...\n</code></pre>"},{"location":"API/particula/particle/#particlecondensationmolecular_enhancement","title":"ParticleCondensation().molecular_enhancement","text":"<p>Show source in particle.py:272</p> <p>molecular enhancement</p>"},{"location":"API/particula/particle/#signature_13","title":"Signature","text":"<pre><code>def molecular_enhancement(self): ...\n</code></pre>"},{"location":"API/particula/particle/#particlecondensationparticle_growth","title":"ParticleCondensation().particle_growth","text":"<p>Show source in particle.py:317</p> <p>particle growth in m/s</p>"},{"location":"API/particula/particle/#signature_14","title":"Signature","text":"<pre><code>def particle_growth(self): ...\n</code></pre>"},{"location":"API/particula/particle/#particlecondensationparticle_saturation_ratio","title":"ParticleCondensation().particle_saturation_ratio","text":"<p>Show source in particle.py:331</p> <p>Calculates the saturation ratio of the particle at its surface, accounting for the Kelvin effect.</p>"},{"location":"API/particula/particle/#returns","title":"Returns","text":"<p>float     The saturation ratio of the particle at its surface.</p>"},{"location":"API/particula/particle/#signature_15","title":"Signature","text":"<pre><code>def particle_saturation_ratio(self): ...\n</code></pre>"},{"location":"API/particula/particle/#particlecondensationvapor_flux","title":"ParticleCondensation().vapor_flux","text":"<p>Show source in particle.py:305</p> <p>vapor flux</p>"},{"location":"API/particula/particle/#signature_16","title":"Signature","text":"<pre><code>def vapor_flux(self): ...\n</code></pre>"},{"location":"API/particula/particle/#particlecondensationvapor_speed","title":"ParticleCondensation().vapor_speed","text":"<p>Show source in particle.py:289</p> <p>vapor speed</p>"},{"location":"API/particula/particle/#signature_17","title":"Signature","text":"<pre><code>def vapor_speed(self): ...\n</code></pre>"},{"location":"API/particula/particle/#particledistribution","title":"ParticleDistribution","text":"<p>Show source in particle.py:34</p> <p>starting a particle distribution from continuous pdf</p>"},{"location":"API/particula/particle/#signature_18","title":"Signature","text":"<pre><code>class ParticleDistribution(Vapor):\n    def __init__(self, **kwargs): ...\n</code></pre>"},{"location":"API/particula/particle/#see-also_2","title":"See also","text":"<ul> <li>Vapor</li> </ul>"},{"location":"API/particula/particle/#particledistributionpre_discretize","title":"ParticleDistribution().pre_discretize","text":"<p>Show source in particle.py:106</p> <p>Returns a distribution pdf of the particles</p> <p>Utilizing the utility discretize to get make a lognorm distribution via scipy.stats.lognorm.pdf:     interval: the size interval of the distribution     gsigma  : geometric standard deviation of distribution     mode    : geometric mean radius of the particles</p>"},{"location":"API/particula/particle/#signature_19","title":"Signature","text":"<pre><code>def pre_discretize(self): ...\n</code></pre>"},{"location":"API/particula/particle/#particledistributionpre_distribution","title":"ParticleDistribution().pre_distribution","text":"<p>Show source in particle.py:124</p> <p>Returns a distribution pdf of the particles</p> <p>Utilizing the utility discretize to get make a lognorm distribution via scipy.stats.lognorm.pdf:     interval: the size interval of the distribution     gsigma  : geometric standard deviation of distribution     mode    : geometric mean radius of the particles</p>"},{"location":"API/particula/particle/#signature_20","title":"Signature","text":"<pre><code>def pre_distribution(self): ...\n</code></pre>"},{"location":"API/particula/particle/#particledistributionpre_radius","title":"ParticleDistribution().pre_radius","text":"<p>Show source in particle.py:60</p> <p>Returns the radius space of the particles</p> <p>Utilizing the utility cut_rad to get 99.99% of the distribution. From this interval, radius is made on a linspace with nbins points. Note: linspace is used here to practical purposes --- often, the logspace treatment will return errors in the discretization due to the asymmetry across the interval (finer resolution for smaller particles, but much coarser resolution for larger particles).</p>"},{"location":"API/particula/particle/#signature_21","title":"Signature","text":"<pre><code>def pre_radius(self): ...\n</code></pre>"},{"location":"API/particula/particle/#particleinstances","title":"ParticleInstances","text":"<p>Show source in particle.py:137</p> <p>starting a particle distribution from single particles</p>"},{"location":"API/particula/particle/#signature_22","title":"Signature","text":"<pre><code>class ParticleInstances(ParticleDistribution):\n    def __init__(self, **kwargs): ...\n</code></pre>"},{"location":"API/particula/particle/#see-also_3","title":"See also","text":"<ul> <li>ParticleDistribution</li> </ul>"},{"location":"API/particula/particle/#particleinstancesaerodynamic_mobility","title":"ParticleInstances().aerodynamic_mobility","text":"<p>Show source in particle.py:237</p> <p>Returns a particle's aerodynamic mobility.</p>"},{"location":"API/particula/particle/#signature_23","title":"Signature","text":"<pre><code>def aerodynamic_mobility(self): ...\n</code></pre>"},{"location":"API/particula/particle/#particleinstancesdiffusion_coefficient","title":"ParticleInstances().diffusion_coefficient","text":"<p>Show source in particle.py:246</p> <p>Returns a particle's diffusion coefficient.</p>"},{"location":"API/particula/particle/#signature_24","title":"Signature","text":"<pre><code>def diffusion_coefficient(self): ...\n</code></pre>"},{"location":"API/particula/particle/#particleinstancesfriction_factor","title":"ParticleInstances().friction_factor","text":"<p>Show source in particle.py:218</p> <p>Returns a particle's friction factor.</p>"},{"location":"API/particula/particle/#signature_25","title":"Signature","text":"<pre><code>def friction_factor(self): ...\n</code></pre>"},{"location":"API/particula/particle/#particleinstancesknudsen_number","title":"ParticleInstances().knudsen_number","text":"<p>Show source in particle.py:202</p> <p>Returns particle's Knudsen number.</p>"},{"location":"API/particula/particle/#signature_26","title":"Signature","text":"<pre><code>def knudsen_number(self): ...\n</code></pre>"},{"location":"API/particula/particle/#particleinstancesparticle_area","title":"ParticleInstances().particle_area","text":"<p>Show source in particle.py:194</p> <p>Returns particle's surface area</p>"},{"location":"API/particula/particle/#signature_27","title":"Signature","text":"<pre><code>def particle_area(self): ...\n</code></pre>"},{"location":"API/particula/particle/#particleinstancesparticle_distribution","title":"ParticleInstances().particle_distribution","text":"<p>Show source in particle.py:175</p> <p>distribution</p>"},{"location":"API/particula/particle/#signature_28","title":"Signature","text":"<pre><code>def particle_distribution(self): ...\n</code></pre>"},{"location":"API/particula/particle/#particleinstancesparticle_mass","title":"ParticleInstances().particle_mass","text":"<p>Show source in particle.py:184</p> <p>Returns mass of particle.</p>"},{"location":"API/particula/particle/#signature_29","title":"Signature","text":"<pre><code>def particle_mass(self): ...\n</code></pre>"},{"location":"API/particula/particle/#particleinstancessettling_velocity","title":"ParticleInstances().settling_velocity","text":"<p>Show source in particle.py:227</p> <p>Returns a particle's settling velocity.</p>"},{"location":"API/particula/particle/#signature_30","title":"Signature","text":"<pre><code>def settling_velocity(self): ...\n</code></pre>"},{"location":"API/particula/particle/#particleinstancesslip_correction_factor","title":"ParticleInstances().slip_correction_factor","text":"<p>Show source in particle.py:210</p> <p>Returns particle's Cunningham slip correction factor.</p>"},{"location":"API/particula/particle/#signature_31","title":"Signature","text":"<pre><code>def slip_correction_factor(self): ...\n</code></pre>"},{"location":"API/particula/particle/#particlewallloss","title":"ParticleWallLoss","text":"<p>Show source in particle.py:354</p> <p>continuing...</p>"},{"location":"API/particula/particle/#signature_32","title":"Signature","text":"<pre><code>class ParticleWallLoss(ParticleCondensation):\n    def __init__(self, **kwargs): ...\n</code></pre>"},{"location":"API/particula/particle/#see-also_4","title":"See also","text":"<ul> <li>ParticleCondensation</li> </ul>"},{"location":"API/particula/particle/#particlewalllosswall_loss_coefficient","title":"ParticleWallLoss().wall_loss_coefficient","text":"<p>Show source in particle.py:374</p> <p>Returns a particle's wall loss coefficient.</p>"},{"location":"API/particula/particle/#signature_33","title":"Signature","text":"<pre><code>def wall_loss_coefficient(self): ...\n</code></pre>"},{"location":"API/particula/rates/","title":"Rates","text":"<p>Particula Index / Particula / Rates</p> <p>Auto-generated documentation for particula.rates module.</p>"},{"location":"API/particula/rates/#rates_1","title":"Rates","text":"<p>Show source in rates.py:12</p> <p>The class to calculate the rates</p>"},{"location":"API/particula/rates/#signature","title":"Signature","text":"<pre><code>class Rates:\n    def __init__(self, particle=None, lazy=True): ...\n</code></pre>"},{"location":"API/particula/rates/#rates_coag_loss_gain","title":"Rates()._coag_loss_gain","text":"<p>Show source in rates.py:40</p> <p>get both loss and gain</p>"},{"location":"API/particula/rates/#signature_1","title":"Signature","text":"<pre><code>def _coag_loss_gain(self): ...\n</code></pre>"},{"location":"API/particula/rates/#ratescoagulation_gain","title":"Rates().coagulation_gain","text":"<p>Show source in rates.py:56</p> <p>get coagulation gain rate</p>"},{"location":"API/particula/rates/#signature_2","title":"Signature","text":"<pre><code>def coagulation_gain(self): ...\n</code></pre>"},{"location":"API/particula/rates/#ratescoagulation_loss","title":"Rates().coagulation_loss","text":"<p>Show source in rates.py:48</p> <p>get the coagulation loss rate</p>"},{"location":"API/particula/rates/#signature_3","title":"Signature","text":"<pre><code>def coagulation_loss(self): ...\n</code></pre>"},{"location":"API/particula/rates/#ratescoagulation_rate","title":"Rates().coagulation_rate","text":"<p>Show source in rates.py:64</p> <p>get the coagulation rate by summing the loss and gain rates</p>"},{"location":"API/particula/rates/#signature_4","title":"Signature","text":"<pre><code>def coagulation_rate(self): ...\n</code></pre>"},{"location":"API/particula/rates/#ratescondensation_growth_rate","title":"Rates().condensation_growth_rate","text":"<p>Show source in rates.py:74</p> <p>condensation rate</p>"},{"location":"API/particula/rates/#signature_5","title":"Signature","text":"<pre><code>def condensation_growth_rate(self): ...\n</code></pre>"},{"location":"API/particula/rates/#ratescondensation_growth_speed","title":"Rates().condensation_growth_speed","text":"<p>Show source in rates.py:69</p> <p>condensation speed</p>"},{"location":"API/particula/rates/#signature_6","title":"Signature","text":"<pre><code>def condensation_growth_speed(self): ...\n</code></pre>"},{"location":"API/particula/rates/#ratesdilution_rate","title":"Rates().dilution_rate","text":"<p>Show source in rates.py:94</p> <p>dilution rate</p>"},{"location":"API/particula/rates/#signature_7","title":"Signature","text":"<pre><code>def dilution_rate(self): ...\n</code></pre>"},{"location":"API/particula/rates/#ratesnucleation_rate","title":"Rates().nucleation_rate","text":"<p>Show source in rates.py:85</p> <p>nucleation rate</p>"},{"location":"API/particula/rates/#signature_8","title":"Signature","text":"<pre><code>def nucleation_rate(self): ...\n</code></pre>"},{"location":"API/particula/rates/#ratessum_rates","title":"Rates().sum_rates","text":"<p>Show source in rates.py:107</p> <p>Sum rates, with options to disable individual rate terms.</p>"},{"location":"API/particula/rates/#arguments","title":"Arguments","text":"<p>coagulation : bool, optional     does the coagulation calcuation, by default True condensation : bool, optional     does the condensation calculation, by default True nucleation : bool, optional     does the nucleation calculation, by default True dilution : bool, optional     does the dilution calculation, by default False wall_loss : bool, optional     does the wall loss calculation, by default False</p>"},{"location":"API/particula/rates/#signature_9","title":"Signature","text":"<pre><code>def sum_rates(\n    self,\n    coagulation=True,\n    condensation=True,\n    nucleation=True,\n    dilution=False,\n    wall_loss=False,\n): ...\n</code></pre>"},{"location":"API/particula/rates/#rateswall_loss_rate","title":"Rates().wall_loss_rate","text":"<p>Show source in rates.py:101</p> <p>wall loss rate</p>"},{"location":"API/particula/rates/#signature_10","title":"Signature","text":"<pre><code>def wall_loss_rate(self): ...\n</code></pre>"},{"location":"API/particula/vapor/","title":"Vapor","text":"<p>Particula Index / Particula / Vapor</p> <p>Auto-generated documentation for particula.vapor module.</p>"},{"location":"API/particula/vapor/#vapor_1","title":"Vapor","text":"<p>Show source in vapor.py:13</p> <p>based on the Environment class</p>"},{"location":"API/particula/vapor/#signature","title":"Signature","text":"<pre><code>class Vapor(Environment):\n    def __init__(self, **kwargs): ...\n</code></pre>"},{"location":"API/particula/vapor/#see-also","title":"See also","text":"<ul> <li>Environment</li> </ul>"},{"location":"API/particula/vapor/#vapordriving_force","title":"Vapor().driving_force","text":"<p>Show source in vapor.py:42</p> <p>condensation driving force</p>"},{"location":"API/particula/vapor/#signature_1","title":"Signature","text":"<pre><code>def driving_force(self, species=None, surface_saturation_ratio=1): ...\n</code></pre>"},{"location":"API/particula/activity/","title":"Activity","text":"<p>Particula Index / Particula / Activity</p> <p>Auto-generated documentation for particula.activity module.</p>"},{"location":"API/particula/activity/#modules","title":"Modules","text":"<ul> <li>Binary Activity</li> <li>Gibbs</li> <li>Phase Separation</li> <li>Ratio</li> <li>Species Density</li> </ul>"},{"location":"API/particula/activity/binary_activity/","title":"Binary Activity","text":"<p>Particula Index / Particula / Activity / Binary Activity</p> <p>Auto-generated documentation for particula.activity.binary_activity module.</p>"},{"location":"API/particula/activity/binary_activity/#attributes","title":"Attributes","text":"<ul> <li> <p><code>FIT_LOW</code> - the fit values for the activity model: {'a1': [7.089476, -7.71186, -38.85941, -100.0], 'a2': [-0.6226781, -100.0, 3.081244e-09, 61.88812], 's': [-5.988895, 6.940689]}</p> </li> <li> <p><code>INTERPOLATE_WATER_FIT</code> - interpolation points, could be done smarter: 500</p> </li> </ul>"},{"location":"API/particula/activity/binary_activity/#activity_coefficients","title":"activity_coefficients","text":"<p>Show source in binary_activity.py:34</p> <p>Calculate the activity coefficients for water and organic matter in organic-water mixtures.</p>"},{"location":"API/particula/activity/binary_activity/#arguments","title":"Arguments","text":"<ul> <li><code>-</code> molar_mass_ratio - Ratio of the molecular weight of water to the     molecular weight of organic matter.</li> <li><code>-</code> organic_mole_fraction - Molar fraction of organic matter in the     mixture.</li> <li><code>-</code> oxygen2carbon - Oxygen to carbon ratio in the organic compound.</li> <li><code>-</code> density - Density of the mixture.</li> <li><code>-</code> functional_group - Optional functional group(s) of the organic     compound, if applicable.</li> </ul>"},{"location":"API/particula/activity/binary_activity/#returns","title":"Returns","text":"<p>A tuple containing the activity of water, activity of organic matter, mass fraction of water, and mass fraction of organic matter, gamma_water (activity coefficient), and gamma_organic (activity coefficient).</p>"},{"location":"API/particula/activity/binary_activity/#signature","title":"Signature","text":"<pre><code>def activity_coefficients(\n    molar_mass_ratio: ArrayLike,\n    organic_mole_fraction: ArrayLike,\n    oxygen2carbon: ArrayLike,\n    density: ArrayLike,\n    functional_group=None,\n) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]: ...\n</code></pre>"},{"location":"API/particula/activity/binary_activity/#bat_blending_weights","title":"bat_blending_weights","text":"<p>Show source in binary_activity.py:335</p> <p>Function to estimate the blending weights for the BAT model.</p>"},{"location":"API/particula/activity/binary_activity/#arguments_1","title":"Arguments","text":"<ul> <li><code>-</code> molar_mass_ratio - The molar mass ratio of water to organic     matter.</li> <li><code>-</code> oxygen2carbon - The oxygen to carbon ratio.</li> </ul>"},{"location":"API/particula/activity/binary_activity/#returns_1","title":"Returns","text":"<ul> <li>blending_weights : List of blending weights for the BAT model in the low, mid, and high oxygen2carbon regions.</li> </ul>"},{"location":"API/particula/activity/binary_activity/#signature_1","title":"Signature","text":"<pre><code>def bat_blending_weights(\n    molar_mass_ratio: ArrayLike, oxygen2carbon: ArrayLike\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/activity/binary_activity/#biphasic_water_activity_point","title":"biphasic_water_activity_point","text":"<p>Show source in binary_activity.py:240</p> <p>This function computes the biphasic to single phase water activity (RH*100).</p>"},{"location":"API/particula/activity/binary_activity/#arguments_2","title":"Arguments","text":"<ul> <li><code>-</code> oxygen2carbon - The oxygen to carbon ratio.</li> <li><code>-</code> hydrogen2carbon - The hydrogen to carbon ratio.</li> <li><code>-</code> molar_mass_ratio - The molar mass ratio of water to organic     matter.</li> <li><code>-</code> functional_group - Optional functional group(s) of the organic     compound, if applicable.</li> </ul>"},{"location":"API/particula/activity/binary_activity/#returns_2","title":"Returns","text":"<ul> <li><code>-</code> np.array - The RH cross point array.</li> </ul>"},{"location":"API/particula/activity/binary_activity/#signature_2","title":"Signature","text":"<pre><code>def biphasic_water_activity_point(\n    oxygen2carbon: ArrayLike,\n    hydrogen2carbon: ArrayLike,\n    molar_mass_ratio: ArrayLike,\n    functional_group: Optional[Union[list[str], str]] = None,\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/activity/binary_activity/#coefficients_c","title":"coefficients_c","text":"<p>Show source in binary_activity.py:398</p> <p>Coefficients for activity model, see Gorkowski (2019). equation S1 S2.</p>"},{"location":"API/particula/activity/binary_activity/#arguments_3","title":"Arguments","text":"<ul> <li><code>-</code> molar_mass_ratio - The molar mass ratio of water to organic     matter.</li> <li><code>-</code> oxygen2carbon - The oxygen to carbon ratio.</li> <li><code>-</code> fit_values - The fit values for the activity model.</li> </ul>"},{"location":"API/particula/activity/binary_activity/#returns_3","title":"Returns","text":"<ul> <li><code>-</code> np.ndarray - The coefficients for the activity model.</li> </ul>"},{"location":"API/particula/activity/binary_activity/#signature_3","title":"Signature","text":"<pre><code>def coefficients_c(\n    molar_mass_ratio: ArrayLike, oxygen2carbon: ArrayLike, fit_values: ArrayLike\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/activity/binary_activity/#convert_to_oh_equivalent","title":"convert_to_oh_equivalent","text":"<p>Show source in binary_activity.py:314</p> <p>just a pass through now, but will add the oh equivalent conversion</p>"},{"location":"API/particula/activity/binary_activity/#signature_4","title":"Signature","text":"<pre><code>def convert_to_oh_equivalent(\n    oxygen2carbon: ArrayLike,\n    molar_mass_ratio: ArrayLike,\n    functional_group: Optional[Union[list[str], str]] = None,\n) -&gt; Tuple[np.ndarray, np.ndarray]: ...\n</code></pre>"},{"location":"API/particula/activity/binary_activity/#fixed_water_activity","title":"fixed_water_activity","text":"<p>Show source in binary_activity.py:425</p> <p>Calculate the activity coefficients of water and organic matter in organic-water mixtures.</p> <p>This function assumes a fixed water activity value (e.g., RH = 75% corresponds to 0.75 water activity in equilibrium). It calculates the activity coefficients for different phases and determines phase separations if they occur.</p>"},{"location":"API/particula/activity/binary_activity/#arguments_4","title":"Arguments","text":"<ul> <li><code>water_activity</code> ArrayLike - An array of water activity values.</li> <li><code>molar_mass_ratio</code> ArrayLike - Array of molar mass ratios of the components.</li> <li><code>oxygen2carbon</code> ArrayLike - Array of oxygen-to-carbon ratios.</li> <li><code>density</code> ArrayLike - Array of densities of the mixture.</li> </ul>"},{"location":"API/particula/activity/binary_activity/#returns_4","title":"Returns","text":"<ul> <li><code>Tuple</code> - A tuple containing the activity coefficients for alpha and beta         phases, and the alpha phase mole fraction.        If no phase separation occurs, the beta phase values are None.</li> </ul>"},{"location":"API/particula/activity/binary_activity/#signature_5","title":"Signature","text":"<pre><code>def fixed_water_activity(\n    water_activity: ArrayLike,\n    molar_mass_ratio: ArrayLike,\n    oxygen2carbon: ArrayLike,\n    density: ArrayLike,\n) -&gt; Tuple: ...\n</code></pre>"},{"location":"API/particula/activity/binary_activity/#gibbs_mix_weight","title":"gibbs_mix_weight","text":"<p>Show source in binary_activity.py:158</p> <p>Gibbs free energy of mixing, see Gorkowski (2019), with weighted oxygen2carbon regions. Only can run one compound at a time.</p>"},{"location":"API/particula/activity/binary_activity/#arguments_5","title":"Arguments","text":"<ul> <li><code>-</code> molar_mass_ratio - The molar mass ratio of water to organic     matter.</li> <li><code>-</code> organic_mole_fraction - The fraction of organic matter.</li> <li><code>-</code> oxygen2carbon - The oxygen to carbon ratio.</li> <li><code>-</code> density - The density of the mixture.</li> <li><code>-</code> functional_group - Optional functional group(s) of the organic     compound, if applicable.</li> </ul>"},{"location":"API/particula/activity/binary_activity/#returns_5","title":"Returns","text":"<ul> <li>gibbs_mix : Gibbs energy of mixing (including 1/RT)</li> <li>derivative_gibbs : derivative of Gibbs energy with respect to</li> <li>mole fraction of organics (includes 1/RT)</li> </ul>"},{"location":"API/particula/activity/binary_activity/#signature_6","title":"Signature","text":"<pre><code>def gibbs_mix_weight(\n    molar_mass_ratio: ArrayLike,\n    organic_mole_fraction: ArrayLike,\n    oxygen2carbon: ArrayLike,\n    density: ArrayLike,\n    functional_group: Optional[str] = None,\n) -&gt; Tuple[np.ndarray, np.ndarray]: ...\n</code></pre>"},{"location":"API/particula/activity/binary_activity/#gibbs_of_mixing","title":"gibbs_of_mixing","text":"<p>Show source in binary_activity.py:98</p> <p>Calculate the Gibbs free energy of mixing for a binary mixture.</p>"},{"location":"API/particula/activity/binary_activity/#arguments_6","title":"Arguments","text":"<ul> <li><code>-</code> molar_mass_ratio - The molar mass ratio of water to organic     matter.</li> <li><code>-</code> organic_mole_fraction - The fraction of organic matter.</li> <li><code>-</code> oxygen2carbon - The oxygen to carbon ratio.</li> <li><code>-</code> density - The density of the mixture.</li> <li><code>-</code> fit_dict - A dictionary of fit values for the low oxygen2carbon region</li> </ul>"},{"location":"API/particula/activity/binary_activity/#returns_6","title":"Returns","text":"<ul> <li><code>Tuple[np.ndarray,</code> np.ndarray] - A tuple containing the Gibbs free energy of mixing and its derivative.</li> </ul>"},{"location":"API/particula/activity/binary_activity/#signature_7","title":"Signature","text":"<pre><code>def gibbs_of_mixing(\n    molar_mass_ratio: ArrayLike,\n    organic_mole_fraction: ArrayLike,\n    oxygen2carbon: ArrayLike,\n    density: ArrayLike,\n    fit_dict: dict,\n) -&gt; Tuple[np.ndarray, np.ndarray]: ...\n</code></pre>"},{"location":"API/particula/activity/gibbs/","title":"Gibbs","text":"<p>Particula Index / Particula / Activity / Gibbs</p> <p>Auto-generated documentation for particula.activity.gibbs module.</p>"},{"location":"API/particula/activity/gibbs/#gibbs_free_engery","title":"gibbs_free_engery","text":"<p>Show source in gibbs.py:6</p> <p>Calculate the gibbs free energy of the mixture. Ideal and non-ideal.</p>"},{"location":"API/particula/activity/gibbs/#arguments","title":"Arguments","text":"<ul> <li><code>organic_mole_fraction</code> np.array - A numpy array of organic mole fractions.</li> <li><code>gibbs_mix</code> np.array - A numpy array of gibbs free energy of mixing.</li> </ul>"},{"location":"API/particula/activity/gibbs/#returns","title":"Returns","text":"<ul> <li><code>gibbs_ideal</code> np.array - The ideal gibbs free energy of mixing.</li> <li><code>gibbs_real</code> np.array - The real gibbs free energy of mixing.</li> </ul>"},{"location":"API/particula/activity/gibbs/#signature","title":"Signature","text":"<pre><code>def gibbs_free_engery(organic_mole_fraction, gibbs_mix): ...\n</code></pre>"},{"location":"API/particula/activity/phase_separation/","title":"Phase Separation","text":"<p>Particula Index / Particula / Activity / Phase Separation</p> <p>Auto-generated documentation for particula.activity.phase_separation module.</p>"},{"location":"API/particula/activity/phase_separation/#find_phase_sep_index","title":"find_phase_sep_index","text":"<p>Show source in phase_separation.py:55</p> <p>This function finds phase separation using activity&gt;1 and inflections in the activity curve data. In physical systems activity can not be above one and curve should be monotonic. Or else there will be phase separation.</p>"},{"location":"API/particula/activity/phase_separation/#arguments","title":"Arguments","text":"<ul> <li><code>-</code> activity_data - A array of activity data.</li> </ul>"},{"location":"API/particula/activity/phase_separation/#returns","title":"Returns","text":"<ul> <li><code>dict</code> - A dictionary containing the following keys:<ul> <li><code>-</code> 'phase_sep_activity' - Phase separation via activity     (1 if there is phase separation, 0 otherwise)</li> <li><code>-</code> 'phase_sep_curve' - Phase separation via activity curvature     (1 if there is phase separation, 0 otherwise)</li> <li><code>-</code> 'index_phase_sep_starts' - Index where phase separation starts</li> <li><code>-</code> 'index_phase_sep_end' - Index where phase separation ends</li> </ul> </li> </ul>"},{"location":"API/particula/activity/phase_separation/#signature","title":"Signature","text":"<pre><code>def find_phase_sep_index(activity_data: ArrayLike) -&gt; dict: ...\n</code></pre>"},{"location":"API/particula/activity/phase_separation/#find_phase_separation","title":"find_phase_separation","text":"<p>Show source in phase_separation.py:137</p> <p>This function checks for phase separation in each activity curve.</p>"},{"location":"API/particula/activity/phase_separation/#arguments_1","title":"Arguments","text":"<ul> <li>activity_water (np.array): A numpy array of water activity values.</li> <li>activity_org (np.array): A numpy array of organic activity values.</li> </ul>"},{"location":"API/particula/activity/phase_separation/#returns_1","title":"Returns","text":"<ul> <li><code>dict</code> - A dictionary containing the following keys:<ul> <li><code>-</code> 'phase_sep_check' - An integer indicating whether phase separation         is present (1) or not (0).</li> <li><code>-</code> 'lower_seperation_index' - The index of the lower separation point         in the activity curve.</li> <li><code>-</code> 'upper_seperation_index' - The index of the upper separation point in         the activity curve.</li> <li><code>-</code> 'matching_upper_seperation_index' - The index where the difference         between activity_water_beta and match_a_w is greater than 0.</li> <li><code>-</code> 'lower_seperation' - The value of water activity at the lower         separation point.</li> <li><code>-</code> 'upper_seperation' - The value of water activity at the upper         separation point.</li> <li><code>-</code> 'matching_upper_seperation' - The value of water activity at the         matching upper separation point.</li> </ul> </li> </ul>"},{"location":"API/particula/activity/phase_separation/#signature_1","title":"Signature","text":"<pre><code>def find_phase_separation(\n    activity_water: ArrayLike, activity_org: ArrayLike\n) -&gt; dict: ...\n</code></pre>"},{"location":"API/particula/activity/phase_separation/#organic_water_single_phase","title":"organic_water_single_phase","text":"<p>Show source in phase_separation.py:23</p> <p>Convert the given molar mass ratio (MW water / MW organic) to a and oxygen2carbon value were above is a single phase with water and below phase separation is possible.</p>"},{"location":"API/particula/activity/phase_separation/#arguments_2","title":"Arguments","text":"<ul> <li><code>-</code> molar_mass_ratio - The molar mass ratio with respect to water.</li> </ul>"},{"location":"API/particula/activity/phase_separation/#returns_2","title":"Returns","text":"<ul> <li>The single phase cross point.</li> </ul>"},{"location":"API/particula/activity/phase_separation/#references","title":"References","text":"<ul> <li>Gorkowski, K., Preston, T. C., &amp; Zuend, A. (2019).   Relative-humidity-dependent organic aerosol thermodynamics   Via an efficient reduced-complexity model.   Atmospheric Chemistry and Physics   https://doi.org/10.5194/acp-19-13383-2019</li> </ul>"},{"location":"API/particula/activity/phase_separation/#signature_2","title":"Signature","text":"<pre><code>def organic_water_single_phase(\n    molar_mass_ratio: Union[int, float, list, np.ndarray],\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/activity/phase_separation/#q_alpha","title":"q_alpha","text":"<p>Show source in phase_separation.py:233</p> <p>This function calculates the q_alpha value using a squeezed logistic     function.</p>"},{"location":"API/particula/activity/phase_separation/#arguments_3","title":"Arguments","text":"<ul> <li>seperation_activity (np.array): A numpy array of values representing     the separation activity.</li> <li>activities (np.array): A numpy array of activity values.</li> </ul>"},{"location":"API/particula/activity/phase_separation/#returns_3","title":"Returns","text":"<ul> <li><code>np.array</code> - The q_alpha value.</li> </ul>"},{"location":"API/particula/activity/phase_separation/#notes","title":"Notes","text":"<ul> <li>The q_alpha value represents the transfer from     q_alpha ~0 to q_alpha ~1.</li> <li>The function uses a sigmoid curve parameter to calculate the     q_alpha value.</li> </ul>"},{"location":"API/particula/activity/phase_separation/#signature_3","title":"Signature","text":"<pre><code>def q_alpha(\n    seperation_activity: Union[int, float, np.ndarray], activities: ArrayLike\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/activity/ratio/","title":"Ratio","text":"<p>Particula Index / Particula / Activity / Ratio</p> <p>Auto-generated documentation for particula.activity.ratio module.</p>"},{"location":"API/particula/activity/ratio/#from_molar_mass_ratio","title":"from_molar_mass_ratio","text":"<p>Show source in ratio.py:22</p> <p>Convert the given molar mass ratio (MW water / MW organic) to a molar mass with respect to the other compound.</p>"},{"location":"API/particula/activity/ratio/#arguments","title":"Arguments","text":"<ul> <li><code>molar_mass_ratio</code> np.array - The molar mass ratio with respect to water.</li> <li><code>other_molar_mass</code> float, optional - The molar mass of the other compound.     Defaults to 18.01528.</li> </ul>"},{"location":"API/particula/activity/ratio/#returns","title":"Returns","text":"<ul> <li><code>np.array</code> - The molar mass of the organic compound.</li> </ul>"},{"location":"API/particula/activity/ratio/#signature","title":"Signature","text":"<pre><code>def from_molar_mass_ratio(molar_mass_ratio, other_molar_mass=18.01528): ...\n</code></pre>"},{"location":"API/particula/activity/ratio/#to_molar_mass_ratio","title":"to_molar_mass_ratio","text":"<p>Show source in ratio.py:4</p> <p>Convert the given molar mass to a molar mass ratio with respect to water. (MW water / MW organic)</p>"},{"location":"API/particula/activity/ratio/#arguments_1","title":"Arguments","text":"<ul> <li><code>molar_mass</code> np.array - The molar mass of the organic compound.</li> <li><code>other_molar_mass</code> float, optional - The molar mass of the other compound.     Defaults to 18.01528.</li> </ul>"},{"location":"API/particula/activity/ratio/#returns_1","title":"Returns","text":"<ul> <li><code>np.array</code> - The molar mass ratio with respect to water.</li> </ul>"},{"location":"API/particula/activity/ratio/#signature_1","title":"Signature","text":"<pre><code>def to_molar_mass_ratio(molar_mass, other_molar_mass=18.01528): ...\n</code></pre>"},{"location":"API/particula/activity/species_density/","title":"Species Density","text":"<p>Particula Index / Particula / Activity / Species Density</p> <p>Auto-generated documentation for particula.activity.species_density module.</p>"},{"location":"API/particula/activity/species_density/#organic_array","title":"organic_array","text":"<p>Show source in species_density.py:93</p> <p>Get densities for an array.</p>"},{"location":"API/particula/activity/species_density/#signature","title":"Signature","text":"<pre><code>def organic_array(\n    molar_mass,\n    oxygen2carbon,\n    hydrogen2carbon=None,\n    nitrogen2carbon=None,\n    mass_ratio_convert=False,\n): ...\n</code></pre>"},{"location":"API/particula/activity/species_density/#organic_density_estimate","title":"organic_density_estimate","text":"<p>Show source in species_density.py:12</p> <p>Function to estimate the density of organic compounds based on the simple model by Girolami (1994). The input parameters include molar mass, O:C and H:C ratios. If the H:C ratio is unknown at input, enter a negative value. The actual H:C will then be estimated based on an initial assumption of H:C = 2. The model also estimates the number of carbon atoms per molecular structure based on molar mass, O:C, and H:C. The density is then approximated by the formula of Girolami.</p> <p>Reference: Girolami, G. S.: A Simple 'Back of the Envelope' Method for Estimating the Densities and Molecular Volumes of Liquids and Solids, J. Chem. Educ., 71(11), 962, doi:10.1021/ed071p962, 1994.</p>"},{"location":"API/particula/activity/species_density/#arguments","title":"Arguments","text":"<ul> <li><code>molar_mass(float)</code> - Molar mass.</li> <li><code>oxygen2carbon</code> float - O:C ratio.</li> <li><code>hydrogen2carbon</code> float - H:C ratio. If unknown, provide a negative     value.</li> <li><code>nitrogen2carbon</code> float, optional - N:C ratio. Defaults to None.</li> </ul>"},{"location":"API/particula/activity/species_density/#returns","title":"Returns","text":"<ul> <li><code>densityEst</code> float - Estimated density in g/cm^3.</li> </ul>"},{"location":"API/particula/activity/species_density/#signature_1","title":"Signature","text":"<pre><code>def organic_density_estimate(\n    molar_mass,\n    oxygen2carbon,\n    hydrogen2carbon=None,\n    nitrogen2carbon=None,\n    mass_ratio_convert=False,\n): ...\n</code></pre>"},{"location":"API/particula/data/","title":"Data","text":"<p>Particula Index / Particula / Data</p> <p>Auto-generated documentation for particula.data module.</p>"},{"location":"API/particula/data/#modules","title":"Modules","text":"<ul> <li>Lake</li> <li>Lake Stats</li> <li>Loader</li> <li>Loader Interface</li> <li>Loader Setting Builders</li> <li>Merger</li> <li>Mixin</li> <li>Process</li> <li>Settings Generator</li> <li>Stream</li> <li>Stream Stats</li> </ul>"},{"location":"API/particula/data/lake/","title":"Lake","text":"<p>Particula Index / Particula / Data / Lake</p> <p>Auto-generated documentation for particula.data.lake module.</p>"},{"location":"API/particula/data/lake/#lake_1","title":"Lake","text":"<p>Show source in lake.py:10</p> <p>A class representing a lake which is a collection of streams.</p>"},{"location":"API/particula/data/lake/#attributes","title":"Attributes","text":"<p>streams (Dict[str, Stream]): A dictionary to hold streams with their names as keys.</p>"},{"location":"API/particula/data/lake/#signature","title":"Signature","text":"<pre><code>class Lake: ...\n</code></pre>"},{"location":"API/particula/data/lake/#lakedelitem","title":"Lake().delitem","text":"<p>Show source in lake.py:90</p> <p>Remove a stream by name. Example: del lake['stream_name']</p>"},{"location":"API/particula/data/lake/#signature_1","title":"Signature","text":"<pre><code>def __delitem__(self, key: str) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/data/lake/#lakedir","title":"Lake().dir","text":"<p>Show source in lake.py:49</p> <p>List available streams. Example: dir(lake)</p>"},{"location":"API/particula/data/lake/#signature_2","title":"Signature","text":"<pre><code>def __dir__(self) -&gt; list: ...\n</code></pre>"},{"location":"API/particula/data/lake/#lakegetattr","title":"Lake().getattr","text":"<p>Show source in lake.py:38</p> <p>Allow accessing streams as an attributes.</p>"},{"location":"API/particula/data/lake/#raises","title":"Raises","text":"<pre><code>- `AttributeError` - If the stream name is not in the lake.\n</code></pre> <ul> <li><code>Example</code> - lake.stream_name</li> </ul>"},{"location":"API/particula/data/lake/#signature_3","title":"Signature","text":"<pre><code>def __getattr__(self, name: str) -&gt; Any: ...\n</code></pre>"},{"location":"API/particula/data/lake/#lakegetitem","title":"Lake().getitem","text":"<p>Show source in lake.py:77</p> <p>Get a stream by name. Example: lake['stream_name']</p>"},{"location":"API/particula/data/lake/#signature_4","title":"Signature","text":"<pre><code>def __getitem__(self, key: str) -&gt; Any: ...\n</code></pre>"},{"location":"API/particula/data/lake/#lakeiter","title":"Lake().iter","text":"<p>Show source in lake.py:54</p> <p>Iterate over the streams in the lake. Example: [stream.header for stream in lake]\"\"</p>"},{"location":"API/particula/data/lake/#signature_5","title":"Signature","text":"<pre><code>def __iter__(self) -&gt; Iterator[Any]: ...\n</code></pre>"},{"location":"API/particula/data/lake/#lakelen","title":"Lake().len","text":"<p>Show source in lake.py:72</p> <p>Return the number of streams in the lake. Example: len(lake)</p>"},{"location":"API/particula/data/lake/#signature_6","title":"Signature","text":"<pre><code>def __len__(self) -&gt; int: ...\n</code></pre>"},{"location":"API/particula/data/lake/#lakerepr","title":"Lake().repr","text":"<p>Show source in lake.py:98</p> <p>Return a string representation of the lake. Example: print(lake)</p>"},{"location":"API/particula/data/lake/#signature_7","title":"Signature","text":"<pre><code>def __repr__(self) -&gt; str: ...\n</code></pre>"},{"location":"API/particula/data/lake/#lakesetitem","title":"Lake().setitem","text":"<p>Show source in lake.py:82</p> <p>Set a stream by name. Example: lake['stream_name'] = new_stream</p>"},{"location":"API/particula/data/lake/#signature_8","title":"Signature","text":"<pre><code>def __setitem__(self, key: str, value: Stream) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/data/lake/#see-also","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"API/particula/data/lake/#lakeadd_stream","title":"Lake().add_stream","text":"<p>Show source in lake.py:19</p> <p>Add a stream to the lake.</p>"},{"location":"API/particula/data/lake/#arguments","title":"Arguments","text":"<ul> <li><code>stream</code> Stream - The stream object to be added.</li> <li><code>name</code> str - The name of the stream.</li> </ul>"},{"location":"API/particula/data/lake/#raises_1","title":"Raises","text":"<pre><code>- `ValueError` - If the stream name is already in use or not a valid\nidentifier.\n</code></pre>"},{"location":"API/particula/data/lake/#signature_9","title":"Signature","text":"<pre><code>def add_stream(self, stream: Stream, name: str) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/data/lake/#see-also_1","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"API/particula/data/lake/#lakeitems","title":"Lake().items","text":"<p>Show source in lake.py:60</p> <p>Return an iterator over the key-value pairs.</p>"},{"location":"API/particula/data/lake/#signature_10","title":"Signature","text":"<pre><code>def items(self) -&gt; Iterator[Tuple[Any, Any]]: ...\n</code></pre>"},{"location":"API/particula/data/lake/#lakekeys","title":"Lake().keys","text":"<p>Show source in lake.py:68</p> <p>Return an iterator over the keys.</p>"},{"location":"API/particula/data/lake/#signature_11","title":"Signature","text":"<pre><code>def keys(self) -&gt; Iterator[Any]: ...\n</code></pre>"},{"location":"API/particula/data/lake/#lakesummary","title":"Lake().summary","text":"<p>Show source in lake.py:103</p> <pre><code>Return a string summary iterating over each stream\nand print Stream.header.\n</code></pre> <p>Example: lake.summary</p>"},{"location":"API/particula/data/lake/#signature_12","title":"Signature","text":"<pre><code>@property\ndef summary(self) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/data/lake/#lakevalues","title":"Lake().values","text":"<p>Show source in lake.py:64</p> <p>Return an iterator over the values.</p>"},{"location":"API/particula/data/lake/#signature_13","title":"Signature","text":"<pre><code>def values(self) -&gt; Iterator[Any]: ...\n</code></pre>"},{"location":"API/particula/data/lake_stats/","title":"Lake Stats","text":"<p>Particula Index / Particula / Data / Lake Stats</p> <p>Auto-generated documentation for particula.data.lake_stats module.</p>"},{"location":"API/particula/data/lake_stats/#average_std","title":"average_std","text":"<p>Show source in lake_stats.py:11</p> <p>Averages the data in each stream within a 'Lake' object.</p> <p>If 'clone' is True, a new 'Lake' instance is created and the averaged data is stored there. If 'clone' is False, the original 'Lake' instance is modified. The averaged output also includes the standard deviation of the data.</p>"},{"location":"API/particula/data/lake_stats/#examples","title":"Examples","text":"<pre><code># Example lake with two streams, each containing numerical data\nlake_data = Lake({'stream1': [1, 2, 3], 'stream2': [4, 5, 6]})\n# Average over a 60-second interval without creating a new lake.\naveraged_lake = average_std(lake_data, 60, clone=False)\nprint(averaged_lake)\nLake({'stream1': [2], 'stream2': [5]})\n</code></pre>"},{"location":"API/particula/data/lake_stats/#arguments","title":"Arguments","text":"<ul> <li><code>lake</code> - The lake data structure containing multiple streams.</li> <li><code>average_interval</code> - The interval over which to average the data.     Default is 60.</li> <li><code>new_time_array</code> - A new array of time points at which to compute the     averages.</li> <li><code>clone</code> - Indicates whether to modify the original lake or return a new     one. Default is True.</li> </ul>"},{"location":"API/particula/data/lake_stats/#returns","title":"Returns","text":"<ul> <li><code>Lake</code> - A lake instance with averaged data.</li> </ul>"},{"location":"API/particula/data/lake_stats/#signature","title":"Signature","text":"<pre><code>def average_std(\n    lake: Lake,\n    average_interval: Union[float, int] = 60,\n    new_time_array: Optional[NDArray[np.float64]] = None,\n    clone: bool = True,\n) -&gt; Lake: ...\n</code></pre>"},{"location":"API/particula/data/lake_stats/#see-also","title":"See also","text":"<ul> <li>Lake</li> </ul>"},{"location":"API/particula/data/loader/","title":"Loader","text":"<p>Particula Index / Particula / Data / Loader</p> <p>Auto-generated documentation for particula.data.loader module.</p>"},{"location":"API/particula/data/loader/#data_format_checks","title":"data_format_checks","text":"<p>Show source in loader.py:154</p> <p>Validate and format raw data according to specified checks.</p>"},{"location":"API/particula/data/loader/#arguments","title":"Arguments","text":"<ul> <li><code>data</code> - List of strings containing the raw data to be checked.</li> <li><code>data_checks</code> - Dictionary specifying the format checks to apply,     such as character limits, character counts, and rows to skip.</li> </ul>"},{"location":"API/particula/data/loader/#returns","title":"Returns","text":"<p>A list of strings containing the validated and formatted data.</p>"},{"location":"API/particula/data/loader/#raises","title":"Raises","text":"<ul> <li><code>TypeError</code> - If <code>data</code> is not provided as a list.</li> </ul>"},{"location":"API/particula/data/loader/#examples","title":"Examples","text":"Validate line based on counts<pre><code>data = ['row 1', 'row 2', 'row 3']\ndata_checks = {\n    \"characters\": [0, 10],\n    \"char_counts\": {\",\": 2, \"/\": 0, \":\": 0},\n    \"skip_rows\": 0,\n    \"skip_end\": 0\n}\nformatted_data = data_format_checks(data, data_checks)\nprint(formatted_data)\n['row 2']\n</code></pre>"},{"location":"API/particula/data/loader/#signature","title":"Signature","text":"<pre><code>def data_format_checks(data: List[str], data_checks: dict) -&gt; List[str]: ...\n</code></pre>"},{"location":"API/particula/data/loader/#data_raw_loader","title":"data_raw_loader","text":"<p>Show source in loader.py:23</p> <p>Loads raw data from file.</p> <p>Load raw data from a file at the specified file path and return it as a list of strings. Attempts to handle UTF-8, UTF-16, and UTF-32 encodings. Defaults to UTF-8 if no byte order mark (BOM) is found.</p>"},{"location":"API/particula/data/loader/#arguments_1","title":"Arguments","text":"<ul> <li><code>file_path</code> str - The file path of the file to read.</li> </ul>"},{"location":"API/particula/data/loader/#returns_1","title":"Returns","text":"<ul> <li><code>list</code> - The raw data read from the file as a list of strings.</li> </ul>"},{"location":"API/particula/data/loader/#examples_1","title":"Examples","text":"Load my_file.txt<pre><code>data = data_raw_loader('my_file.txt')\nLoading data from: my_file.txt\nprint(data)\n['line 1', 'line 2', 'line 3']\n</code></pre>"},{"location":"API/particula/data/loader/#signature_1","title":"Signature","text":"<pre><code>def data_raw_loader(file_path: str) -&gt; list: ...\n</code></pre>"},{"location":"API/particula/data/loader/#filter_list","title":"filter_list","text":"<p>Show source in loader.py:72</p> <p>Filter rows from a list of strings based on character counts.</p> <p>Each row must contain a specified number of certain characters to pass the filter. The <code>char_counts</code> dictionary specifies the characters to count and the exact count required for each character in each row.</p>"},{"location":"API/particula/data/loader/#arguments_2","title":"Arguments","text":"<ul> <li><code>data</code> - A list of strings to be filtered.</li> <li><code>char_counts</code> - A dictionary specifying character counts for filtering.     The keys are the characters to count, and the values are the     required counts for each character in a row.</li> </ul>"},{"location":"API/particula/data/loader/#returns_2","title":"Returns","text":"<p>A new list of strings containing only the rows that meet the character count requirements.</p>"},{"location":"API/particula/data/loader/#raises_1","title":"Raises","text":"<ul> <li><code>UserWarning</code> - If more than 90% of the rows are filtered out, indicating     that the filter may be too strict based on the specified     character(s).</li> </ul>"},{"location":"API/particula/data/loader/#examples_2","title":"Examples","text":"Filter rows based on comma counts<pre><code>data = ['apple,banana,orange',\n         'pear,kiwi,plum', 'grapefruit,lemon']\nchar_counts = {',': 2}\nfiltered_data = filter_list(data, char_counts)\nprint(filtered_data)\n['apple,banana,orange', 'pear,kiwi,plum']\n</code></pre>"},{"location":"API/particula/data/loader/#signature_2","title":"Signature","text":"<pre><code>def filter_list(data: List[str], char_counts: dict) -&gt; List[str]: ...\n</code></pre>"},{"location":"API/particula/data/loader/#general_data_formatter","title":"general_data_formatter","text":"<p>Show source in loader.py:454</p> <p>Format and sample data to extract time and data streams.</p>"},{"location":"API/particula/data/loader/#arguments_3","title":"Arguments","text":"<ul> <li><code>data</code> - List of strings containing the raw data.</li> <li><code>data_checks</code> - Dictionary specifying validation rules for the data.</li> <li><code>data_column</code> - List of indices identifying the columns containing the     data.</li> <li><code>time_column</code> - Index or list of indices identifying the column(s)     containing the time information.</li> <li><code>time_format</code> - String specifying the format of the time information,     e.g., '%Y-%m-%d %H:%M:%S'.</li> <li><code>delimiter</code> - String used to separate columns in the data. Default is ','.</li> <li><code>header_row</code> - Index of the row containing column names. Default is 0.</li> <li><code>date_offset</code> - Optional string to add as a fixed offset to the timestamp.     Default is None.</li> <li><code>seconds_shift</code> - Number of seconds to add to the timestamp. Default is 0.</li> <li><code>timezone_identifier</code> - Timezone identifier for the timestamps.     Default is 'UTC'.</li> </ul>"},{"location":"API/particula/data/loader/#returns_3","title":"Returns","text":"<p>Tuple (np.ndarray, np.ndarray):     - The first array contains the epoch times.     - The second array contains the corresponding data values.</p>"},{"location":"API/particula/data/loader/#signature_3","title":"Signature","text":"<pre><code>def general_data_formatter(\n    data: list,\n    data_checks: dict,\n    data_column: list,\n    time_column: Union[int, List[int]],\n    time_format: str,\n    delimiter: str = \",\",\n    header_row: int = 0,\n    date_offset: Optional[str] = None,\n    seconds_shift: int = 0,\n    timezone_identifier: str = \"UTC\",\n) -&gt; Tuple[np.ndarray, np.ndarray]: ...\n</code></pre>"},{"location":"API/particula/data/loader/#get_files_in_folder_with_size","title":"get_files_in_folder_with_size","text":"<p>Show source in loader.py:675</p> <p>Returns a list of files in the specified folder and subfolder that match the given filename pattern and have a size greater than the specified minimum size.</p>"},{"location":"API/particula/data/loader/#arguments_4","title":"Arguments","text":"<p>path : str     The path to the parent folder. subfolder : str     The name of the subfolder containing the files. filename_regex : str     A regular expression pattern for matching the filenames. min_size : int, optional     The minimum file size in bytes (default is 10).</p>"},{"location":"API/particula/data/loader/#returns_4","title":"Returns","text":"<p>Tuple(List[str], List[str], List[int]): - <code>-</code> file_list - The filenames that match the pattern and size criteria. - <code>-</code> full_path - The full paths to the files. - <code>-</code> file_size - The file sizes in bytes.</p>"},{"location":"API/particula/data/loader/#signature_4","title":"Signature","text":"<pre><code>def get_files_in_folder_with_size(\n    path: str, subfolder: str, filename_regex: str, min_size: int = 10\n) -&gt; Tuple[List[str], List[str], List[int]]: ...\n</code></pre>"},{"location":"API/particula/data/loader/#keyword_to_index","title":"keyword_to_index","text":"<p>Show source in loader.py:521</p> <p>Convert a keyword representing a column position in the header to its index.</p> <p>This function processes a keyword that can either be an integer index or a string corresponding to a column name. If the keyword is an integer, it is treated as the direct index of the column. If the keyword is a string, the function searches the header list for the column name and returns its index.</p>"},{"location":"API/particula/data/loader/#arguments_5","title":"Arguments","text":"<ul> <li><code>keyword</code> - The keyword representing the column's position in the header.     It can be an integer index or a string specifying the column name.</li> <li><code>header</code> - A list of column names (header) in the data.</li> </ul>"},{"location":"API/particula/data/loader/#returns_5","title":"Returns","text":"<p>The index of the column in the header.</p>"},{"location":"API/particula/data/loader/#raises_2","title":"Raises","text":"<ul> <li><code>ValueError</code> - If the keyword is a string and is not found in the header,     or if the keyword is an integer but is out of the header's     index range.</li> </ul>"},{"location":"API/particula/data/loader/#signature_5","title":"Signature","text":"<pre><code>def keyword_to_index(keyword: Union[str, int], header: List[str]) -&gt; int: ...\n</code></pre>"},{"location":"API/particula/data/loader/#load_lake","title":"load_lake","text":"<p>Show source in loader.py:956</p> <p>Load a lake object by loading individual streams from separate pickle files.</p>"},{"location":"API/particula/data/loader/#arguments_6","title":"Arguments","text":"<ul> <li><code>path</code> - Path to load pickle files.</li> <li><code>suffix_name</code> - Suffix to add to pickle file names. The default is None.</li> <li><code>folder</code> - Folder to load pickle files from. The default is 'output'.</li> </ul>"},{"location":"API/particula/data/loader/#returns_6","title":"Returns","text":"<ul> <li><code>Lake</code> - Reconstructed Lake object.</li> </ul>"},{"location":"API/particula/data/loader/#signature_6","title":"Signature","text":"<pre><code>def load_lake(\n    path: str, suffix_name: Optional[str] = None, folder: str = \"output\"\n) -&gt; Lake: ...\n</code></pre>"},{"location":"API/particula/data/loader/#see-also","title":"See also","text":"<ul> <li>Lake</li> </ul>"},{"location":"API/particula/data/loader/#load_stream","title":"load_stream","text":"<p>Show source in loader.py:845</p> <p>Load stream object from a pickle file.</p>"},{"location":"API/particula/data/loader/#args","title":"Args","text":"<p>path : str     Path to load pickle file. suffix_name : str, optional     Suffix to add to pickle file name. The default is None. folder : str, optional     Folder to load pickle file from. The default is 'output'.</p>"},{"location":"API/particula/data/loader/#returns_7","title":"Returns","text":"<p>Stream     Loaded Stream object.</p>"},{"location":"API/particula/data/loader/#signature_7","title":"Signature","text":"<pre><code>def load_stream(\n    path: str, suffix_name: Optional[str] = None, folder: str = \"output\"\n) -&gt; Stream: ...\n</code></pre>"},{"location":"API/particula/data/loader/#see-also_1","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"API/particula/data/loader/#netcdf_data_1d_load","title":"netcdf_data_1d_load","text":"<p>Show source in loader.py:1067</p> <p>Given a netCDF file path and settings, returns a tuple containing the epoch time, header, and data as a numpy array. We do apply the mask to the data, and fill the masked values with nan.</p>"},{"location":"API/particula/data/loader/#arguments_7","title":"Arguments","text":"<ul> <li><code>file_path</code> str - The path to the netCDF file.</li> <li><code>settings</code> dict - A dictionary containing settings for the instrument.</li> </ul>"},{"location":"API/particula/data/loader/#returns_8","title":"Returns","text":"<p>Tuple[np.ndarray, list, np.ndarray]: A tuple containing the epoch time, header, and data as a numpy array.</p> <p>Errors:     - <code>KeyError</code> - If the settings dictionary does not contain 'data_1d'.</p>"},{"location":"API/particula/data/loader/#signature_8","title":"Signature","text":"<pre><code>def netcdf_data_1d_load(\n    file_path: str, settings: dict\n) -&gt; Tuple[np.ndarray, list, np.ndarray]: ...\n</code></pre>"},{"location":"API/particula/data/loader/#netcdf_data_2d_load","title":"netcdf_data_2d_load","text":"<p>Show source in loader.py:1123</p> <p>Given a netCDF file path and settings, returns a tuple containing the epoch time, header, and data as a numpy array. We do apply the mask to the data, and fill the masked values with nan.</p>"},{"location":"API/particula/data/loader/#arguments_8","title":"Arguments","text":"<ul> <li><code>file_path</code> str - The path to the netCDF file.</li> <li><code>settings</code> dict - A dictionary containing settings for the instrument.</li> </ul>"},{"location":"API/particula/data/loader/#returns_9","title":"Returns","text":"<p>Tuple[np.ndarray, list, np.ndarray]: A tuple containing the epoch time, header, and data as a numpy array.</p> <p>Errors:     - <code>KeyError</code> - If the settings dictionary does not contain 'data_2d'.</p>"},{"location":"API/particula/data/loader/#signature_9","title":"Signature","text":"<pre><code>def netcdf_data_2d_load(\n    file_path: str, settings: dict\n) -&gt; Tuple[np.ndarray, list, np.ndarray]: ...\n</code></pre>"},{"location":"API/particula/data/loader/#netcdf_get_epoch_time","title":"netcdf_get_epoch_time","text":"<p>Show source in loader.py:1041</p> <p>Given a netCDF file path and settings, returns an array of epoch times in seconds as a float.</p> <p>Currently only uses ARM 1.2 netCDF files (base_time + time_offset)</p>"},{"location":"API/particula/data/loader/#arguments_9","title":"Arguments","text":"<ul> <li><code>file_path</code> str - The path to the netCDF file.</li> <li><code>settings</code> dict - A dictionary containing settings for the instrument.</li> </ul>"},{"location":"API/particula/data/loader/#returns_10","title":"Returns","text":"<ul> <li><code>np.ndarray</code> - An array of epoch times, in seconds as a float.</li> </ul>"},{"location":"API/particula/data/loader/#signature_10","title":"Signature","text":"<pre><code>def netcdf_get_epoch_time(file_path: str, settings: dict) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/data/loader/#netcdf_info_print","title":"netcdf_info_print","text":"<p>Show source in loader.py:1172</p> <p>Prints information about a netCDF file. Useful for generating settings dictionaries.</p>"},{"location":"API/particula/data/loader/#arguments_10","title":"Arguments","text":"<ul> <li><code>file_path</code> str - The path to the netCDF file.</li> <li><code>file_return</code> bool - If True, returns the netCDF file object.     Defaults to False.</li> </ul>"},{"location":"API/particula/data/loader/#returns_11","title":"Returns","text":"<ul> <li><code>nc_file</code> netCDF4.Dataset - The netCDF file object.</li> </ul>"},{"location":"API/particula/data/loader/#signature_11","title":"Signature","text":"<pre><code>def netcdf_info_print(file_path, file_return=False): ...\n</code></pre>"},{"location":"API/particula/data/loader/#non_standard_date_location","title":"non_standard_date_location","text":"<p>Show source in loader.py:647</p> <p>Extracts the date from a non-standard location in the data.</p>"},{"location":"API/particula/data/loader/#arguments_11","title":"Arguments","text":"<ul> <li><code>data</code> - A list of strings representing the data.</li> <li><code>date_location</code> - A dictionary specifying the method for extracting the     date from the data.         - <code>-</code> 'file_header_block' - The date is located in the file header             block, and its position is specified by the 'row',             'delimiter', and 'index' keys.</li> </ul>"},{"location":"API/particula/data/loader/#returns_12","title":"Returns","text":"<ul> <li><code>str</code> - The date extracted from the specified location in the data.</li> </ul>"},{"location":"API/particula/data/loader/#raises_3","title":"Raises","text":"<ul> <li><code>ValueError</code> - If an unsupported or invalid method is specified in     date_location.</li> </ul>"},{"location":"API/particula/data/loader/#signature_12","title":"Signature","text":"<pre><code>def non_standard_date_location(data: list, date_location: dict) -&gt; str: ...\n</code></pre>"},{"location":"API/particula/data/loader/#parse_time_column","title":"parse_time_column","text":"<p>Show source in loader.py:223</p> <p>Parse the time column(s) from a data line and return the timestamp.</p>"},{"location":"API/particula/data/loader/#arguments_12","title":"Arguments","text":"<ul> <li><code>time_column</code> - Index or list of indices identifying the column(s)     containing the time information.</li> <li><code>time_format</code> - String specifying the format of the time information,     e.g., '%Y-%m-%d %H:%M:%S'.</li> <li><code>line</code> - A numpy array representing the data line to parse.</li> <li><code>date_offset</code> - Optional string representing a fixed offset to add     to the timestamp. Default is None.</li> <li><code>seconds_shift</code> - Number of seconds to add to the timestamp. Default is 0.</li> <li><code>timezone_identifier</code> - Timezone identifier for the timestamp.     Default is 'UTC'.</li> </ul>"},{"location":"API/particula/data/loader/#returns_13","title":"Returns","text":"<p>A float representing the timestamp in seconds since the epoch.</p>"},{"location":"API/particula/data/loader/#raises_4","title":"Raises","text":"<ul> <li><code>ValueError</code> - If the specified time column or format is invalid.</li> </ul>"},{"location":"API/particula/data/loader/#signature_13","title":"Signature","text":"<pre><code>def parse_time_column(\n    time_column: Union[int, List[int]],\n    time_format: str,\n    line: np.ndarray,\n    date_offset: Optional[str] = None,\n    seconds_shift: int = 0,\n    timezone_identifier: str = \"UTC\",\n) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/data/loader/#replace_list","title":"replace_list","text":"<p>Show source in loader.py:119</p> <p>Replace characters in each string of a list based on a replacement dictionary.</p> <p>Each character specified in the <code>replace_dict</code> will be replaced with the corresponding value in every string in the input list.</p>"},{"location":"API/particula/data/loader/#arguments_13","title":"Arguments","text":"<ul> <li><code>data</code> - A list of strings in which the characters will be replaced.</li> <li><code>replace_dict</code> - A dictionary specifying character replacements.     The keys are the characters to be replaced, and the values are the     replacement characters or strings.</li> </ul>"},{"location":"API/particula/data/loader/#returns_14","title":"Returns","text":"<p>A new list of strings with the replacements applied.</p>"},{"location":"API/particula/data/loader/#examples_3","title":"Examples","text":"Replace characters in a list of strings<pre><code>data = ['apple[banana]orange', '[pear] kiwi plum']\nreplace_dict = {'[': '', ']': ''}\nreplaced_data = replace_list(data, replace_dict)\nprint(replaced_data)\n['applebananaorange', 'pear kiwi plum']\n</code></pre>"},{"location":"API/particula/data/loader/#signature_14","title":"Signature","text":"<pre><code>def replace_list(data: List[str], replace_dict: Dict[str, str]) -&gt; List[str]: ...\n</code></pre>"},{"location":"API/particula/data/loader/#sample_data","title":"sample_data","text":"<p>Show source in loader.py:291</p> <p>Extract time and data streams from input data.</p>"},{"location":"API/particula/data/loader/#arguments_14","title":"Arguments","text":"<ul> <li><code>data</code> - List of strings containing the input data.</li> <li><code>time_column</code> - Index or list of indices indicating the column(s)     containing the time values.</li> <li><code>time_format</code> - Format string specifying the time format, e.g.,     '%Y-%m-%d %H:%M:%S'.</li> <li><code>data_columns</code> - List of indices identifying the columns containing     the data values.</li> <li><code>delimiter</code> - Character used to separate columns in the input data.</li> <li><code>date_offset</code> - Optional string representing an offset to apply to     the date, in the format 'days:hours:minutes:seconds'.     Default is None.</li> <li><code>seconds_shift</code> - Number of seconds to shift the timestamps. Default is 0.</li> <li><code>timezone_identifier</code> - Timezone of the data. Default is 'UTC'.</li> </ul>"},{"location":"API/particula/data/loader/#returns_15","title":"Returns","text":"<p>Tuple (np.ndarray, np.ndarray):     - <code>-</code> <code>epoch_time</code> - A 1-D numpy array of epoch times.     - <code>-</code> <code>data_array</code> - A 2-D numpy array of data values.</p>"},{"location":"API/particula/data/loader/#raises_5","title":"Raises","text":"<ul> <li><code>ValueError</code> - If the data is not in the expected format or     if no matching data value is found.</li> </ul>"},{"location":"API/particula/data/loader/#signature_15","title":"Signature","text":"<pre><code>def sample_data(\n    data: List[str],\n    time_column: Union[int, List[int]],\n    time_format: str,\n    data_columns: List[int],\n    delimiter: str,\n    date_offset: Optional[str] = None,\n    seconds_shift: int = 0,\n    timezone_identifier: str = \"UTC\",\n) -&gt; Tuple[np.ndarray, np.ndarray]: ...\n</code></pre>"},{"location":"API/particula/data/loader/#save_lake","title":"save_lake","text":"<p>Show source in loader.py:884</p> <p>Save each stream in the lake as separate pickle files.</p>"},{"location":"API/particula/data/loader/#arguments_15","title":"Arguments","text":"<ul> <li><code>path</code> - Path to save pickle files.</li> <li><code>lake</code> - Lake object to be saved.</li> <li><code>suffix_name</code> - Suffix to add to pickle file names. The default is None.</li> <li><code>folder</code> - Folder to save pickle files. The default is 'output'.</li> </ul>"},{"location":"API/particula/data/loader/#signature_16","title":"Signature","text":"<pre><code>def save_lake(\n    path: str, lake: Lake, suffix_name: Optional[str] = None, folder: str = \"output\"\n) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/data/loader/#see-also_2","title":"See also","text":"<ul> <li>Lake</li> </ul>"},{"location":"API/particula/data/loader/#save_stream","title":"save_stream","text":"<p>Show source in loader.py:796</p> <p>Save stream object as a pickle file.</p>"},{"location":"API/particula/data/loader/#args_1","title":"Args","text":"<p>stream : Stream     Stream object to be saved. path : str     Path to save pickle file. suffix_name : str, optional     Suffix to add to pickle file name. The default is None.</p>"},{"location":"API/particula/data/loader/#signature_17","title":"Signature","text":"<pre><code>def save_stream(\n    path: str, stream: Stream, suffix_name: Optional[str] = None, folder: str = \"output\"\n) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/data/loader/#see-also_3","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"API/particula/data/loader/#save_stream_to_csv","title":"save_stream_to_csv","text":"<p>Show source in loader.py:723</p> <p>Save stream object as a CSV file, with an option to include formatted time.</p>"},{"location":"API/particula/data/loader/#arguments_16","title":"Arguments","text":"<p>stream : Stream     Stream object to be saved. path : str     Path where the CSV file will be saved. suffix_name : str, optional     Suffix to add to CSV file name. The default is None. folder : str, optional     Subfolder within path to save the CSV file. The default is 'output'. include_time : bool, optional     Whether to include time data in the first column. The default is True. include_iso_datatime : bool, optional     Whether to include ISO formatted datetime in the second column.     The default is True. The format is ISO 8601,     '2021-01-01T00:00:00Z'.</p>"},{"location":"API/particula/data/loader/#signature_18","title":"Signature","text":"<pre><code>def save_stream_to_csv(\n    stream: Stream,\n    path: str,\n    suffix_name: Optional[str] = None,\n    folder: str = \"output\",\n    include_time: bool = True,\n) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/data/loader/#see-also_4","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"API/particula/data/loader/#sizer_data_formatter","title":"sizer_data_formatter","text":"<p>Show source in loader.py:558</p> <p>Format data from a particle sizer into structured arrays.</p>"},{"location":"API/particula/data/loader/#arguments_17","title":"Arguments","text":"<ul> <li><code>data</code> - List of raw data strings to be formatted.</li> <li><code>data_checks</code> - Dictionary specifying validation rules for the data.</li> <li><code>data_sizer_reader</code> - Dictionary containing mappings for interpreting     the sizer data format.</li> <li><code>time_column</code> - Index or list of indices indicating the position of     the time column(s) in the data.</li> <li><code>time_format</code> - Format string for parsing time information in the data.</li> <li><code>delimiter</code> - Delimiter used to separate values in the data.     Default is ','.</li> <li><code>header_row</code> - Row index of the header containing column names.     Default is 0.</li> <li><code>date_offset</code> - Optional string representing an offset to add to     timestamps. Default is None.</li> <li><code>seconds_shift</code> - Number of seconds to shift the timestamps.     Default is 0.</li> <li><code>timezone_identifier</code> - Timezone identifier for the data timestamps.     Default is 'UTC'.</li> </ul>"},{"location":"API/particula/data/loader/#returns_16","title":"Returns","text":"<p>Tuple(np.ndarray, np.ndarray, list):     - A numpy array of epoch times.     - A numpy array of Dp header values.     - A list of numpy arrays representing the data.</p>"},{"location":"API/particula/data/loader/#signature_19","title":"Signature","text":"<pre><code>def sizer_data_formatter(\n    data: List[str],\n    data_checks: Dict[str, Any],\n    data_sizer_reader: Dict[str, str],\n    time_column: Union[int, List[int]],\n    time_format: str,\n    delimiter: str = \",\",\n    header_row: int = 0,\n    date_offset: Optional[str] = None,\n    seconds_shift: int = 0,\n    timezone_identifier: str = \"UTC\",\n) -&gt; Tuple[np.ndarray, np.ndarray, list]: ...\n</code></pre>"},{"location":"API/particula/data/loader_interface/","title":"Loader Interface","text":"<p>Particula Index / Particula / Data / Loader Interface</p> <p>Auto-generated documentation for particula.data.loader_interface module.</p>"},{"location":"API/particula/data/loader_interface/#get_1d_stream","title":"get_1d_stream","text":"<p>Show source in loader_interface.py:226</p> <p>Loads and formats a 1D data stream from a file and initializes or updates a Stream object.</p>"},{"location":"API/particula/data/loader_interface/#arguments","title":"Arguments","text":"<p>file_path : str     The path of the file to load data from. first_pass : bool     Whether this is the first time data is being loaded. If True, the     stream is initialized.     If False, raises an error as only one file can be loaded. settings : dict     A dictionary containing data formatting settings such as data checks,     column names,     time format, delimiter, and timezone information. stream : Stream, optional     An instance of Stream class to be updated with loaded data. Defaults     to a new Stream object.</p>"},{"location":"API/particula/data/loader_interface/#returns","title":"Returns","text":"<p>Stream     The Stream object updated with the loaded data and corresponding time     information.</p>"},{"location":"API/particula/data/loader_interface/#raises","title":"Raises","text":"<p>ValueError     If <code>first_pass</code> is False, indicating data has already been loaded. TypeError     If <code>settings</code> is not a dictionary. FileNotFoundError     If the file specified by <code>file_path</code> does not exist. KeyError     If any required keys are missing in the <code>settings</code> dictionary.</p>"},{"location":"API/particula/data/loader_interface/#signature","title":"Signature","text":"<pre><code>def get_1d_stream(\n    file_path: str,\n    settings: dict,\n    first_pass: bool = True,\n    stream: Optional[Stream] = None,\n) -&gt; Stream: ...\n</code></pre>"},{"location":"API/particula/data/loader_interface/#see-also","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"API/particula/data/loader_interface/#get_2d_stream","title":"get_2d_stream","text":"<p>Show source in loader_interface.py:338</p> <p>Initializes a 2D stream using the settings in the DataLake object.</p>"},{"location":"API/particula/data/loader_interface/#arguments_1","title":"Arguments","text":"<pre><code>- `key` *str* - The key of the stream to initialise.\n- `path` *str* - The path of the file to load data from.\n- `first_pass` *bool* - Whether this is the first time loading data.\n</code></pre>"},{"location":"API/particula/data/loader_interface/#returns_1","title":"Returns","text":"<pre><code>None.\n</code></pre>"},{"location":"API/particula/data/loader_interface/#signature_1","title":"Signature","text":"<pre><code>def get_2d_stream(\n    file_path: str,\n    settings: dict,\n    first_pass: bool = True,\n    stream: Optional[Stream] = None,\n) -&gt; Stream: ...\n</code></pre>"},{"location":"API/particula/data/loader_interface/#see-also_1","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"API/particula/data/loader_interface/#get_new_files","title":"get_new_files","text":"<p>Show source in loader_interface.py:13</p> <p>Scan a directory for new files based on import settings and stream status.</p> <p>This function looks for files in a specified path using import settings. It compares the new list of files with a pre-loaded list in the stream object to determine which files are new. The comparison is made based on file names and sizes. It returns a tuple with the paths of new files, a boolean indicating if this was the first pass, and a list of file information for new files.</p>"},{"location":"API/particula/data/loader_interface/#arguments_2","title":"Arguments","text":"<p>path : str     The top-level directory path to scan for files. import_settings : dict     A dictionary with 'relative_data_folder', 'filename_regex',     and 'MIN_SIZE_BYTES' as keys     used to specify the subfolder path and the regex pattern for filtering     file names. It should also include 'min_size' key to specify the     minimum size of the files to be considered. loaded_list : list of lists     A list of lists with file names and sizes that have already been     loaded. The default is None. If None, it will be assumed that no     files have been loaded.</p>"},{"location":"API/particula/data/loader_interface/#returns_2","title":"Returns","text":"<p>tuple of (list, bool, list)     A tuple containing a list of full paths of new files, a boolean     indicating if no previous files were loaded (True if it's the first     pass), and a list of lists with new file names and sizes.</p>"},{"location":"API/particula/data/loader_interface/#raises_1","title":"Raises","text":"<p>YourErrorType     Explanation of when and why your error is raised and what it means.</p>"},{"location":"API/particula/data/loader_interface/#signature_2","title":"Signature","text":"<pre><code>def get_new_files(\n    path: str, import_settings: dict, loaded_list: Optional[list] = None\n) -&gt; tuple: ...\n</code></pre>"},{"location":"API/particula/data/loader_interface/#load_files_interface","title":"load_files_interface","text":"<p>Show source in loader_interface.py:109</p> <p>Load files into a stream object based on settings.</p>"},{"location":"API/particula/data/loader_interface/#arguments_3","title":"Arguments","text":"<p>path : str     The top-level directory path to scan for folders of data. folder_settings : dict     A dictionary with keys corresponding to the stream names and values     corresponding to the settings for each stream. The settings can     be generated using the settings_generator function. stream : Stream, optional     An instance of Stream class to be updated with loaded data. Defaults     to a new Stream object. - <code>sub_sample</code> - int, optional     sub-sample only the first n files. Defaults to None.</p>"},{"location":"API/particula/data/loader_interface/#returns_3","title":"Returns","text":"<p>Stream     The Stream object updated with the loaded data.</p>"},{"location":"API/particula/data/loader_interface/#signature_3","title":"Signature","text":"<pre><code>def load_files_interface(\n    path: str,\n    settings: dict,\n    stream: Optional[Stream] = None,\n    sub_sample: Optional[int] = None,\n) -&gt; Stream: ...\n</code></pre>"},{"location":"API/particula/data/loader_interface/#see-also_2","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"API/particula/data/loader_interface/#load_folders_interface","title":"load_folders_interface","text":"<p>Show source in loader_interface.py:185</p> <p>Load files into a lake object based on settings.</p>"},{"location":"API/particula/data/loader_interface/#arguments_4","title":"Arguments","text":"<p>path : str     The top-level directory path to scan for folders of data. folder_settings : dict     A dictionary with keys corresponding to the stream names and values     corresponding to the settings for each stream. The settings can     be generated using the settings_generator function. lake : Lake, optional     An instance of Lake class to be updated with loaded data. Defaults     to a new Lake object.</p>"},{"location":"API/particula/data/loader_interface/#returns_4","title":"Returns","text":"<p>Lake     The Lake object updated with the loaded data streams.</p>"},{"location":"API/particula/data/loader_interface/#signature_4","title":"Signature","text":"<pre><code>def load_folders_interface(\n    path: str, folder_settings: dict, lake: Optional[Lake] = None\n) -&gt; Lake: ...\n</code></pre>"},{"location":"API/particula/data/loader_interface/#see-also_3","title":"See also","text":"<ul> <li>Lake</li> </ul>"},{"location":"API/particula/data/loader_setting_builders/","title":"Loader Setting Builders","text":"<p>Particula Index / Particula / Data / Loader Setting Builders</p> <p>Auto-generated documentation for particula.data.loader_setting_builders module.</p>"},{"location":"API/particula/data/loader_setting_builders/#datachecksbuilder","title":"DataChecksBuilder","text":"<p>Show source in loader_setting_builders.py:100</p> <p>Builder class for constructing the data checks dictionary.</p>"},{"location":"API/particula/data/loader_setting_builders/#signature","title":"Signature","text":"<pre><code>class DataChecksBuilder(\n    BuilderABC,\n    ChecksCharactersMixin,\n    ChecksCharCountsMixin,\n    ChecksReplaceCharsMixin,\n    ChecksSkipRowsMixin,\n    ChecksSkipEndMixin,\n):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/data/loader_setting_builders/#see-also","title":"See also","text":"<ul> <li>BuilderABC</li> <li>ChecksCharCountsMixin</li> <li>ChecksCharactersMixin</li> <li>ChecksReplaceCharsMixin</li> <li>ChecksSkipEndMixin</li> <li>ChecksSkipRowsMixin</li> </ul>"},{"location":"API/particula/data/loader_setting_builders/#datachecksbuilderbuild","title":"DataChecksBuilder().build","text":"<p>Show source in loader_setting_builders.py:125</p> <p>Build and return the data checks dictionary.</p>"},{"location":"API/particula/data/loader_setting_builders/#signature_1","title":"Signature","text":"<pre><code>def build(self) -&gt; Dict[str, Any]: ...\n</code></pre>"},{"location":"API/particula/data/loader_setting_builders/#loader1dsettingsbuilder","title":"Loader1DSettingsBuilder","text":"<p>Show source in loader_setting_builders.py:33</p> <p>Builder class for creating settings for loading and checking 1D data from CSV files.</p>"},{"location":"API/particula/data/loader_setting_builders/#signature_2","title":"Signature","text":"<pre><code>class Loader1DSettingsBuilder(\n    BuilderABC,\n    RelativeFolderMixin,\n    FilenameRegexMixin,\n    FileMinSizeBytesMixin,\n    HeaderRowMixin,\n    DataChecksMixin,\n    DataColumnMixin,\n    DataHeaderMixin,\n    TimeColumnMixin,\n    TimeFormatMixin,\n    DelimiterMixin,\n    TimeShiftSecondsMixin,\n    TimezoneIdentifierMixin,\n):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/data/loader_setting_builders/#see-also_1","title":"See also","text":"<ul> <li>BuilderABC</li> <li>DataChecksMixin</li> <li>DataColumnMixin</li> <li>DataHeaderMixin</li> <li>DelimiterMixin</li> <li>FileMinSizeBytesMixin</li> <li>FilenameRegexMixin</li> <li>HeaderRowMixin</li> <li>RelativeFolderMixin</li> <li>TimeColumnMixin</li> <li>TimeFormatMixin</li> <li>TimeShiftSecondsMixin</li> <li>TimezoneIdentifierMixin</li> </ul>"},{"location":"API/particula/data/loader_setting_builders/#loader1dsettingsbuilderbuild","title":"Loader1DSettingsBuilder().build","text":"<p>Show source in loader_setting_builders.py:80</p> <p>Build and return the settings dictionary for 1D data loading.</p>"},{"location":"API/particula/data/loader_setting_builders/#signature_3","title":"Signature","text":"<pre><code>def build(self) -&gt; Dict[str, Any]: ...\n</code></pre>"},{"location":"API/particula/data/loader_setting_builders/#loadersizersettingsbuilder","title":"LoaderSizerSettingsBuilder","text":"<p>Show source in loader_setting_builders.py:164</p> <p>Builder class for creating settings for loading and checking sizer 1D and 2D data from CSV files.</p>"},{"location":"API/particula/data/loader_setting_builders/#signature_4","title":"Signature","text":"<pre><code>class LoaderSizerSettingsBuilder(\n    BuilderABC,\n    RelativeFolderMixin,\n    FilenameRegexMixin,\n    FileMinSizeBytesMixin,\n    HeaderRowMixin,\n    DataChecksMixin,\n    DataColumnMixin,\n    DataHeaderMixin,\n    TimeColumnMixin,\n    TimeFormatMixin,\n    DelimiterMixin,\n    TimeShiftSecondsMixin,\n    TimezoneIdentifierMixin,\n    SizerDataReaderMixin,\n):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/data/loader_setting_builders/#see-also_2","title":"See also","text":"<ul> <li>BuilderABC</li> <li>DataChecksMixin</li> <li>DataColumnMixin</li> <li>DataHeaderMixin</li> <li>DelimiterMixin</li> <li>FileMinSizeBytesMixin</li> <li>FilenameRegexMixin</li> <li>HeaderRowMixin</li> <li>RelativeFolderMixin</li> <li>SizerDataReaderMixin</li> <li>TimeColumnMixin</li> <li>TimeFormatMixin</li> <li>TimeShiftSecondsMixin</li> <li>TimezoneIdentifierMixin</li> </ul>"},{"location":"API/particula/data/loader_setting_builders/#loadersizersettingsbuilderbuild","title":"LoaderSizerSettingsBuilder().build","text":"<p>Show source in loader_setting_builders.py:214</p> <p>Build and return the two dictionaries for 1D and 2D sizer data loading .</p>"},{"location":"API/particula/data/loader_setting_builders/#signature_5","title":"Signature","text":"<pre><code>def build(self) -&gt; Tuple[Dict[str, Any], Dict[str, Any]]: ...\n</code></pre>"},{"location":"API/particula/data/loader_setting_builders/#sizerdatareaderbuilder","title":"SizerDataReaderBuilder","text":"<p>Show source in loader_setting_builders.py:136</p> <p>Builder class for constructing the sizer data reader dictionary.</p>"},{"location":"API/particula/data/loader_setting_builders/#signature_6","title":"Signature","text":"<pre><code>class SizerDataReaderBuilder(\n    BuilderABC,\n    SizerConcentrationConvertFromMixin,\n    SizerStartKeywordMixin,\n    SizerEndKeywordMixin,\n):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/data/loader_setting_builders/#see-also_3","title":"See also","text":"<ul> <li>BuilderABC</li> <li>SizerConcentrationConvertFromMixin</li> <li>SizerEndKeywordMixin</li> <li>SizerStartKeywordMixin</li> </ul>"},{"location":"API/particula/data/loader_setting_builders/#sizerdatareaderbuilderbuild","title":"SizerDataReaderBuilder().build","text":"<p>Show source in loader_setting_builders.py:154</p> <p>Build and return the sizer data reader dictionary.</p>"},{"location":"API/particula/data/loader_setting_builders/#signature_7","title":"Signature","text":"<pre><code>def build(self) -&gt; Dict[str, Any]: ...\n</code></pre>"},{"location":"API/particula/data/merger/","title":"Merger","text":"<p>Particula Index / Particula / Data / Merger</p> <p>Auto-generated documentation for particula.data.merger module.</p>"},{"location":"API/particula/data/merger/#combine_data","title":"combine_data","text":"<p>Show source in merger.py:15</p> <p>\" Merge or adds processed data together. Accounts for data shape miss matches and duplicate timestamps. If the data is a different shape than the existing data, it will be reshaped to match the existing data.</p>"},{"location":"API/particula/data/merger/#arguments","title":"Arguments","text":"<p>data : np.array     Existing data stream. time : np.array     Time array for the existing data. header_list : List[str]     List of headers for the existing data. data_new : np.array     Processed data to add to the data stream. time_new : np.array     Time array for the new data. header_new : List[str]     List of headers for the new data.</p>"},{"location":"API/particula/data/merger/#returns","title":"Returns","text":"<p>Tuple[np.array, List[str], Dict[str, int]]     A tuple containing the updated data stream, the updated header list,     and     a dictionary mapping the header names to their corresponding indices in     the data stream.</p>"},{"location":"API/particula/data/merger/#signature","title":"Signature","text":"<pre><code>def combine_data(\n    data: np.ndarray,\n    time: np.ndarray,\n    header_list: list,\n    data_new: np.ndarray,\n    time_new: np.ndarray,\n    header_new: list,\n) -&gt; Tuple[np.ndarray, list]: ...\n</code></pre>"},{"location":"API/particula/data/merger/#stream_add_data","title":"stream_add_data","text":"<p>Show source in merger.py:99</p> <p>Adds a new data stream and corresponding time stream to the existing data.</p>"},{"location":"API/particula/data/merger/#args","title":"Args","text":"<p>stream : object     A Stream object, containing the existing data. new_time : np.ndarray (m,)     An array of time values for the new data stream. new_data : np.ndarray     An array of data values for the new data stream. header_check : bool, optional     If True, checks whether the header in the new data matches the     header in the existing data. Defaults to False. new_header : list of str, optional     A list of header names for the new data stream. Required if     header_check is True.</p>"},{"location":"API/particula/data/merger/#returns_1","title":"Returns","text":"<p>stream : object     A Stream object, containing the updated data.</p>"},{"location":"API/particula/data/merger/#raises","title":"Raises","text":"<p>ValueError     If header_check is True and header is not provided or     header does not match the existing header.</p>"},{"location":"API/particula/data/merger/#notes","title":"Notes","text":"<p>If header_check is True, the method checks whether the header in the new data matches the header in the existing data. If they do not match, the method attempts to merge the headers and updates the header dictionary.</p> <p>If header_check is False or the headers match, the new data is appended to the existing data.</p> <p>The function also checks whether the time stream is increasing, and if not, sorts the time stream and corresponding data.</p>"},{"location":"API/particula/data/merger/#signature_1","title":"Signature","text":"<pre><code>def stream_add_data(\n    stream: Stream,\n    time_new: np.ndarray,\n    data_new: np.ndarray,\n    header_check: Optional[bool] = False,\n    header_new: Optional[list] = None,\n) -&gt; Stream: ...\n</code></pre>"},{"location":"API/particula/data/merger/#see-also","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"API/particula/data/mixin/","title":"Mixin","text":"<p>Particula Index / Particula / Data / Mixin</p> <p>Auto-generated documentation for particula.data.mixin module.</p>"},{"location":"API/particula/data/mixin/#checkscharcountsmixin","title":"ChecksCharCountsMixin","text":"<p>Show source in mixin.py:430</p> <p>Mixin class for setting the character counts for data checks.</p>"},{"location":"API/particula/data/mixin/#signature","title":"Signature","text":"<pre><code>class ChecksCharCountsMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#checkscharcountsmixinset_char_counts","title":"ChecksCharCountsMixin().set_char_counts","text":"<p>Show source in mixin.py:436</p> <p>Set the required character counts for the data checks. This is the number of times a character should appear in a line of the data file, for it to be considered valid, and proceed with data parsing.</p>"},{"location":"API/particula/data/mixin/#arguments","title":"Arguments","text":"<ul> <li><code>char_counts</code> - Dictionary of characters and their required counts     for the data checks. The keys are the characters, and the     values are the required counts. e.g. {\",\": 4, \":\": 0}.</li> </ul>"},{"location":"API/particula/data/mixin/#examples","title":"Examples","text":"Set number of commas<pre><code>char_counts = {\",\": 4}\n# valid line: '1,2,3,4'\n# invalid line removed: '1,2,3'\n</code></pre> Filter out specific words<pre><code>char_counts = {\"Temp1 Error\": 0}\n# valid line: '23.4, 0.1, 0.2, no error'\n# invalid line removed: '23.4, 0.1, 0.2, Temp1 Error'\n</code></pre>"},{"location":"API/particula/data/mixin/#signature_1","title":"Signature","text":"<pre><code>def set_char_counts(self, char_counts: dict[str, int]): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#checkscharactersmixin","title":"ChecksCharactersMixin","text":"<p>Show source in mixin.py:395</p> <p>Mixin class for setting the character length range for data checks.</p>"},{"location":"API/particula/data/mixin/#signature_2","title":"Signature","text":"<pre><code>class ChecksCharactersMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#checkscharactersmixinset_characters","title":"ChecksCharactersMixin().set_characters","text":"<p>Show source in mixin.py:401</p> <p>Set the character length range for the data checks. This is how many characters are expected a line of the data file, for it to be considered valid, and proceed with data parsing.</p>"},{"location":"API/particula/data/mixin/#arguments_1","title":"Arguments","text":"<ul> <li><code>characters</code> - List of one (or two) integers for the minimum (and     maximum) number of characters expected in a line of the data     file. e.g. [10, 100] for 10 to 100 characters. or [10] for     10 or more characters.</li> </ul>"},{"location":"API/particula/data/mixin/#examples_1","title":"Examples","text":"Set minimum characters<pre><code>characters = [5]\n# valid line: '1,2,3,4,5'\n# invalid line: '1,2'\n</code></pre> Set range of characters<pre><code>characters = [5, 10]\n# valid line: '1,2,3,4,5'\n# invalid line: '1,2,3,4,5,6,7,8,9,10,11'\n# invalid line: '1,2'\n</code></pre>"},{"location":"API/particula/data/mixin/#signature_3","title":"Signature","text":"<pre><code>def set_characters(self, characters: list[int]): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#checksreplacecharsmixin","title":"ChecksReplaceCharsMixin","text":"<p>Show source in mixin.py:508</p> <p>Mixin class for setting the characters to replace in the data lines.</p>"},{"location":"API/particula/data/mixin/#signature_4","title":"Signature","text":"<pre><code>class ChecksReplaceCharsMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#checksreplacecharsmixinset_replace_chars","title":"ChecksReplaceCharsMixin().set_replace_chars","text":"<p>Show source in mixin.py:514</p> <p>Set the characters to replace in the data lines.</p> <p>This is useful to replace unwanted characters from the data lines before converting the data to the required format. Each key in the replace_dict represents the character to replace, and the corresponding value is the replacement target.</p>"},{"location":"API/particula/data/mixin/#arguments_2","title":"Arguments","text":"<ul> <li><code>replace_dict</code> dict - Dictionary with keys as characters to replace     and values as the replacement targets.</li> </ul>"},{"location":"API/particula/data/mixin/#examples_2","title":"Examples","text":"Replace brackets with empty string<pre><code>replace_dict = {\"[\": \"\", \"]\": \"\"}\n# data: '[1], [2], [3]' -&gt; '1, 2, 3'\n</code></pre> Replace spaces with underscores<pre><code>replace_dict = {\" \": \"_\"}\n# data: '1, 2, 3' -&gt; '1,_2,_3'\n</code></pre> Replace multiple characters<pre><code>replace_dict = {\"[\": \"\", \"]\": \"\", \"\n\": \" \"}\n# data: '[1]\n[2]\n[3]' -&gt; '1 2 3'\n</code></pre>"},{"location":"API/particula/data/mixin/#returns","title":"Returns","text":"<ul> <li><code>self</code> - The instance of the class to allow for method chaining.</li> </ul>"},{"location":"API/particula/data/mixin/#references","title":"References","text":"<p>Python str.replace</p>"},{"location":"API/particula/data/mixin/#signature_5","title":"Signature","text":"<pre><code>def set_replace_chars(self, replace_chars: dict[str, str]): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#checksskipendmixin","title":"ChecksSkipEndMixin","text":"<p>Show source in mixin.py:486</p> <p>Mixin class for setting the number of rows to skip at the end.</p>"},{"location":"API/particula/data/mixin/#signature_6","title":"Signature","text":"<pre><code>class ChecksSkipEndMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#checksskipendmixinset_skip_end","title":"ChecksSkipEndMixin().set_skip_end","text":"<p>Show source in mixin.py:492</p> <p>Set the number of rows to skip at the end of the file.</p>"},{"location":"API/particula/data/mixin/#arguments_3","title":"Arguments","text":"<ul> <li><code>skip_end</code> int - Number of rows to skip at the end of the file.</li> </ul>"},{"location":"API/particula/data/mixin/#examples_3","title":"Examples","text":"Skip last row<pre><code>skip_end = 10\n# Skip the last 10 row of the file.\n</code></pre>"},{"location":"API/particula/data/mixin/#signature_7","title":"Signature","text":"<pre><code>def set_skip_end(self, skip_end: int = 0): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#checksskiprowsmixin","title":"ChecksSkipRowsMixin","text":"<p>Show source in mixin.py:463</p> <p>Mixin class for setting the number of rows to skip at the beginning.</p>"},{"location":"API/particula/data/mixin/#signature_8","title":"Signature","text":"<pre><code>class ChecksSkipRowsMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#checksskiprowsmixinset_skip_rows","title":"ChecksSkipRowsMixin().set_skip_rows","text":"<p>Show source in mixin.py:469</p> <p>Set the number of rows to skip at the beginning of the file.</p>"},{"location":"API/particula/data/mixin/#arguments_4","title":"Arguments","text":"<ul> <li><code>skip_rows</code> int - Number of rows to skip at the beginning of the     file.</li> </ul>"},{"location":"API/particula/data/mixin/#examples_4","title":"Examples","text":"Skip the first 2 rows<pre><code>skip_rows = 2\n# Skip the first 2 rows of the file.\n</code></pre>"},{"location":"API/particula/data/mixin/#signature_9","title":"Signature","text":"<pre><code>def set_skip_rows(self, skip_rows: int = 0): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#datachecksmixin","title":"DataChecksMixin","text":"<p>Show source in mixin.py:120</p> <p>Mixin class for setting the data checks.</p>"},{"location":"API/particula/data/mixin/#signature_10","title":"Signature","text":"<pre><code>class DataChecksMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#datachecksmixinset_data_checks","title":"DataChecksMixin().set_data_checks","text":"<p>Show source in mixin.py:126</p> <p>Dictionary of data checks to perform on the loaded data.</p>"},{"location":"API/particula/data/mixin/#arguments_5","title":"Arguments","text":"<ul> <li><code>checks</code> dict - Dictionary of data checks to perform on the loaded     data. The keys are the names of the checks, and the values are     the parameters for the checks.</li> </ul>"},{"location":"API/particula/data/mixin/#signature_11","title":"Signature","text":"<pre><code>def set_data_checks(self, data_checks: Dict[str, Any]): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#datacolumnmixin","title":"DataColumnMixin","text":"<p>Show source in mixin.py:138</p> <p>Mixin class for setting the data column.</p>"},{"location":"API/particula/data/mixin/#signature_12","title":"Signature","text":"<pre><code>class DataColumnMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#datacolumnmixinset_data_column","title":"DataColumnMixin().set_data_column","text":"<p>Show source in mixin.py:144</p> <p>The data columns for the data files to load. Build with <code>DataChecksBuilder</code>.</p>"},{"location":"API/particula/data/mixin/#arguments_6","title":"Arguments","text":"<ul> <li><code>data_columns</code> - List of column numbers or names for the data columns     to load from the data files. The columns are indexed from 0.     e.g. [3, 5] or ['data 1', 'data 3'].</li> </ul>"},{"location":"API/particula/data/mixin/#examples_5","title":"Examples","text":"Single data column, index<pre><code>data_columns = [3]\n# header: 'Time, Temp, data 1, data 2, data 3'\n# line: '2021-01-01T12:00:00, 25.8, 1.2, 3.4' # load 1.2\n</code></pre> Single data column, name<pre><code>data_columns = ['data 1']\n# header: 'Time, Temp, data 1, data 3, data 5'\n# line: '2021-01-01T12:00:00, 25.8, 1.2, 3.4' # load 25.8\n</code></pre> Multiple data columns, index<pre><code>data_columns = [1, 3]\n# header: 'Time, Temp, data 1, data 3, data 5'\n# line: '2021-01-01T12:00:00, 25.8, 1.2, 3.4' # load 25.8, 3.4\n</code></pre> Multiple data columns, name<pre><code>data_columns = ['Temp', 'data 3']\n# header: 'Time, Temp, data 1, data 3, data 5'\n# line: '2021-01-01T12:00:00, 25.8, 1.2, 3.4' # load 25.8, 3.4\n</code></pre>"},{"location":"API/particula/data/mixin/#signature_13","title":"Signature","text":"<pre><code>def set_data_column(self, data_columns: Union[List[str], List[int]]): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#dataheadermixin","title":"DataHeaderMixin","text":"<p>Show source in mixin.py:182</p> <p>Mixin class for setting the data header for the Stream.</p>"},{"location":"API/particula/data/mixin/#signature_14","title":"Signature","text":"<pre><code>class DataHeaderMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#dataheadermixinset_data_header","title":"DataHeaderMixin().set_data_header","text":"<p>Show source in mixin.py:188</p> <p>Set the Stream headers corresponding to the data columns. This is to improve the readability of the Stream data. The headers should be in the same order as the data columns. These are also the same headers that will be written to the output file or csv.</p>"},{"location":"API/particula/data/mixin/#arguments_7","title":"Arguments","text":"<ul> <li><code>headers</code> - List of headers corresponding to the data     columns to load. e.g. ['data-1[m/s]', 'data_3[L]'].</li> </ul>"},{"location":"API/particula/data/mixin/#examples_6","title":"Examples","text":"Single header<pre><code>headers = ['data-1[m/s]']\n# Name the only data column as 'data-1[m/s]'.\n</code></pre> Multiple headers<pre><code>headers = ['data-1[m/s]', 'data-3[L]']\n# Name the data columns as 'data-1[m/s]' and 'data-3[L]'.\n</code></pre>"},{"location":"API/particula/data/mixin/#signature_15","title":"Signature","text":"<pre><code>def set_data_header(self, headers: List[str]): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#delimitermixin","title":"DelimiterMixin","text":"<p>Show source in mixin.py:296</p> <p>Mixin class for setting the delimiter.</p>"},{"location":"API/particula/data/mixin/#signature_16","title":"Signature","text":"<pre><code>class DelimiterMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#delimitermixinset_delimiter","title":"DelimiterMixin().set_delimiter","text":"<p>Show source in mixin.py:302</p> <p>Set the delimiter for the data files to load.</p>"},{"location":"API/particula/data/mixin/#arguments_8","title":"Arguments","text":"<ul> <li><code>delimiter</code> str - Delimiter for the data columns in the data files.     e.g. ',' for CSV files or ' ' for tab-separated files.</li> </ul>"},{"location":"API/particula/data/mixin/#examples_7","title":"Examples","text":"CSV delimiter<pre><code>delimiter = \",\"\n# CSV file with columns separated by commas.\n</code></pre> Tab delimiter<pre><code>delimiter = \"   \"\n# Tab-separated file with columns separated by tabs.\n</code></pre> Space delimiter<pre><code>delimiter = \" \"\n# Space-separated file with columns separated by spaces.\n</code></pre>"},{"location":"API/particula/data/mixin/#signature_17","title":"Signature","text":"<pre><code>def set_delimiter(self, delimiter: str): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#fileminsizebytesmixin","title":"FileMinSizeBytesMixin","text":"<p>Show source in mixin.py:74</p> <p>Mixin class for setting the minimum file size in bytes.</p>"},{"location":"API/particula/data/mixin/#signature_18","title":"Signature","text":"<pre><code>class FileMinSizeBytesMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#fileminsizebytesmixinset_file_min_size_bytes","title":"FileMinSizeBytesMixin().set_file_min_size_bytes","text":"<p>Show source in mixin.py:80</p> <p>Set the minimum file size in bytes for the data files to load.</p>"},{"location":"API/particula/data/mixin/#arguments_9","title":"Arguments","text":"<ul> <li><code>size</code> int - Minimum file size in bytes. Default is 10000 bytes.</li> </ul>"},{"location":"API/particula/data/mixin/#signature_19","title":"Signature","text":"<pre><code>def set_file_min_size_bytes(self, size: int = 10000): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#filenameregexmixin","title":"FilenameRegexMixin","text":"<p>Show source in mixin.py:37</p> <p>Mixin class for setting the filename regex.</p>"},{"location":"API/particula/data/mixin/#signature_20","title":"Signature","text":"<pre><code>class FilenameRegexMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#filenameregexmixinset_filename_regex","title":"FilenameRegexMixin().set_filename_regex","text":"<p>Show source in mixin.py:43</p> <p>Set the filename regex for the data files to load.</p>"},{"location":"API/particula/data/mixin/#arguments_10","title":"Arguments","text":"<ul> <li><code>regex</code> str - Regular expression for the filenames, e.g.     'data_*.csv'.</li> </ul>"},{"location":"API/particula/data/mixin/#examples_8","title":"Examples","text":"Match all files<pre><code>regex = \".*\"\n# Match all files in the folder.\n</code></pre> Match CSV files<pre><code>regex = \".*.csv\"\n# Match all CSV files in the folder.\n</code></pre> Match specific files<pre><code>regex = \"data_*.csv\"\n# Match files starting with 'data_' and ending with '.csv'.\n</code></pre>"},{"location":"API/particula/data/mixin/#references_1","title":"References","text":"<p>Explore Regex Python Regex Doc</p>"},{"location":"API/particula/data/mixin/#signature_21","title":"Signature","text":"<pre><code>def set_filename_regex(self, regex: str): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#headerrowmixin","title":"HeaderRowMixin","text":"<p>Show source in mixin.py:90</p> <p>Mixin class for setting the header row.</p>"},{"location":"API/particula/data/mixin/#signature_22","title":"Signature","text":"<pre><code>class HeaderRowMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#headerrowmixinset_header_row","title":"HeaderRowMixin().set_header_row","text":"<p>Show source in mixin.py:96</p> <p>Set the header row for the data files to load.</p>"},{"location":"API/particula/data/mixin/#arguments_11","title":"Arguments","text":"<ul> <li><code>row</code> int - Row number for the header row in the data file, indexed     from 0.</li> </ul>"},{"location":"API/particula/data/mixin/#examples_9","title":"Examples","text":"Header row at the top<pre><code>row = 0\n# line 0: 'Time, Temp, data 1, data 2, data 3'\n</code></pre> Header is third row<pre><code>row = 2\n# line 0: \"Experiment 1\"\n# line 1: \"Date: 2021-01-01\"\n# line 2: 'Time, Temp, data 1, data 2, data 3'\n</code></pre>"},{"location":"API/particula/data/mixin/#signature_23","title":"Signature","text":"<pre><code>def set_header_row(self, row: int): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#relativefoldermixin","title":"RelativeFolderMixin","text":"<p>Show source in mixin.py:8</p> <p>Mixin class for setting the relative data folder.</p>"},{"location":"API/particula/data/mixin/#signature_24","title":"Signature","text":"<pre><code>class RelativeFolderMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#relativefoldermixinset_relative_data_folder","title":"RelativeFolderMixin().set_relative_data_folder","text":"<p>Show source in mixin.py:14</p> <p>Set the relative data folder for the folder with the data loading.</p>"},{"location":"API/particula/data/mixin/#arguments_12","title":"Arguments","text":"<ul> <li><code>folder</code> str - Relative path to the data folder.     e.g. 'data_folder'. Where the data folder is located in     project_path/data_folder.</li> </ul>"},{"location":"API/particula/data/mixin/#examples_10","title":"Examples","text":"Set data folder<pre><code>folder = \"data_folder\"\n# Set the data folder to 'data_folder'.\n</code></pre> Set a subfolder<pre><code>folder = \"subfolder/data_folder\"\n# Set the data folder to 'subfolder/data_folder'.\n</code></pre>"},{"location":"API/particula/data/mixin/#signature_25","title":"Signature","text":"<pre><code>def set_relative_data_folder(self, folder: str): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#sizerconcentrationconvertfrommixin","title":"SizerConcentrationConvertFromMixin","text":"<p>Show source in mixin.py:617</p> <p>Mixin class for setting to convert the sizer concentration to a different scale.</p>"},{"location":"API/particula/data/mixin/#signature_26","title":"Signature","text":"<pre><code>class SizerConcentrationConvertFromMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#sizerconcentrationconvertfrommixinset_sizer_concentration_convert_from","title":"SizerConcentrationConvertFromMixin().set_sizer_concentration_convert_from","text":"<p>Show source in mixin.py:624</p> <p>Set to convert the sizer concentration from dw or (pmf) scale to dN/dlogDp scale.</p>"},{"location":"API/particula/data/mixin/#arguments_13","title":"Arguments","text":"<ul> <li><code>convert_from</code> - Conversion flag to convert the sizer concentration     from dw or (pmf) scale to dN/dlogDp scale. The option is only     \"dw\" all other values are ignored.</li> </ul>"},{"location":"API/particula/data/mixin/#examples_11","title":"Examples","text":"Convert from dw scale<pre><code>convert_from = \"dw\"\n# Convert the sizer concentration from dw scale to dN/dlogDp scale.\n</code></pre> Convert Ignored<pre><code>convert_from = \"pmf\"\n# Ignored, no conversion is performed, when loading the sizer data.\n</code></pre>"},{"location":"API/particula/data/mixin/#signature_27","title":"Signature","text":"<pre><code>def set_sizer_concentration_convert_from(self, convert_from: Optional[str] = None): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#sizerdatareadermixin","title":"SizerDataReaderMixin","text":"<p>Show source in mixin.py:651</p> <p>Mixin class for the dictionary of the sizer data reader settings.</p>"},{"location":"API/particula/data/mixin/#signature_28","title":"Signature","text":"<pre><code>class SizerDataReaderMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#sizerdatareadermixinset_data_sizer_reader","title":"SizerDataReaderMixin().set_data_sizer_reader","text":"<p>Show source in mixin.py:657</p> <p>Dictionary of the sizer data reader settings for the data files. Build with <code>SizerDataReaderBuilder</code>.</p>"},{"location":"API/particula/data/mixin/#arguments_14","title":"Arguments","text":"<ul> <li><code>data_sizer_reader</code> - Dictionary of the sizer data reader settings     for the data files. The keys are the names of the settings,     and the values are the parameters for the settings.</li> </ul>"},{"location":"API/particula/data/mixin/#signature_29","title":"Signature","text":"<pre><code>def set_data_sizer_reader(self, data_sizer_reader: Dict[str, Any]): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#sizerendkeywordmixin","title":"SizerEndKeywordMixin","text":"<p>Show source in mixin.py:586</p> <p>Mixin class for setting the end key for the sizer data.</p>"},{"location":"API/particula/data/mixin/#signature_30","title":"Signature","text":"<pre><code>class SizerEndKeywordMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#sizerendkeywordmixinset_sizer_end_keyword","title":"SizerEndKeywordMixin().set_sizer_end_keyword","text":"<p>Show source in mixin.py:592</p> <p>Set the end keyword for the sizer data, to identify the end of the sizer data block in the data files. This can be a string or an integer (column index) to identify the end of the sizer data block.</p>"},{"location":"API/particula/data/mixin/#arguments_15","title":"Arguments","text":"<ul> <li><code>end_keyword</code> - End key for the sizer data in the data files.     e.g. '789.3' or -3 for the 3<sup>rd</sup> column from the end.</li> </ul>"},{"location":"API/particula/data/mixin/#examples_12","title":"Examples","text":"End key as a string<pre><code>end_key = \"789.3\"\n# header: '... 689.1, 750.2, 789.3, Total Conc, Comments'\n</code></pre> End key as a column index<pre><code>end_key = -3\n# header: '... 689.1, 750.2, 789.3, Total Conc, Comments'\n</code></pre>"},{"location":"API/particula/data/mixin/#signature_31","title":"Signature","text":"<pre><code>def set_sizer_end_keyword(self, end_key: Union[str, int]): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#sizerstartkeywordmixin","title":"SizerStartKeywordMixin","text":"<p>Show source in mixin.py:555</p> <p>Mixin class for setting the start key for the sizer data.</p>"},{"location":"API/particula/data/mixin/#signature_32","title":"Signature","text":"<pre><code>class SizerStartKeywordMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#sizerstartkeywordmixinset_sizer_start_keyword","title":"SizerStartKeywordMixin().set_sizer_start_keyword","text":"<p>Show source in mixin.py:561</p> <p>Set the start keyword for the sizer data, to identify the start of the sizer data block in the data files. This can be a string or an integer (column index) to identify the start of the sizer data block.</p>"},{"location":"API/particula/data/mixin/#arguments_16","title":"Arguments","text":"<ul> <li><code>start_keyword</code> - Start key for the sizer data in the data files.     e.g. '25.8' or 3 for the 4<sup>th</sup> column</li> </ul>"},{"location":"API/particula/data/mixin/#examples_13","title":"Examples","text":"Start key as a string<pre><code>start_key = \"35.8\"\n# header: 'Time, Temp, 35.8, 36.0, 36.2, ...'\n</code></pre> Start key as a column index<pre><code>start_key = 2\n# header: 'Time, Temp, 35.8, 36.0, 36.2, ...'\n</code></pre>"},{"location":"API/particula/data/mixin/#signature_33","title":"Signature","text":"<pre><code>def set_sizer_start_keyword(self, start_key: Union[str, int]): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#timecolumnmixin","title":"TimeColumnMixin","text":"<p>Show source in mixin.py:213</p> <p>Mixin class for setting the time column.</p>"},{"location":"API/particula/data/mixin/#signature_34","title":"Signature","text":"<pre><code>class TimeColumnMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#timecolumnmixinset_time_column","title":"TimeColumnMixin().set_time_column","text":"<p>Show source in mixin.py:219</p> <p>The time column for the data files to load. The time column is used to convert the time data to an Unix-Epoch timestamp.</p>"},{"location":"API/particula/data/mixin/#arguments_17","title":"Arguments","text":"<ul> <li><code>columns</code> - List of column indexes for the time columns to     load from the data files. The columns are indexed from 0.     e.g. [0] or [1, 2] to combine 1 and 2 columns.</li> </ul>"},{"location":"API/particula/data/mixin/#examples_14","title":"Examples","text":"Single time column<pre><code>columns = [0]\n# Load the time data from the first column.\n# line: '2021-01-01T12:00:00, 1.2, 3.4'\n</code></pre> Multiple time columns<pre><code>columns = [1, 2]\n# Load the time data from the second and third columns.\n# line: '1.2, 2021-01-01, 12:00:00'\n</code></pre>"},{"location":"API/particula/data/mixin/#signature_35","title":"Signature","text":"<pre><code>def set_time_column(self, columns: List[int]): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#timeformatmixin","title":"TimeFormatMixin","text":"<p>Show source in mixin.py:245</p> <p>Mixin class for setting the time format.</p>"},{"location":"API/particula/data/mixin/#signature_36","title":"Signature","text":"<pre><code>class TimeFormatMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#timeformatmixinset_time_format","title":"TimeFormatMixin().set_time_format","text":"<p>Show source in mixin.py:251</p> <p>Set the time format for the time data in the data files.</p>"},{"location":"API/particula/data/mixin/#arguments_18","title":"Arguments","text":"<ul> <li><code>time_format_str</code> str - Time format string for the time data in the     data files. Default is ISO \"%Y-%m-%dT%H:%M:%S\", list \"epoch\"     if the time data is in Unix-Epoch format. Use the Python time     format codes otherwise,     e.g. \"%Y-%m-%dT%H:%M:%S\" for '2021-01-01T12:00:00'.</li> </ul>"},{"location":"API/particula/data/mixin/#examples_15","title":"Examples","text":"USA date format<pre><code>time_format_str = \"%m/%d/%Y %H:%M:%S\"\n# e.g. '01/01/2021 12:00:00'\n</code></pre> European date format<pre><code>time_format_str = \"%d/%m/%Y %H:%M:%S\"\n# e.g. '01/01/2021 12:00:00'\n</code></pre> ISO date format<pre><code>time_format_str = \"%Y-%m-%dT%H:%M:%S\"\n# e.g. '2021-01-01T12:00:00'\n</code></pre> AM/PM time format<pre><code>time_format_str = \"%Y-%m-%d %I:%M:%S %p\"\n# e.g. '2021-01-01 12:00:00 PM'\n</code></pre> Fractional seconds<pre><code>time_format_str = \"%Y-%m-%dT%H:%M:%S.%f\"\n# e.g. '2021-01-01T12:00:00.123456'\n</code></pre>"},{"location":"API/particula/data/mixin/#references_2","title":"References","text":"<ul> <li>Python Docs</li> <li>Python Time Format</li> </ul>"},{"location":"API/particula/data/mixin/#signature_37","title":"Signature","text":"<pre><code>def set_time_format(self, time_format_str: str = \"%Y-%m-%dT%H:%M:%S\"): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#timeshiftsecondsmixin","title":"TimeShiftSecondsMixin","text":"<p>Show source in mixin.py:329</p> <p>Mixin class for setting the time shift in seconds.</p>"},{"location":"API/particula/data/mixin/#signature_38","title":"Signature","text":"<pre><code>class TimeShiftSecondsMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#timeshiftsecondsmixinset_time_shift_seconds","title":"TimeShiftSecondsMixin().set_time_shift_seconds","text":"<p>Show source in mixin.py:335</p> <p>Set the time shift in seconds for the time data in the data files. This is helpful to match the time stamps of two data folders. This shift is applied to all files loaded with this builder.</p>"},{"location":"API/particula/data/mixin/#arguments_19","title":"Arguments","text":"<ul> <li><code>shift</code> int - Time shift in seconds for the time data in the data     files. Default is 0 seconds.</li> </ul>"},{"location":"API/particula/data/mixin/#examples_16","title":"Examples","text":"Shift by 1 hour<pre><code>shift = 3600\n# Shift the time data by 1 hour (3600 seconds).\n</code></pre> Shift by 1 day<pre><code>shift = 86400\n# Shift the time data by 1 day (86400 seconds).\n</code></pre>"},{"location":"API/particula/data/mixin/#signature_39","title":"Signature","text":"<pre><code>def set_time_shift_seconds(self, shift: int = 0): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#timezoneidentifiermixin","title":"TimezoneIdentifierMixin","text":"<p>Show source in mixin.py:359</p> <p>Mixin class for setting the timezone identifier.</p>"},{"location":"API/particula/data/mixin/#signature_40","title":"Signature","text":"<pre><code>class TimezoneIdentifierMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/data/mixin/#timezoneidentifiermixinset_timezone_identifier","title":"TimezoneIdentifierMixin().set_timezone_identifier","text":"<p>Show source in mixin.py:365</p> <p>Set the timezone identifier for the time data in the data files. The timezone shift is handled by the pytz library.</p>"},{"location":"API/particula/data/mixin/#arguments_20","title":"Arguments","text":"<ul> <li><code>timezone</code> str - Timezone identifier for the time data in the data     files. Default is 'UTC'.</li> </ul>"},{"location":"API/particula/data/mixin/#examples_17","title":"Examples","text":"List of Timezones<pre><code>timezone = \"Europe/London\"  # or \"GMT\"\n</code></pre> Mountain Timezone<pre><code>timezone = \"America/Denver\"  # or \"MST7MDT\"\n</code></pre> ETH Zurich Timezone<pre><code>timezone = \"Europe/Zurich\"  # or \"CET\"\n</code></pre>"},{"location":"API/particula/data/mixin/#references_3","title":"References","text":"<p>List of Timezones</p>"},{"location":"API/particula/data/mixin/#signature_41","title":"Signature","text":"<pre><code>def set_timezone_identifier(self, timezone: str = \"UTC\"): ...\n</code></pre>"},{"location":"API/particula/data/settings_generator/","title":"Settings Generator","text":"<p>Particula Index / Particula / Data / Settings Generator</p> <p>Auto-generated documentation for particula.data.settings_generator module.</p>"},{"location":"API/particula/data/settings_generator/#for_general_1d_load","title":"for_general_1d_load","text":"<p>Show source in settings_generator.py:14</p> <p>Generate a settings dictionary for loading and checking 1D data from CSV files.</p>"},{"location":"API/particula/data/settings_generator/#arguments","title":"Arguments","text":"<ul> <li>relative_data_folder (str): The folder path relative to the main script     where data files are located. Default is 'instrument_data'.</li> <li>filename_regex (str): Regular expression pattern to match filenames in     the data folder. Default is '*.csv'.</li> <li>file_min_size_bytes (int): Minimum size in bytes for files to be     considered valid. Default is 10.</li> <li>header_row (int): The index of the row containing column headers     (0-indexed). Default is 0.</li> <li>data_checks (Optional[dict]): A dictionary containing data quality     checks such as character length, required character counts, rows to     skip at the beginning or end. Defaults to basic checks if None.</li> <li>data_column (list of int): List of indices for columns containing data     points to be loaded. Default is [3, 5].</li> <li>data_header (List[str]): List of strings representing the header names     for data columns. Default is ['data 1', 'data 3'].</li> <li>time_column (List[int]): List of indices for columns containing time     information. Default is [0, 1].</li> <li>time_format (str): String format for parsing time columns, using     strftime conventions. Default is '%Y-%m-%d %H:%M:%S.%f'.</li> <li>delimiter (str): Character used to separate values in the file.     Default is ','.</li> <li>time_shift_seconds (int): Number of seconds by which to shift time data     (positive or negative). Default is 0.</li> <li>timezone_identifier (str): Timezone identifier for time conversion.     Default is 'UTC'.</li> </ul>"},{"location":"API/particula/data/settings_generator/#returns","title":"Returns","text":"<ul> <li><code>-</code> dict - A dictionary with settings for data loading procedures including     file paths, size requirements, header information, and data check     parameters.</li> </ul>"},{"location":"API/particula/data/settings_generator/#signature","title":"Signature","text":"<pre><code>def for_general_1d_load(\n    relative_data_folder: str = \"instrument_data\",\n    filename_regex: str = \"*.csv\",\n    file_min_size_bytes: int = 10,\n    header_row: int = 0,\n    data_checks: Optional[dict] = None,\n    data_column: list = [3, 5],\n    data_header: List[str] = [\"data 1\", \"data 3\"],\n    time_column: List[int] = [0, 1],\n    time_format: str = \"%Y-%m-%d %H:%M:%S.%f\",\n    delimiter: str = \",\",\n    time_shift_seconds: int = 0,\n    timezone_identifier: str = \"UTC\",\n) -&gt; dict: ...\n</code></pre>"},{"location":"API/particula/data/settings_generator/#for_general_sizer_1d_2d_load","title":"for_general_sizer_1d_2d_load","text":"<p>Show source in settings_generator.py:89</p> <p>Generate settings for the 1D general file loader and the 2D general sizer     file loader.</p>"},{"location":"API/particula/data/settings_generator/#arguments_1","title":"Arguments","text":"<ul> <li>relative_data_folder (str): Path to the folder containing data files,     relative to the script's location.</li> <li>filename_regex (str): Regex pattern to match filenames for loading.</li> <li>file_min_size_bytes (int): Minimum file size in bytes for a file to be     considered valid for loading.</li> <li>header_row (int): Row index for the header (0-based) in the data files.</li> <li>data_checks (dict, optional): Specifications for data integrity checks     to apply when loading data.</li> <li>data_1d_column (list of int): Column indices for 1D data extraction.</li> <li>data_1d_header (list of str): Header names corresponding to the     <code>data_1d_column</code> indices.</li> <li>data_2d_dp_start_keyword (str): Keyword indicating the start of 2D data     points in a file.</li> <li>data_2d_dp_end_keyword (str): Keyword indicating the end of 2D data     points in a file.</li> <li>data_2d_convert_concentration_from (str, optional): Unit to convert from     if concentration scaling is needed for 2D data.</li> <li>time_column (list of int): Column indices for time data extraction.</li> <li>time_format (str): Format string for parsing time data.</li> <li>delimiter (str): Delimiter character for splitting data in the file.</li> <li>time_shift_seconds (int): Seconds to shift the time data by.</li> <li>timezone_identifier (str): Timezone ID for time data interpretation.</li> </ul>"},{"location":"API/particula/data/settings_generator/#returns_1","title":"Returns","text":"<ul> <li>tuple of (dict, dict): A tuple containing two dictionaries with settings     for the 1D and 2D data loaders.</li> </ul> <p>The function defaults <code>data_checks</code> to basic validation criteria if not     provided. It returns separate dictionaries for settings applicable to     1D and 2D data loaders, which include file paths, size checks, and     data parsing rules.</p>"},{"location":"API/particula/data/settings_generator/#signature_1","title":"Signature","text":"<pre><code>def for_general_sizer_1d_2d_load(\n    relative_data_folder: str = \"instrument_data\",\n    filename_regex: str = \"*.csv\",\n    file_min_size_bytes: int = 10,\n    header_row: int = 0,\n    data_checks: Optional[dict] = None,\n    data_1d_column: list = [3, 5],\n    data_1d_header: List[str] = [\"data 1\", \"data 3\"],\n    data_2d_dp_start_keyword: str = \"Date Time\",\n    data_2d_dp_end_keyword: str = \"Total Conc\",\n    data_2d_convert_concentration_from: str = \"dw/dlogdp\",\n    time_column: List[int] = [0, 1],\n    time_format: str = \"%Y-%m-%d %H:%M:%S.%f\",\n    delimiter: str = \",\",\n    time_shift_seconds: int = 0,\n    timezone_identifier: str = \"UTC\",\n) -&gt; tuple: ...\n</code></pre>"},{"location":"API/particula/data/settings_generator/#load_settings_for_lake","title":"load_settings_for_lake","text":"<p>Show source in settings_generator.py:260</p> <p>Load settings for Lake data from a JSON file. The settings file is a dictionary of stream settings dictionaries.</p> <p>Given a path and subfolder, this function searches for a JSON file named 'lake_settings' with an optional suffix. It returns the settings as a dictionary. If no file is found, or multiple files are found, appropriate errors or warnings are raised.</p>"},{"location":"API/particula/data/settings_generator/#arguments_2","title":"Arguments","text":"<ul> <li><code>-</code> path - The path where the subfolder is located.</li> <li><code>-</code> subfolder - The subfolder where the settings file is expected.</li> <li><code>-</code> settings_suffix - An optional suffix for the settings     file name. Default is an empty string.</li> </ul>"},{"location":"API/particula/data/settings_generator/#returns_2","title":"Returns","text":"<ul> <li><code>-</code> dict - A dictionary of settings loaded from the file.</li> </ul>"},{"location":"API/particula/data/settings_generator/#raises","title":"Raises","text":"<ul> <li><code>-</code> FileNotFoundError - If no settings file is found.</li> <li><code>-</code> Warning - If more than one settings file is found.</li> </ul>"},{"location":"API/particula/data/settings_generator/#signature_2","title":"Signature","text":"<pre><code>def load_settings_for_lake(\n    path: str, subfolder: str = \"\", settings_suffix: str = \"\"\n) -&gt; dict: ...\n</code></pre>"},{"location":"API/particula/data/settings_generator/#load_settings_for_stream","title":"load_settings_for_stream","text":"<p>Show source in settings_generator.py:186</p> <p>Load settings for Stream data from a JSON file.</p> <p>Given a path and subfolder, this function searches for a JSON file named 'stream_settings' with an optional suffix. It returns the settings as a dictionary. If no file is found, or multiple files are found, appropriate errors or warnings are raised.</p>"},{"location":"API/particula/data/settings_generator/#arguments_3","title":"Arguments","text":"<ul> <li><code>-</code> path - The path where the subfolder is located.</li> <li><code>-</code> subfolder - The subfolder where the settings file is expected.</li> <li><code>-</code> settings_suffix - An optional suffix for the settings     file name. Default is an empty string.</li> </ul>"},{"location":"API/particula/data/settings_generator/#returns_3","title":"Returns","text":"<ul> <li><code>-</code> dict - A dictionary of settings loaded from the file.</li> </ul>"},{"location":"API/particula/data/settings_generator/#raises_1","title":"Raises","text":"<ul> <li><code>-</code> FileNotFoundError - If no settings file is found.</li> <li><code>-</code> Warning - If more than one settings file is found.</li> </ul>"},{"location":"API/particula/data/settings_generator/#signature_3","title":"Signature","text":"<pre><code>def load_settings_for_stream(\n    path: str, subfolder: str, settings_suffix: str = \"\"\n) -&gt; dict: ...\n</code></pre>"},{"location":"API/particula/data/settings_generator/#save_settings_for_lake","title":"save_settings_for_lake","text":"<p>Show source in settings_generator.py:307</p> <p>Save settings for lake data to a JSON file.</p> <p>Given a dictionary of settings, this function saves it to a JSON file named 'lake_settings' with an optional suffix in the specified filename. The JSON file is formatted with a 4-space indentation.</p>"},{"location":"API/particula/data/settings_generator/#arguments_4","title":"Arguments","text":"<ul> <li><code>-</code> settings - The settings dictionary to be saved.</li> <li><code>-</code> path - The path where the subfolder is located.</li> <li><code>-</code> subfolder - The subfolder where the settings file will be saved.</li> <li><code>-</code> settings_suffix - An optional suffix for the settings     file name. Default is an empty string.</li> </ul>"},{"location":"API/particula/data/settings_generator/#returns_4","title":"Returns","text":"<ul> <li>None</li> </ul>"},{"location":"API/particula/data/settings_generator/#signature_4","title":"Signature","text":"<pre><code>def save_settings_for_lake(\n    settings: dict, path: str, subfolder: str = \"\", settings_suffix: str = \"\"\n) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/data/settings_generator/#save_settings_for_stream","title":"save_settings_for_stream","text":"<p>Show source in settings_generator.py:232</p> <p>Save settings for lake data to a JSON file.</p> <p>Given a dictionary of settings, this function saves it to a JSON file named 'stream_settings' with an optional suffix in the specified filename. The JSON file is formatted with a 4-space indentation.</p>"},{"location":"API/particula/data/settings_generator/#arguments_5","title":"Arguments","text":"<ul> <li><code>-</code> settings - The settings dictionary to be saved.</li> <li><code>-</code> path - The path where the subfolder is located.</li> <li><code>-</code> subfolder - The subfolder where the settings file will be saved.</li> <li><code>-</code> settings_suffix - An optional suffix for the settings     file name. Default is an empty string.</li> </ul>"},{"location":"API/particula/data/settings_generator/#returns_5","title":"Returns","text":"<ul> <li>None</li> </ul>"},{"location":"API/particula/data/settings_generator/#signature_5","title":"Signature","text":"<pre><code>def save_settings_for_stream(\n    settings: dict, path: str, subfolder: str, settings_suffix: str = \"\"\n) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/data/stream/","title":"Stream","text":"<p>Particula Index / Particula / Data / Stream</p> <p>Auto-generated documentation for particula.data.stream module.</p>"},{"location":"API/particula/data/stream/#stream_1","title":"Stream","text":"<p>Show source in stream.py:13</p> <p>Consistent format for storing data.</p> <p>Represents a consistent format for storing and managing data streams within a list. Similar to pandas but with tighter control over the data allowed and expected format.</p>"},{"location":"API/particula/data/stream/#attributes","title":"Attributes","text":"<ul> <li><code>header</code> - Headers of the data stream, each a string.</li> <li><code>data</code> - 2D numpy array where rows are timepoints and columns     correspond to headers.</li> <li><code>time</code> - 1D numpy array representing the time points of the data stream.</li> <li><code>files</code> - List of filenames that contain the data stream.</li> </ul>"},{"location":"API/particula/data/stream/#methods","title":"Methods","text":"<ul> <li><code>validate_inputs</code> - Validates the types of class inputs.</li> <li><code>__getitem__(index)</code> - Returns the data at the specified index.</li> <li><code>__setitem__(index,</code> value) - Sets or updates data at the specified index.</li> <li><code>__len__()</code> - Returns the length of the time stream.</li> <li><code>datetime64</code> - Converts time stream to numpy datetime64 array for plots.</li> <li><code>header_dict</code> - Provides a dictionary mapping of header indices to names.</li> <li><code>header_float</code> - Converts header names to a numpy array of floats.</li> </ul>"},{"location":"API/particula/data/stream/#signature","title":"Signature","text":"<pre><code>class Stream: ...\n</code></pre>"},{"location":"API/particula/data/stream/#streamgetitem","title":"Stream().getitem","text":"<p>Show source in stream.py:54</p> <p>Gets data at a specified index or header name.</p> <p>Allows indexing of the data stream using an integer index or a string corresponding to the header. If a string is used, the header index is retrieved and used to return the data array. Only one str argument is allowed. A list of int is allowed.</p>"},{"location":"API/particula/data/stream/#arguments","title":"Arguments","text":"<ul> <li><code>index</code> - The index or name of the data column to     retrieve.</li> </ul>"},{"location":"API/particula/data/stream/#returns","title":"Returns","text":"<ul> <li><code>np.ndarray</code> - The data array at the specified index.</li> </ul>"},{"location":"API/particula/data/stream/#signature_1","title":"Signature","text":"<pre><code>def __getitem__(self, index: Union[int, str]) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/data/stream/#streamlen","title":"Stream().len","text":"<p>Show source in stream.py:99</p> <p>Returns the number of time points in the data stream.</p>"},{"location":"API/particula/data/stream/#returns_1","title":"Returns","text":"<ul> <li><code>int</code> - Length of the time stream.</li> </ul>"},{"location":"API/particula/data/stream/#signature_2","title":"Signature","text":"<pre><code>def __len__(self) -&gt; int: ...\n</code></pre>"},{"location":"API/particula/data/stream/#streampop","title":"Stream().pop","text":"<p>Show source in stream.py:108</p> <p>Removes data at a specified index or header name.</p> <p>Allows indexing of the data stream using an integer index or a string corresponding to the header. If a string is used, the header index is retrieved and used to return the data array. Only one str argument is allowed. A list of int is allowed.</p>"},{"location":"API/particula/data/stream/#arguments_1","title":"Arguments","text":"<ul> <li><code>index</code> - The index or name of the data column to     retrieve.</li> </ul>"},{"location":"API/particula/data/stream/#signature_3","title":"Signature","text":"<pre><code>def __pop__(self, index: Union[int, str]) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/data/stream/#streamsetitem","title":"Stream().setitem","text":"<p>Show source in stream.py:73</p> <p>Sets or adds data at a specified index.</p> <p>If index is a string and not in headers, it is added. This is used to add new data columns to the stream.</p>"},{"location":"API/particula/data/stream/#arguments_2","title":"Arguments","text":"<ul> <li><code>index</code> - The index or name of the data column to set.</li> <li><code>value</code> - The data to set at the specified index.</li> </ul>"},{"location":"API/particula/data/stream/#notes","title":"Notes","text":"<p>Support setting multiple rows by accepting a list of values.</p>"},{"location":"API/particula/data/stream/#signature_4","title":"Signature","text":"<pre><code>def __setitem__(self, index: Union[int, str], value: NDArray[np.float64]): ...\n</code></pre>"},{"location":"API/particula/data/stream/#streamdatetime64","title":"Stream().datetime64","text":"<p>Show source in stream.py:125</p> <p>Converts the epoch time array to a datetime64 for plotting.</p> <p>This method converts the time array to a datetime64 array, which can be used for plotting time series data. This generally assumes that the time array is in seconds since the epoch.</p>"},{"location":"API/particula/data/stream/#returns_2","title":"Returns","text":"<ul> <li><code>np.ndarray</code> - Datetime64 array representing the time stream.</li> </ul>"},{"location":"API/particula/data/stream/#signature_5","title":"Signature","text":"<pre><code>@property\ndef datetime64(self) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/data/stream/#streamheader_dict","title":"Stream().header_dict","text":"<p>Show source in stream.py:138</p> <p>Provides a dictionary mapping from index to header names.</p>"},{"location":"API/particula/data/stream/#returns_3","title":"Returns","text":"<ul> <li><code>dict</code> - Dictionary with indices as keys and header names as values.</li> </ul>"},{"location":"API/particula/data/stream/#signature_6","title":"Signature","text":"<pre><code>@property\ndef header_dict(self) -&gt; dict[int, str]: ...\n</code></pre>"},{"location":"API/particula/data/stream/#streamheader_float","title":"Stream().header_float","text":"<p>Show source in stream.py:147</p> <p>Attempts to convert header names to a float array, where possible.</p>"},{"location":"API/particula/data/stream/#returns_4","title":"Returns","text":"<ul> <li><code>np.ndarray</code> - Array of header names converted to floats.</li> </ul>"},{"location":"API/particula/data/stream/#signature_7","title":"Signature","text":"<pre><code>@property\ndef header_float(self) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/data/stream/#streamvalidate_inputs","title":"Stream().validate_inputs","text":"<p>Show source in stream.py:45</p> <p>Validates that header is a list.</p>"},{"location":"API/particula/data/stream/#raises","title":"Raises","text":"<ul> <li><code>TypeError</code> - If header is not a list.</li> </ul>"},{"location":"API/particula/data/stream/#signature_8","title":"Signature","text":"<pre><code>def validate_inputs(self): ...\n</code></pre>"},{"location":"API/particula/data/stream/#streamaveraged","title":"StreamAveraged","text":"<p>Show source in stream.py:158</p> <p>Stream Class with Averaged Data and Standard Deviation.</p> <p>Extends the Stream class with functionalities specific to handling averaged data streams. Mainly adding standard deviation to the data stream.</p>"},{"location":"API/particula/data/stream/#attributes_1","title":"Attributes","text":"<ul> <li><code>average_interval</code> - The interval in units (e.g., seconds, minutes) over     which data is averaged.</li> <li><code>start_time</code> - The start time from which data begins to be averaged.</li> <li><code>stop_time</code> - The time at which data ceases to be averaged.</li> <li><code>standard_deviation</code> - A numpy array storing the standard deviation of     data streams.</li> </ul>"},{"location":"API/particula/data/stream/#signature_9","title":"Signature","text":"<pre><code>class StreamAveraged(Stream): ...\n</code></pre>"},{"location":"API/particula/data/stream/#see-also","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"API/particula/data/stream/#streamaveragedget_std","title":"StreamAveraged().get_std","text":"<p>Show source in stream.py:210</p> <p>Retrieves the standard deviation</p> <p>In the averaged data stream, the standard deviation of the data is stored in a separate array that mirrors the same indices as the data stream. This method allows retrieval of the standard deviation at a specified index.</p>"},{"location":"API/particula/data/stream/#arguments_3","title":"Arguments","text":"<ul> <li><code>index</code> - The index or header name of the data stream for which standard deviation is needed.</li> </ul>"},{"location":"API/particula/data/stream/#returns_5","title":"Returns","text":"<ul> <li><code>np.ndarray</code> - The standard deviation values at the specified index.</li> </ul>"},{"location":"API/particula/data/stream/#raises_1","title":"Raises","text":"<ul> <li><code>ValueError</code> - If the specified index does not exist in the header.</li> </ul>"},{"location":"API/particula/data/stream/#signature_10","title":"Signature","text":"<pre><code>def get_std(self, index: Union[int, str]) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/data/stream/#streamaveragedvalidate_averaging_params","title":"StreamAveraged().validate_averaging_params","text":"<p>Show source in stream.py:185</p> <p>Ensures that averaging parameters are valid.</p>"},{"location":"API/particula/data/stream/#raises_2","title":"Raises","text":"<ul> <li><code>ValueError</code> - If average_interval is not a positive number.</li> <li><code>ValueError</code> - If start_time or stop_time are not numerical or if     start_time is greater than or equal to stop_time.</li> </ul>"},{"location":"API/particula/data/stream/#signature_11","title":"Signature","text":"<pre><code>def validate_averaging_params(self): ...\n</code></pre>"},{"location":"API/particula/data/stream_stats/","title":"Stream Stats","text":"<p>Particula Index / Particula / Data / Stream Stats</p> <p>Auto-generated documentation for particula.data.stream_stats module.</p>"},{"location":"API/particula/data/stream_stats/#average_std","title":"average_std","text":"<p>Show source in stream_stats.py:34</p> <p>Calculate the average and standard deviation of data within a given 'stream' object over specified intervals.</p> <p>This function takes a 'stream' object, which should contain time-series data, and computes the average and standard deviation of the data at intervals specified by 'average_interval'. If data.time is in seconds then the units of the interval are seconds (hour in hours etc). The results are returned as a new 'StreamAveraged' object containing the processed data.</p>"},{"location":"API/particula/data/stream_stats/#arguments","title":"Arguments","text":"<ul> <li>stream (object): The input stream object containing 'time' and 'data'     arrays along with other associated metadata.</li> <li>average_interval (float|int, optional): The time interval over which the     averaging is to be performed.</li> <li>new_time_array (np.ndarray, optional): An optional array of time points     at which the average and standard deviation are computed.     If not provided, a new time array is generated based on the start and     end times within the 'stream.time' object.</li> </ul>"},{"location":"API/particula/data/stream_stats/#returns","title":"Returns","text":"<ul> <li>StreamAveraged (object): An object of type 'StreamAveraged' containing     the averaged data, time array, start and stop times, the standard     deviation of the averaged data, and other metadata from the original     'stream' object.</li> </ul> <p>The function checks for an existing 'new_time_array' and generates one if needed. It then calculates the average and standard deviation for each interval and constructs a 'StreamAveraged' object with the results and metadata from the original 'stream' object.</p>"},{"location":"API/particula/data/stream_stats/#signature","title":"Signature","text":"<pre><code>def average_std(\n    stream: Stream,\n    average_interval: Union[float, int] = 60,\n    new_time_array: Optional[np.ndarray] = None,\n) -&gt; StreamAveraged: ...\n</code></pre>"},{"location":"API/particula/data/stream_stats/#see-also","title":"See also","text":"<ul> <li>StreamAveraged</li> <li>Stream</li> </ul>"},{"location":"API/particula/data/stream_stats/#drop_masked","title":"drop_masked","text":"<p>Show source in stream_stats.py:14</p> <p>Drop rows where mask is false, and return data stream.</p>"},{"location":"API/particula/data/stream_stats/#args","title":"Args","text":"<p>stream : object     data stream object mask : np.ndarray     mask to apply to data stream</p>"},{"location":"API/particula/data/stream_stats/#returns_1","title":"Returns","text":"<p>object     stream object</p>"},{"location":"API/particula/data/stream_stats/#signature_1","title":"Signature","text":"<pre><code>def drop_masked(stream: Stream, mask: ignore) -&gt; Stream: ...\n</code></pre>"},{"location":"API/particula/data/stream_stats/#see-also_1","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"API/particula/data/stream_stats/#filtering","title":"filtering","text":"<p>Show source in stream_stats.py:104</p> <p>Filters the data of the given 'stream' object based on the specified bounds or specific value. The filtered data can be either dropped or replaced with a specified value.  Note, not all parameters need to be specified, but at least one must be provided (top, bottom, value)</p>"},{"location":"API/particula/data/stream_stats/#arguments_1","title":"Arguments","text":"<ul> <li>stream (Stream): The input stream object containing 'data' and 'time'     attributes.</li> <li>bottom (float, optional): The lower bound for filtering data. Defaults     to None.</li> <li>top (float, optional): The upper bound for filtering data.     Defaults to None.</li> <li>value (float, optional): Specific value to filter from data.     Defaults to None.</li> <li>invert (bool): If True, inverts the filter criteria.     Defaults to False.</li> <li>clone (bool): If True, returns a copy of the 'stream' object, with     filtered data. If False, modifies the 'stream' object in-place.     Defaults to True.</li> <li>replace_with (float|int, optional): Value to replace filtered-out data.     Defaults to None.</li> <li>drop (bool, optional): If True, filtered-out data points are dropped     from the dataset. Defaults to False.</li> <li>header (list, optional): The header of the data to filter on. This can     same as calling Stream['header']     Defaults to None.</li> </ul>"},{"location":"API/particula/data/stream_stats/#returns_2","title":"Returns","text":"<ul> <li><code>-</code> Stream - The 'stream' object with data filtered as specified.</li> </ul> <p>If 'drop' is True, 'replace_with' is ignored and filtered data points are removed from the 'stream' object. Otherwise, filtered data points are replaced with 'replace_with' value.</p> <p>add specific data row to filter on</p>"},{"location":"API/particula/data/stream_stats/#signature_2","title":"Signature","text":"<pre><code>def filtering(\n    stream: Stream,\n    bottom: Optional[float] = None,\n    top: Optional[float] = None,\n    value: Optional[float] = None,\n    invert: Optional[bool] = False,\n    clone: Optional[bool] = True,\n    replace_with: Optional[Union[float, int]] = None,\n    drop: Optional[bool] = False,\n    header: Optional[Union[list, int, str]] = None,\n) -&gt; Stream: ...\n</code></pre>"},{"location":"API/particula/data/stream_stats/#see-also_2","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"API/particula/data/stream_stats/#remove_time_window","title":"remove_time_window","text":"<p>Show source in stream_stats.py:177</p> <p>Remove a time window from a stream object.</p>"},{"location":"API/particula/data/stream_stats/#arguments_2","title":"Arguments","text":"<ul> <li><code>stream</code> - The input stream object containing 'data' and 'time'     attributes.</li> <li><code>epoch_start</code> - The start time of the time window to be     removed.</li> <li><code>epoch_end</code> - The end time of the time window to be     removed. If not provided, the time window is the closest time     point to 'epoch_start'.</li> </ul>"},{"location":"API/particula/data/stream_stats/#returns_3","title":"Returns","text":"<ul> <li><code>Stream</code> - The 'stream' object with the specified time window removed.</li> </ul>"},{"location":"API/particula/data/stream_stats/#signature_3","title":"Signature","text":"<pre><code>def remove_time_window(\n    stream: Stream,\n    epoch_start: Union[float, int],\n    epoch_end: Optional[Union[float, int]] = None,\n) -&gt; Stream: ...\n</code></pre>"},{"location":"API/particula/data/stream_stats/#see-also_3","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"API/particula/data/stream_stats/#select_time_window","title":"select_time_window","text":"<p>Show source in stream_stats.py:212</p> <p>Keep only a specified time window in a stream object and remove all other data.</p>"},{"location":"API/particula/data/stream_stats/#arguments_3","title":"Arguments","text":"<ul> <li><code>stream</code> - The input stream object containing 'data' and 'time'     attributes.</li> <li><code>epoch_start</code> - The start time of the time window to be kept.</li> <li><code>epoch_end</code> - The end time of the time window to be kept. If not provided,     only the closest time point to 'epoch_start' will be kept.</li> </ul>"},{"location":"API/particula/data/stream_stats/#returns_4","title":"Returns","text":"<ul> <li><code>Stream</code> - The stream object with only the specified time window retained.</li> </ul>"},{"location":"API/particula/data/stream_stats/#signature_4","title":"Signature","text":"<pre><code>def select_time_window(\n    stream: Stream,\n    epoch_start: Union[float, int],\n    epoch_end: Optional[Union[float, int]] = None,\n    clone: Optional[bool] = True,\n) -&gt; Stream: ...\n</code></pre>"},{"location":"API/particula/data/stream_stats/#see-also_4","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"API/particula/data/stream_stats/#time_derivative_of_stream","title":"time_derivative_of_stream","text":"<p>Show source in stream_stats.py:251</p> <p>Calculate the rate of change of the concentration PMF over time and return a new stream.</p> <p>Uses a linear regression model to fit the slope over a time window. The edge cases are handled by using a smaller window size.</p>"},{"location":"API/particula/data/stream_stats/#arguments_4","title":"Arguments","text":"<ul> <li><code>pmf_fitted_stream</code> - Stream object containing the fitted concentration     PMF data.</li> <li><code>window_size</code> - Size of the time window for fitting the slope.</li> </ul>"},{"location":"API/particula/data/stream_stats/#returns_5","title":"Returns","text":"<ul> <li><code>rate_of_change_stream</code> - Stream object containing the rate of     change of the concentration PMF.</li> </ul>"},{"location":"API/particula/data/stream_stats/#signature_5","title":"Signature","text":"<pre><code>def time_derivative_of_stream(\n    stream: Stream, liner_slope_window_size: int = 12\n) -&gt; Stream: ...\n</code></pre>"},{"location":"API/particula/data/stream_stats/#see-also_5","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"API/particula/data/process/","title":"Process","text":"<p>Particula Index / Particula / Data / Process</p> <p>Auto-generated documentation for particula.data.process module.</p>"},{"location":"API/particula/data/process/#modules","title":"Modules","text":"<ul> <li>Aerodynamic Convert</li> <li>Chamber Rate Fitting</li> <li>Kappa Via Extinction</li> <li>Lognormal 2mode</li> <li>Mie Angular</li> <li>Mie Bulk</li> <li>Ml Analysis</li> <li>Optical Instrument</li> <li>Scattering Truncation</li> <li>Size Distribution</li> </ul>"},{"location":"API/particula/data/process/aerodynamic_convert/","title":"Aerodynamic Convert","text":"<p>Particula Index / Particula / Data / Process / Aerodynamic Convert</p> <p>Auto-generated documentation for particula.data.process.aerodynamic_convert module.</p>"},{"location":"API/particula/data/process/aerodynamic_convert/#_cost_aerodynamic_radius","title":"_cost_aerodynamic_radius","text":"<p>Show source in aerodynamic_convert.py:21</p> <p>Optimization cost function to determine the aerodynamic radius of a particle.</p>"},{"location":"API/particula/data/process/aerodynamic_convert/#arguments","title":"Arguments","text":"<ul> <li><code>guess_aerodynamic_radius</code> - The initial guess for the aerodynamic radius.</li> <li><code>mean_free_path_air</code> - The mean free path of air molecules.</li> <li><code>particle_radius</code> - The known physical radius of the particle.</li> <li><code>kwargs</code> - Additional keyword arguments for the optimization.<ul> <li>density (float): The density of the particle. Default is     1500 kg/m^3.</li> <li>reference_density (float): The reference density for the     aerodynamic radius calculation. Default is 1000 kg/m^3.</li> <li>aerodynamic_shape_factor (float): The aerodynamic shape factor.     Default is 1.0.</li> </ul> </li> </ul>"},{"location":"API/particula/data/process/aerodynamic_convert/#returns","title":"Returns","text":"<p>The squared error between the guessed aerodynamic radius and     the calculated aerodynamic radius.</p>"},{"location":"API/particula/data/process/aerodynamic_convert/#signature","title":"Signature","text":"<pre><code>def _cost_aerodynamic_radius(\n    guess_aerodynamic_radius: Union[float, NDArray[np.float64]],\n    mean_free_path_air: Union[float, NDArray[np.float64]],\n    particle_radius: Union[float, NDArray[np.float64]],\n    **kwargs\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/data/process/aerodynamic_convert/#_cost_physical_radius","title":"_cost_physical_radius","text":"<p>Show source in aerodynamic_convert.py:80</p> <p>Optimization cost function to determine the physical radius of a particle.</p>"},{"location":"API/particula/data/process/aerodynamic_convert/#arguments_1","title":"Arguments","text":"<ul> <li><code>guess_physical_radius</code> - The initial guess for the physical radius.</li> <li><code>mean_free_path_air</code> - The mean free path of air molecules.</li> <li><code>aerodynamic_radius</code> - The known aerodynamic radius of the particle.</li> <li><code>kwargs</code> - Additional keyword arguments for the optimization<ul> <li>density (float): The density of the particle. Default is     1500 kg/m^3.</li> <li>reference_density (float): The reference density for the     aerodynamic radius calculation. Default is 1000 kg/m^3.</li> <li>aerodynamic_shape_factor (float): The aerodynamic shape factor.     Default is 1.0.</li> </ul> </li> </ul>"},{"location":"API/particula/data/process/aerodynamic_convert/#returns_1","title":"Returns","text":"<p>The squared error between the guessed physical radius and the calculated aerodynamic radius.</p>"},{"location":"API/particula/data/process/aerodynamic_convert/#signature_1","title":"Signature","text":"<pre><code>def _cost_physical_radius(\n    guess_physical_radius: Union[float, NDArray[np.float64]],\n    mean_free_path_air: Union[float, NDArray[np.float64]],\n    aerodynamic_radius: Union[float, NDArray[np.float64]],\n    **kwargs\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/data/process/aerodynamic_convert/#convert_aerodynamic_to_physical_radius","title":"convert_aerodynamic_to_physical_radius","text":"<p>Show source in aerodynamic_convert.py:139</p> <p>Convert aerodynamic radius to physical radius for a particle or an array of particles.</p>"},{"location":"API/particula/data/process/aerodynamic_convert/#arguments_2","title":"Arguments","text":"<ul> <li><code>aerodynamic_radius</code> - The aerodynamic radius or array of radii to be     converted.</li> <li><code>pressure</code> - The ambient pressure in Pascals.</li> <li><code>temperature</code> - The ambient temperature in Kelvin.</li> <li><code>particle_density</code> - The density of the particles in kg/m^3.</li> <li><code>aerodynamic_shape_factor</code> - The aerodynamic shape factor. Default is 1.0.</li> <li><code>reference_density</code> - The reference density for the aerodynamic radius     in kg/m^3. Default is 1000 kg/m^3.</li> </ul>"},{"location":"API/particula/data/process/aerodynamic_convert/#returns_2","title":"Returns","text":"<p>The physical radius or array of radii corresponding to the aerodynamic radius/radii.</p>"},{"location":"API/particula/data/process/aerodynamic_convert/#signature_2","title":"Signature","text":"<pre><code>def convert_aerodynamic_to_physical_radius(\n    aerodynamic_radius: Union[float, NDArray[np.float64]],\n    pressure: float,\n    temperature: float,\n    particle_density: float,\n    aerodynamic_shape_factor: float = 1.0,\n    reference_density: float = 1000.0,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/data/process/aerodynamic_convert/#convert_physical_to_aerodynamic_radius","title":"convert_physical_to_aerodynamic_radius","text":"<p>Show source in aerodynamic_convert.py:197</p> <p>Convert physical radius to aerodynamic radius for a particle or an array of particles.</p>"},{"location":"API/particula/data/process/aerodynamic_convert/#arguments_3","title":"Arguments","text":"<ul> <li><code>physical_radius</code> - The physical radius or array of radii to be converted.</li> <li><code>pressure</code> - The ambient pressure in Pascals.</li> <li><code>temperature</code> - The ambient temperature in Kelvin.</li> <li><code>particle_density</code> - The density of the particles in kg/m^3.</li> <li><code>aerodynamic_shape_factor</code> - The aerodynamic shape factor. Default is 1.0.</li> <li><code>reference_density</code> - The reference density for the aerodynamic radius     in kg/m^3. Default is 1000 kg/m^3.</li> </ul>"},{"location":"API/particula/data/process/aerodynamic_convert/#returns_3","title":"Returns","text":"<p>The aerodynamic radius or array of radii corresponding to the physical radius/radii.</p>"},{"location":"API/particula/data/process/aerodynamic_convert/#signature_3","title":"Signature","text":"<pre><code>def convert_physical_to_aerodynamic_radius(\n    physical_radius: Union[float, NDArray[np.float64]],\n    pressure: float,\n    temperature: float,\n    particle_density: float,\n    aerodynamic_shape_factor: float = 1.0,\n    reference_density: float = 1000.0,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/data/process/chamber_rate_fitting/","title":"Chamber Rate Fitting","text":"<p>Particula Index / Particula / Data / Process / Chamber Rate Fitting</p> <p>Auto-generated documentation for particula.data.process.chamber_rate_fitting module.</p>"},{"location":"API/particula/data/process/chamber_rate_fitting/#chamberparameters","title":"ChamberParameters","text":"<p>Show source in chamber_rate_fitting.py:174</p> <p>Data class for the chamber parameters.</p>"},{"location":"API/particula/data/process/chamber_rate_fitting/#signature","title":"Signature","text":"<pre><code>class ChamberParameters: ...\n</code></pre>"},{"location":"API/particula/data/process/chamber_rate_fitting/#calculate_optimized_rates","title":"calculate_optimized_rates","text":"<p>Show source in chamber_rate_fitting.py:294</p> <p>Calculate the coagulation rates using the optimized parameters and return the rates and R2 score.</p>"},{"location":"API/particula/data/process/chamber_rate_fitting/#arguments","title":"Arguments","text":"<ul> <li><code>radius_bins</code> - Array of particle radii in meters.</li> <li><code>concentration_pmf</code> - 2D array of concentration PMF values.</li> <li><code>wall_eddy_diffusivity</code> - Optimized wall eddy diffusivity.</li> <li><code>alpha_collision_efficiency</code> - Optimized alpha collision efficiency.</li> <li><code>chamber_params</code> - ChamberParameters object containing chamber-related     parameters.</li> <li><code>time_derivative_concentration_pmf</code> - Array of observed rate of change     of the concentration PMF (optional).</li> </ul>"},{"location":"API/particula/data/process/chamber_rate_fitting/#returns","title":"Returns","text":"<ul> <li><code>coagulation_loss</code> - Loss rate due to coagulation.</li> <li><code>coagulation_gain</code> - Gain rate due to coagulation.</li> <li><code>dilution_loss</code> - Loss rate due to dilution.</li> <li><code>wall_loss_rate</code> - Loss rate due to wall deposition.</li> <li><code>net_rate</code> - Net rate considering all effects.</li> <li><code>r2_value</code> - R2 score between the net rate and the observed rate.</li> </ul>"},{"location":"API/particula/data/process/chamber_rate_fitting/#signature_1","title":"Signature","text":"<pre><code>def calculate_optimized_rates(\n    radius_bins: NDArray[np.float64],\n    concentration_pmf: NDArray[np.float64],\n    wall_eddy_diffusivity: float,\n    alpha_collision_efficiency: float,\n    chamber_parameters: ChamberParameters,\n    time_derivative_concentration_pmf: Optional[NDArray[np.float64]] = None,\n) -&gt; Tuple[float, float, float, float, float, float]: ...\n</code></pre>"},{"location":"API/particula/data/process/chamber_rate_fitting/#see-also","title":"See also","text":"<ul> <li>ChamberParameters</li> </ul>"},{"location":"API/particula/data/process/chamber_rate_fitting/#calculate_pmf_rates","title":"calculate_pmf_rates","text":"<p>Show source in chamber_rate_fitting.py:22</p> <p>Calculate the coagulation, dilution, and wall loss rates, and return the net rate.</p>"},{"location":"API/particula/data/process/chamber_rate_fitting/#arguments_1","title":"Arguments","text":"<ul> <li><code>radius_bins</code> - Array of particle radii.</li> <li><code>concentration_pmf</code> - Array of particle concentration     probability mass function.</li> <li><code>temperature</code> - Temperature in Kelvin.</li> <li><code>pressure</code> - Pressure in Pascals.</li> <li><code>particle_density</code> - Density of the particles in kg/m^3.</li> <li><code>alpha_collision_efficiency</code> - Collision efficiency factor.</li> <li><code>volume</code> - Volume of the chamber in m^3.</li> <li><code>input_flow_rate</code> - Input flow rate in m^3/s.</li> <li><code>wall_eddy_diffusivity</code> - Eddy diffusivity for wall loss in m^2/s.</li> <li><code>chamber_dimensions</code> - Dimensions of the chamber     (length, width, height) in meters.</li> </ul>"},{"location":"API/particula/data/process/chamber_rate_fitting/#returns_1","title":"Returns","text":"<ul> <li><code>coagulation_loss</code> - Loss rate due to coagulation.</li> <li><code>coagulation_gain</code> - Gain rate due to coagulation.</li> <li><code>dilution_loss</code> - Loss rate due to dilution.</li> <li><code>wall_loss_rate</code> - Loss rate due to wall deposition.</li> <li><code>net_rate</code> - Net rate considering all effects.</li> </ul>"},{"location":"API/particula/data/process/chamber_rate_fitting/#signature_2","title":"Signature","text":"<pre><code>def calculate_pmf_rates(\n    radius_bins: NDArray[np.float64],\n    concentration_pmf: NDArray[np.float64],\n    temperature: float = 293.15,\n    pressure: float = 101325,\n    particle_density: float = 1000,\n    alpha_collision_efficiency: float = 1,\n    volume: float = 1,\n    input_flow_rate: float = 1.6e-07,\n    wall_eddy_diffusivity: float = 0.1,\n    chamber_dimensions: Tuple[float, float, float] = (1, 1, 1),\n) -&gt; Tuple[\n    NDArray[np.float64],\n    NDArray[np.float64],\n    NDArray[np.float64],\n    NDArray[np.float64],\n    NDArray[np.float64],\n]: ...\n</code></pre>"},{"location":"API/particula/data/process/chamber_rate_fitting/#coagulation_rates_cost_function","title":"coagulation_rates_cost_function","text":"<p>Show source in chamber_rate_fitting.py:122</p> <p>Cost function for the optimization of the eddy diffusivity and alpha collision efficiency.</p>"},{"location":"API/particula/data/process/chamber_rate_fitting/#signature_3","title":"Signature","text":"<pre><code>def coagulation_rates_cost_function(\n    parameters: NDArray[np.float64],\n    radius_bins: NDArray[np.float64],\n    concentration_pmf: NDArray[np.float64],\n    time_derivative_concentration_pmf: NDArray[np.float64],\n    temperature: float = 293.15,\n    pressure: float = 101325,\n    particle_density: float = 1000,\n    volume: float = 1,\n    input_flow_rate: float = 1.6e-07,\n    chamber_dimensions: Tuple[float, float, float] = (1, 1, 1),\n) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/data/process/chamber_rate_fitting/#create_guess_and_bounds","title":"create_guess_and_bounds","text":"<p>Show source in chamber_rate_fitting.py:185</p> <p>Create the initial guess array and bounds list for the optimization.</p>"},{"location":"API/particula/data/process/chamber_rate_fitting/#arguments_2","title":"Arguments","text":"<ul> <li><code>guess_eddy_diffusivity</code> - Initial guess for eddy diffusivity.</li> <li><code>guess_alpha_collision_efficiency</code> - Initial guess for alpha collision     efficiency.</li> <li><code>bounds_eddy_diffusivity</code> - Bounds for eddy diffusivity.</li> <li><code>bounds_alpha_collision_efficiency</code> - Bounds for alpha collision     efficiency.</li> </ul>"},{"location":"API/particula/data/process/chamber_rate_fitting/#returns_2","title":"Returns","text":"<ul> <li><code>initial_guess</code> - Numpy array of the initial guess values.</li> <li><code>bounds</code> - List of tuples representing the bounds for each parameter.</li> </ul>"},{"location":"API/particula/data/process/chamber_rate_fitting/#signature_4","title":"Signature","text":"<pre><code>def create_guess_and_bounds(\n    guess_eddy_diffusivity: float,\n    guess_alpha_collision_efficiency: float,\n    bounds_eddy_diffusivity: Tuple[float, float],\n    bounds_alpha_collision_efficiency: Tuple[float, float],\n) -&gt; Tuple[NDArray[np.float64], List[Tuple[float, float]]]: ...\n</code></pre>"},{"location":"API/particula/data/process/chamber_rate_fitting/#optimize_and_calculate_rates_looped","title":"optimize_and_calculate_rates_looped","text":"<p>Show source in chamber_rate_fitting.py:363</p> <p>Perform optimization and calculate rates for each time point in the stream.</p>"},{"location":"API/particula/data/process/chamber_rate_fitting/#arguments_3","title":"Arguments","text":"<ul> <li><code>pmf_stream</code> - Stream object containing the fitted PMF data.</li> <li><code>pmf_derivative_stream</code> - Stream object containing the derivative of the     PMF data.</li> <li><code>chamber_parameters</code> - ChamberParameters object containing     chamber-related parameters.</li> <li><code>fit_guess</code> - Initial guess for the optimization.</li> <li><code>fit_bounds</code> - Bounds for the optimization parameters.</li> </ul>"},{"location":"API/particula/data/process/chamber_rate_fitting/#returns_3","title":"Returns","text":"<ul> <li><code>result_stream</code> - Stream containing the optimization results for     each time point.</li> <li><code>coagulation_loss_stream</code> - Stream containing coagulation loss rates.</li> <li><code>coagulation_gain_stream</code> - Stream containing coagulation gain rates.</li> <li><code>coagulation_net_stream</code> - Stream containing net coagulation rates.</li> <li><code>dilution_loss_stream</code> - Stream containing dilution loss rates.</li> <li><code>wall_loss_rate_stream</code> - Stream containing wall loss rates.</li> <li><code>total_rate_stream</code> - Stream containing total rates.</li> </ul>"},{"location":"API/particula/data/process/chamber_rate_fitting/#signature_5","title":"Signature","text":"<pre><code>def optimize_and_calculate_rates_looped(\n    pmf_stream: Stream,\n    pmf_derivative_stream: Stream,\n    chamber_parameters: ChamberParameters,\n    fit_guess: NDArray[np.float64],\n    fit_bounds: List[Tuple[float, float]],\n) -&gt; Tuple[Stream, Stream, Stream, Stream, Stream, Stream, Stream]: ...\n</code></pre>"},{"location":"API/particula/data/process/chamber_rate_fitting/#see-also_1","title":"See also","text":"<ul> <li>ChamberParameters</li> <li>Stream</li> </ul>"},{"location":"API/particula/data/process/chamber_rate_fitting/#optimize_chamber_parameters","title":"optimize_chamber_parameters","text":"<p>Show source in chamber_rate_fitting.py:232</p> <p>Optimize the eddy diffusivity and alpha collision efficiency parameters for a given particle size distribution and its time derivative.</p>"},{"location":"API/particula/data/process/chamber_rate_fitting/#arguments_4","title":"Arguments","text":"<ul> <li><code>radius_bins</code> - Array of particle size bins in meters.</li> <li><code>concentration_pmf</code> - Array of particle mass fractions (PMF)     concentrations at each radius bin.</li> <li><code>time_derivative_concentration_pmf</code> - Array of time derivatives of     the PMF concentrations, representing the rate of change     in concentration over time.</li> <li><code>chamber_params</code> - ChamberParameters object containing the physical     properties of the chamber, including temperature, pressure,     particle density, volume, input flow rate, and chamber dimensions.</li> <li><code>fit_guess</code> - Initial guess for the optimization parameters     (eddy diffusivity and alpha collision efficiency).</li> <li><code>fit_bounds</code> - List of tuples specifying the bounds for the     optimization parameters (lower and upper bounds     for each parameter).</li> <li><code>minimize_method</code> - Optimization method to be used. Default is \"L-BFGS-B\".     The following methods from <code>scipy.optimize.minimize</code> accept bounds,     \"L-BFGS-B\", \"TNC\", \"SLSQP\", \"Powell\", \"trust-constr\".</li> </ul>"},{"location":"API/particula/data/process/chamber_rate_fitting/#returns_4","title":"Returns","text":"<ul> <li><code>wall_eddy_diffusivity_optimized</code> - Optimized value of the wall eddy     diffusivity (in 1/s).</li> <li><code>alpha_collision_efficiency_optimized</code> - Optimized value of the alpha     collision efficiency (dimensionless).</li> </ul>"},{"location":"API/particula/data/process/chamber_rate_fitting/#signature_6","title":"Signature","text":"<pre><code>def optimize_chamber_parameters(\n    radius_bins: NDArray[np.float64],\n    concentration_pmf: NDArray[np.float64],\n    time_derivative_concentration_pmf: NDArray[np.float64],\n    chamber_parameters: ChamberParameters,\n    fit_guess: NDArray[np.float64],\n    fit_bounds: List[Tuple[float, float]],\n    minimize_method: str = \"L-BFGS-B\",\n) -&gt; Tuple[float, float]: ...\n</code></pre>"},{"location":"API/particula/data/process/chamber_rate_fitting/#see-also_2","title":"See also","text":"<ul> <li>ChamberParameters</li> </ul>"},{"location":"API/particula/data/process/chamber_rate_fitting/#optimize_parameters","title":"optimize_parameters","text":"<p>Show source in chamber_rate_fitting.py:215</p> <p>Get the optimized parameters using the given cost function.</p>"},{"location":"API/particula/data/process/chamber_rate_fitting/#signature_7","title":"Signature","text":"<pre><code>def optimize_parameters(\n    cost_function: ignore,\n    initial_guess: NDArray[np.float64],\n    bounds: List[Tuple[float, float]],\n    method: str,\n) -&gt; Tuple[float, float]: ...\n</code></pre>"},{"location":"API/particula/data/process/kappa_via_extinction/","title":"Kappa Via Extinction","text":"<p>Particula Index / Particula / Data / Process / Kappa Via Extinction</p> <p>Auto-generated documentation for particula.data.process.kappa_via_extinction module.</p>"},{"location":"API/particula/data/process/kappa_via_extinction/#extinction_ratio_wet_dry","title":"extinction_ratio_wet_dry","text":"<p>Show source in kappa_via_extinction.py:18</p> <p>Calculate the extinction ratio between wet and dry aerosols, considering water uptake through the kappa parameter.</p> <p>This function uses Mie theory to determine the optical properties of aerosols with varying water content, allowing for analysis of hygroscopic growth and its impact on aerosol optical characteristics.</p>"},{"location":"API/particula/data/process/kappa_via_extinction/#arguments","title":"Arguments","text":"<ul> <li><code>kappa</code> - Hygroscopicity parameter, defining the water uptake ability     of particles.</li> <li><code>number_per_cm3</code> - Number concentration of particles per cubic     centimeter for each size bin.</li> <li><code>diameters</code> - Diameters of particles in nanometers for each size bin.</li> <li><code>water_activity_sizer</code> - Water activity of the aerosol size distribution.</li> <li><code>water_activity_dry</code> - Water activity for the calculation of \"dry\"     aerosol properties.</li> <li><code>water_activity_wet</code> - Water activity for the calculation of \"wet\"     aerosol properties.</li> <li><code>refractive_index_dry</code> - Refractive index of the dry aerosol particles.     Default is 1.45.</li> <li><code>water_refractive_index</code> - Refractive index of water. Default is 1.33.</li> <li><code>wavelength</code> - Wavelength of the incident light in nanometers.     Default is 450 nm.</li> <li><code>discretize</code> - If True, discretizes input arguments for Mie calculations     to enable caching. Default is True.</li> <li><code>return_coefficients</code> - If True, returns the individual extinction     coefficients for wet and dry aerosols instead of their ratio.     Default is False.</li> <li><code>return_all_optics</code> - If True, returns all optical properties calculated     by Mie theory, not just extinction. Default is False.</li> </ul>"},{"location":"API/particula/data/process/kappa_via_extinction/#returns","title":"Returns","text":"<p>By default, returns the ratio of wet to dry aerosol extinction. If <code>return_coefficients</code> is True, returns a tuple of NDArrays containing the extinction coefficients for wet and dry aerosols, respectively.</p>"},{"location":"API/particula/data/process/kappa_via_extinction/#signature","title":"Signature","text":"<pre><code>def extinction_ratio_wet_dry(\n    kappa: Union[float, NDArray[np.float64]],\n    number_per_cm3: NDArray[np.float64],\n    diameters: NDArray[np.float64],\n    water_activity_sizer: NDArray[np.float64],\n    water_activity_dry: NDArray[np.float64],\n    water_activity_wet: NDArray[np.float64],\n    refractive_index_dry: Union[complex, float] = 1.45,\n    water_refractive_index: Union[complex, float] = 1.33,\n    wavelength: float = 450,\n    discretize: bool = True,\n    return_coefficients: bool = False,\n    return_all_optics: bool = False,\n) -&gt; Union[float, Tuple[NDArray, NDArray]]: ...\n</code></pre>"},{"location":"API/particula/data/process/kappa_via_extinction/#fit_extinction_ratio_with_kappa","title":"fit_extinction_ratio_with_kappa","text":"<p>Show source in kappa_via_extinction.py:134</p> <p>Fit the kappa parameter based on the measured extinction ratios of dry and wet aerosols, considering water uptake effects.</p> <p>This method uses Mie theory to optimize kappa by minimizing the difference between the calculated and observed extinction ratios of wet to dry aerosols.</p>"},{"location":"API/particula/data/process/kappa_via_extinction/#arguments_1","title":"Arguments","text":"<ul> <li><code>b_ext_dry</code> - The measured extinction of the dry aerosol.</li> <li><code>b_ext_wet</code> - The measured extinction of the wet aerosol.</li> <li><code>number_per_cm3</code> - Number concentration of particles per cubic centimeter     for each size bin.</li> <li><code>diameters</code> - Diameters of particles in nanometers for each size bin.</li> <li><code>water_activity_sizer</code> - Water activity corresponding to the aerosol     size distribution.</li> <li><code>water_activity_dry</code> - Water activity for the \"dry\" aerosol condition.</li> <li><code>water_activity_wet</code> - Water activity for the \"wet\" aerosol condition.</li> <li><code>refractive_index_dry</code> - Refractive index of the dry aerosol particles.     Default is 1.45.</li> <li><code>water_refractive_index</code> - Refractive index of water. Default is 1.33.</li> <li><code>wavelength</code> - Wavelength of incident light in nanometers. Default is     450 nm.</li> <li><code>discretize</code> - If True, discretizes input arguments for Mie calculations     to enable caching. Default is True.</li> <li><code>kappa_bounds</code> - Bounds within which to fit the kappa parameter.     Default is (0, 1).</li> <li><code>kappa_tolerance</code> - Tolerance level for the optimization of kappa.     Default is 1e-6.</li> <li><code>kappa_maxiter</code> - Maximum number of iterations allowed in the optimization     process. Default is 200.</li> </ul>"},{"location":"API/particula/data/process/kappa_via_extinction/#returns_1","title":"Returns","text":"<p>The optimized kappa parameter that best fits the observed extinction ratios.</p>"},{"location":"API/particula/data/process/kappa_via_extinction/#signature_1","title":"Signature","text":"<pre><code>def fit_extinction_ratio_with_kappa(\n    b_ext_dry: Union[float, np.float64],\n    b_ext_wet: Union[float, np.float64],\n    number_per_cm3: NDArray[np.float64],\n    diameters: NDArray[np.float64],\n    water_activity_sizer: NDArray[np.float64],\n    water_activity_dry: NDArray[np.float64],\n    water_activity_wet: NDArray[np.float64],\n    refractive_index_dry: Union[complex, float] = 1.45,\n    water_refractive_index: Union[complex, float] = 1.33,\n    wavelength: float = 450,\n    discretize: bool = True,\n    kappa_bounds: Tuple[float, float] = (0, 1),\n    kappa_tolerance: float = 1e-06,\n    kappa_maxiter: int = 200,\n) -&gt; Union[float, np.float64]: ...\n</code></pre>"},{"location":"API/particula/data/process/kappa_via_extinction/#kappa_from_extinction_looped","title":"kappa_from_extinction_looped","text":"<p>Show source in kappa_via_extinction.py:228</p> <p>Fit the extinction ratio to the kappa value for a set of measurements, looping over time indexes in <code>number_per_cm3</code>.</p> <p>This function is designed for analyzing data from a CAPS (Cavity Attenuated Phase Shift) instrument under varying humidities.</p>"},{"location":"API/particula/data/process/kappa_via_extinction/#arguments_2","title":"Arguments","text":"<ul> <li><code>extinction_dry</code> - Array of dry aerosol extinction measurements.</li> <li><code>extinction_wet</code> - Array of wet aerosol extinction measurements.</li> <li><code>number_per_cm3</code> - Array of particle number concentrations in #/cm\u00b3.</li> <li><code>diameter</code> - Array of particle diameters in nanometers.</li> <li><code>water_activity_sizer</code> - Water activity (relative humidity/100) of the     sizing instrument's air.</li> <li><code>water_activity_sample_dry</code> - Water activity (relative humidity/100) of     the air for dry measurements.</li> <li><code>water_activity_sample_wet</code> - Water activity (relative humidity/100) of     the air for wet measurements.</li> <li><code>refractive_index_dry</code> - Refractive index of dry particles.     Default is 1.45.</li> <li><code>water_refractive_index</code> - Refractive index of water. Default is 1.33.</li> <li><code>wavelength</code> - Wavelength of the light source in nanometers.     Default is 450 nm.</li> <li><code>discretize</code> - If True, calculations are performed with discretized     parameter values to potentially improve performance.     Default is True.</li> </ul>"},{"location":"API/particula/data/process/kappa_via_extinction/#returns_2","title":"Returns","text":"<p>A 2D array where each row corresponds to the time-indexed kappa value, lower and upper bounds of the kappa estimation, structured as [kappa, lower, upper].</p>"},{"location":"API/particula/data/process/kappa_via_extinction/#signature_2","title":"Signature","text":"<pre><code>def kappa_from_extinction_looped(\n    extinction_dry: NDArray[np.float64],\n    extinction_wet: NDArray[np.float64],\n    number_per_cm3: NDArray[np.float64],\n    diameter: NDArray[np.float64],\n    water_activity_sizer: NDArray[np.float64],\n    water_activity_sample_dry: NDArray[np.float64],\n    water_activity_sample_wet: NDArray[np.float64],\n    refractive_index_dry: Union[complex, float] = 1.45,\n    water_refractive_index: Union[complex, float] = 1.33,\n    wavelength: float = 450,\n    discretize: bool = True,\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/data/process/lognormal_2mode/","title":"Lognormal 2mode","text":"<p>Particula Index / Particula / Data / Process / Lognormal 2mode</p> <p>Auto-generated documentation for particula.data.process.lognormal_2mode module.</p>"},{"location":"API/particula/data/process/lognormal_2mode/#attributes","title":"Attributes","text":"<ul> <li><code>logger</code> - Set up logging: logging.getLogger('particula')</li> </ul>"},{"location":"API/particula/data/process/lognormal_2mode/#cost_function","title":"cost_function","text":"<p>Show source in lognormal_2mode.py:26</p> <p>Cost function for the lognormal distribution with 2 modes.</p>"},{"location":"API/particula/data/process/lognormal_2mode/#arguments","title":"Arguments","text":"<ul> <li><code>params</code> - Combined array of mode_values, geometric_standard_deviation,     and number_of_particles.</li> <li><code>x_values</code> - The x-values (particle sizes).</li> <li><code>concentration_pdf</code> - The actual concentration PDF to fit.</li> </ul>"},{"location":"API/particula/data/process/lognormal_2mode/#returns","title":"Returns","text":"<p>The mean squared error between the actual and guessed concentration     PDF.</p>"},{"location":"API/particula/data/process/lognormal_2mode/#signature","title":"Signature","text":"<pre><code>def cost_function(\n    params: NDArray[np.float64],\n    x_values: NDArray[np.float64],\n    concentration_pdf: NDArray[np.float64],\n) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/data/process/lognormal_2mode/#create_lognormal_2mode_from_fit","title":"create_lognormal_2mode_from_fit","text":"<p>Show source in lognormal_2mode.py:383</p> <p>Create a fitted PMF stream and concentration matrix based on optimized parameters.</p>"},{"location":"API/particula/data/process/lognormal_2mode/#arguments_1","title":"Arguments","text":"<ul> <li><code>parameters_stream</code> - Stream object containing the optimized parameters.</li> <li><code>radius_min</code> - Log10 of the minimum radius value in meters (default: -9).</li> <li><code>radius_max</code> - Log10 of the maximum radius value in meters (default: -6).</li> <li><code>num_radius_bins</code> - Number of radius bins to create between radius_min     and radius_max.</li> </ul>"},{"location":"API/particula/data/process/lognormal_2mode/#returns_1","title":"Returns","text":"<ul> <li><code>fitted_pmf_stream</code> - A Stream object containing the time and fitted     concentration PMF data.</li> <li><code>fitted_concentration_pmf</code> - A numpy array with the fitted     concentration PMF values.</li> </ul>"},{"location":"API/particula/data/process/lognormal_2mode/#signature_1","title":"Signature","text":"<pre><code>def create_lognormal_2mode_from_fit(\n    parameters_stream: Stream,\n    radius_min: float = 1e-09,\n    radius_max: float = 1e-06,\n    num_radius_bins: int = 250,\n) -&gt; Tuple[Stream, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/data/process/lognormal_2mode/#see-also","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"API/particula/data/process/lognormal_2mode/#evaluate_fit","title":"evaluate_fit","text":"<p>Show source in lognormal_2mode.py:131</p> <p>Evaluate the best fit and calculate R\u00b2 score.</p>"},{"location":"API/particula/data/process/lognormal_2mode/#signature_2","title":"Signature","text":"<pre><code>def evaluate_fit(\n    best_result: dict[str, Any],\n    logspace_x: NDArray[np.float64],\n    concentration_pdf: NDArray[np.float64],\n) -&gt; Tuple[NDArray[np.float64], NDArray[np.float64], NDArray[np.float64], float]: ...\n</code></pre>"},{"location":"API/particula/data/process/lognormal_2mode/#get_bounds","title":"get_bounds","text":"<p>Show source in lognormal_2mode.py:73</p> <p>Provide default bounds for optimization parameters.</p>"},{"location":"API/particula/data/process/lognormal_2mode/#signature_3","title":"Signature","text":"<pre><code>def get_bounds() -&gt; List[Tuple[float, Any]]: ...\n</code></pre>"},{"location":"API/particula/data/process/lognormal_2mode/#get_initial_guesses","title":"get_initial_guesses","text":"<p>Show source in lognormal_2mode.py:85</p> <p>Combine initial guesses into a single array.</p>"},{"location":"API/particula/data/process/lognormal_2mode/#signature_4","title":"Signature","text":"<pre><code>def get_initial_guesses(\n    mode_guess: NDArray[np.float64],\n    geometric_standard_deviation_guess: NDArray[np.float64],\n    number_of_particles_in_mode_guess: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/data/process/lognormal_2mode/#guess_and_optimize_looped","title":"guess_and_optimize_looped","text":"<p>Show source in lognormal_2mode.py:301</p> <p>Generate initial guesses using a machine learning model, optimize them, and return a Stream object with the results.</p>"},{"location":"API/particula/data/process/lognormal_2mode/#arguments_2","title":"Arguments","text":"<ul> <li><code>experiment_time</code> - Array of experiment time points.</li> <li><code>radius_m</code> - Array of particle radii in meters.</li> <li><code>concentration_m3_pdf</code> - 2D array of concentration PDFs for each     time point.</li> </ul>"},{"location":"API/particula/data/process/lognormal_2mode/#returns_2","title":"Returns","text":"<ul> <li><code>fitted_stream</code> - A Stream object containing the initial guesses,     optimized values, and R\u00b2 scores.</li> </ul>"},{"location":"API/particula/data/process/lognormal_2mode/#signature_5","title":"Signature","text":"<pre><code>def guess_and_optimize_looped(\n    experiment_time: NDArray[np.float64],\n    radius_m: NDArray[np.float64],\n    concentration_m3_pdf: NDArray[np.float64],\n) -&gt; Stream: ...\n</code></pre>"},{"location":"API/particula/data/process/lognormal_2mode/#see-also_1","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"API/particula/data/process/lognormal_2mode/#optimize_fit","title":"optimize_fit","text":"<p>Show source in lognormal_2mode.py:165</p> <p>Optimize the lognormal 2-mode distribution parameters using multiple optimization methods.</p>"},{"location":"API/particula/data/process/lognormal_2mode/#signature_6","title":"Signature","text":"<pre><code>def optimize_fit(\n    mode_guess: NDArray[np.float64],\n    geometric_standard_deviation_guess: NDArray[np.float64],\n    number_of_particles_in_mode_guess: NDArray[np.float64],\n    logspace_x: NDArray[np.float64],\n    concentration_pdf: NDArray[np.float64],\n    bounds: Optional[List[Tuple[float, Any]]] = None,\n    list_of_methods: Optional[List[str]] = None,\n) -&gt; Tuple[\n    NDArray[np.float64], NDArray[np.float64], NDArray[np.float64], float, dict[str, Any]\n]: ...\n</code></pre>"},{"location":"API/particula/data/process/lognormal_2mode/#optimize_fit_looped","title":"optimize_fit_looped","text":"<p>Show source in lognormal_2mode.py:232</p> <p>Loop through the concentration PDFs to get the best optimization.</p>"},{"location":"API/particula/data/process/lognormal_2mode/#arguments_3","title":"Arguments","text":"<ul> <li><code>mode_guess</code> - Array of mode values.</li> <li><code>geometric_standard_deviation_guess</code> - Array of geometric standard     deviations.</li> <li><code>number_of_particles_in_mode_guess</code> - Array of number of particles.</li> <li><code>x_values</code> - Array of x-values (particle sizes).</li> <li><code>concentration_pdf</code> - Matrix of concentration PDF values.</li> <li><code>bounds</code> - List of bounds for optimization.</li> <li><code>list_of_methods</code> - List of optimization methods.</li> </ul>"},{"location":"API/particula/data/process/lognormal_2mode/#returns_3","title":"Returns","text":"<ul> <li><code>optimized_mode_values</code> - Optimized mode values.</li> <li><code>optimized_gsd</code> - Optimized geometric standard deviations.</li> <li><code>optimized_number_of_particles</code> - Optimized number of particles.</li> <li><code>r2</code> - R\u00b2 score.</li> <li><code>optimization_results</code> - Dictionary of optimization results.</li> </ul>"},{"location":"API/particula/data/process/lognormal_2mode/#signature_7","title":"Signature","text":"<pre><code>def optimize_fit_looped(\n    mode_guess: NDArray[np.float64],\n    geometric_standard_deviation_guess: NDArray[np.float64],\n    number_of_particles_in_mode_guess: NDArray[np.float64],\n    logspace_x: NDArray[np.float64],\n    concentration_pdf: NDArray[np.float64],\n    bounds: Optional[List[Tuple[float, Any]]] = None,\n    list_of_methods: Optional[List[str]] = None,\n) -&gt; Tuple[\n    NDArray[np.float64], NDArray[np.float64], NDArray[np.float64], NDArray[np.float64]\n]: ...\n</code></pre>"},{"location":"API/particula/data/process/lognormal_2mode/#run_optimization","title":"run_optimization","text":"<p>Show source in lognormal_2mode.py:100</p> <p>Perform the optimization using the specified method.</p>"},{"location":"API/particula/data/process/lognormal_2mode/#signature_8","title":"Signature","text":"<pre><code>def run_optimization(\n    method: str,\n    initial_guess: NDArray[np.float64],\n    bounds: List[Tuple[float, Any]],\n    x_values: NDArray[np.float64],\n    concentration_pdf: NDArray[np.float64],\n) -&gt; Optional[dict[str, Any]]: ...\n</code></pre>"},{"location":"API/particula/data/process/mie_angular/","title":"Mie Angular","text":"<p>Particula Index / Particula / Data / Process / Mie Angular</p> <p>Auto-generated documentation for particula.data.process.mie_angular module.</p>"},{"location":"API/particula/data/process/mie_angular/#assign_scattering_thetas","title":"assign_scattering_thetas","text":"<p>Show source in mie_angular.py:101</p> <p>Assign scattering angles and efficiencies based on the z-axis position within the CAPS instrument.</p>"},{"location":"API/particula/data/process/mie_angular/#arguments","title":"Arguments","text":"<ul> <li><code>alpha</code> - The forward scattering angle in radians.</li> <li><code>beta</code> - The backward scattering angle in radians.</li> <li><code>q_mie</code> - The Mie scattering efficiency.</li> <li><code>z_position</code> - The position along the z-axis in centimeters (cm).</li> <li><code>integrate_sphere_diameter_cm</code> - The diameter of the integrating sphere     in centimeters (cm).</li> </ul>"},{"location":"API/particula/data/process/mie_angular/#returns","title":"Returns","text":"<p>Tuple: - The forward scattering angle (theta1) in radians. - The backward scattering angle (theta2) in radians. - The ideal scattering efficiency (qsca_ideal) for the given z-axis     position.</p>"},{"location":"API/particula/data/process/mie_angular/#signature","title":"Signature","text":"<pre><code>def assign_scattering_thetas(\n    alpha: float,\n    beta: float,\n    q_mie: float,\n    z_position: Union[float, np.float64],\n    integrate_sphere_diameter_cm: float,\n) -&gt; Tuple[float, float, float]: ...\n</code></pre>"},{"location":"API/particula/data/process/mie_angular/#calculate_scattering_angles","title":"calculate_scattering_angles","text":"<p>Show source in mie_angular.py:63</p> <p>Calculate forward and backward scattering angles for a given position along the z-axis within the CAPS instrument geometry.</p>"},{"location":"API/particula/data/process/mie_angular/#arguments_1","title":"Arguments","text":"<ul> <li><code>z_position</code> - The position along the z-axis in centimeters (cm).</li> <li><code>integrate_sphere_diameter_cm</code> - The diameter of the integrating sphere     in centimeters (cm).</li> <li><code>tube_diameter_cm</code> - The diameter of the sample tube in centimeters (cm).</li> </ul>"},{"location":"API/particula/data/process/mie_angular/#returns_1","title":"Returns","text":"<p>Tuple: - The forward scattering angle (alpha) in radians. - The backward scattering angle (beta) in radians.</p>"},{"location":"API/particula/data/process/mie_angular/#signature_1","title":"Signature","text":"<pre><code>def calculate_scattering_angles(\n    z_position: Union[float, np.float64],\n    integrate_sphere_diameter_cm: float,\n    tube_diameter_cm: float,\n) -&gt; Tuple[float, float]: ...\n</code></pre>"},{"location":"API/particula/data/process/mie_angular/#discretize_scattering_angles","title":"discretize_scattering_angles","text":"<p>Show source in mie_angular.py:16</p> <p>Discretize and cache the scattering function for a spherical particle with specified material properties and size.</p> <p>This function optimizes the performance of scattering calculations by caching results for frequently used parameters, thereby reducing the need for repeated calculations.</p>"},{"location":"API/particula/data/process/mie_angular/#arguments_2","title":"Arguments","text":"<ul> <li><code>m_sphere</code> - The complex or real refractive index of the particle.</li> <li><code>wavelength</code> - The wavelength of the incident light in nanometers (nm).</li> <li><code>diameter</code> - The diameter of the particle in nanometers (nm).</li> <li><code>min_angle</code> - The minimum scattering angle in degrees to be considered in     the calculation. Defaults to 0.</li> <li><code>max_angle</code> - The maximum scattering angle in degrees to be considered in     the calculation. Defaults to 180.</li> <li><code>angular_resolution</code> - The resolution in degrees between calculated     scattering angles. Defaults to 1.</li> </ul>"},{"location":"API/particula/data/process/mie_angular/#returns_2","title":"Returns","text":"<p>Tuple: - <code>-</code> measure - The scattering intensity as a function of angle. - <code>-</code> parallel - The scattering intensity for parallel polarization. - <code>-</code> perpendicular - The scattering intensity for perpendicular     polarization. - <code>-</code> unpolarized - The unpolarized scattering intensity.</p>"},{"location":"API/particula/data/process/mie_angular/#signature_2","title":"Signature","text":"<pre><code>@lru_cache(maxsize=100000)\ndef discretize_scattering_angles(\n    m_sphere: Union[complex, float],\n    wavelength: float,\n    diameter: Union[float, np.float64],\n    min_angle: int = 0,\n    max_angle: int = 180,\n    angular_resolution: float = 1,\n) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: ...\n</code></pre>"},{"location":"API/particula/data/process/mie_bulk/","title":"Mie Bulk","text":"<p>Particula Index / Particula / Data / Process / Mie Bulk</p> <p>Auto-generated documentation for particula.data.process.mie_bulk module.</p>"},{"location":"API/particula/data/process/mie_bulk/#compute_bulk_optics","title":"compute_bulk_optics","text":"<p>Show source in mie_bulk.py:129</p> <p>Compute bulk optical properties from size-dependent efficiency factors for a size distribution.</p> <p>This function calculates various bulk optical properties such as extinction, scattering, and backscattering coefficients based on the size distribution and corresponding efficiency factors.</p>"},{"location":"API/particula/data/process/mie_bulk/#arguments","title":"Arguments","text":"<ul> <li><code>q_ext</code> - Array of extinction efficiency factors.</li> <li><code>q_sca</code> - Array of scattering efficiency factors.</li> <li><code>q_back</code> - Array of backscatter efficiency factors.</li> <li><code>q_ratio</code> - Array of backscatter-to-extinction ratio efficiency factors.</li> <li><code>g</code> - Array of asymmetry factors.</li> <li><code>area_dist</code> - Area-scaled size distribution array.</li> <li><code>extinction_only</code> - Flag indicating whether to compute only the     extinction coefficient.</li> <li><code>pms</code> - Flag indicating whether a probability mass distribution is used,     where the sum of all bins     represents the total number of particles.</li> <li><code>dp</code> - Array of particle diameters in nanometers.</li> </ul>"},{"location":"API/particula/data/process/mie_bulk/#returns","title":"Returns","text":"<p>If <code>extinction_only</code> is True, returns an array with the bulk extinction coefficient. Otherwise, returns a tuple containing the bulk optical properties, including extinction, scattering, and backscattering coefficients, and possibly others depending on the input flags.</p>"},{"location":"API/particula/data/process/mie_bulk/#signature","title":"Signature","text":"<pre><code>def compute_bulk_optics(\n    q_ext: NDArray[np.float64],\n    q_sca: NDArray[np.float64],\n    q_back: NDArray[np.float64],\n    q_ratio: NDArray[np.float64],\n    g: NDArray[np.float64],\n    area_dist: NDArray[np.float64],\n    extinction_only: bool,\n    pms: bool,\n    dp: NDArray[np.float64],\n) -&gt; Union[NDArray[np.float64], tuple[NDArray[np.float64], ...]]: ...\n</code></pre>"},{"location":"API/particula/data/process/mie_bulk/#discretize_auto_mieq","title":"discretize_auto_mieq","text":"<p>Show source in mie_bulk.py:19</p> <p>Compute Mie coefficients for a spherical particle based on its material properties, size, and the properties of the surrounding medium.</p> <p>This function uses the PyMieScatt library to calculate various Mie efficiencies and parameters for a single sphere, including extinction efficiency (q_ext), scattering efficiency (q_sca), absorption efficiency (q_abs), asymmetry factor (g), radiation pressure efficiency (q_pr), backscatter efficiency (q_back), and the ratio of backscatter to extinction efficiency (q_ratio).</p> <p>The function is optimized with an LRU (Least Recently Used) cache, which stores up to 100,000 recent computations to improve performance by avoiding repeated calculations for the same inputs.</p>"},{"location":"API/particula/data/process/mie_bulk/#arguments_1","title":"Arguments","text":"<ul> <li><code>m_sphere</code> - The complex refractive index of the sphere. A real     number can be provided for non-absorbing materials.</li> <li><code>wavelength</code> - The wavelength of the incident light in nanometers (nm).</li> <li><code>diameter</code> - The diameter of the sphere in nanometers (nm).</li> <li><code>m_medium</code> - The refractive index of the surrounding medium.     Default is 1.0, corresponding to vacuum.</li> </ul>"},{"location":"API/particula/data/process/mie_bulk/#returns_1","title":"Returns","text":"<p>Tuple:     - q_ext, Extinction efficiency.     - q_sca, Scattering efficiency.     - q_abs, Absorption efficiency.     - g, Asymmetry factor.     - q_pr, Radiation pressure efficiency.     - q_back, Backscatter efficiency.     - q_ratio, Ratio of backscatter to extinction efficiency.</p>"},{"location":"API/particula/data/process/mie_bulk/#signature_1","title":"Signature","text":"<pre><code>@lru_cache(maxsize=100000)\ndef discretize_auto_mieq(\n    m_sphere: Union[complex, float],\n    wavelength: float,\n    diameter: float,\n    m_medium: float = 1.0,\n) -&gt; Tuple[float, ...]: ...\n</code></pre>"},{"location":"API/particula/data/process/mie_bulk/#discretize_mie_parameters","title":"discretize_mie_parameters","text":"<p>Show source in mie_bulk.py:64</p> <p>Discretize the refractive index, wavelength, and diameters for Mie scattering calculations.</p> <p>This function improves numerical stability and performance by discretizing the refractive index of the material, the wavelength of incident light, and the diameters of particles. Discretization reduces the variability in input parameters, making Mie scattering computations more efficient by creating a more manageable set of unique calculations.</p>"},{"location":"API/particula/data/process/mie_bulk/#arguments_2","title":"Arguments","text":"<ul> <li><code>m_sphere</code> - The complex or real refractive index of the particles.     This value is discretized to a specified base to reduce     input variability.</li> <li><code>wavelength</code> - The wavelength of incident light in nanometers (nm),     discretized to minimize variations in related computations.</li> <li><code>diameter</code> - The particle diameter or array of diameters in nanometers     (nm), discretized to a specified base to standardize input sizes     for calculations.</li> <li><code>base_m_sphere</code> - Optional; the base value to which the real and     imaginary parts of the refractive index are rounded.     Default is 0.001.</li> <li><code>base_wavelength</code> - Optional; the base value to which the wavelength is     rounded. Default is 1 nm.</li> <li><code>base_diameter</code> - Optional; the base value to which particle diameters     are rounded. Default is 5 nm.</li> </ul>"},{"location":"API/particula/data/process/mie_bulk/#returns_2","title":"Returns","text":"<p>Tuple:     - The discretized refractive index (m_sphere).     - The discretized wavelength.     - The discretized diameter or array of diameters, suitable for use         in Mie scattering calculations with potentially improved         performance and reduced computational overhead.</p>"},{"location":"API/particula/data/process/mie_bulk/#signature_2","title":"Signature","text":"<pre><code>def discretize_mie_parameters(\n    m_sphere: Union[complex, float],\n    wavelength: float,\n    diameter: Union[float, NDArray[np.float64]],\n    base_m_sphere: float = 0.001,\n    base_wavelength: float = 1,\n    base_diameter: float = 5,\n) -&gt; Tuple[Union[complex, float], float, Union[float, list[float]]]: ...\n</code></pre>"},{"location":"API/particula/data/process/mie_bulk/#format_mie_results","title":"format_mie_results","text":"<p>Show source in mie_bulk.py:194</p> <p>Format the output results of the Mie scattering calculations.</p>"},{"location":"API/particula/data/process/mie_bulk/#arguments_3","title":"Arguments","text":"<ul> <li><code>b_ext</code> - Array of bulk extinction coefficients.</li> <li><code>b_sca</code> - Array of bulk scattering coefficients.</li> <li><code>b_abs</code> - Array of bulk absorption coefficients.</li> <li><code>big_g</code> - Array of asymmetry factors (g).</li> <li><code>b_pr</code> - Array of bulk radiation pressure efficiencies.</li> <li><code>b_back</code> - Array of bulk backscattering coefficients.</li> <li><code>b_ratio</code> - Array of backscatter-to-extinction ratios.</li> <li><code>as_dict</code> - Flag to determine if the results should be returned as a     dictionary.</li> </ul>"},{"location":"API/particula/data/process/mie_bulk/#returns_3","title":"Returns","text":"<p>(dict, Tuple):     - If <code>as_dict</code> is True, returns a dictionary with the bulk optical         properties.     - If <code>as_dict</code> is False, returns a tuple of the bulk         optical properties in the following order,         (b_ext, b_sca, b_abs, big_g, b_pr, b_back, b_ratio).</p>"},{"location":"API/particula/data/process/mie_bulk/#signature_3","title":"Signature","text":"<pre><code>def format_mie_results(\n    b_ext: NDArray[np.float64],\n    b_sca: NDArray[np.float64],\n    b_abs: NDArray[np.float64],\n    big_g: NDArray[np.float64],\n    b_pr: NDArray[np.float64],\n    b_back: NDArray[np.float64],\n    b_ratio: NDArray[np.float64],\n    as_dict: bool,\n) -&gt; Union[dict[str, NDArray[np.float64]], tuple[NDArray[np.float64], ...]]: ...\n</code></pre>"},{"location":"API/particula/data/process/mie_bulk/#mie_size_distribution","title":"mie_size_distribution","text":"<p>Show source in mie_bulk.py:239</p> <p>Calculate Mie scattering parameters for a size distribution of spherical particles.</p> <p>This function computes optical properties such as extinction, scattering, absorption coefficients, asymmetry factor, backscatter efficiency, and their ratios for a given size distribution of spherical particles. It supports various modes of calculation, including discretization of input parameters and optional truncation of the scattering efficiency.</p>"},{"location":"API/particula/data/process/mie_bulk/#arguments_4","title":"Arguments","text":"<ul> <li><code>m_sphere</code> - The complex refractive index of the particles. Real values     can be used for non-absorbing materials.</li> <li><code>wavelength</code> - The wavelength of the incident light in nanometers (nm).</li> <li><code>diameter</code> - An array of particle diameters in nanometers (nm).</li> <li><code>number_per_cm3</code> - The number distribution of particles per cubic     centimeter (#/cm^3).</li> <li><code>n_medium</code> - The refractive index of the medium. Defaults to 1.0     (air or vacuum).</li> <li><code>pms</code> - Specifies if the size distribution is in probability mass form.     Default is True.</li> <li><code>as_dict</code> - If True, results are returned as a dictionary. Otherwise,     as a tuple. Default is False.</li> <li><code>extinction_only</code> - If True, only the extinction coefficient is     calculated and returned. Default is False.</li> <li><code>discretize</code> - If True, input parameters (m_sphere, wavelength, diameter)     are discretized for computation. Default is False.</li> <li><code>truncation_calculation</code> - Enables truncation of the scattering     efficiency based on a multiple of the backscattering coefficient.     Default is False.</li> <li><code>truncation_b_sca_multiple</code> - The multiple of the backscattering     coefficient used for truncating the scattering efficiency.     Required if <code>truncation_calculation</code> is True.</li> </ul>"},{"location":"API/particula/data/process/mie_bulk/#returns_4","title":"Returns","text":"<p>(NDArray, dict, Tuple):     - An array of extinction coefficients if <code>extinction_only</code> is True.     - A dictionary of computed optical properties if <code>as_dict</code> is True.     - A tuple of computed optical properties otherwise.</p>"},{"location":"API/particula/data/process/mie_bulk/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code> - If <code>truncation_calculation</code> is True but     <code>truncation_b_sca_multiple</code> is not specified.</li> </ul>"},{"location":"API/particula/data/process/mie_bulk/#signature_4","title":"Signature","text":"<pre><code>def mie_size_distribution(\n    m_sphere: Union[complex, float],\n    wavelength: float,\n    diameter: NDArray[np.float64],\n    number_per_cm3: NDArray[np.float64],\n    n_medium: float = 1.0,\n    pms: bool = True,\n    as_dict: bool = False,\n    extinction_only: bool = False,\n    discretize: bool = False,\n    truncation_calculation: bool = False,\n    truncation_b_sca_multiple: Optional[float] = None,\n) -&gt; Union[\n    NDArray[np.float64], dict[str, NDArray[np.float64]], Tuple[NDArray[np.float64], ...]\n]: ...\n</code></pre>"},{"location":"API/particula/data/process/optical_instrument/","title":"Optical Instrument","text":"<p>Particula Index / Particula / Data / Process / Optical Instrument</p> <p>Auto-generated documentation for particula.data.process.optical_instrument module.</p>"},{"location":"API/particula/data/process/optical_instrument/#capsinstrumentkeywordbuilder","title":"CapsInstrumentKeywordBuilder","text":"<p>Show source in optical_instrument.py:13</p> <p>Builder class for CAPS Instrument Keywords dictionary.</p>"},{"location":"API/particula/data/process/optical_instrument/#signature","title":"Signature","text":"<pre><code>class CapsInstrumentKeywordBuilder:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/data/process/optical_instrument/#capsinstrumentkeywordbuilderbuild","title":"CapsInstrumentKeywordBuilder().build","text":"<p>Show source in optical_instrument.py:92</p> <p>Validate and return the keywords dictionary.</p>"},{"location":"API/particula/data/process/optical_instrument/#returns","title":"Returns","text":"<ul> <li><code>dict</code> - The validated keywords dictionary.</li> </ul>"},{"location":"API/particula/data/process/optical_instrument/#signature_1","title":"Signature","text":"<pre><code>def build(self) -&gt; dict[str, Union[str, float, int, bool]]: ...\n</code></pre>"},{"location":"API/particula/data/process/optical_instrument/#capsinstrumentkeywordbuilderpre_build_check","title":"CapsInstrumentKeywordBuilder().pre_build_check","text":"<p>Show source in optical_instrument.py:77</p> <p>Check that all required parameters have been set.</p>"},{"location":"API/particula/data/process/optical_instrument/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code> - If any required keyword has not been set.</li> </ul>"},{"location":"API/particula/data/process/optical_instrument/#signature_2","title":"Signature","text":"<pre><code>def pre_build_check(self): ...\n</code></pre>"},{"location":"API/particula/data/process/optical_instrument/#capsinstrumentkeywordbuilderset_keyword","title":"CapsInstrumentKeywordBuilder().set_keyword","text":"<p>Show source in optical_instrument.py:38</p> <p>Set the keyword parameter for the activity calculation.</p>"},{"location":"API/particula/data/process/optical_instrument/#arguments","title":"Arguments","text":"<ul> <li><code>keyword</code> - The keyword to set.</li> <li><code>value</code> - The value to set the keyword to.</li> </ul>"},{"location":"API/particula/data/process/optical_instrument/#raises_1","title":"Raises","text":"<ul> <li><code>ValueError</code> - If the keyword is not recognized or the value type     is incorrect.</li> </ul>"},{"location":"API/particula/data/process/optical_instrument/#signature_3","title":"Signature","text":"<pre><code>def set_keyword(self, keyword: str, value: Optional[Union[str, float, int, bool]]): ...\n</code></pre>"},{"location":"API/particula/data/process/optical_instrument/#capsinstrumentkeywordbuilderset_keywords","title":"CapsInstrumentKeywordBuilder().set_keywords","text":"<p>Show source in optical_instrument.py:67</p> <p>Set multiple keywords at once.</p>"},{"location":"API/particula/data/process/optical_instrument/#arguments_1","title":"Arguments","text":"<ul> <li><code>kwargs</code> - The keywords and their values to set.</li> </ul>"},{"location":"API/particula/data/process/optical_instrument/#signature_4","title":"Signature","text":"<pre><code>def set_keywords(self, **kwargs: Union[str, float, int, bool]): ...\n</code></pre>"},{"location":"API/particula/data/process/optical_instrument/#albedo_from_ext_scat","title":"albedo_from_ext_scat","text":"<p>Show source in optical_instrument.py:247</p> <p>Calculate the albedo from the extinction and scattering data in the stream.</p> <p>This function computes the absorption as the difference between extinction and scattering, and the single-scattering albedo as the ratio of scattering to extinction. If the extinction values are zero or negative, the albedo is set to <code>np.nan</code>.</p>"},{"location":"API/particula/data/process/optical_instrument/#arguments_2","title":"Arguments","text":"<ul> <li><code>stream</code> - The datastream containing CAPS data.</li> <li><code>extinction_key</code> - The key for the extinction data in the stream.</li> <li><code>scattering_key</code> - The key for the scattering data in the stream.</li> <li><code>new_absorption_key</code> - The key where the calculated absorption will     be stored.</li> <li><code>new_albedo_key</code> - The key where the calculated albedo will     be stored.</li> </ul>"},{"location":"API/particula/data/process/optical_instrument/#returns_1","title":"Returns","text":"<ul> <li><code>Stream</code> - The updated datastream with the new absorption and albedo values.</li> </ul>"},{"location":"API/particula/data/process/optical_instrument/#raises_2","title":"Raises","text":"<ul> <li><code>KeyError</code> - If the provided extinction or scattering keys are not found     in the stream.</li> </ul>"},{"location":"API/particula/data/process/optical_instrument/#signature_5","title":"Signature","text":"<pre><code>def albedo_from_ext_scat(\n    stream: Stream,\n    extinction_key: str,\n    scattering_key: str,\n    new_absorption_key: str,\n    new_albedo_key: str,\n) -&gt; Stream: ...\n</code></pre>"},{"location":"API/particula/data/process/optical_instrument/#see-also","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"API/particula/data/process/optical_instrument/#caps_processing","title":"caps_processing","text":"<p>Show source in optical_instrument.py:102</p> <p>Process CAPS data and SMPS data for kappa fitting, apply truncation corrections, and add the results to the caps stream.</p>"},{"location":"API/particula/data/process/optical_instrument/#arguments_3","title":"Arguments","text":"<ul> <li><code>stream_size_distribution</code> - Stream containing size distribution data.</li> <li><code>stream_sizer_properties</code> - Stream containing sizer properties data.</li> <li><code>stream_caps</code> - Stream containing CAPS data.</li> <li><code>keywords</code> - Dictionary containing configuration parameters.</li> </ul>"},{"location":"API/particula/data/process/optical_instrument/#returns_2","title":"Returns","text":"<p>Stream with processed CAPS data, including kappa fitting results and truncation corrections.</p>"},{"location":"API/particula/data/process/optical_instrument/#signature_6","title":"Signature","text":"<pre><code>def caps_processing(\n    stream_size_distribution: Stream,\n    stream_sizer_properties: Stream,\n    stream_caps: Stream,\n    keywords: dict[str, Union[str, float, int, bool]],\n): ...\n</code></pre>"},{"location":"API/particula/data/process/optical_instrument/#see-also_1","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"API/particula/data/process/optical_instrument/#enhancement_ratio","title":"enhancement_ratio","text":"<p>Show source in optical_instrument.py:313</p> <p>Calculate the enhancement ratio from two data keys in the stream.</p> <p>This is the ratio between the numerator and the denominator. If the denominator is zero, then the ratio is set to <code>np.nan</code>. This function is useful for f(RH) calculations.</p>"},{"location":"API/particula/data/process/optical_instrument/#arguments_4","title":"Arguments","text":"<ul> <li><code>stream</code> - The datastream containing the data.</li> <li><code>numerator_key</code> - The key for the numerator data in the stream.</li> <li><code>denominator_key</code> - The key for the denominator data in the stream.</li> <li><code>new_key</code> - The key where the calculated enhancement ratio will     be stored.</li> </ul>"},{"location":"API/particula/data/process/optical_instrument/#returns_3","title":"Returns","text":"<ul> <li><code>Stream</code> - The updated datastream with the new enhancement ratio values.</li> </ul>"},{"location":"API/particula/data/process/optical_instrument/#raises_3","title":"Raises","text":"<ul> <li><code>KeyError</code> - If the provided numerator or denominator keys are not found     in the stream.</li> </ul>"},{"location":"API/particula/data/process/optical_instrument/#signature_7","title":"Signature","text":"<pre><code>def enhancement_ratio(\n    stream: Stream, numerator_key: str, denominator_key: str, new_key: str\n) -&gt; Stream: ...\n</code></pre>"},{"location":"API/particula/data/process/optical_instrument/#see-also_2","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"API/particula/data/process/scattering_truncation/","title":"Scattering Truncation","text":"<p>Particula Index / Particula / Data / Process / Scattering Truncation</p> <p>Auto-generated documentation for particula.data.process.scattering_truncation module.</p>"},{"location":"API/particula/data/process/scattering_truncation/#correction_for_distribution","title":"correction_for_distribution","text":"<p>Show source in scattering_truncation.py:245</p> <p>Correction for a size distribution of particles.</p> <p>Calculates the correction factor for scattering measurements due to truncation effects in aerosol size distribution measurements. This correction factor is used to adjust the measured scattering coefficient, accounting for the limited angular range of the instrument.</p>"},{"location":"API/particula/data/process/scattering_truncation/#arguments","title":"Arguments","text":"<ul> <li><code>m_sphere</code> - The complex or real refractive index of the particles.</li> <li><code>wavelength</code> - The wavelength of the incident light in nanometers (nm).</li> <li><code>diameter_sizes</code> - An array of particle diameters in nanometers (nm)     corresponding to the size distribution.</li> <li><code>number_per_cm3</code> - An array of particle number concentrations     (#/cm^3) for each diameter in the size distribution.</li> <li><code>discretize</code> - If True, the calculation will use discretized values     for the refractive index, wavelength, and diameters to     potentially improve computation performance. Default is True.</li> </ul>"},{"location":"API/particula/data/process/scattering_truncation/#returns","title":"Returns","text":"<p>Array:     The correction factor for scattering measurements. This factor is     dimensionless and is used to correct the measured scattering     coefficient for truncation effects, calculated as the ratio of     the ideal (full angular range) to truncated scattering coefficient.</p>"},{"location":"API/particula/data/process/scattering_truncation/#examples","title":"Examples","text":"<p>b_sca_corrected = b_sca_measured * bsca_correction</p>"},{"location":"API/particula/data/process/scattering_truncation/#signature","title":"Signature","text":"<pre><code>def correction_for_distribution(\n    m_sphere: Union[complex, float],\n    wavelength: float,\n    diameter_sizes: NDArray[np.float64],\n    number_per_cm3: NDArray[np.float64],\n    discretize: bool = True,\n) -&gt; Union[float, np.float64]: ...\n</code></pre>"},{"location":"API/particula/data/process/scattering_truncation/#correction_for_humidified","title":"correction_for_humidified","text":"<p>Show source in scattering_truncation.py:313</p> <p>Truncation Correction for humidified aerosol measurements.</p> <p>Calculates the scattering correction for humidified aerosol measurements, accounting for water uptake by adjusting the aerosol's refractive index. This function requires the kappa values for the particles, which describe their hygroscopic growth.</p>"},{"location":"API/particula/data/process/scattering_truncation/#arguments_1","title":"Arguments","text":"<ul> <li><code>kappa</code> - Hygroscopicity parameter kappa, indicating the water uptake     capability of the particles.</li> <li><code>number_per_cm3</code> - Number concentration of particles per cubic     centimeter (#/cm\u00b3) for each size bin.</li> <li><code>diameter</code> - Array of particle diameters in nanometers (nm).</li> <li><code>water_activity_sizer</code> - Water activity (relative humidity/100) of the     air sample used for sizing.</li> <li><code>water_activity_sample</code> - Water activity (relative humidity/100) of the     air sample in optical measurements.</li> <li><code>refractive_index_dry</code> - Refractive index of the dry particles.     Default is 1.45.</li> <li><code>water_refractive_index</code> - Refractive index of water. Default is 1.33.</li> <li><code>wavelength</code> - Wavelength of the incident light in nanometers (nm).     Default is 450.</li> <li><code>discretize</code> - If True, calculation uses discretized values for     refractive index, wavelength, and diameters to improve performance.     Default is True.</li> </ul>"},{"location":"API/particula/data/process/scattering_truncation/#returns_1","title":"Returns","text":"<p>np.float64:     A numpy array of scattering correction factors for each particle     size in the distribution, to be applied to measured backscatter     coefficients to account for truncation effects due to humidity.</p>"},{"location":"API/particula/data/process/scattering_truncation/#signature_1","title":"Signature","text":"<pre><code>def correction_for_humidified(\n    kappa: Union[float, np.float64],\n    number_per_cm3: NDArray[np.float64],\n    diameter: NDArray[np.float64],\n    water_activity_sizer: np.float64,\n    water_activity_sample: np.float64,\n    refractive_index_dry: Union[complex, float] = 1.45,\n    water_refractive_index: Union[complex, float] = 1.33,\n    wavelength: float = 450,\n    discretize: bool = True,\n) -&gt; np.float64: ...\n</code></pre>"},{"location":"API/particula/data/process/scattering_truncation/#correction_for_humidified_looped","title":"correction_for_humidified_looped","text":"<p>Show source in scattering_truncation.py:387</p> <p>Looped correction for humidified aerosol measurements.</p> <p>Corrects scattering measurements for aerosol particles to account for truncation errors in CAPS instrument. This correction is vital for accurate representation of particle scattering properties under different humidity conditions. The function iterates over time-indexed measurements, calculating corrections based on input parameters reflecting the particles' physical and chemical characteristics.</p>"},{"location":"API/particula/data/process/scattering_truncation/#arguments_2","title":"Arguments","text":"<ul> <li><code>kappa</code> - Hygroscopicity parameter array for the aerosol particles,     indicating water uptake ability.</li> <li><code>number_per_cm3</code> - Time-indexed number concentration of particles     in #/cm\u00b3 for each size.</li> <li><code>diameter</code> - Particle diameters, crucial for calculating scattering     effects.</li> <li><code>water_activity_sizer</code> - Water activity measured by the sizing     instrument, indicating relative humidity.</li> <li><code>water_activity_sample</code> - Sample water activity, corresponding to     the ambient conditions during measurement.</li> <li><code>refractive_index_dry</code> - Refractive index of the dry particles,     affecting their scattering behavior. Default is 1.45.</li> <li><code>water_refractive_index</code> - Refractive index of water, important     for calculations involving humidified conditions. Default is 1.33.</li> <li><code>wavelength</code> - Wavelength of the incident light in nanometers,     which influences scattering intensity. Default is 450.</li> <li><code>discretize</code> - If set to True, performs discretized calculations for     potentially improved computational performance. Default is True.</li> </ul>"},{"location":"API/particula/data/process/scattering_truncation/#returns_2","title":"Returns","text":"<p>An array of corrected scattering multipliers for each time index, accounting for aerosol particle size, composition, and environmental conditions.</p>"},{"location":"API/particula/data/process/scattering_truncation/#notes","title":"Notes","text":"<p>The correction process includes data nan checks for missing values, ensuring robust and reliable correction outcomes.</p>"},{"location":"API/particula/data/process/scattering_truncation/#signature_2","title":"Signature","text":"<pre><code>def correction_for_humidified_looped(\n    kappa: NDArray[np.float64],\n    number_per_cm3: NDArray[np.float64],\n    diameter: NDArray[np.float64],\n    water_activity_sizer: NDArray[np.float64],\n    water_activity_sample: NDArray[np.float64],\n    refractive_index_dry: Union[complex, float] = 1.45,\n    water_refractive_index: Union[complex, float] = 1.33,\n    wavelength: float = 450,\n    discretize: bool = True,\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/data/process/scattering_truncation/#get_truncated_scattering","title":"get_truncated_scattering","text":"<p>Show source in scattering_truncation.py:17</p> <p>Extracts the truncated scattering intensity and corresponding angles based on the given truncation angles.</p>"},{"location":"API/particula/data/process/scattering_truncation/#arguments_3","title":"Arguments","text":"<ul> <li><code>su</code> - The scattering intensity for unpolarized light as a function of     angle.</li> <li><code>theta</code> - The array of angles corresponding to the scattering intensity     measurements.</li> <li><code>theta1</code> - The lower bound of the angle range for truncation in radians.</li> <li><code>theta2</code> - The upper bound of the angle range for truncation in radians.</li> </ul>"},{"location":"API/particula/data/process/scattering_truncation/#returns_3","title":"Returns","text":"<p>Tuple (np.ndarray, np.ndarray):     A tuple containing the truncated scattering intensity and the     corresponding angles within the truncated range.</p>"},{"location":"API/particula/data/process/scattering_truncation/#signature_3","title":"Signature","text":"<pre><code>def get_truncated_scattering(\n    scattering_unpolarized: np.ndarray, theta: np.ndarray, theta1: float, theta2: float\n) -&gt; Tuple[np.ndarray, np.ndarray]: ...\n</code></pre>"},{"location":"API/particula/data/process/scattering_truncation/#trunc_mono","title":"trunc_mono","text":"<p>Show source in scattering_truncation.py:47</p> <p>Truncation correction for monodisperse aerosol particle.</p> <p>Calculates the single scattering albedo (SSA) correction due to truncation for monodisperse aerosol measurements using the CAPS-PM-SSA instrument. The correction accounts for the incomplete angular range of scattering measurements due to the instrument's geometry.</p>"},{"location":"API/particula/data/process/scattering_truncation/#arguments_4","title":"Arguments","text":"<ul> <li><code>m_sphere</code> - Complex or real refractive index of the aerosol.</li> <li><code>wavelength</code> - Wavelength of light in nanometers used in the CAPS     instrument.</li> <li><code>diameter</code> - Diameter of the monodisperse aerosol in nanometers.</li> <li><code>full_output</code> - If True, additional details about the calculation     are returned, including z-axis values, angles of integration,     and both truncated     and ideal scattering efficiencies. calibrated_trunc : bool, optional     If True, applies a numberical calibration factor to the truncation     correction, so 150 is 1. Default is True. discretize : bool, optional     If True, discretizes the input parameters for potentially improved     stability/performance in scattering function calculations. Can not     be done for full_output=True</li> </ul>"},{"location":"API/particula/data/process/scattering_truncation/#returns_4","title":"Returns","text":"<p>Tuple:     If fullOutput is False, returns only the truncation correction     factor. If fullOutput is True, returns a tuple containing the     truncation correction factor, z-axis positions, truncated     scattering efficiency, ideal scattering efficiency, forward     scattering angle, and backward scattering angle.</p>"},{"location":"API/particula/data/process/scattering_truncation/#signature_4","title":"Signature","text":"<pre><code>@lru_cache(maxsize=100000)\ndef trunc_mono(\n    m_sphere: Union[complex, float],\n    wavelength: float,\n    diameter: float,\n    full_output: bool = False,\n    calibrated_trunc: bool = True,\n    discretize: bool = True,\n) -&gt; Union[\n    float, Tuple[float, np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]\n]: ...\n</code></pre>"},{"location":"API/particula/data/process/scattering_truncation/#truncation_for_diameters","title":"truncation_for_diameters","text":"<p>Show source in scattering_truncation.py:191</p> <p>Truncation correction for an array of particle diameters.</p> <p>Calculates the truncation correction for an array of particle diameters given a specific refractive index and wavelength. This function is particularly useful for aerosol optical property measurements where truncation effects due to instrument geometry need to be accounted for.</p>"},{"location":"API/particula/data/process/scattering_truncation/#arguments_5","title":"Arguments","text":"<ul> <li><code>m_sphere</code> - The complex or real refractive index of the particles.</li> <li><code>wavelength</code> - The wavelength of the incident light in nanometers (nm).</li> <li><code>diameter_sizes</code> - An array of particle diameters in nanometers (nm) for     which the truncation correction will be calculated.</li> <li><code>discretize</code> - A flag indicating whether to discretize the input     parameters for potentially improved calculation performance.     Default is True.</li> <li><code>calibrated_trunc</code> - If True, applies a numberical calibration factor to     the truncation correction, so 150 is 1. Default is True.</li> </ul>"},{"location":"API/particula/data/process/scattering_truncation/#returns_5","title":"Returns","text":"<p>An array of truncation corrections corresponding to the input array of particle diameters.</p>"},{"location":"API/particula/data/process/scattering_truncation/#signature_5","title":"Signature","text":"<pre><code>def truncation_for_diameters(\n    m_sphere: Union[complex, float],\n    wavelength: float,\n    diameter_sizes: NDArray[np.float64],\n    discretize: bool = True,\n    calibrated_trunc: bool = True,\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/data/process/size_distribution/","title":"Size Distribution","text":"<p>Particula Index / Particula / Data / Process / Size Distribution</p> <p>Auto-generated documentation for particula.data.process.size_distribution module.</p>"},{"location":"API/particula/data/process/size_distribution/#iterate_merge_distributions","title":"iterate_merge_distributions","text":"<p>Show source in size_distribution.py:341</p> <p>Merge two sets of particle size distributions using linear weighting.</p>"},{"location":"API/particula/data/process/size_distribution/#arguments","title":"Arguments","text":"<ul> <li><code>concentration_lower</code> - The concentration of particles in the lower     distribution.</li> <li><code>diameters_lower</code> - The diameters corresponding to the lower distribution.</li> <li><code>concentration_upper</code> - The concentration of particles in the upper     distribution.</li> <li><code>diameters_upper</code> - The diameters corresponding to the upper distribution.</li> </ul>"},{"location":"API/particula/data/process/size_distribution/#returns","title":"Returns","text":"<p>Tuple: - The merged diameter distribution. - The merged concentration distribution.</p>"},{"location":"API/particula/data/process/size_distribution/#signature","title":"Signature","text":"<pre><code>def iterate_merge_distributions(\n    concentration_lower: np.ndarray,\n    diameters_lower: np.ndarray,\n    concentration_upper: np.ndarray,\n    diameters_upper: np.ndarray,\n) -&gt; tuple[np.ndarray, np.ndarray]: ...\n</code></pre>"},{"location":"API/particula/data/process/size_distribution/#mean_properties","title":"mean_properties","text":"<p>Show source in size_distribution.py:20</p> <p>Calculate the mean properties of the size distribution.</p>"},{"location":"API/particula/data/process/size_distribution/#arguments_1","title":"Arguments","text":"<ul> <li><code>sizer_dndlogdp</code> - Array of particle concentrations in each bin.</li> <li><code>sizer_diameter</code> - Array of bin center diameters.</li> <li><code>total_concentration</code> - Optional; the total concentration of particles     in the distribution. If not provided, it will be calculated.</li> <li><code>sizer_limits</code> - Optional; the lower and upper limits of the size     range of interest. If not provided, the full range will be used.</li> </ul>"},{"location":"API/particula/data/process/size_distribution/#returns_1","title":"Returns","text":"<p>Tuple: - Total concentration of particles in the distribution. - Total mass of particles in the distribution. - Mean diameter of the distribution by number. - Mean diameter of the distribution by volume. - Geometric mean diameter of the distribution. - Mode diameter of the distribution by number. - Mode diameter of the distribution by volume.</p>"},{"location":"API/particula/data/process/size_distribution/#signature_1","title":"Signature","text":"<pre><code>def mean_properties(\n    sizer_dndlogdp: np.ndarray,\n    sizer_diameter: np.ndarray,\n    total_concentration: Optional[float] = None,\n    sizer_limits: Optional[list] = None,\n) -&gt; Tuple[float, float, float, float, float, float, float]: ...\n</code></pre>"},{"location":"API/particula/data/process/size_distribution/#merge_distributions","title":"merge_distributions","text":"<p>Show source in size_distribution.py:261</p> <p>Merge two particle size distributions using linear weighting, accounting for mobility versus aerodynamic diameters.</p>"},{"location":"API/particula/data/process/size_distribution/#arguments_2","title":"Arguments","text":"<ul> <li><code>concentration_lower</code> - The concentration of particles in the lower     distribution.</li> <li><code>diameters_lower</code> - The diameters corresponding to the lower distribution.</li> <li><code>concentration_upper</code> - The concentration of particles in the upper     distribution.</li> <li><code>diameters_upper</code> - The diameters corresponding to the upper distribution.</li> </ul>"},{"location":"API/particula/data/process/size_distribution/#returns_2","title":"Returns","text":"<p>Tuple: - <code>-</code> new_2d - The merged concentration distribution. - <code>-</code> new_diameter - The merged diameter distribution.</p>"},{"location":"API/particula/data/process/size_distribution/#notes","title":"Notes","text":"<p>Add process the moblity vs aerodynamic diameters</p>"},{"location":"API/particula/data/process/size_distribution/#signature_2","title":"Signature","text":"<pre><code>def merge_distributions(\n    concentration_lower: np.ndarray,\n    diameters_lower: np.ndarray,\n    concentration_upper: np.ndarray,\n    diameters_upper: np.ndarray,\n) -&gt; tuple[np.ndarray, np.ndarray]: ...\n</code></pre>"},{"location":"API/particula/data/process/size_distribution/#merge_size_distribution","title":"merge_size_distribution","text":"<p>Show source in size_distribution.py:387</p> <p>Merge two particle size distributions using linear weighting. The concentrations should be in dN/dlogDp.</p>"},{"location":"API/particula/data/process/size_distribution/#arguments_3","title":"Arguments","text":"<ul> <li><code>stream_lower</code> - The stream with the lower size range, e.g., from an SMPS.</li> <li><code>stream_upper</code> - The stream with the upper size range, e.g., from an     OPS or APS.</li> <li><code>lower_units</code> - The units of the lower distribution. Default is 'nm'.</li> <li><code>upper_units</code> - The units of the upper distribution. Default is 'um'.</li> </ul>"},{"location":"API/particula/data/process/size_distribution/#returns_3","title":"Returns","text":"<ul> <li><code>Stream</code> - A stream object containing the merged size distribution.</li> </ul>"},{"location":"API/particula/data/process/size_distribution/#signature_3","title":"Signature","text":"<pre><code>def merge_size_distribution(\n    stream_lower: Stream,\n    stream_upper: Stream,\n    lower_units: str = \"nm\",\n    upper_units: str = \"um\",\n) -&gt; object: ...\n</code></pre>"},{"location":"API/particula/data/process/size_distribution/#see-also","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"API/particula/data/process/size_distribution/#resample_distribution","title":"resample_distribution","text":"<p>Show source in size_distribution.py:428</p> <p>Resample a particle size distribution to a new set of diameters using numpy interpolation. Extrapolated values will be set to NaN.</p>"},{"location":"API/particula/data/process/size_distribution/#arguments_4","title":"Arguments","text":"<ul> <li><code>stream</code> - The stream object containing the size distribution to resample.</li> <li><code>new_diameters</code> - The new diameters to which the distribution will be     resampled.</li> <li><code>concentration_scale</code> - The concentration scale of the distribution.     Options are 'dn/dlogdp', 'dn', 'pms'     (which is equivalent to 'dn'), or 'pdf'. Default is 'dn/dlogdp'.</li> <li><code>clone</code> - Whether to clone the stream before resampling. Default is False.</li> </ul>"},{"location":"API/particula/data/process/size_distribution/#returns_4","title":"Returns","text":"<ul> <li><code>Stream</code> - The resampled stream object.</li> </ul>"},{"location":"API/particula/data/process/size_distribution/#signature_4","title":"Signature","text":"<pre><code>def resample_distribution(\n    stream: Stream,\n    new_diameters: np.ndarray,\n    concentration_scale: str = \"dn/dlogdp\",\n    clone: bool = False,\n) -&gt; Stream: ...\n</code></pre>"},{"location":"API/particula/data/process/size_distribution/#see-also_1","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"API/particula/data/process/size_distribution/#sizer_mean_properties","title":"sizer_mean_properties","text":"<p>Show source in size_distribution.py:112</p> <p>Calculate the mean properties of the size distribution and return the updated stream.</p>"},{"location":"API/particula/data/process/size_distribution/#arguments_5","title":"Arguments","text":"<ul> <li><code>stream</code> - The stream containing the size distribution data to process.</li> <li><code>sizer_limits</code> - A list specifying the lower and upper limits of the     size range of interest, in the units specified by <code>diameter_units</code>.     Default is None, which means the full range is used.</li> <li><code>density</code> - The density of the particles in g/cm\u00b3. Default is 1.5 g/cm\u00b3.</li> <li><code>diameter_units</code> - The units of the diameter. Default is 'nm'. The     specified units will be converted to nanometers.</li> </ul>"},{"location":"API/particula/data/process/size_distribution/#returns_5","title":"Returns","text":"<ul> <li><code>Stream</code> - The updated stream with the mean properties added.</li> </ul>"},{"location":"API/particula/data/process/size_distribution/#signature_5","title":"Signature","text":"<pre><code>def sizer_mean_properties(\n    stream: Stream,\n    sizer_limits: Optional[List[float]] = None,\n    density: float = 1.5,\n    diameter_units: str = \"nm\",\n) -&gt; Stream: ...\n</code></pre>"},{"location":"API/particula/data/process/size_distribution/#see-also_2","title":"See also","text":"<ul> <li>Stream</li> </ul>"},{"location":"API/particula/data/process/ml_analysis/","title":"Ml Analysis","text":"<p>Particula Index / Particula / Data / Process / Ml Analysis</p> <p>Auto-generated documentation for particula.data.process.ml_analysis module.</p>"},{"location":"API/particula/data/process/ml_analysis/#modules","title":"Modules","text":"<ul> <li>Generate And Train 2mode Sizer</li> <li>Get Ml Folder</li> <li>Run Ml Trainings</li> </ul>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/","title":"Generate And Train 2mode Sizer","text":"<p>Particula Index / Particula / Data / Process / Ml Analysis / Generate And Train 2mode Sizer</p> <p>Auto-generated documentation for particula.data.process.ml_analysis.generate_and_train_2mode_sizer module.</p>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#attributes","title":"Attributes","text":"<ul> <li> <p><code>logger</code> - Set up logging: logging.getLogger('particula')</p> </li> <li> <p><code>TOTAL_NUMBER_SIMULATED</code> - Training parameters: 10000000</p> </li> </ul>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#create_pipeline","title":"create_pipeline","text":"<p>Show source in generate_and_train_2mode_sizer.py:181</p> <p>Create a pipeline with normalization and MLPRegressor model.</p>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#returns","title":"Returns","text":"<p>A scikit-learn Pipeline object.</p>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#signature","title":"Signature","text":"<pre><code>def create_pipeline() -&gt; Pipeline: ...\n</code></pre>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#evaluate_pipeline","title":"evaluate_pipeline","text":"<p>Show source in generate_and_train_2mode_sizer.py:316</p> <p>Evaluate the pipeline and print the mean squared error for each target.</p>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#arguments","title":"Arguments","text":"<ul> <li><code>pipeline</code> - The trained pipeline.</li> <li><code>X_test</code> - The test feature array.</li> <li><code>y_test</code> - The test target array.</li> </ul>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#signature_1","title":"Signature","text":"<pre><code>def evaluate_pipeline(\n    pipeline: Pipeline, x_test: NDArray[np.float64], y_test: NDArray[np.float64]\n) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#generate_simulated_data","title":"generate_simulated_data","text":"<p>Show source in generate_and_train_2mode_sizer.py:48</p> <p>Generate simulated lognormal aerosol particle size distributions.</p>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#arguments_1","title":"Arguments","text":"<ul> <li><code>total_number_simulated</code> - Total number of simulated distributions.</li> <li><code>number_of_modes_sim</code> - Number of modes to simulate (1, 2, or 3).</li> <li><code>x_array_max_index</code> - Number of size bins in the particle size array.</li> <li><code>lower_bound_gsd</code> - Lower bound for the geometric standard deviation.</li> <li><code>upper_bound_gsd</code> - Upper bound for the geometric standard deviation.</li> <li><code>seed</code> - Random seed for reproducibility.</li> </ul>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#returns_1","title":"Returns","text":"<ul> <li><code>x_values</code> - Array of particle sizes.</li> <li><code>mode_index_sim</code> - Array of simulated mode indices.</li> <li><code>geomertic_standard_deviation_sim</code> - Array of simulated geometric     standard deviations (GSDs).</li> <li><code>number_of_particles_sim</code> - Array of simulated relative number     concentrations.</li> <li><code>number_pdf_sim</code> - Array of simulated probability density     functions (PDFs).</li> </ul>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#signature_2","title":"Signature","text":"<pre><code>def generate_simulated_data(\n    total_number_simulated: int = 10000,\n    number_of_modes_sim: int = 2,\n    x_array_max_index: int = 128,\n    lower_bound_gsd: float = 1.0,\n    upper_bound_gsd: float = 2.0,\n    seed: int = 0,\n) -&gt; Tuple[\n    NDArray[np.float64],\n    NDArray[np.int64],\n    NDArray[np.float64],\n    NDArray[np.float64],\n    NDArray[np.float64],\n]: ...\n</code></pre>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#load_and_cache_pipeline","title":"load_and_cache_pipeline","text":"<p>Show source in generate_and_train_2mode_sizer.py:368</p> <p>Load and cache the ML pipeline if not already loaded.</p>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#arguments_2","title":"Arguments","text":"<ul> <li><code>filename</code> - Path to the pipeline file.</li> </ul>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#returns_2","title":"Returns","text":"<p>The loaded pipeline.</p>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#signature_3","title":"Signature","text":"<pre><code>def load_and_cache_pipeline(filename: str) -&gt; Pipeline: ...\n</code></pre>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#load_pipeline","title":"load_pipeline","text":"<p>Show source in generate_and_train_2mode_sizer.py:355</p> <p>Load a pipeline from a file.</p>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#arguments_3","title":"Arguments","text":"<ul> <li><code>filename</code> - The filename to load the pipeline from.</li> </ul>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#returns_3","title":"Returns","text":"<p>The loaded pipeline.</p>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#signature_4","title":"Signature","text":"<pre><code>def load_pipeline(filename: str) -&gt; Pipeline: ...\n</code></pre>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#lognormal_2mode_ml_guess","title":"lognormal_2mode_ml_guess","text":"<p>Show source in generate_and_train_2mode_sizer.py:455</p> <p>Load the machine learning pipeline, interpolate the concentration PDF, and predict lognormal parameters.</p>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#arguments_4","title":"Arguments","text":"<ul> <li><code>file_name</code> - Path to the saved ML pipeline file.</li> <li><code>x_values</code> - Array of x-values (particle sizes).</li> <li><code>concentration_pdf</code> - Array of concentration PDF values.</li> </ul>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#returns_4","title":"Returns","text":"<ul> <li><code>mode_values_guess</code> - Predicted mode values after rescaling.</li> <li><code>geometric_standard_deviation_guess</code> - Predicted geometric standard     deviations after rescaling.</li> <li><code>number_of_particles_guess</code> - Predicted number of particles after     rescaling.</li> </ul>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#signature_5","title":"Signature","text":"<pre><code>def lognormal_2mode_ml_guess(\n    logspace_x: NDArray[np.float64], concentration_pdf: NDArray[np.float64]\n) -&gt; Tuple[NDArray[np.float64], NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#looped_lognormal_2mode_ml_guess","title":"looped_lognormal_2mode_ml_guess","text":"<p>Show source in generate_and_train_2mode_sizer.py:540</p> <p>Loop through the concentration PDFs to get the best guess.</p>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#arguments_5","title":"Arguments","text":"<ul> <li><code>logspace_x</code> - Array of x-values (particle sizes).</li> <li><code>concentration_pdf</code> - Matrix of concentration PDF values.</li> </ul>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#returns_5","title":"Returns","text":"<p>Tuple: - <code>-</code> mode_values_guess - Predicted mode values after rescaling. - <code>-</code> geometric_standard_deviation_guess - Predicted geometric standard     deviations after rescaling. - <code>-</code> number_of_particles_guess - Predicted number of particles after     rescaling.</p>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#signature_6","title":"Signature","text":"<pre><code>def looped_lognormal_2mode_ml_guess(\n    logspace_x: NDArray[np.float64], concentration_pdf: NDArray[np.float64]\n) -&gt; Tuple[NDArray[np.float64], NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#normalize_max","title":"normalize_max","text":"<p>Show source in generate_and_train_2mode_sizer.py:133</p> <p>Normalize each sample in X by dividing by its maximum value.</p>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#arguments_6","title":"Arguments","text":"<ul> <li><code>X</code> - The input array to be normalized.</li> </ul>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#returns_6","title":"Returns","text":"<p>The normalized array.</p>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#signature_7","title":"Signature","text":"<pre><code>def normalize_max(x_input: NDArray[np.float64]) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#normalize_targets","title":"normalize_targets","text":"<p>Show source in generate_and_train_2mode_sizer.py:146</p> <p>Normalize the mode index, GSD, and relative number concentration.</p>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#arguments_7","title":"Arguments","text":"<ul> <li><code>mode_index_sim</code> - Array of mode indices.</li> <li><code>geomertic_standard_deviation_sim</code> - Array of geometric standard     deviations (GSDs).</li> <li><code>number_of_particles_sim</code> - Array of relative number concentrations.</li> <li><code>x_array_max_index</code> - Maximum index for the mode.</li> <li><code>lower_bound_gsd</code> - Lower bound for the geometric standard     deviation (GSD).</li> <li><code>upper_bound_gsd</code> - Upper bound for the geometric standard     deviation (GSD).</li> </ul>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#returns_7","title":"Returns","text":"<ul> <li><code>y</code> - Normalized array combining mode indices, GSDs, and relative     number concentrations.</li> </ul>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#signature_8","title":"Signature","text":"<pre><code>def normalize_targets(\n    mode_index_sim: NDArray[np.int64],\n    geomertic_standard_deviation_sim: NDArray[np.float64],\n    number_of_particles_sim: NDArray[np.float64],\n    x_array_max_index: int,\n    lower_bound_gsd: float,\n    upper_bound_gsd: float,\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#save_pipeline","title":"save_pipeline","text":"<p>Show source in generate_and_train_2mode_sizer.py:344</p> <p>Save the trained pipeline to a file.</p>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#arguments_8","title":"Arguments","text":"<ul> <li><code>pipeline</code> - The trained pipeline.</li> <li><code>filename</code> - The filename to save the pipeline to.</li> </ul>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#signature_9","title":"Signature","text":"<pre><code>def save_pipeline(pipeline: Pipeline, filename: str) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#train_network_and_save","title":"train_network_and_save","text":"<p>Show source in generate_and_train_2mode_sizer.py:386</p> <p>Train the neural network and save the pipeline.</p>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#signature_10","title":"Signature","text":"<pre><code>def train_network_and_save(): ...\n</code></pre>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#train_pipeline","title":"train_pipeline","text":"<p>Show source in generate_and_train_2mode_sizer.py:208</p> <p>Train the pipeline and return the trained model along with train/test data.</p>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#arguments_9","title":"Arguments","text":"<ul> <li><code>X</code> - The feature array.</li> <li><code>y</code> - The target array.</li> <li><code>test_size</code> - The proportion of the dataset to include in the test split.</li> <li><code>random_state</code> - Random seed for reproducibility.</li> </ul>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#returns_8","title":"Returns","text":"<ul> <li><code>pipeline</code> - The trained pipeline. X_train, X_test, y_train, y_test: The training and testing data splits.</li> </ul>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#signature_11","title":"Signature","text":"<pre><code>def train_pipeline(\n    x_input: NDArray[np.float64],\n    y: NDArray[np.float64],\n    test_split_size: float = 0.3,\n    random_state: int = 42,\n) -&gt; Tuple[\n    Pipeline,\n    NDArray[np.float64],\n    NDArray[np.float64],\n    NDArray[np.float64],\n    NDArray[np.float64],\n]: ...\n</code></pre>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#train_pipeline_with_progress","title":"train_pipeline_with_progress","text":"<p>Show source in generate_and_train_2mode_sizer.py:248</p> <p>Train the pipeline in batches with progress tracking, and return the trained model along with train/test data.</p>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#arguments_10","title":"Arguments","text":"<ul> <li><code>X</code> - The feature array.</li> <li><code>y</code> - The target array.</li> <li><code>test_size</code> - The proportion of the dataset to include in the test split.</li> <li><code>random_state</code> - Random seed for reproducibility.</li> <li><code>n_batches</code> - Number of batches to split the training into.</li> </ul>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#returns_9","title":"Returns","text":"<ul> <li><code>pipeline</code> - The trained pipeline. X_train, X_test, y_train, y_test: The training and testing data splits.</li> </ul>"},{"location":"API/particula/data/process/ml_analysis/generate_and_train_2mode_sizer/#signature_12","title":"Signature","text":"<pre><code>def train_pipeline_with_progress(\n    x_input: NDArray[np.float64],\n    y: NDArray[np.float64],\n    test_split_size: float = 0.3,\n    random_state: int = 42,\n    n_batches: int = 10,\n) -&gt; Tuple[\n    Pipeline,\n    NDArray[np.float64],\n    NDArray[np.float64],\n    NDArray[np.float64],\n    NDArray[np.float64],\n]: ...\n</code></pre>"},{"location":"API/particula/data/process/ml_analysis/get_ml_folder/","title":"Get Ml Folder","text":"<p>Particula Index / Particula / Data / Process / Ml Analysis / Get Ml Folder</p> <p>Auto-generated documentation for particula.data.process.ml_analysis.get_ml_folder module.</p>"},{"location":"API/particula/data/process/ml_analysis/get_ml_folder/#get_ml_analysis_folder","title":"get_ml_analysis_folder","text":"<p>Show source in get_ml_folder.py:6</p> <p>Get the location of the data folder.</p>"},{"location":"API/particula/data/process/ml_analysis/get_ml_folder/#signature","title":"Signature","text":"<pre><code>def get_ml_analysis_folder(): ...\n</code></pre>"},{"location":"API/particula/data/process/ml_analysis/run_ml_trainings/","title":"Run Ml Trainings","text":"<p>Particula Index / Particula / Data / Process / Ml Analysis / Run Ml Trainings</p> <p>Auto-generated documentation for particula.data.process.ml_analysis.run_ml_trainings module.</p>"},{"location":"API/particula/equilibria/","title":"Equilibria","text":"<p>Particula Index / Particula / Equilibria</p> <p>Auto-generated documentation for particula.equilibria module.</p>"},{"location":"API/particula/equilibria/#modules","title":"Modules","text":"<ul> <li>Partitioning</li> </ul>"},{"location":"API/particula/equilibria/partitioning/","title":"Partitioning","text":"<p>Particula Index / Particula / Equilibria / Partitioning</p> <p>Auto-generated documentation for particula.equilibria.partitioning module.</p>"},{"location":"API/particula/equilibria/partitioning/#get_properties_for_liquid_vapor_partitioning","title":"get_properties_for_liquid_vapor_partitioning","text":"<p>Show source in partitioning.py:212</p> <p>Get properties for liquid-vapor partitioning.</p>"},{"location":"API/particula/equilibria/partitioning/#signature","title":"Signature","text":"<pre><code>def get_properties_for_liquid_vapor_partitioning(\n    water_activity_desired, molar_mass, oxygen2carbon, density\n): ...\n</code></pre>"},{"location":"API/particula/equilibria/partitioning/#liquid_vapor_obj_function","title":"liquid_vapor_obj_function","text":"<p>Show source in partitioning.py:9</p> <p>Objective function for liquid-vapor partitioning.</p>"},{"location":"API/particula/equilibria/partitioning/#signature_1","title":"Signature","text":"<pre><code>def liquid_vapor_obj_function(\n    e_j_partition_guess,\n    c_star_j_dry,\n    concentration_organic_matter,\n    gamma_organic_ab,\n    mass_fraction_water_ab,\n    q_ab,\n    molar_mass,\n    error_only=True,\n): ...\n</code></pre>"},{"location":"API/particula/equilibria/partitioning/#liquid_vapor_partitioning","title":"liquid_vapor_partitioning","text":"<p>Show source in partitioning.py:158</p> <p>Thermodynamic equilibrium between liquid and vapor phase. with activity coefficients,</p>"},{"location":"API/particula/equilibria/partitioning/#signature_2","title":"Signature","text":"<pre><code>def liquid_vapor_partitioning(\n    c_star_j_dry,\n    concentration_organic_matter,\n    molar_mass,\n    gamma_organic_ab,\n    mass_fraction_water_ab,\n    q_ab,\n    partition_coefficient_guess=None,\n): ...\n</code></pre>"},{"location":"API/particula/lagrangian/","title":"Lagrangian","text":"<p>Particula Index / Particula / Lagrangian</p> <p>Auto-generated documentation for particula.lagrangian module.</p>"},{"location":"API/particula/lagrangian/#modules","title":"Modules","text":"<ul> <li>Boundary</li> <li>Collisions</li> <li>Integration</li> <li>Particle Pairs</li> <li>Particle Property</li> </ul>"},{"location":"API/particula/lagrangian/boundary/","title":"Boundary","text":"<p>Particula Index / Particula / Lagrangian / Boundary</p> <p>Auto-generated documentation for particula.lagrangian.boundary module.</p>"},{"location":"API/particula/lagrangian/boundary/#wrapped_cube","title":"wrapped_cube","text":"<p>Show source in boundary.py:6</p> <p>Apply cubic boundary conditions with wrap-around, to the position tensor.</p> <p>This function modifies positions that exceed the cubic domain side, wrapping them around to the opposite side of the domain. It handles both positive and negative overflows. The center of the cube is assumed to be at zero. If a particle is way outside the cube, it is wrapped around to the opposite side of the cube.</p>"},{"location":"API/particula/lagrangian/boundary/#arguments","title":"Arguments","text":"<ul> <li>position (torch.Tensor): A tensor representing positions that might     exceed the domain boundaries. [3, num_particles]</li> <li>cube_side (float): The cube side length of the domain.</li> </ul>"},{"location":"API/particula/lagrangian/boundary/#returns","title":"Returns","text":"<ul> <li><code>-</code> torch.Tensor - The modified position tensor with boundary conditions     applied.</li> </ul>"},{"location":"API/particula/lagrangian/boundary/#examples","title":"Examples","text":"<p>position = torch.tensor([...])  # Position tensor cube_side = 10.0  # Define the domain wrapped_position = boundary.wrapped_cube(position,     cube_side)</p>"},{"location":"API/particula/lagrangian/boundary/#signature","title":"Signature","text":"<pre><code>def wrapped_cube(position: torch.Tensor, cube_side: float) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"API/particula/lagrangian/collisions/","title":"Collisions","text":"<p>Particula Index / Particula / Lagrangian / Collisions</p> <p>Auto-generated documentation for particula.lagrangian.collisions module.</p>"},{"location":"API/particula/lagrangian/collisions/#coalescence","title":"coalescence","text":"<p>Show source in collisions.py:69</p> <p>Update mass and velocity of particles based on collision pairs, conserving mass and momentum.</p> <p>This function processes collision pairs, sorts them to avoid duplicate handling, and then updates the mass and velocity of colliding particles according to the conservation of mass and momentum.</p>"},{"location":"API/particula/lagrangian/collisions/#arguments","title":"Arguments","text":"<ul> <li><code>position</code> torch.Tensor - A 2D tensor of shape [n_dimensions, n_particles]     representing the positions of particles.</li> <li><code>velocity</code> torch.Tensor - A 2D tensor of shape [n_dimensions, n_particles]     representing the velocities of particles.</li> <li><code>mass</code> torch.Tensor - A 1D tensor containing the mass of each particle.</li> <li><code>radius</code> torch.Tensor - A 1D tensor containing the radius of each particle.</li> <li><code>collision_indices_pairs</code> torch.Tensor - A 2D tensor containing pairs of     indices representing colliding particles.</li> <li><code>remove_duplicates_func</code> function - A function to remove duplicate entries     from a tensor of index pairs.</li> </ul>"},{"location":"API/particula/lagrangian/collisions/#returns","title":"Returns","text":"<ul> <li><code>-</code> torch.Tensor - A 2D tensor of shape [n_dimensions, n_particles]     representing the updated velocities of particles.</li> </ul>"},{"location":"API/particula/lagrangian/collisions/#notes","title":"Notes","text":"<ul> <li>This function modifies the <code>velocity</code> and <code>mass</code> tensors in-place.</li> <li>It assumes that the mass and momentum are transferred from the right     particle to the left in each collision pair.</li> <li>The subtraction approach for the right-side particles ensures no mass is     lost in multi-particle collisions (e.g., A&lt;-B and B&lt;-D).</li> </ul>"},{"location":"API/particula/lagrangian/collisions/#signature","title":"Signature","text":"<pre><code>def coalescence(\n    position: torch.Tensor,\n    velocity: torch.Tensor,\n    mass: torch.Tensor,\n    radius: torch.Tensor,\n    collision_indices_pairs: torch.Tensor,\n) -&gt; Tuple[torch.Tensor, torch.Tensor]: ...\n</code></pre>"},{"location":"API/particula/lagrangian/collisions/#elastic_collision","title":"elastic_collision","text":"<p>Show source in collisions.py:136</p> <p>Update velocities of particles based on elastic collision pairs using matrix operations, conserving kinetic energy and momentum.</p>"},{"location":"API/particula/lagrangian/collisions/#arguments_1","title":"Arguments","text":"<ul> <li><code>velocity</code> torch.Tensor - A 2D tensor of shape [n_dimensions, n_particles]     representing the velocities of particles.</li> <li><code>mass</code> torch.Tensor - A 1D tensor containing the mass of each particle.</li> <li><code>collision_indices_pairs</code> torch.Tensor - A 2D tensor containing pairs of     indices representing colliding particles.</li> <li><code>remove_duplicates_func</code> function - A function to remove duplicate entries     from a tensor of index pairs.</li> </ul>"},{"location":"API/particula/lagrangian/collisions/#returns_1","title":"Returns","text":"<ul> <li><code>torch.Tensor</code> - A 2D tensor of shape [n_dimensions, n_particles]     representing the updated velocities of particles.</li> </ul>"},{"location":"API/particula/lagrangian/collisions/#notes_1","title":"Notes","text":"<ul> <li>This function modifies the <code>velocity</code> tensor in-place.</li> <li>Mass remains unchanged in elastic collisions.</li> </ul>"},{"location":"API/particula/lagrangian/collisions/#examples","title":"Examples","text":"<ul> <li><code>2d</code> - https://www.wolframalpha.com/input?i=elastic+collision&amp;assumption=%7B%22F%22%2C+%22ElasticCollision%22%2C+%22m2%22%7D+-%3E%221+kg%22&amp;assumption=%7B%22F%22%2C+%22ElasticCollision%22%2C+%22m1%22%7D+-%3E%221+kg%22&amp;assumption=%22FSelect%22+-%3E+%7B%7B%22ElasticCollision2D%22%7D%7D&amp;assumption=%7B%22F%22%2C+%22ElasticCollision%22%2C+%22v1i%22%7D+-%3E%221+m%2Fs%22&amp;assumption=%7B%22F%22%2C+%22ElasticCollision%22%2C+%22v2i%22%7D+-%3E%22-0.5+m%2Fs%22</li> <li><code>3d</code> fortran - https://www.plasmaphysics.org.uk/programs/coll3d_for.htm https://www.plasmaphysics.org.uk/collision3d.htm</li> </ul> <p>I think the approach is take a pair, and rotate the coordinate system so that the collision is in the x-y plane. Then, the z component of the velocity is a 1d problem, and the x-y component is a 2d problem. Then, rotate back to the original coordinate system.</p>"},{"location":"API/particula/lagrangian/collisions/#signature_1","title":"Signature","text":"<pre><code>def elastic_collision(\n    velocity: torch.Tensor, mass: torch.Tensor, collision_indices_pairs: torch.Tensor\n) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"API/particula/lagrangian/collisions/#find_collisions","title":"find_collisions","text":"<p>Show source in collisions.py:9</p> <p>Find the collision pairs from a distance matrix, given the mass and indices of particles.</p> <p>This function identifies pairs of particles that are within a certain distance threshold (&lt;0), indicating a collision. It filters out pairs involving particles with zero mass.</p>"},{"location":"API/particula/lagrangian/collisions/#arguments_2","title":"Arguments","text":"<ul> <li><code>distance_matrix</code> torch.Tensor - A 2D tensor containing the pairwise     distances between particles.</li> <li><code>indices</code> torch.Tensor - A 1D tensor containing the indices of the     particles.</li> <li><code>mass</code> torch.Tensor - A 1D tensor containing the mass of each particle.</li> <li><code>k</code> int, optional - The number of closest neighbors to consider for each     particle. Defaults to 1.</li> </ul>"},{"location":"API/particula/lagrangian/collisions/#returns_2","title":"Returns","text":"<ul> <li><code>torch.Tensor</code> - A 2D tensor of shape [n_collisions, 2] containing the indices of colliding pairs of particles.</li> </ul>"},{"location":"API/particula/lagrangian/collisions/#notes_2","title":"Notes","text":"<ul> <li>The function assumes that the diagonal elements of the distance matrix (distances of particles to themselves) are less than zero.</li> <li>Particles with zero mass are excluded from the collision pairs.</li> </ul>"},{"location":"API/particula/lagrangian/collisions/#signature_2","title":"Signature","text":"<pre><code>def find_collisions(\n    distance_matrix: torch.Tensor, indices: torch.Tensor, mass: torch.Tensor, k: int = 1\n) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"API/particula/lagrangian/integration/","title":"Integration","text":"<p>Particula Index / Particula / Lagrangian / Integration</p> <p>Auto-generated documentation for particula.lagrangian.integration module.</p>"},{"location":"API/particula/lagrangian/integration/#leapfrog","title":"leapfrog","text":"<p>Show source in integration.py:7</p> <p>Perform a single step of leapfrog integration on the position and velocity of a particle.</p> <p>Leapfrog integration is a numerical method used for solving differential equations typically found in molecular dynamics and astrophysics. It is symplectic, hence conserves energy over long simulations, and is known for its simple implementation and stability over large time steps.</p>"},{"location":"API/particula/lagrangian/integration/#arguments","title":"Arguments","text":"<ul> <li>position (Tensor): The current position of the particle.</li> <li>velocity (Tensor): The current velocity of the particle.</li> <li>force (Tensor): The current force acting on the particle.</li> <li>mass (float): The mass of the particle.</li> <li>time_step (float): The time step for the integration.</li> </ul>"},{"location":"API/particula/lagrangian/integration/#returns","title":"Returns","text":"<ul> <li><code>-</code> tuple - Updated position and velocity of the particle after one time step.</li> </ul> <p>Reference: - https://en.wikipedia.org/wiki/Leapfrog_integration</p>"},{"location":"API/particula/lagrangian/integration/#signature","title":"Signature","text":"<pre><code>def leapfrog(\n    position: torch.Tensor,\n    velocity: torch.Tensor,\n    force: torch.Tensor,\n    mass: torch.Tensor,\n    time_step: float,\n) -&gt; Tuple[torch.Tensor, torch.Tensor]: ...\n</code></pre>"},{"location":"API/particula/lagrangian/particle_pairs/","title":"Particle Pairs","text":"<p>Particula Index / Particula / Lagrangian / Particle Pairs</p> <p>Auto-generated documentation for particula.lagrangian.particle_pairs module.</p>"},{"location":"API/particula/lagrangian/particle_pairs/#calculate_pairwise_distance","title":"calculate_pairwise_distance","text":"<p>Show source in particle_pairs.py:48</p> <p>need to test this:</p> <p>Calculate the pairwise Euclidean distances between points in a given position tensor.</p> <p>This function computes the pairwise distances between points represented in the input tensor. Each row of the input tensor is considered a point in n-dimensional space.</p>"},{"location":"API/particula/lagrangian/particle_pairs/#arguments","title":"Arguments","text":"<ul> <li><code>position</code> torch.Tensor - A 2D tensor of shape [n_dimensions, n_points]</li> </ul>"},{"location":"API/particula/lagrangian/particle_pairs/#returns","title":"Returns","text":"<ul> <li><code>torch.Tensor</code> - A 2D tensor of shape [n_points, n_points] containing the pairwise Euclidean distances between each pair of points. The element at [i, j] in the output tensor represents the distance between the i-th and j-th points in the input tensor.</li> </ul>"},{"location":"API/particula/lagrangian/particle_pairs/#examples","title":"Examples","text":"<p>position = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])</p>"},{"location":"API/particula/lagrangian/particle_pairs/#output-will-be-a-3x3-tensor-with-the-pairwise-distances-between-these","title":"Output will be a 3x3 tensor with the pairwise distances between these","text":"<p>3 points.</p>"},{"location":"API/particula/lagrangian/particle_pairs/#signature","title":"Signature","text":"<pre><code>def calculate_pairwise_distance(position: torch.Tensor) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"API/particula/lagrangian/particle_pairs/#full_sweep_and_prune","title":"full_sweep_and_prune","text":"<p>Show source in particle_pairs.py:159</p> <p>Sweep and prune algorithm for collision detection along all three axes (x, y, z). This function identifies pairs of particles that are close enough to potentially collide in 3D space.</p>"},{"location":"API/particula/lagrangian/particle_pairs/#arguments_1","title":"Arguments","text":"<ul> <li><code>position</code> torch.Tensor - The 2D tensor of particle positions,     where each row represents an axis (x, y, z).</li> <li><code>radius</code> torch.Tensor - The radius of particles.</li> </ul>"},{"location":"API/particula/lagrangian/particle_pairs/#returns_1","title":"Returns","text":"<ul> <li><code>torch.Tensor</code> - A tensor containing pairs of indices of potentially     colliding particles.</li> </ul>"},{"location":"API/particula/lagrangian/particle_pairs/#signature_1","title":"Signature","text":"<pre><code>def full_sweep_and_prune(\n    position: torch.Tensor, radius: torch.Tensor\n) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"API/particula/lagrangian/particle_pairs/#full_sweep_and_prune_simplified","title":"full_sweep_and_prune_simplified","text":"<p>Show source in particle_pairs.py:240</p> <p>A simplified version of the full sweep and prune algorithm for collision written above, it is not working yet. there is an error in the update of the indices in the y and z axis.</p> <p>Sweep and prune algorithm for collision detection along all three axes (x, y, z). This function identifies pairs of particles that are close enough to potentially collide in 3D space.</p>"},{"location":"API/particula/lagrangian/particle_pairs/#arguments_2","title":"Arguments","text":"<ul> <li><code>position</code> torch.Tensor - The 2D tensor of particle positions,     where each row represents an axis (x, y, z).</li> <li><code>radius</code> torch.Tensor - The radius of particles.</li> </ul>"},{"location":"API/particula/lagrangian/particle_pairs/#returns_2","title":"Returns","text":"<ul> <li><code>torch.Tensor</code> - A tensor containing pairs of indices of potentially     colliding particles.</li> </ul>"},{"location":"API/particula/lagrangian/particle_pairs/#signature_2","title":"Signature","text":"<pre><code>def full_sweep_and_prune_simplified(\n    position: torch.Tensor, radius: torch.Tensor, working_yet: bool = False\n) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"API/particula/lagrangian/particle_pairs/#remove_duplicates","title":"remove_duplicates","text":"<p>Show source in particle_pairs.py:7</p> <p>Removes duplicate entries from a specified column in a tensor of index pairs.</p> <p>This function is designed to work with tensors where each row represents a pair of indices. It removes rows containing duplicate entries in the specified column.</p>"},{"location":"API/particula/lagrangian/particle_pairs/#arguments_3","title":"Arguments","text":"<ul> <li>index_pairs (torch.Tensor): A 2D tensor of shape [n, 2], where n is the     number of index pairs.</li> <li>index_to_remove (int): The column index (0 or 1) from which to remove     duplicate entries.</li> </ul>"},{"location":"API/particula/lagrangian/particle_pairs/#returns_3","title":"Returns","text":"<ul> <li><code>-</code> torch.Tensor - A 2D tensor of index pairs with duplicates removed from     the specified column.</li> </ul>"},{"location":"API/particula/lagrangian/particle_pairs/#examples_1","title":"Examples","text":"<p>index_pairs = torch.tensor([[1, 2], [3, 4], [1, 2]]) index_to_remove = 0</p>"},{"location":"API/particula/lagrangian/particle_pairs/#output-will-be-1-2-3-4-assuming-column-0-is-chosen-for-removing","title":"Output will be [[1, 2], [3, 4]] assuming column 0 is chosen for removing","text":"<pre><code>duplicates.\n</code></pre>"},{"location":"API/particula/lagrangian/particle_pairs/#signature_3","title":"Signature","text":"<pre><code>def remove_duplicates(\n    index_pairs: torch.Tensor, index_to_remove: int\n) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"API/particula/lagrangian/particle_pairs/#single_axis_sweep_and_prune","title":"single_axis_sweep_and_prune","text":"<p>Show source in particle_pairs.py:118</p> <p>Sweep and prune algorithm for collision detection along a single axis. This function identifies pairs of particles that are close enough to potentially collide.</p>"},{"location":"API/particula/lagrangian/particle_pairs/#arguments_4","title":"Arguments","text":"<ul> <li><code>position_axis</code> torch.Tensor - The position of particles along a single     axis.</li> <li><code>radius</code> torch.Tensor - The radius of particles.</li> </ul>"},{"location":"API/particula/lagrangian/particle_pairs/#returns_4","title":"Returns","text":"<ul> <li><code>Tuple[torch.Tensor,</code> torch.Tensor] - Two tensors containing the indices of potentially colliding particles.</li> </ul>"},{"location":"API/particula/lagrangian/particle_pairs/#signature_4","title":"Signature","text":"<pre><code>def single_axis_sweep_and_prune(\n    position_axis: torch.Tensor, radius: torch.Tensor\n) -&gt; Tuple[torch.Tensor, torch.Tensor]: ...\n</code></pre>"},{"location":"API/particula/lagrangian/particle_pairs/#validate_pair_distance","title":"validate_pair_distance","text":"<p>Show source in particle_pairs.py:79</p> <p>Validates if the Euclidean distances between pairs of points are smaller than the sum of their radii.</p>"},{"location":"API/particula/lagrangian/particle_pairs/#arguments_5","title":"Arguments","text":"<ul> <li><code>collision_indices_pairs</code> torch.Tensor - A tensor containing pairs of     indices of potentially colliding particles.</li> <li><code>position</code> torch.Tensor - A 2D tensor of particle positions, where each     column represents a particle, and each row represents an axis.</li> <li><code>radius</code> torch.Tensor - A 1D tensor representing the radius of each     particle.</li> </ul>"},{"location":"API/particula/lagrangian/particle_pairs/#returns_5","title":"Returns","text":"<ul> <li><code>torch.Tensor</code> - A tensor containing the indices of the pairs of     particles that are actually colliding.</li> </ul>"},{"location":"API/particula/lagrangian/particle_pairs/#signature_5","title":"Signature","text":"<pre><code>def validate_pair_distance(\n    collision_indices_pairs: torch.Tensor, position: torch.Tensor, radius: torch.Tensor\n) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"API/particula/lagrangian/particle_property/","title":"Particle Property","text":"<p>Particula Index / Particula / Lagrangian / Particle Property</p> <p>Auto-generated documentation for particula.lagrangian.particle_property module.</p>"},{"location":"API/particula/lagrangian/particle_property/#friction_factor_wrapper","title":"friction_factor_wrapper","text":"<p>Show source in particle_property.py:70</p> <p>Calculate the friction factor for a given radius, temperature, and pressure.</p> <p>This function wraps several underlying calculations related to dynamic viscosity, mean free path, Knudsen number, and slip correction factor to compute the particle friction factor.</p>"},{"location":"API/particula/lagrangian/particle_property/#arguments","title":"Arguments","text":"<ul> <li><code>radius_meter</code> - A tensor representing the radius of the sphere(s) in meters. Can be a scalar or a vector.</li> <li><code>temperature_kelvin</code> - A tensor of the temperature in Kelvin.</li> <li><code>pressure_pascal</code> - A tensor of the pressure in Pascals.</li> </ul>"},{"location":"API/particula/lagrangian/particle_property/#returns","title":"Returns","text":"<ul> <li><code>torch.Tensor</code> - A tensor of the same shape as <code>radius_meter</code>, representing the particle friction factor.</li> </ul>"},{"location":"API/particula/lagrangian/particle_property/#signature","title":"Signature","text":"<pre><code>def friction_factor_wrapper(\n    radius_meter: torch.Tensor, temperature_kelvin: float, pressure_pascal: float\n) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"API/particula/lagrangian/particle_property/#generate_particle_masses","title":"generate_particle_masses","text":"<p>Show source in particle_property.py:122</p> <p>Generate an array of particle masses based on a log-normal distribution of particle radii and a given density.</p>"},{"location":"API/particula/lagrangian/particle_property/#arguments_1","title":"Arguments","text":"<ul> <li><code>mean_radius</code> float - Mean radius of the particles. The units are     specified by <code>radius_input_units</code>.</li> <li><code>std_dev_radius</code> float - Standard deviation of the particle radii. The     units are specified by <code>radius_input_units</code>.</li> <li><code>density</code> torch.Tensor - Density of the particles in kg/m^3.</li> <li><code>num_particles</code> int - Number of particles to generate.</li> <li><code>radius_input_units</code> str, optional - Units of <code>mean_radius</code> and     <code>std_dev_radius</code>. Defaults to 'nm' (nanometers).</li> </ul>"},{"location":"API/particula/lagrangian/particle_property/#returns_1","title":"Returns","text":"<ul> <li><code>torch.Tensor</code> - A tensor of particle masses in kg, corresponding to each     particle.</li> </ul>"},{"location":"API/particula/lagrangian/particle_property/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code> - If <code>mean_radius</code> or <code>std_dev_radius</code> are non-positive.</li> </ul>"},{"location":"API/particula/lagrangian/particle_property/#signature_1","title":"Signature","text":"<pre><code>def generate_particle_masses(\n    mean_radius: float,\n    std_dev_radius: float,\n    density: torch.Tensor,\n    num_particles: int,\n    radius_input_units: str = \"nm\",\n) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"API/particula/lagrangian/particle_property/#mass_calculation","title":"mass_calculation","text":"<p>Show source in particle_property.py:44</p> <p>Calculate the mass of a sphere given its radius and density using the formula for the volume of a sphere.</p> <p>This function assumes a uniform density and spherical shape to compute the mass based on the mass-density relationship: Volume = Mass / Density. The volume of a sphere is given by (4/3) * pi * radius^3.</p>"},{"location":"API/particula/lagrangian/particle_property/#arguments_2","title":"Arguments","text":"<ul> <li>radius (torch.Tensor): A tensor containing the radius of the sphere(s).     Can be a scalar or a vector.</li> <li>density (torch.Tensor): A tensor containing the density of the sphere(s).     Can be a scalar or a vector.</li> </ul>"},{"location":"API/particula/lagrangian/particle_property/#returns_2","title":"Returns","text":"<ul> <li><code>torch.Tensor</code> - A tensor of the same shape as <code>radius</code> and <code>density</code>     representing the mass of the sphere(s).</li> </ul>"},{"location":"API/particula/lagrangian/particle_property/#signature_2","title":"Signature","text":"<pre><code>def mass_calculation(radius: torch.Tensor, density: torch.Tensor) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"API/particula/lagrangian/particle_property/#nearest_match","title":"nearest_match","text":"<p>Show source in particle_property.py:254</p> <p>Perform nearest neighbor interpolation (on torch objects) to find y-values corresponding to new x-values. The function identifies the nearest x-value for each value in x_new and returns the corresponding y-value.</p>"},{"location":"API/particula/lagrangian/particle_property/#arguments_3","title":"Arguments","text":"<ul> <li><code>x_values</code> torch.Tensor - The original x-values of shape (n,).</li> <li><code>y_values</code> torch.Tensor - The original y-values of shape (n,).     Each y-value corresponds to an x-value.</li> <li><code>x_new</code> torch.Tensor - The new x-values for which y-values are to be     interpolated, of shape (m,).</li> </ul>"},{"location":"API/particula/lagrangian/particle_property/#returns_3","title":"Returns","text":"<ul> <li><code>torch.Tensor</code> - The interpolated y-values of shape (m,). Each value     corresponds to the nearest match from x_values.</li> </ul>"},{"location":"API/particula/lagrangian/particle_property/#signature_3","title":"Signature","text":"<pre><code>def nearest_match(\n    x_values: torch.Tensor, y_values: torch.Tensor, x_new: torch.Tensor\n) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"API/particula/lagrangian/particle_property/#radius_calculation","title":"radius_calculation","text":"<p>Show source in particle_property.py:12</p> <p>Calculate the radius of a sphere given its mass and density using the formula for the volume of a sphere.</p> <p>This function assumes a uniform density and spherical shape to compute the radius based on the mass-density relationship: Volume = Mass / Density. The volume of a sphere is given by (4/3) * pi * radius^3.</p>"},{"location":"API/particula/lagrangian/particle_property/#arguments_4","title":"Arguments","text":"<ul> <li>mass (torch.Tensor): A tensor containing the mass of the sphere(s). Can     be a scalar or a vector.</li> <li>density (torch.Tensor): A tensor containing the density of the sphere(s).     Can be a scalar or a vector.</li> </ul>"},{"location":"API/particula/lagrangian/particle_property/#returns_4","title":"Returns","text":"<ul> <li><code>torch.Tensor</code> - A tensor of the same shape as <code>mass</code> and <code>density</code>     representing the radius of the sphere(s).</li> </ul>"},{"location":"API/particula/lagrangian/particle_property/#notes","title":"Notes","text":"<ul> <li>The function supports broadcasting, so <code>mass</code> and <code>density</code> can be of     different shapes, as long as they are broadcastable to a common shape.</li> <li>Units of mass and density should be consistent to obtain a radius in     meaningful units.</li> </ul>"},{"location":"API/particula/lagrangian/particle_property/#signature_4","title":"Signature","text":"<pre><code>def radius_calculation(mass: torch.Tensor, density: torch.Tensor) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"API/particula/lagrangian/particle_property/#random_thermal_velocity","title":"random_thermal_velocity","text":"<p>Show source in particle_property.py:221</p> <p>Generate a random thermal velocity for each particle.</p>"},{"location":"API/particula/lagrangian/particle_property/#arguments_5","title":"Arguments","text":"<ul> <li><code>temperature_kelvin</code> torch.Tensor - Temperature of the fluid in Kelvin.</li> <li><code>mass_kg</code> torch.Tensor - Mass of the particle in kilograms.</li> <li><code>number_of_particles</code> int - Number of particles.</li> </ul>"},{"location":"API/particula/lagrangian/particle_property/#returns_5","title":"Returns","text":"<ul> <li><code>torch.Tensor</code> - Thermal speed of the particle in meters per second.</li> </ul>"},{"location":"API/particula/lagrangian/particle_property/#signature_5","title":"Signature","text":"<pre><code>def random_thermal_velocity(\n    temperature_kelvin: float,\n    mass_kg: torch.Tensor,\n    number_of_particles: int,\n    t_type=torch.float,\n    random_seed: int = 0,\n) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"API/particula/lagrangian/particle_property/#speed","title":"speed","text":"<p>Show source in particle_property.py:206</p> <p>Calculate the speed of a particle.</p>"},{"location":"API/particula/lagrangian/particle_property/#arguments_6","title":"Arguments","text":"<ul> <li><code>velocity</code> torch.Tensor - Velocity of the particle.</li> </ul>"},{"location":"API/particula/lagrangian/particle_property/#returns_6","title":"Returns","text":"<ul> <li><code>torch.Tensor</code> - Speed of the particle.</li> </ul>"},{"location":"API/particula/lagrangian/particle_property/#signature_6","title":"Signature","text":"<pre><code>def speed(velocity: torch.Tensor) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"API/particula/lagrangian/particle_property/#thermal_speed","title":"thermal_speed","text":"<p>Show source in particle_property.py:173</p> <p>Calculate the thermal speed of a particle based on its temperature and mass.</p> <p>The thermal speed is computed using the formula: sqrt(8 * k * T / (pi * m)) where k is the Boltzmann constant, T is the temperature in Kelvin, and m is the particle mass in kilograms.</p>"},{"location":"API/particula/lagrangian/particle_property/#arguments_7","title":"Arguments","text":"<ul> <li><code>temperature_kelvin</code> float - Temperature of the environment in Kelvin.</li> <li><code>mass_kg</code> torch.Tensor - Mass of the particle(s) in kilograms.     Can be a scalar or a vector.</li> </ul>"},{"location":"API/particula/lagrangian/particle_property/#returns_7","title":"Returns","text":"<ul> <li><code>torch.Tensor</code> - The thermal speed of the particle(s) in meters per second</li> </ul>"},{"location":"API/particula/lagrangian/particle_property/#raises_1","title":"Raises","text":"<ul> <li><code>ValueError</code> - If <code>temperature_kelvin</code> is less than or equal to zero or if any element of <code>mass_kg</code> is non-positive.</li> </ul>"},{"location":"API/particula/lagrangian/particle_property/#signature_7","title":"Signature","text":"<pre><code>def thermal_speed(temperature_kelvin: float, mass_kg: torch.Tensor) -&gt; torch.Tensor: ...\n</code></pre>"},{"location":"API/particula/next/","title":"Next","text":"<p>Particula Index / Particula / Next</p> <p>Auto-generated documentation for particula.next module.</p>"},{"location":"API/particula/next/#modules","title":"Modules","text":"<ul> <li>Abc Builder</li> <li>Abc Factory</li> <li>Aerosol</li> <li>Builder Mixin</li> <li>Dynamics</li> <li>Gas</li> <li>Particles</li> <li>Runnable</li> </ul>"},{"location":"API/particula/next/abc_builder/","title":"Abc Builder","text":"<p>Particula Index / Particula / Next / Abc Builder</p> <p>Auto-generated documentation for particula.next.abc_builder module.</p>"},{"location":"API/particula/next/abc_builder/#builderabc","title":"BuilderABC","text":"<p>Show source in abc_builder.py:23</p> <p>Abstract base class for builders with common methods to check keys and set parameters from a dictionary.</p>"},{"location":"API/particula/next/abc_builder/#attributes","title":"Attributes","text":"<ul> <li><code>required_parameters</code> - List of required parameters for the builder.</li> </ul>"},{"location":"API/particula/next/abc_builder/#methods","title":"Methods","text":"<ul> <li><code>check_keys</code> parameters - Check if the keys you want to set are present in the parameters dictionary.</li> <li><code>set_parameters</code> parameters - Set parameters from a dictionary including optional suffix for units as '_units'.</li> <li><code>pre_build_check()</code> - Check if all required attribute parameters are set before building.</li> <li><code>build</code> abstract - Build and return the strategy object.</li> </ul>"},{"location":"API/particula/next/abc_builder/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code> - If any required key is missing during check_keys or pre_build_check, or if trying to set an invalid parameter.</li> <li><code>Warning</code> - If using default units for any parameter.</li> </ul>"},{"location":"API/particula/next/abc_builder/#references","title":"References","text":"<p>This module also defines mixin classes for the Builder classes to set some optional method to be used in the Builder classes. Mixin Wikipedia</p>"},{"location":"API/particula/next/abc_builder/#signature","title":"Signature","text":"<pre><code>class BuilderABC(ABC):\n    def __init__(self, required_parameters: Optional[list[str]] = None): ...\n</code></pre>"},{"location":"API/particula/next/abc_builder/#builderabcbuild","title":"BuilderABC().build","text":"<p>Show source in abc_builder.py:133</p> <p>Build and return the strategy object with the set parameters.</p>"},{"location":"API/particula/next/abc_builder/#returns","title":"Returns","text":"<ul> <li><code>strategy</code> - The built strategy object.</li> </ul>"},{"location":"API/particula/next/abc_builder/#signature_1","title":"Signature","text":"<pre><code>@abstractmethod\ndef build(self) -&gt; Any: ...\n</code></pre>"},{"location":"API/particula/next/abc_builder/#builderabccheck_keys","title":"BuilderABC().check_keys","text":"<p>Show source in abc_builder.py:53</p> <p>Check if the keys are present and valid.</p>"},{"location":"API/particula/next/abc_builder/#arguments","title":"Arguments","text":"<ul> <li><code>parameters</code> - The parameters dictionary to check.</li> </ul>"},{"location":"API/particula/next/abc_builder/#raises_1","title":"Raises","text":"<ul> <li><code>ValueError</code> - If any required key is missing or if trying to set an invalid parameter.</li> </ul>"},{"location":"API/particula/next/abc_builder/#signature_2","title":"Signature","text":"<pre><code>def check_keys(self, parameters: dict[str, Any]): ...\n</code></pre>"},{"location":"API/particula/next/abc_builder/#builderabcpre_build_check","title":"BuilderABC().pre_build_check","text":"<p>Show source in abc_builder.py:118</p> <p>Check if all required attribute parameters are set before building.</p>"},{"location":"API/particula/next/abc_builder/#raises_2","title":"Raises","text":"<ul> <li><code>ValueError</code> - If any required parameter is missing.</li> </ul>"},{"location":"API/particula/next/abc_builder/#signature_3","title":"Signature","text":"<pre><code>def pre_build_check(self): ...\n</code></pre>"},{"location":"API/particula/next/abc_builder/#builderabcset_parameters","title":"BuilderABC().set_parameters","text":"<p>Show source in abc_builder.py:90</p> <p>Set parameters from a dictionary including optional suffix for units as '_units'.</p>"},{"location":"API/particula/next/abc_builder/#arguments_1","title":"Arguments","text":"<ul> <li><code>parameters</code> - The parameters dictionary to set.</li> </ul>"},{"location":"API/particula/next/abc_builder/#returns_1","title":"Returns","text":"<ul> <li><code>self</code> - The builder object with the set parameters.</li> </ul>"},{"location":"API/particula/next/abc_builder/#raises_3","title":"Raises","text":"<ul> <li><code>ValueError</code> - If any required key is missing.</li> <li><code>Warning</code> - If using default units for any parameter.</li> </ul>"},{"location":"API/particula/next/abc_builder/#signature_4","title":"Signature","text":"<pre><code>def set_parameters(self, parameters: dict[str, Any]): ...\n</code></pre>"},{"location":"API/particula/next/abc_factory/","title":"Abc Factory","text":"<p>Particula Index / Particula / Next / Abc Factory</p> <p>Auto-generated documentation for particula.next.abc_factory module.</p>"},{"location":"API/particula/next/abc_factory/#attributes","title":"Attributes","text":"<ul> <li><code>BuilderT</code> - Define a generic type variable for the strategy type, to get good type hints: TypeVar('BuilderT')</li> </ul>"},{"location":"API/particula/next/abc_factory/#strategyfactory","title":"StrategyFactory","text":"<p>Show source in abc_factory.py:18</p> <p>Abstract base class for strategy factories.</p>"},{"location":"API/particula/next/abc_factory/#signature","title":"Signature","text":"<pre><code>class StrategyFactory(ABC, Generic[BuilderT, StrategyT]): ...\n</code></pre>"},{"location":"API/particula/next/abc_factory/#see-also","title":"See also","text":"<ul> <li>BuilderT</li> <li>StrategyT</li> </ul>"},{"location":"API/particula/next/abc_factory/#strategyfactoryget_builders","title":"StrategyFactory().get_builders","text":"<p>Show source in abc_factory.py:23</p> <p>Returns the mapping of strategy types to builder instances.</p>"},{"location":"API/particula/next/abc_factory/#signature_1","title":"Signature","text":"<pre><code>@abstractmethod\ndef get_builders(self) -&gt; Dict[str, BuilderT]: ...\n</code></pre>"},{"location":"API/particula/next/abc_factory/#see-also_1","title":"See also","text":"<ul> <li>BuilderT</li> </ul>"},{"location":"API/particula/next/abc_factory/#strategyfactoryget_strategy","title":"StrategyFactory().get_strategy","text":"<p>Show source in abc_factory.py:29</p> <p>Generic factory method to create strategies.</p>"},{"location":"API/particula/next/abc_factory/#signature_2","title":"Signature","text":"<pre><code>def get_strategy(\n    self, strategy_type: str, parameters: Optional[Dict[str, Any]] = None\n) -&gt; StrategyT: ...\n</code></pre>"},{"location":"API/particula/next/abc_factory/#see-also_2","title":"See also","text":"<ul> <li>StrategyT</li> </ul>"},{"location":"API/particula/next/aerosol/","title":"Aerosol","text":"<p>Particula Index / Particula / Next / Aerosol</p> <p>Auto-generated documentation for particula.next.aerosol module.</p>"},{"location":"API/particula/next/aerosol/#aerosol_1","title":"Aerosol","text":"<p>Show source in aerosol.py:14</p> <p>Collection of Gas and Particle objects.</p> <p>A class for interacting with collections of Gas and Particle objects. Allows for the representation and manipulation of an aerosol, which is composed of various gases and particles.</p>"},{"location":"API/particula/next/aerosol/#signature","title":"Signature","text":"<pre><code>class Aerosol:\n    def __init__(\n        self,\n        atmosphere: Atmosphere,\n        particles: Union[ParticleRepresentation, List[ParticleRepresentation]],\n    ): ...\n</code></pre>"},{"location":"API/particula/next/aerosol/#see-also","title":"See also","text":"<ul> <li>Atmosphere</li> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/aerosol/#aerosolstr","title":"Aerosol().str","text":"<p>Show source in aerosol.py:39</p> <p>Returns a string representation of the aerosol.</p>"},{"location":"API/particula/next/aerosol/#returns","title":"Returns","text":"<ul> <li><code>str</code> - A string representation of the aerosol.</li> </ul>"},{"location":"API/particula/next/aerosol/#signature_1","title":"Signature","text":"<pre><code>def __str__(self) -&gt; str: ...\n</code></pre>"},{"location":"API/particula/next/aerosol/#aerosoladd_particle","title":"Aerosol().add_particle","text":"<p>Show source in aerosol.py:75</p> <p>Adds a Particle instance to the aerosol.</p>"},{"location":"API/particula/next/aerosol/#arguments","title":"Arguments","text":"<ul> <li><code>particle</code> - The Particle instance to add.</li> </ul>"},{"location":"API/particula/next/aerosol/#signature_2","title":"Signature","text":"<pre><code>def add_particle(self, particle: ParticleRepresentation): ...\n</code></pre>"},{"location":"API/particula/next/aerosol/#see-also_1","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/aerosol/#aerosoliterate_gas","title":"Aerosol().iterate_gas","text":"<p>Show source in aerosol.py:51</p> <p>Returns an iterator for atmosphere species.</p>"},{"location":"API/particula/next/aerosol/#returns_1","title":"Returns","text":"<ul> <li><code>Iterator[GasSpecies]</code> - An iterator over the gas species type.</li> </ul>"},{"location":"API/particula/next/aerosol/#signature_3","title":"Signature","text":"<pre><code>def iterate_gas(self) -&gt; Iterator[GasSpecies]: ...\n</code></pre>"},{"location":"API/particula/next/aerosol/#see-also_2","title":"See also","text":"<ul> <li>GasSpecies</li> </ul>"},{"location":"API/particula/next/aerosol/#aerosoliterate_particle","title":"Aerosol().iterate_particle","text":"<p>Show source in aerosol.py:59</p> <p>Returns an iterator for particle.</p>"},{"location":"API/particula/next/aerosol/#returns_2","title":"Returns","text":"<ul> <li><code>Iterator[Particle]</code> - An iterator over the particle type.</li> </ul>"},{"location":"API/particula/next/aerosol/#signature_4","title":"Signature","text":"<pre><code>def iterate_particle(self) -&gt; Iterator[ParticleRepresentation]: ...\n</code></pre>"},{"location":"API/particula/next/aerosol/#see-also_3","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/aerosol/#aerosolreplace_atmosphere","title":"Aerosol().replace_atmosphere","text":"<p>Show source in aerosol.py:67</p> <p>Replaces the current Atmosphere instance with a new one.</p>"},{"location":"API/particula/next/aerosol/#arguments_1","title":"Arguments","text":"<ul> <li><code>gas</code> - The instance to replace the current one.</li> </ul>"},{"location":"API/particula/next/aerosol/#signature_5","title":"Signature","text":"<pre><code>def replace_atmosphere(self, atmosphere: Atmosphere): ...\n</code></pre>"},{"location":"API/particula/next/aerosol/#see-also_4","title":"See also","text":"<ul> <li>Atmosphere</li> </ul>"},{"location":"API/particula/next/builder_mixin/","title":"Builder Mixin","text":"<p>Particula Index / Particula / Next / Builder Mixin</p> <p>Auto-generated documentation for particula.next.builder_mixin module.</p>"},{"location":"API/particula/next/builder_mixin/#builderactivitystrategymixin","title":"BuilderActivityStrategyMixin","text":"<p>Show source in builder_mixin.py:373</p> <p>Mixin class for Builder classes to set activity_strategy.</p>"},{"location":"API/particula/next/builder_mixin/#methods","title":"Methods","text":"<ul> <li><code>set_activity_strategy</code> - Set the activity_strategy attribute.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature","title":"Signature","text":"<pre><code>class BuilderActivityStrategyMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#builderactivitystrategymixinset_activity_strategy","title":"BuilderActivityStrategyMixin().set_activity_strategy","text":"<p>Show source in builder_mixin.py:383</p> <p>Set the activity strategy of the particle.</p>"},{"location":"API/particula/next/builder_mixin/#arguments","title":"Arguments","text":"<ul> <li><code>activity_strategy</code> - Activity strategy of the particle.</li> <li><code>activity_strategy_units</code> - Not used. (for interface consistency)</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_1","title":"Signature","text":"<pre><code>def set_activity_strategy(\n    self,\n    activity_strategy: ActivityStrategy,\n    activity_strategy_units: Optional[str] = None,\n): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#see-also","title":"See also","text":"<ul> <li>ActivityStrategy</li> </ul>"},{"location":"API/particula/next/builder_mixin/#builderchargemixin","title":"BuilderChargeMixin","text":"<p>Show source in builder_mixin.py:152</p> <p>Mixin class for Builder classes to set charge and charge_units.</p>"},{"location":"API/particula/next/builder_mixin/#methods_1","title":"Methods","text":"<ul> <li><code>set_charge</code> - Set the charge attribute and units.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_2","title":"Signature","text":"<pre><code>class BuilderChargeMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#builderchargemixinset_charge","title":"BuilderChargeMixin().set_charge","text":"<p>Show source in builder_mixin.py:162</p> <p>Set the number of elemental charges on the particle.</p>"},{"location":"API/particula/next/builder_mixin/#arguments_1","title":"Arguments","text":"<ul> <li><code>charge</code> - Charge of the particle [C].</li> <li><code>charge_units</code> - Not used. (for interface consistency)</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_3","title":"Signature","text":"<pre><code>def set_charge(\n    self, charge: Union[float, NDArray[np.float64]], charge_units: Optional[str] = None\n): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#builderconcentrationmixin","title":"BuilderConcentrationMixin","text":"<p>Show source in builder_mixin.py:113</p> <p>Mixin class for Builder classes to set concentration and concentration_units.</p>"},{"location":"API/particula/next/builder_mixin/#arguments_2","title":"Arguments","text":"<ul> <li><code>default_units</code> - Default units of concentration. Default is kg/m^3.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#methods_2","title":"Methods","text":"<ul> <li><code>set_concentration</code> - Set the concentration attribute and units.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_4","title":"Signature","text":"<pre><code>class BuilderConcentrationMixin:\n    def __init__(self, default_units: Optional[str] = \"kg/m^3\"): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#builderconcentrationmixinset_concentration","title":"BuilderConcentrationMixin().set_concentration","text":"<p>Show source in builder_mixin.py:128</p> <p>Set the concentration.</p>"},{"location":"API/particula/next/builder_mixin/#arguments_3","title":"Arguments","text":"<ul> <li><code>concentration</code> - Concentration in the mixture.</li> <li><code>concentration_units</code> - Units of the concentration. Default is kg/m^3.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_5","title":"Signature","text":"<pre><code>def set_concentration(\n    self,\n    concentration: Union[float, NDArray[np.float64]],\n    concentration_units: Optional[str] = None,\n): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#builderdensitymixin","title":"BuilderDensityMixin","text":"<p>Show source in builder_mixin.py:20</p> <p>Mixin class for Builder classes to set density and density_units.</p>"},{"location":"API/particula/next/builder_mixin/#methods_3","title":"Methods","text":"<ul> <li><code>set_density</code> - Set the density attribute and units.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_6","title":"Signature","text":"<pre><code>class BuilderDensityMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#builderdensitymixinset_density","title":"BuilderDensityMixin().set_density","text":"<p>Show source in builder_mixin.py:30</p> <p>Set the density of the particle in kg/m^3.</p>"},{"location":"API/particula/next/builder_mixin/#arguments_4","title":"Arguments","text":"<ul> <li><code>density</code> - Density of the particle.</li> <li><code>density_units</code> - Units of the density. Default is kg/m^3</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_7","title":"Signature","text":"<pre><code>def set_density(\n    self,\n    density: Union[float, NDArray[np.float64]],\n    density_units: Optional[str] = \"kg/m^3\",\n): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#builderdistributionstrategymixin","title":"BuilderDistributionStrategyMixin","text":"<p>Show source in builder_mixin.py:400</p> <p>Mixin class for Builder classes to set distribution_strategy.</p>"},{"location":"API/particula/next/builder_mixin/#methods_4","title":"Methods","text":"<ul> <li><code>set_distribution_strategy</code> - Set the distribution_strategy attribute.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_8","title":"Signature","text":"<pre><code>class BuilderDistributionStrategyMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#builderdistributionstrategymixinset_distribution_strategy","title":"BuilderDistributionStrategyMixin().set_distribution_strategy","text":"<p>Show source in builder_mixin.py:410</p> <p>Set the distribution strategy of the particle.</p>"},{"location":"API/particula/next/builder_mixin/#arguments_5","title":"Arguments","text":"<ul> <li><code>distribution_strategy</code> - Distribution strategy of the particle.</li> <li><code>distribution_strategy_units</code> - Not used. (for interface consistency)</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_9","title":"Signature","text":"<pre><code>def set_distribution_strategy(\n    self,\n    distribution_strategy: DistributionStrategy,\n    distribution_strategy_units: Optional[str] = None,\n): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#see-also_1","title":"See also","text":"<ul> <li>DistributionStrategy</li> </ul>"},{"location":"API/particula/next/builder_mixin/#builderlognormalmixin","title":"BuilderLognormalMixin","text":"<p>Show source in builder_mixin.py:429</p> <p>Mixin class for Builder classes to set lognormal distributions.</p>"},{"location":"API/particula/next/builder_mixin/#methods_5","title":"Methods","text":"<ul> <li><code>set_mode</code> - Set the mode attribute and units.</li> <li><code>set_geometric_standard_deviation</code> - Set the geometric standard deviation     attribute and units.</li> <li><code>set_number_concentration</code> - Set the number concentration attribute and     units.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_10","title":"Signature","text":"<pre><code>class BuilderLognormalMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#builderlognormalmixinset_geometric_standard_deviation","title":"BuilderLognormalMixin().set_geometric_standard_deviation","text":"<p>Show source in builder_mixin.py:466</p> <p>Set the geometric standard deviation for the distribution.</p>"},{"location":"API/particula/next/builder_mixin/#arguments_6","title":"Arguments","text":"<ul> <li><code>geometric_standard_deviation</code> - The geometric standard deviation for     the radius.</li> <li><code>geometric_standard_deviation_units</code> - Optional, ignored units for     geometric standard deviation [dimensionless].</li> </ul>"},{"location":"API/particula/next/builder_mixin/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code> - If geometric standard deviation is negative.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_11","title":"Signature","text":"<pre><code>def set_geometric_standard_deviation(\n    self,\n    geometric_standard_deviation: NDArray[np.float64],\n    geometric_standard_deviation_units: Optional[str] = None,\n): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#builderlognormalmixinset_mode","title":"BuilderLognormalMixin().set_mode","text":"<p>Show source in builder_mixin.py:445</p> <p>Set the mode for distribution.</p>"},{"location":"API/particula/next/builder_mixin/#arguments_7","title":"Arguments","text":"<ul> <li><code>mode</code> - The modes for the radius.</li> <li><code>mode_units</code> - The units for the modes, default is 'm'.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#raises_1","title":"Raises","text":"<ul> <li><code>ValueError</code> - If mode is negative.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_12","title":"Signature","text":"<pre><code>def set_mode(self, mode: NDArray[np.float64], mode_units: str = \"m\"): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#builderlognormalmixinset_number_concentration","title":"BuilderLognormalMixin().set_number_concentration","text":"<p>Show source in builder_mixin.py:491</p> <p>Set the number concentration for the distribution.</p>"},{"location":"API/particula/next/builder_mixin/#arguments_8","title":"Arguments","text":"<ul> <li><code>number_concentration</code> - The number concentration for the radius.</li> <li><code>number_concentration_units</code> - The units for the number concentration,     default is '1/m^3'.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#raises_2","title":"Raises","text":"<ul> <li><code>ValueError</code> - If number concentration is negative.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_13","title":"Signature","text":"<pre><code>def set_number_concentration(\n    self,\n    number_concentration: NDArray[np.float64],\n    number_concentration_units: str = \"1/m^3\",\n): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#buildermassmixin","title":"BuilderMassMixin","text":"<p>Show source in builder_mixin.py:179</p> <p>Mixin class for Builder classes to set mass and mass_units.</p>"},{"location":"API/particula/next/builder_mixin/#methods_6","title":"Methods","text":"<ul> <li><code>set_mass</code> - Set the mass attribute and units.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_14","title":"Signature","text":"<pre><code>class BuilderMassMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#buildermassmixinset_mass","title":"BuilderMassMixin().set_mass","text":"<p>Show source in builder_mixin.py:189</p> <p>Set the mass of the particle in kg.</p>"},{"location":"API/particula/next/builder_mixin/#arguments_9","title":"Arguments","text":"<ul> <li><code>mass</code> - Mass of the particle.</li> <li><code>mass_units</code> - Units of the mass. Default is kg.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#raises_3","title":"Raises","text":"<ul> <li><code>ValueError</code> - If mass is negative</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_15","title":"Signature","text":"<pre><code>def set_mass(\n    self, mass: Union[float, NDArray[np.float64]], mass_units: Optional[str] = \"kg\"\n): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#buildermolarmassmixin","title":"BuilderMolarMassMixin","text":"<p>Show source in builder_mixin.py:81</p> <p>Mixin class for Builder classes to set molar_mass and molar_mass_units.</p>"},{"location":"API/particula/next/builder_mixin/#methods_7","title":"Methods","text":"<ul> <li><code>set_molar_mass</code> - Set the molar_mass attribute and units.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_16","title":"Signature","text":"<pre><code>class BuilderMolarMassMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#buildermolarmassmixinset_molar_mass","title":"BuilderMolarMassMixin().set_molar_mass","text":"<p>Show source in builder_mixin.py:91</p> <p>Set the molar mass of the particle in kg/mol.</p>"},{"location":"API/particula/next/builder_mixin/#arguments_10","title":"Arguments","text":"<ul> <li><code>-</code> molar_mass - Molar mass of the particle.</li> <li><code>-</code> molar_mass_units - Units of the molar mass. Default is kg/mol.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_17","title":"Signature","text":"<pre><code>def set_molar_mass(\n    self,\n    molar_mass: Union[float, NDArray[np.float64]],\n    molar_mass_units: Optional[str] = \"kg/mol\",\n): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#builderparticleresolvedcountmixin","title":"BuilderParticleResolvedCountMixin","text":"<p>Show source in builder_mixin.py:516</p> <p>Mixin class for Builder classes to set particle_resolved_count.</p>"},{"location":"API/particula/next/builder_mixin/#methods_8","title":"Methods","text":"<ul> <li><code>set_particle_resolved_count</code> - Set the number of particles to resolve.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_18","title":"Signature","text":"<pre><code>class BuilderParticleResolvedCountMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#builderparticleresolvedcountmixinset_particle_resolved_count","title":"BuilderParticleResolvedCountMixin().set_particle_resolved_count","text":"<p>Show source in builder_mixin.py:526</p> <p>Set the number of particles to resolve.</p>"},{"location":"API/particula/next/builder_mixin/#arguments_11","title":"Arguments","text":"<ul> <li><code>particle_resolved_count</code> - The number of particles to resolve.</li> <li><code>particle_resolved_count_units</code> - Ignored units for particle resolved.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#raises_4","title":"Raises","text":"<ul> <li><code>ValueError</code> - If particle_resolved_count is negative.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_19","title":"Signature","text":"<pre><code>def set_particle_resolved_count(\n    self,\n    particle_resolved_count: int,\n    particle_resolved_count_units: Optional[str] = None,\n): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#builderpressuremixin","title":"BuilderPressureMixin","text":"<p>Show source in builder_mixin.py:311</p> <p>Mixin class for AtmosphereBuilder to set total pressure.</p>"},{"location":"API/particula/next/builder_mixin/#methods_9","title":"Methods","text":"<ul> <li><code>set_pressure</code> - Set the total pressure attribute and units.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_20","title":"Signature","text":"<pre><code>class BuilderPressureMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#builderpressuremixinset_pressure","title":"BuilderPressureMixin().set_pressure","text":"<p>Show source in builder_mixin.py:321</p> <p>Set the total pressure of the atmosphere.</p>"},{"location":"API/particula/next/builder_mixin/#arguments_12","title":"Arguments","text":"<ul> <li><code>total_pressure</code> - Total pressure of the gas mixture.</li> <li><code>pressure_units</code> - Units of the pressure. Options include     'Pa', 'kPa', 'MPa', 'psi', 'bar', 'atm'. Default is 'Pa'.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#returns","title":"Returns","text":"<ul> <li><code>AtmosphereBuilderMixin</code> - This object instance with updated pressure.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#raises_5","title":"Raises","text":"<ul> <li><code>ValueError</code> - If the total pressure is below zero.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_21","title":"Signature","text":"<pre><code>def set_pressure(\n    self, pressure: Union[float, NDArray[np.float64]], pressure_units: str = \"Pa\"\n): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#builderradiusmixin","title":"BuilderRadiusMixin","text":"<p>Show source in builder_mixin.py:243</p> <p>Mixin class for Builder classes to set radius and radius_units.</p>"},{"location":"API/particula/next/builder_mixin/#methods_10","title":"Methods","text":"<ul> <li><code>set_radius</code> - Set the radius attribute and units.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_22","title":"Signature","text":"<pre><code>class BuilderRadiusMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#builderradiusmixinset_radius","title":"BuilderRadiusMixin().set_radius","text":"<p>Show source in builder_mixin.py:253</p> <p>Set the radius of the particle in meters.</p>"},{"location":"API/particula/next/builder_mixin/#arguments_13","title":"Arguments","text":"<ul> <li><code>radius</code> - Radius of the particle.</li> <li><code>radius_units</code> - Units of the radius. Default is m.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#raises_6","title":"Raises","text":"<ul> <li><code>ValueError</code> - If radius is negative</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_23","title":"Signature","text":"<pre><code>def set_radius(\n    self, radius: Union[float, NDArray[np.float64]], radius_units: Optional[str] = \"m\"\n): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#buildersurfacestrategymixin","title":"BuilderSurfaceStrategyMixin","text":"<p>Show source in builder_mixin.py:346</p> <p>Mixin class for Builder classes to set surface_strategy.</p>"},{"location":"API/particula/next/builder_mixin/#methods_11","title":"Methods","text":"<ul> <li><code>set_surface_strategy</code> - Set the surface_strategy attribute.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_24","title":"Signature","text":"<pre><code>class BuilderSurfaceStrategyMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#buildersurfacestrategymixinset_surface_strategy","title":"BuilderSurfaceStrategyMixin().set_surface_strategy","text":"<p>Show source in builder_mixin.py:356</p> <p>Set the surface strategy of the particle.</p>"},{"location":"API/particula/next/builder_mixin/#arguments_14","title":"Arguments","text":"<ul> <li><code>surface_strategy</code> - Surface strategy of the particle.</li> <li><code>surface_strategy_units</code> - Not used. (for interface consistency)</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_25","title":"Signature","text":"<pre><code>def set_surface_strategy(\n    self, surface_strategy: SurfaceStrategy, surface_strategy_units: Optional[str] = None\n): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#see-also_2","title":"See also","text":"<ul> <li>SurfaceStrategy</li> </ul>"},{"location":"API/particula/next/builder_mixin/#buildersurfacetensionmixin","title":"BuilderSurfaceTensionMixin","text":"<p>Show source in builder_mixin.py:49</p> <p>Mixin class for Builder classes to set surface_tension.</p>"},{"location":"API/particula/next/builder_mixin/#methods_12","title":"Methods","text":"<pre><code>- `set_surface_tension` - Set the surface_tension attribute and units.\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#signature_26","title":"Signature","text":"<pre><code>class BuilderSurfaceTensionMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#buildersurfacetensionmixinset_surface_tension","title":"BuilderSurfaceTensionMixin().set_surface_tension","text":"<p>Show source in builder_mixin.py:60</p> <p>Set the surface tension of the particle in N/m.</p>"},{"location":"API/particula/next/builder_mixin/#arguments_15","title":"Arguments","text":"<ul> <li><code>surface_tension</code> - Surface tension of the particle.</li> <li><code>surface_tension_units</code> - Surface tension units. Default is N/m.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_27","title":"Signature","text":"<pre><code>def set_surface_tension(\n    self,\n    surface_tension: Union[float, NDArray[np.float64]],\n    surface_tension_units: Optional[str] = \"N/m\",\n): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#buildertemperaturemixin","title":"BuilderTemperatureMixin","text":"<p>Show source in builder_mixin.py:275</p> <p>Mixin class for AtmosphereBuilder to set temperature.</p>"},{"location":"API/particula/next/builder_mixin/#methods_13","title":"Methods","text":"<ul> <li><code>set_temperature</code> - Set the temperature attribute and units.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_28","title":"Signature","text":"<pre><code>class BuilderTemperatureMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#buildertemperaturemixinset_temperature","title":"BuilderTemperatureMixin().set_temperature","text":"<p>Show source in builder_mixin.py:285</p> <p>Set the temperature of the atmosphere.</p>"},{"location":"API/particula/next/builder_mixin/#arguments_16","title":"Arguments","text":"<ul> <li><code>temperature</code> float - Temperature of the gas mixture.</li> <li><code>temperature_units</code> str - Units of the temperature.     Options include 'degC', 'degF', 'degR', 'K'. Default is 'K'.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#returns_1","title":"Returns","text":"<ul> <li><code>AtmosphereBuilderMixin</code> - This object instance with updated     temperature.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#raises_7","title":"Raises","text":"<ul> <li><code>ValueError</code> - If the converted temperature is below absolute zero.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_29","title":"Signature","text":"<pre><code>def set_temperature(self, temperature: float, temperature_units: str = \"K\"): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#buildervolumemixin","title":"BuilderVolumeMixin","text":"<p>Show source in builder_mixin.py:211</p> <p>Mixin class for Builder classes to set volume and volume_units.</p>"},{"location":"API/particula/next/builder_mixin/#methods_14","title":"Methods","text":"<ul> <li><code>set_volume</code> - Set the volume attribute and units.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_30","title":"Signature","text":"<pre><code>class BuilderVolumeMixin:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/builder_mixin/#buildervolumemixinset_volume","title":"BuilderVolumeMixin().set_volume","text":"<p>Show source in builder_mixin.py:221</p> <p>Set the volume in m^3.</p>"},{"location":"API/particula/next/builder_mixin/#arguments_17","title":"Arguments","text":"<ul> <li><code>volume</code> - Volume.</li> <li><code>volume_units</code> - Units of the volume. Default is m^3.</li> </ul>"},{"location":"API/particula/next/builder_mixin/#raises_8","title":"Raises","text":"<ul> <li><code>ValueError</code> - If volume is negative</li> </ul>"},{"location":"API/particula/next/builder_mixin/#signature_31","title":"Signature","text":"<pre><code>def set_volume(\n    self, volume: Union[float, NDArray[np.float64]], volume_units: Optional[str] = \"m^3\"\n): ...\n</code></pre>"},{"location":"API/particula/next/runnable/","title":"Runnable","text":"<p>Particula Index / Particula / Next / Runnable</p> <p>Auto-generated documentation for particula.next.runnable module.</p>"},{"location":"API/particula/next/runnable/#runnable_1","title":"Runnable","text":"<p>Show source in runnable.py:10</p> <p>Runnable process that can modify an aerosol instance.</p> <p>Parameters: None</p>"},{"location":"API/particula/next/runnable/#methods","title":"Methods","text":"<ul> <li><code>-</code> rate - Return the rate of the process.</li> <li><code>-</code> execute - Execute the process and modify the aerosol instance.</li> <li><code>-</code> or - Chain this process with another process using the | operator.</li> </ul>"},{"location":"API/particula/next/runnable/#signature","title":"Signature","text":"<pre><code>class Runnable(ABC): ...\n</code></pre>"},{"location":"API/particula/next/runnable/#runnableor","title":"Runnable().or","text":"<p>Show source in runnable.py:45</p> <p>Chain this process with another process using the | operator.</p>"},{"location":"API/particula/next/runnable/#signature_1","title":"Signature","text":"<pre><code>def __or__(self, other: \"Runnable\"): ...\n</code></pre>"},{"location":"API/particula/next/runnable/#runnableexecute","title":"Runnable().execute","text":"<p>Show source in runnable.py:28</p> <p>Execute the process and modify the aerosol instance.</p>"},{"location":"API/particula/next/runnable/#arguments","title":"Arguments","text":"<ul> <li><code>aerosol</code> Aerosol - The aerosol instance to modify.</li> <li><code>time_step</code> float - The time step for the process in seconds.</li> <li><code>sub_steps</code> int - The number of sub-steps to use for the process,     default is 1. Which means the full time step is used. A value     of 2 would mean the time step is divided into two sub-steps.</li> </ul>"},{"location":"API/particula/next/runnable/#signature_2","title":"Signature","text":"<pre><code>@abstractmethod\ndef execute(self, aerosol: Aerosol, time_step: float, sub_steps: int = 1) -&gt; Aerosol: ...\n</code></pre>"},{"location":"API/particula/next/runnable/#see-also","title":"See also","text":"<ul> <li>Aerosol</li> </ul>"},{"location":"API/particula/next/runnable/#runnablerate","title":"Runnable().rate","text":"<p>Show source in runnable.py:21</p> <p>Return the rate of the process.</p>"},{"location":"API/particula/next/runnable/#arguments_1","title":"Arguments","text":"<ul> <li>aerosol (Aerosol): The aerosol instance to modify.</li> </ul>"},{"location":"API/particula/next/runnable/#signature_3","title":"Signature","text":"<pre><code>@abstractmethod\ndef rate(self, aerosol: Aerosol) -&gt; Any: ...\n</code></pre>"},{"location":"API/particula/next/runnable/#see-also_1","title":"See also","text":"<ul> <li>Aerosol</li> </ul>"},{"location":"API/particula/next/runnable/#runnablesequence","title":"RunnableSequence","text":"<p>Show source in runnable.py:54</p> <p>A sequence of processes to be executed in order.</p>"},{"location":"API/particula/next/runnable/#attributes","title":"Attributes","text":"<ul> <li>processes (List[Runnable]): A list of RunnableProcess objects.</li> </ul>"},{"location":"API/particula/next/runnable/#methods_1","title":"Methods","text":"<ul> <li><code>-</code> add_process - Add a process to the sequence.</li> <li><code>-</code> execute - Execute the sequence of processes on an aerosol instance.</li> <li><code>-</code> or - Add a process to the sequence using the | operator.</li> </ul>"},{"location":"API/particula/next/runnable/#signature_4","title":"Signature","text":"<pre><code>class RunnableSequence:\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/runnable/#runnablesequenceor","title":"RunnableSequence().or","text":"<p>Show source in runnable.py:79</p> <p>Add a runnable to the sequence using the | operator.</p>"},{"location":"API/particula/next/runnable/#signature_5","title":"Signature","text":"<pre><code>def __or__(self, process: Runnable): ...\n</code></pre>"},{"location":"API/particula/next/runnable/#see-also_2","title":"See also","text":"<ul> <li>Runnable</li> </ul>"},{"location":"API/particula/next/runnable/#runnablesequenceadd_process","title":"RunnableSequence().add_process","text":"<p>Show source in runnable.py:68</p> <p>Add a process to the sequence.</p>"},{"location":"API/particula/next/runnable/#signature_6","title":"Signature","text":"<pre><code>def add_process(self, process: Runnable): ...\n</code></pre>"},{"location":"API/particula/next/runnable/#see-also_3","title":"See also","text":"<ul> <li>Runnable</li> </ul>"},{"location":"API/particula/next/runnable/#runnablesequenceexecute","title":"RunnableSequence().execute","text":"<p>Show source in runnable.py:72</p> <p>Execute the sequence of runnables on an aerosol instance.</p>"},{"location":"API/particula/next/runnable/#signature_7","title":"Signature","text":"<pre><code>def execute(self, aerosol: Aerosol, time_step: float) -&gt; Aerosol: ...\n</code></pre>"},{"location":"API/particula/next/runnable/#see-also_4","title":"See also","text":"<ul> <li>Aerosol</li> </ul>"},{"location":"API/particula/next/dynamics/","title":"Dynamics","text":"<p>Particula Index / Particula / Next / Dynamics</p> <p>Auto-generated documentation for particula.next.dynamics module.</p>"},{"location":"API/particula/next/dynamics/#modules","title":"Modules","text":"<ul> <li>Coagulation</li> <li>Condensation</li> <li>Dilution</li> <li>Particle Process</li> <li>Properties</li> <li>Wall Loss</li> </ul>"},{"location":"API/particula/next/dynamics/dilution/","title":"Dilution","text":"<p>Particula Index / Particula / Next / Dynamics / Dilution</p> <p>Auto-generated documentation for particula.next.dynamics.dilution module.</p>"},{"location":"API/particula/next/dynamics/dilution/#dilution_rate","title":"dilution_rate","text":"<p>Show source in dilution.py:49</p> <p>Calculate the dilution rate of a substance.</p> <p>The dilution rate quantifies the rate at which the concentration of a substance decreases due to dilution, based on the volume dilution coefficient and the current concentration of the substance.</p>"},{"location":"API/particula/next/dynamics/dilution/#arguments","title":"Arguments","text":"<ul> <li><code>coefficient</code> - The volume dilution coefficient in inverse seconds (s\u207b\u00b9).</li> <li><code>concentration</code> - The concentration of the substance in the system     in particles per cubic meter (#/m\u00b3) or any other relevant units.</li> </ul>"},{"location":"API/particula/next/dynamics/dilution/#returns","title":"Returns","text":"<p>The dilution rate, which is the rate of decrease in concentration in inverse seconds (s\u207b\u00b9). The value is returned as negative, indicating a reduction in concentration over time.</p>"},{"location":"API/particula/next/dynamics/dilution/#examples","title":"Examples","text":"float input<pre><code>dilution_rate(\n    coefficient=0.01,\n    concentration=100,\n)\n# Returns -1.0\n</code></pre> array input<pre><code>dilution_rate(\n    coefficient=0.01,\n    concentration=np.array([100, 200, 300]),\n)\n# Returns array([-1., -2., -3.])\n</code></pre>"},{"location":"API/particula/next/dynamics/dilution/#signature","title":"Signature","text":"<pre><code>def dilution_rate(\n    coefficient: Union[float, NDArray[np.float64]],\n    concentration: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/dilution/#volume_dilution_coefficient","title":"volume_dilution_coefficient","text":"<p>Show source in dilution.py:10</p> <p>Calculate the volume dilution coefficient.</p> <p>The volume dilution coefficient is a measure of how quickly a substance is diluted within a given volume due to an incoming flow. It is defined as the ratio of the flow rate to the volume.</p>"},{"location":"API/particula/next/dynamics/dilution/#arguments_1","title":"Arguments","text":"<ul> <li><code>volume</code> - The volume of the system in cubic meters (m\u00b3).</li> <li><code>input_flow_rate</code> - The flow rate of the substance entering the system     in cubic meters per second (m\u00b3/s).</li> </ul>"},{"location":"API/particula/next/dynamics/dilution/#returns_1","title":"Returns","text":"<p>The volume dilution coefficient in inverse seconds (s\u207b\u00b9).</p>"},{"location":"API/particula/next/dynamics/dilution/#examples_1","title":"Examples","text":"float input<pre><code>volume_dilution_coefficient(\n    volume=10,\n    input_flow_rate=0.1,\n)\n# Returns 0.01\n</code></pre> array input<pre><code>volume_dilution_coefficient(\n    volume=np.array([10, 20, 30]),\n    input_flow_rate=np.array([0.1, 0.2, 0.3]),\n)\n# Returns array([0.01, 0.01, 0.01])\n</code></pre>"},{"location":"API/particula/next/dynamics/dilution/#signature_1","title":"Signature","text":"<pre><code>def volume_dilution_coefficient(\n    volume: Union[float, NDArray[np.float64]],\n    input_flow_rate: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/particle_process/","title":"Particle Process","text":"<p>Particula Index / Particula / Next / Dynamics / Particle Process</p> <p>Auto-generated documentation for particula.next.dynamics.particle_process module.</p>"},{"location":"API/particula/next/dynamics/particle_process/#coagulation","title":"Coagulation","text":"<p>Show source in particle_process.py:92</p> <p>A class for running a coagulation strategy.</p>"},{"location":"API/particula/next/dynamics/particle_process/#arguments","title":"Arguments","text":"<ul> <li><code>coagulation_strategy</code> CoagulationStrategy - The coagulation strategy to     use.</li> </ul>"},{"location":"API/particula/next/dynamics/particle_process/#methods","title":"Methods","text":"<ul> <li><code>execute</code> - Execute the coagulation process.</li> <li><code>rate</code> - Calculate the rate of coagulation for each particle.</li> </ul>"},{"location":"API/particula/next/dynamics/particle_process/#signature","title":"Signature","text":"<pre><code>class Coagulation(Runnable):\n    def __init__(self, coagulation_strategy: CoagulationStrategy): ...\n</code></pre>"},{"location":"API/particula/next/dynamics/particle_process/#see-also","title":"See also","text":"<ul> <li>CoagulationStrategy</li> <li>Runnable</li> </ul>"},{"location":"API/particula/next/dynamics/particle_process/#coagulationexecute","title":"Coagulation().execute","text":"<p>Show source in particle_process.py:108</p> <p>Execute the coagulation process.</p>"},{"location":"API/particula/next/dynamics/particle_process/#arguments_1","title":"Arguments","text":"<ul> <li><code>aerosol</code> Aerosol - The aerosol instance to modify.</li> </ul>"},{"location":"API/particula/next/dynamics/particle_process/#signature_1","title":"Signature","text":"<pre><code>def execute(self, aerosol: Aerosol, time_step: float, sub_steps: int = 1) -&gt; Aerosol: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/particle_process/#see-also_1","title":"See also","text":"<ul> <li>Aerosol</li> </ul>"},{"location":"API/particula/next/dynamics/particle_process/#coagulationrate","title":"Coagulation().rate","text":"<p>Show source in particle_process.py:129</p> <p>Calculate the rate of coagulation for each particle.</p>"},{"location":"API/particula/next/dynamics/particle_process/#arguments_2","title":"Arguments","text":"<ul> <li><code>aerosol</code> Aerosol - The aerosol instance to modify.</li> </ul>"},{"location":"API/particula/next/dynamics/particle_process/#returns","title":"Returns","text":"<ul> <li><code>np.ndarray</code> - An array of coagulation rates for each particle.</li> </ul>"},{"location":"API/particula/next/dynamics/particle_process/#signature_2","title":"Signature","text":"<pre><code>def rate(self, aerosol: Aerosol) -&gt; Any: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/particle_process/#see-also_2","title":"See also","text":"<ul> <li>Aerosol</li> </ul>"},{"location":"API/particula/next/dynamics/particle_process/#masscondensation","title":"MassCondensation","text":"<p>Show source in particle_process.py:17</p> <p>A class for running a mass condensation process.</p>"},{"location":"API/particula/next/dynamics/particle_process/#arguments_3","title":"Arguments","text":"<ul> <li><code>condensation_strategy</code> CondensationStrategy - The condensation strategy     to use.</li> </ul>"},{"location":"API/particula/next/dynamics/particle_process/#methods_1","title":"Methods","text":"<ul> <li><code>execute</code> - Execute the mass condensation process.</li> <li><code>rate</code> - Calculate the rate of mass condensation for each particle due to     each condensable gas species.</li> </ul>"},{"location":"API/particula/next/dynamics/particle_process/#signature_3","title":"Signature","text":"<pre><code>class MassCondensation(Runnable):\n    def __init__(self, condensation_strategy: CondensationStrategy): ...\n</code></pre>"},{"location":"API/particula/next/dynamics/particle_process/#see-also_3","title":"See also","text":"<ul> <li>CondensationStrategy</li> <li>Runnable</li> </ul>"},{"location":"API/particula/next/dynamics/particle_process/#masscondensationexecute","title":"MassCondensation().execute","text":"<p>Show source in particle_process.py:34</p> <p>Execute the mass condensation process.</p>"},{"location":"API/particula/next/dynamics/particle_process/#arguments_4","title":"Arguments","text":"<ul> <li><code>aerosol</code> Aerosol - The aerosol instance to modify.</li> </ul>"},{"location":"API/particula/next/dynamics/particle_process/#signature_4","title":"Signature","text":"<pre><code>def execute(self, aerosol: Aerosol, time_step: float, sub_steps: int = 1) -&gt; Aerosol: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/particle_process/#see-also_4","title":"See also","text":"<ul> <li>Aerosol</li> </ul>"},{"location":"API/particula/next/dynamics/particle_process/#masscondensationrate","title":"MassCondensation().rate","text":"<p>Show source in particle_process.py:61</p> <p>Calculate the rate of mass condensation for each particle due to each condensable gas species.</p>"},{"location":"API/particula/next/dynamics/particle_process/#arguments_5","title":"Arguments","text":"<ul> <li><code>aerosol</code> Aerosol - The aerosol instance to modify.</li> </ul>"},{"location":"API/particula/next/dynamics/particle_process/#returns_1","title":"Returns","text":"<ul> <li><code>np.ndarray</code> - An array of condensation rates for each particle.</li> </ul>"},{"location":"API/particula/next/dynamics/particle_process/#signature_5","title":"Signature","text":"<pre><code>def rate(self, aerosol: Aerosol) -&gt; Any: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/particle_process/#see-also_5","title":"See also","text":"<ul> <li>Aerosol</li> </ul>"},{"location":"API/particula/next/dynamics/wall_loss/","title":"Wall Loss","text":"<p>Particula Index / Particula / Next / Dynamics / Wall Loss</p> <p>Auto-generated documentation for particula.next.dynamics.wall_loss module.</p>"},{"location":"API/particula/next/dynamics/wall_loss/#rectangle_wall_loss_rate","title":"rectangle_wall_loss_rate","text":"<p>Show source in wall_loss.py:65</p> <p>Calculate the wall loss rate of particles in a rectangular chamber.</p> <p>This function computes the rate at which particles are lost to the walls of a rectangular chamber, based on the system state. It uses the wall eddy diffusivity, particle properties (radius, density, concentration), and environmental conditions (temperature, pressure) to determine the loss rate. The chamber dimensions (length, width, height) are also taken into account.</p>"},{"location":"API/particula/next/dynamics/wall_loss/#arguments","title":"Arguments","text":"<ul> <li><code>wall_eddy_diffusivity</code> - The rate of wall eddy diffusivity in inverse     seconds (s\u207b\u00b9).</li> <li><code>particle_radius</code> - The radius of the particle in meters (m).</li> <li><code>particle_density</code> - The density of the particle in kilograms per cubic     meter (kg/m\u00b3).</li> <li><code>particle_concentration</code> - The concentration of particles in the chamber     in particles per cubic meter (#/m\u00b3).</li> <li><code>temperature</code> - The temperature of the system in Kelvin (K).</li> <li><code>pressure</code> - The pressure of the system in Pascals (Pa).</li> <li><code>chamber_dimensions</code> - A tuple containing the length, width, and height     of the rectangular chamber in meters (m).</li> </ul>"},{"location":"API/particula/next/dynamics/wall_loss/#returns","title":"Returns","text":"<p>The wall loss rate of the particles in the chamber.</p>"},{"location":"API/particula/next/dynamics/wall_loss/#signature","title":"Signature","text":"<pre><code>def rectangle_wall_loss_rate(\n    wall_eddy_diffusivity: float,\n    particle_radius: Union[float, NDArray[np.float64]],\n    particle_density: Union[float, NDArray[np.float64]],\n    particle_concentration: Union[float, NDArray[np.float64]],\n    temperature: float,\n    pressure: float,\n    chamber_dimensions: Tuple[float, float, float],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/wall_loss/#spherical_wall_loss_rate","title":"spherical_wall_loss_rate","text":"<p>Show source in wall_loss.py:16</p> <p>Calculate the wall loss rate of particles in a spherical chamber.</p> <p>This function computes the rate at which particles are lost to the walls of a spherical chamber, based on the system state. It uses the wall eddy diffusivity, particle properties (radius, density, concentration), and environmental conditions (temperature, pressure) to determine the loss rate.</p>"},{"location":"API/particula/next/dynamics/wall_loss/#arguments_1","title":"Arguments","text":"<ul> <li><code>wall_eddy_diffusivity</code> - The rate of wall eddy diffusivity in inverse     seconds (s\u207b\u00b9).</li> <li><code>particle_radius</code> - The radius of the particle in meters (m).</li> <li><code>particle_density</code> - The density of the particle in kilograms per cubic     meter (kg/m\u00b3).</li> <li><code>particle_concentration</code> - The concentration of particles in the chamber     in particles per cubic meter (#/m\u00b3).</li> <li><code>temperature</code> - The temperature of the system in Kelvin (K).</li> <li><code>pressure</code> - The pressure of the system in Pascals (Pa).</li> <li><code>chamber_radius</code> - The radius of the spherical chamber in meters (m).</li> </ul>"},{"location":"API/particula/next/dynamics/wall_loss/#returns_1","title":"Returns","text":"<p>The wall loss rate of the particles in the chamber.</p>"},{"location":"API/particula/next/dynamics/wall_loss/#signature_1","title":"Signature","text":"<pre><code>def spherical_wall_loss_rate(\n    wall_eddy_diffusivity: float,\n    particle_radius: Union[float, NDArray[np.float64]],\n    particle_density: Union[float, NDArray[np.float64]],\n    particle_concentration: Union[float, NDArray[np.float64]],\n    temperature: float,\n    pressure: float,\n    chamber_radius: float,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/","title":"Coagulation","text":"<p>Particula Index / Particula / Next / Dynamics / Coagulation</p> <p>Auto-generated documentation for particula.next.dynamics.coagulation module.</p>"},{"location":"API/particula/next/dynamics/coagulation/#modules","title":"Modules","text":"<ul> <li>Brownian Kernel</li> <li>Kernel</li> <li>Particle Resolved Method</li> <li>Rate</li> <li>Strategy</li> <li>Super Droplet Method</li> <li>Transition Regime</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/brownian_kernel/","title":"Brownian Kernel","text":"<p>Particula Index / Particula / Next / Dynamics / Coagulation / Brownian Kernel</p> <p>Auto-generated documentation for particula.next.dynamics.coagulation.brownian_kernel module.</p>"},{"location":"API/particula/next/dynamics/coagulation/brownian_kernel/#brownian_coagulation_kernel","title":"brownian_coagulation_kernel","text":"<p>Show source in brownian_kernel.py:109</p> <p>Returns the Brownian coagulation kernel for aerosol particles. Defined as the product of the diffusivity of the particles, the collection term <code>g</code>, and the radius of the particles.</p>"},{"location":"API/particula/next/dynamics/coagulation/brownian_kernel/#args","title":"Args","text":"<p>radius_particle : The radius of the particles [m]. diffusivity_particle : The diffusivity of the particles [m^2/s]. g_collection_term_particle : The collection term for Brownian coagulation [dimensionless]. alpha_collision_efficiency : The collision efficiency of the particles [dimensionless].</p>"},{"location":"API/particula/next/dynamics/coagulation/brownian_kernel/#returns","title":"Returns","text":"<p>Square matrix of Brownian coagulation kernel for aerosol particles [m^3/s].</p>"},{"location":"API/particula/next/dynamics/coagulation/brownian_kernel/#references","title":"References","text":"<p>Seinfeld, J. H., &amp; Pandis, S. N. (2016). Atmospheric chemistry and physics, Section 13 TABLE 13.1 Fuchs Form of the Brownian Coagulation Coefficient K12 (with alpha collision efficiency term 13.56)</p>"},{"location":"API/particula/next/dynamics/coagulation/brownian_kernel/#signature","title":"Signature","text":"<pre><code>def brownian_coagulation_kernel(\n    radius_particle: Union[float, NDArray[np.float64]],\n    diffusivity_particle: Union[float, NDArray[np.float64]],\n    g_collection_term_particle: Union[float, NDArray[np.float64]],\n    mean_thermal_speed_particle: Union[float, NDArray[np.float64]],\n    alpha_collision_efficiency: Union[float, NDArray[np.float64]] = 1.0,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/brownian_kernel/#brownian_coagulation_kernel_via_system_state","title":"brownian_coagulation_kernel_via_system_state","text":"<p>Show source in brownian_kernel.py:178</p> <p>Returns the Brownian coagulation kernel for aerosol particles, calculating the intermediate properties needed.</p>"},{"location":"API/particula/next/dynamics/coagulation/brownian_kernel/#arguments","title":"Arguments","text":"<p>radius_particle : The radius of the particles [m]. mass_particle : The mass of the particles [kg]. temperature : The temperature of the air [K]. pressure : The pressure of the air [Pa]. alpha_collision_efficiency : The collision efficiency of the particles     [dimensionless].</p>"},{"location":"API/particula/next/dynamics/coagulation/brownian_kernel/#returns_1","title":"Returns","text":"<p>Square matrix of Brownian coagulation kernel for aerosol particles     [m^3/s].</p>"},{"location":"API/particula/next/dynamics/coagulation/brownian_kernel/#references_1","title":"References","text":"<p>Seinfeld, J. H., &amp; Pandis, S. N. (2016). Atmospheric chemistry and physics, Section 13 TABLE 13.1 Fuchs Form of the Brownian Coagulation Coefficient K12.</p>"},{"location":"API/particula/next/dynamics/coagulation/brownian_kernel/#signature_1","title":"Signature","text":"<pre><code>def brownian_coagulation_kernel_via_system_state(\n    radius_particle: Union[float, NDArray[np.float64]],\n    mass_particle: Union[float, NDArray[np.float64]],\n    temperature: float,\n    pressure: float,\n    alpha_collision_efficiency: Union[float, NDArray[np.float64]] = 1.0,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/brownian_kernel/#brownian_diffusivity","title":"brownian_diffusivity","text":"<p>Show source in brownian_kernel.py:83</p> <p>Returns the diffusivity of the particles due to Brownian motion</p> <p>THis is just the scaled aerodynamic mobility of the particles.</p>"},{"location":"API/particula/next/dynamics/coagulation/brownian_kernel/#args_1","title":"Args","text":"<ul> <li>temperature : The temperature of the air [K].</li> <li>aerodynamic_mobility : The aerodynamic mobility of the particles [m^2/s].</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/brownian_kernel/#returns_2","title":"Returns","text":"<p>The diffusivity of the particles due to Brownian motion [m^2/s].</p>"},{"location":"API/particula/next/dynamics/coagulation/brownian_kernel/#references_2","title":"References","text":"<p>Seinfeld, J. H., &amp; Pandis, S. N. (2016). Atmospheric chemistry and physics, Section 13 TABLE 13.1 Fuchs Form of the Brownian Coagulation Coefficient K12</p>"},{"location":"API/particula/next/dynamics/coagulation/brownian_kernel/#signature_2","title":"Signature","text":"<pre><code>def brownian_diffusivity(\n    temperature: Union[float, NDArray[np.float64]],\n    aerodynamic_mobility: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/brownian_kernel/#g_collection_term","title":"g_collection_term","text":"<p>Show source in brownian_kernel.py:49</p> <p>Returns the <code>g</code> collection term for Brownian coagulation.</p> <p>Defined as the ratio of the mean free path of the particles to the radius of the particles.</p>"},{"location":"API/particula/next/dynamics/coagulation/brownian_kernel/#args_2","title":"Args","text":"<p>mean_free_path_particle : The mean free path of the particles [m]. radius_particle : The radius of the particles [m].</p>"},{"location":"API/particula/next/dynamics/coagulation/brownian_kernel/#returns_3","title":"Returns","text":"<p>The collection term for Brownian coagulation [dimensionless].</p>"},{"location":"API/particula/next/dynamics/coagulation/brownian_kernel/#references_3","title":"References","text":"<p>Seinfeld, J. H., &amp; Pandis, S. N. (2016). Atmospheric chemistry and physics, Section 13 TABLE 13.1 Fuchs Form of the Brownian Coagulation Coefficient K12</p> <p>The np.sqrt(2) term appears to be an error in the text, as the term is not used in the second edition of the book. And when it it is used, the values are too small, by about 2x.</p>"},{"location":"API/particula/next/dynamics/coagulation/brownian_kernel/#signature_3","title":"Signature","text":"<pre><code>def g_collection_term(\n    mean_free_path_particle: Union[float, NDArray[np.float64]],\n    radius_particle: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/brownian_kernel/#mean_free_path_l","title":"mean_free_path_l","text":"<p>Show source in brownian_kernel.py:18</p> <p>Calculate the mean free path of particles for coagulation.</p> <p>Calculate the mean free path of particles, defined for Brownian coagulation as the ratio of the diffusivity of the particles to their mean thermal speed. This parameter is crucial for understanding particle dynamics in a fluid.</p>"},{"location":"API/particula/next/dynamics/coagulation/brownian_kernel/#arguments_1","title":"Arguments","text":"<ul> <li>diffusivity_particle : The diffusivity of the particles [m^2/s].</li> <li>mean_thermal_speed_particle : The mean thermal speed of the particles [m/s].</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/brownian_kernel/#returns_4","title":"Returns","text":"<p>The mean free path of the particles [m].</p>"},{"location":"API/particula/next/dynamics/coagulation/brownian_kernel/#references_4","title":"References","text":"<p>Seinfeld, J. H., &amp; Pandis, S. N. (2016). Atmospheric chemistry and physics, Section 13 TABLE 13.1 Fuchs Form of the Brownian Coagulation Coefficient K12.</p>"},{"location":"API/particula/next/dynamics/coagulation/brownian_kernel/#signature_4","title":"Signature","text":"<pre><code>def mean_free_path_l(\n    diffusivity_particle: Union[float, NDArray[np.float64]],\n    mean_thermal_speed_particle: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/kernel/","title":"Kernel","text":"<p>Particula Index / Particula / Next / Dynamics / Coagulation / Kernel</p> <p>Auto-generated documentation for particula.next.dynamics.coagulation.kernel module.</p>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#coulombdyachkov2007","title":"CoulombDyachkov2007","text":"<p>Show source in kernel.py:130</p> <p>Dyachkov et al. (2007) approximation for the dimensionless coagulation kernel. Accounts for the Coulomb potential between particles.</p>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#references","title":"References","text":"<ul> <li>Dyachkov, S. A., Kustova, E. V., &amp; Kustov, A. V. (2007). Coagulation of particles in the transition regime: The effect of the Coulomb potential. Journal of Chemical Physics, 126(12). https://doi.org/10.1063/1.2713719</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#signature","title":"Signature","text":"<pre><code>class CoulombDyachkov2007(KernelStrategy): ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#see-also","title":"See also","text":"<ul> <li>KernelStrategy</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#coulombdyachkov2007dimensionless","title":"CoulombDyachkov2007().dimensionless","text":"<p>Show source in kernel.py:143</p>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#signature_1","title":"Signature","text":"<pre><code>def dimensionless(\n    self,\n    diffusive_knudsen: NDArray[np.float64],\n    coulomb_potential_ratio: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#coulombgatti2008","title":"CoulombGatti2008","text":"<p>Show source in kernel.py:153</p> <p>Gatti and Kortshagen (2008) approximation for the dimensionless coagulation kernel. Accounts for the Coulomb potential between particles.</p>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#references_1","title":"References","text":"<ul> <li>Gatti, M., &amp; Kortshagen, U. (2008). Analytical model of particle charging in plasmas over a wide range of collisionality. Physical Review E - Statistical, Nonlinear, and Soft Matter Physics, 78(4). https://doi.org/10.1103/PhysRevE.78.046402</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#signature_2","title":"Signature","text":"<pre><code>class CoulombGatti2008(KernelStrategy): ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#see-also_1","title":"See also","text":"<ul> <li>KernelStrategy</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#coulombgatti2008dimensionless","title":"CoulombGatti2008().dimensionless","text":"<p>Show source in kernel.py:166</p>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#signature_3","title":"Signature","text":"<pre><code>def dimensionless(\n    self,\n    diffusive_knudsen: NDArray[np.float64],\n    coulomb_potential_ratio: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#coulombgopalakrishnan2012","title":"CoulombGopalakrishnan2012","text":"<p>Show source in kernel.py:176</p> <p>Gopalakrishnan and Hogan (2012) approximation for the dimensionless coagulation kernel. Accounts for the Coulomb potential between particles.</p>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#references_2","title":"References","text":"<ul> <li>Gopalakrishnan, R., &amp; Hogan, C. J. (2012). Coulomb-influenced collisions in aerosols and dusty plasmas. Physical Review E - Statistical, Nonlinear, and Soft Matter Physics, 85(2). https://doi.org/10.1103/PhysRevE.85.026410</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#signature_4","title":"Signature","text":"<pre><code>class CoulombGopalakrishnan2012(KernelStrategy): ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#see-also_2","title":"See also","text":"<ul> <li>KernelStrategy</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#coulombgopalakrishnan2012dimensionless","title":"CoulombGopalakrishnan2012().dimensionless","text":"<p>Show source in kernel.py:189</p>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#signature_5","title":"Signature","text":"<pre><code>def dimensionless(\n    self,\n    diffusive_knudsen: NDArray[np.float64],\n    coulomb_potential_ratio: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#coulumbchahl2019","title":"CoulumbChahl2019","text":"<p>Show source in kernel.py:199</p> <p>Chahl and Gopalakrishnan (2019) approximation for the dimensionless coagulation kernel. Accounts for the Coulomb potential between particles.</p>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#references_3","title":"References","text":"<ul> <li>Chahl, H. S., &amp; Gopalakrishnan, R. (2019). High potential, near free molecular regime Coulombic collisions in aerosols and dusty plasmas. Aerosol Science and Technology, 53(8), 933-957. https://doi.org/10.1080/02786826.2019.1614522</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#signature_6","title":"Signature","text":"<pre><code>class CoulumbChahl2019(KernelStrategy): ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#see-also_3","title":"See also","text":"<ul> <li>KernelStrategy</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#coulumbchahl2019dimensionless","title":"CoulumbChahl2019().dimensionless","text":"<p>Show source in kernel.py:212</p>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#signature_7","title":"Signature","text":"<pre><code>def dimensionless(\n    self,\n    diffusive_knudsen: NDArray[np.float64],\n    coulomb_potential_ratio: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#hardsphere","title":"HardSphere","text":"<p>Show source in kernel.py:117</p> <p>Hard sphere dimensionless coagulation strategy.</p>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#signature_8","title":"Signature","text":"<pre><code>class HardSphere(KernelStrategy): ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#see-also_4","title":"See also","text":"<ul> <li>KernelStrategy</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#hardspheredimensionless","title":"HardSphere().dimensionless","text":"<p>Show source in kernel.py:122</p>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#signature_9","title":"Signature","text":"<pre><code>def dimensionless(\n    self, diffusive_knudsen: NDArray[np.float64], coulomb_potential_ratio: ignore\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#kernelstrategy","title":"KernelStrategy","text":"<p>Show source in kernel.py:12</p> <p>Abstract class for dimensionless coagulation strategies. This class defines the dimensionless kernel (H) method that must be implemented by any dimensionless coagulation strategy.</p>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#methods","title":"Methods","text":"<ul> <li>dimensionless (abstractmethod): Calculate the dimensionless coagulation kernel.</li> <li><code>-</code> kernel - Calculate the dimensioned coagulation kernel.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#signature_10","title":"Signature","text":"<pre><code>class KernelStrategy(ABC): ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#kernelstrategydimensionless","title":"KernelStrategy().dimensionless","text":"<p>Show source in kernel.py:25</p> <p>Return the dimensionless coagulation kernel (H)</p>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#arguments","title":"Arguments","text":"<ul> <li><code>-</code> diffusive_knudsen - The diffusive Knudsen number (K_nD) [dimensionless].</li> <li><code>-</code> coulomb_potential_ratio - The Coulomb potential ratio (phi_E) [dimensionless].</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#returns","title":"Returns","text":"<p>The dimensionless coagulation kernel (H) [dimensionless].</p>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#references_4","title":"References","text":"<ul> <li>Dyachkov, S. A., Kustova, E. V., &amp; Kustov, A. V. (2007). Coagulation of particles in the transition regime: The effect of the Coulomb potential. Journal of Chemical Physics, 126(12). https://doi.org/10.1063/1.2713719</li> <li>Gatti, M., &amp; Kortshagen, U. (2008). Analytical model of particle charging in plasmas over a wide range of collisionality. Physical Review E - Statistical, Nonlinear, and Soft Matter Physics, 78(4). https://doi.org/10.1103/PhysRevE.78.046402</li> <li>Gopalakrishnan, R., &amp; Hogan, C. J. (2011). Determination of the transition regime collision kernel from mean first passage times. Aerosol Science and Technology, 45(12), 1499-1509. https://doi.org/10.1080/02786826.2011.601775</li> <li>Gopalakrishnan, R., &amp; Hogan, C. J. (2012). Coulomb-influenced collisions in aerosols and dusty plasmas. Physical Review E - Statistical, Nonlinear, and Soft Matter Physics, 85(2). https://doi.org/10.1103/PhysRevE.85.026410</li> <li>Chahl, H. S., &amp; Gopalakrishnan, R. (2019). High potential, near free molecular regime Coulombic collisions in aerosols and dusty plasmas. Aerosol Science and Technology, 53(8), 933-957. https://doi.org/10.1080/02786826.2019.1614522</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#signature_11","title":"Signature","text":"<pre><code>@abstractmethod\ndef dimensionless(\n    self,\n    diffusive_knudsen: NDArray[np.float64],\n    coulomb_potential_ratio: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#kernelstrategykernel","title":"KernelStrategy().kernel","text":"<p>Show source in kernel.py:68</p> <p>The dimensioned coagulation kernel for each particle pair, calculated from the dimensionless coagulation kernel and the reduced quantities. All inputs are square matrices, for all particle-particle interactions.</p>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#arguments_1","title":"Arguments","text":"<ul> <li><code>-</code> dimensionless_kernel - The dimensionless coagulation kernel [dimensionless].</li> <li><code>-</code> coulomb_potential_ratio - The Coulomb potential ratio [dimensionless].</li> <li><code>-</code> sum_of_radii - The sum of the radii of the particles [m].</li> <li><code>-</code> reduced_mass - The reduced mass of the particles [kg].</li> <li><code>-</code> reduced_friction_factor - The reduced friction factor of the particles [dimensionless].</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#returns_1","title":"Returns","text":"<p>The dimensioned coagulation kernel, as a square matrix, of all particle-particle interactions [m^3/s].</p> <p>Check, were the /s comes from.</p>"},{"location":"API/particula/next/dynamics/coagulation/kernel/#references_5","title":"References","text":""},{"location":"API/particula/next/dynamics/coagulation/kernel/#signature_12","title":"Signature","text":"<pre><code>def kernel(\n    self,\n    dimensionless_kernel: NDArray[np.float64],\n    coulomb_potential_ratio: NDArray[np.float64],\n    sum_of_radii: NDArray[np.float64],\n    reduced_mass: NDArray[np.float64],\n    reduced_friction_factor: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/particle_resolved_method/","title":"Particle Resolved Method","text":"<p>Particula Index / Particula / Next / Dynamics / Coagulation / Particle Resolved Method</p> <p>Auto-generated documentation for particula.next.dynamics.coagulation.particle_resolved_method module.</p>"},{"location":"API/particula/next/dynamics/coagulation/particle_resolved_method/#calculate_probabilities","title":"calculate_probabilities","text":"<p>Show source in particle_resolved_method.py:33</p> <p>Calculate coagulation probabilities based on kernel values and system parameters.</p>"},{"location":"API/particula/next/dynamics/coagulation/particle_resolved_method/#arguments","title":"Arguments","text":"<ul> <li><code>kernel_values</code> float - Interpolated kernel value for a particle pair.</li> <li><code>time_step</code> float - The time step over which coagulation occurs.</li> <li><code>events</code> int - Number of possible coagulation events.</li> <li><code>tests</code> int - Number of tests (or trials) for coagulation.</li> <li><code>volume</code> float - Volume of the system.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/particle_resolved_method/#returns","title":"Returns","text":"<ul> <li><code>float</code> - Coagulation probability.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/particle_resolved_method/#signature","title":"Signature","text":"<pre><code>def calculate_probabilities(\n    kernel_values: Union[float, NDArray[np.float64]],\n    time_step: float,\n    events: int,\n    tests: int,\n    volume: float,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/particle_resolved_method/#interpolate_kernel","title":"interpolate_kernel","text":"<p>Show source in particle_resolved_method.py:15</p> <p>Create a 2D interpolation function for the coagulation kernel.</p>"},{"location":"API/particula/next/dynamics/coagulation/particle_resolved_method/#arguments_1","title":"Arguments","text":"<ul> <li><code>kernel</code> NDArray[np.float64] - Coagulation kernel.</li> <li><code>kernel_radius</code> NDArray[np.float64] - Radii corresponding to kernel     bins.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/particle_resolved_method/#returns_1","title":"Returns","text":"<ul> <li><code>RectBivariateSpline</code> - Interpolated kernel function.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/particle_resolved_method/#signature_1","title":"Signature","text":"<pre><code>def interpolate_kernel(\n    kernel: NDArray[np.float64], kernel_radius: NDArray[np.float64]\n) -&gt; RectBivariateSpline: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/particle_resolved_method/#particle_resolved_coagulation_step","title":"particle_resolved_coagulation_step","text":"<p>Show source in particle_resolved_method.py:140</p> <p>Perform a single step of particle coagulation, updating particle radii based on coagulation events.</p>"},{"location":"API/particula/next/dynamics/coagulation/particle_resolved_method/#arguments_2","title":"Arguments","text":"<ul> <li><code>particle_radius</code> NDArray[np.float64] - Array of particle radii.</li> <li><code>kernel</code> NDArray[np.float64] - Coagulation kernel as a 2D array where     each element represents the probability of coagulation between     particles of corresponding sizes.</li> <li><code>kernel_radius</code> NDArray[np.float64] - Array of radii corresponding to     the kernel bins.</li> <li><code>volume</code> float - Volume of the system in which coagulation occurs.</li> <li><code>time_step</code> float - Time step over which coagulation is calculated.</li> <li><code>random_generator</code> np.random.Generator - Random number generator for     stochastic processes.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/particle_resolved_method/#returns_2","title":"Returns","text":"<ul> <li><code>NDArray[np.int64]</code> - Array of indices corresponding to the coagulation     events, where each element is a pair of indices corresponding to     the coagulating particles [loss, gain].</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/particle_resolved_method/#signature_2","title":"Signature","text":"<pre><code>def particle_resolved_coagulation_step(\n    particle_radius: NDArray[np.float64],\n    kernel: NDArray[np.float64],\n    kernel_radius: NDArray[np.float64],\n    volume: float,\n    time_step: float,\n    random_generator: np.random.Generator,\n) -&gt; NDArray[np.int64]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/particle_resolved_method/#particle_resolved_update_step","title":"particle_resolved_update_step","text":"<p>Show source in particle_resolved_method.py:94</p> <p>Update the particle radii and concentrations after coagulation events.</p>"},{"location":"API/particula/next/dynamics/coagulation/particle_resolved_method/#arguments_3","title":"Arguments","text":"<ul> <li><code>particle_radius</code> NDArray[float64] - Array of particle radii.</li> <li><code>small_index</code> NDArray[int64] - Indices corresponding to smaller     particles.</li> <li><code>large_index</code> NDArray[int64] - Indices corresponding to larger     particles.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/particle_resolved_method/#returns_3","title":"Returns","text":"<ul> <li>Updated array of particle radii.</li> <li>Updated array for the radii of particles that were lost.</li> <li>Updated array for the radii of particles that were gained.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/particle_resolved_method/#signature_3","title":"Signature","text":"<pre><code>def particle_resolved_update_step(\n    particle_radius: NDArray[np.float64],\n    loss: NDArray[np.float64],\n    gain: NDArray[np.float64],\n    small_index: NDArray[np.int64],\n    large_index: NDArray[np.int64],\n) -&gt; Tuple[NDArray[np.float64], NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/particle_resolved_method/#resolve_final_coagulation_state","title":"resolve_final_coagulation_state","text":"<p>Show source in particle_resolved_method.py:57</p> <p>Resolve the final state of particles that have undergone multiple coagulation events.</p>"},{"location":"API/particula/next/dynamics/coagulation/particle_resolved_method/#arguments_4","title":"Arguments","text":"<ul> <li><code>small_indices</code> NDArray[np.int64] - Indices of smaller particles.</li> <li><code>large_indices</code> NDArray[np.int64] - Indices of larger particles.</li> <li><code>particle_radius</code> NDArray[np.float64] - Radii of particles.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/particle_resolved_method/#returns_4","title":"Returns","text":"<ul> <li><code>Tuple[NDArray[np.int64],</code> NDArray[np.int64]] - Updated small and large indices.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/particle_resolved_method/#signature_4","title":"Signature","text":"<pre><code>def resolve_final_coagulation_state(\n    small_indices: NDArray[np.int64],\n    large_indices: NDArray[np.int64],\n    particle_radius: NDArray[np.float64],\n) -&gt; Tuple[NDArray[np.int64], NDArray[np.int64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/rate/","title":"Rate","text":"<p>Particula Index / Particula / Next / Dynamics / Coagulation / Rate</p> <p>Auto-generated documentation for particula.next.dynamics.coagulation.rate module.</p>"},{"location":"API/particula/next/dynamics/coagulation/rate/#continuous_gain","title":"continuous_gain","text":"<p>Show source in rate.py:120</p> <p>Calculate the coagulation gain rate, via the integration method.</p>"},{"location":"API/particula/next/dynamics/coagulation/rate/#arguments","title":"Arguments","text":"<p>radius : The radius of the particles. concentration : The distribution of particles. kernel : The coagulation kernel.</p>"},{"location":"API/particula/next/dynamics/coagulation/rate/#returns","title":"Returns","text":"<p>The coagulation gain rate.</p>"},{"location":"API/particula/next/dynamics/coagulation/rate/#references","title":"References","text":"<ul> <li>This equation necessitates the use of a for-loop due to the convoluted use of different radii at different stages. This is the most expensive step of all coagulation calculations. Using <code>RectBivariateSpline</code> accelerates this significantly.</li> <li>Note, to estimate the kernel and distribution at (other_radius**3 - some_radius**3)*(\u2153) we use interporlation techniques.</li> <li>Seinfeld, J. H., &amp; Pandis, S. (2016). Atmospheric chemistry and physics, Chapter 13 Equations 13.61</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/rate/#signature","title":"Signature","text":"<pre><code>def continuous_gain(\n    radius: Union[float, NDArray[np.float64]],\n    concentration: Union[float, NDArray[np.float64]],\n    kernel: NDArray[np.float64],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/rate/#continuous_loss","title":"continuous_loss","text":"<p>Show source in rate.py:96</p> <p>Calculate the coagulation loss rate, via the integration method.</p>"},{"location":"API/particula/next/dynamics/coagulation/rate/#arguments_1","title":"Arguments","text":"<p>radius : The radius of the particles. concentration : The distribution of particles. kernel : The coagulation kernel.</p>"},{"location":"API/particula/next/dynamics/coagulation/rate/#returns_1","title":"Returns","text":"<p>The coagulation loss rate.</p>"},{"location":"API/particula/next/dynamics/coagulation/rate/#references_1","title":"References","text":"<ul> <li>Seinfeld, J. H., &amp; Pandis, S. N. (2016). Atmospheric chemistry and     physics, Chapter 13 Equations 13.61</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/rate/#signature_1","title":"Signature","text":"<pre><code>def continuous_loss(\n    radius: Union[float, NDArray[np.float64]],\n    concentration: Union[float, NDArray[np.float64]],\n    kernel: NDArray[np.float64],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/rate/#discrete_gain","title":"discrete_gain","text":"<p>Show source in rate.py:40</p> <p>Calculate the coagulation gain rate, via the integration method, by converting to a continuous distribution.</p>"},{"location":"API/particula/next/dynamics/coagulation/rate/#arguments_2","title":"Arguments","text":"<p>radius : The radius of the particles. concentration : The distribution of particles. kernel : The coagulation kernel.</p>"},{"location":"API/particula/next/dynamics/coagulation/rate/#returns_2","title":"Returns","text":"<p>The coagulation gain rate.</p>"},{"location":"API/particula/next/dynamics/coagulation/rate/#references_2","title":"References","text":"<ul> <li>This equation necessitates the use of a for-loop due to the convoluted use of different radii at different stages. This is the most expensive step of all coagulation calculations. Using <code>RectBivariateSpline</code> accelerates this significantly.</li> <li>Note, to estimate the kernel and distribution at (other_radius**3 - some_radius**3)*(\u2153) we use interporlation techniques.</li> <li>Seinfeld, J. H., &amp; Pandis, S. (2016). Atmospheric chemistry and physics, Chapter 13 Equations 13.61</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/rate/#signature_2","title":"Signature","text":"<pre><code>def discrete_gain(\n    radius: Union[float, NDArray[np.float64]],\n    concentration: Union[float, NDArray[np.float64]],\n    kernel: NDArray[np.float64],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/rate/#discrete_loss","title":"discrete_loss","text":"<p>Show source in rate.py:19</p> <p>Calculate the coagulation loss rate, via the summation method.</p>"},{"location":"API/particula/next/dynamics/coagulation/rate/#arguments_3","title":"Arguments","text":"<p>concentraiton : The distribution of particles. kernel : The coagulation kernel.</p>"},{"location":"API/particula/next/dynamics/coagulation/rate/#returns_3","title":"Returns","text":"<p>The coagulation loss rate.</p>"},{"location":"API/particula/next/dynamics/coagulation/rate/#references_3","title":"References","text":"<p>Seinfeld, J. H., &amp; Pandis, S. N. (2016). Atmospheric chemistry and physics, Chapter 13 Equations 13.61</p>"},{"location":"API/particula/next/dynamics/coagulation/rate/#signature_3","title":"Signature","text":"<pre><code>def discrete_loss(\n    concentration: Union[float, NDArray[np.float64]], kernel: NDArray[np.float64]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/","title":"Strategy","text":"<p>Particula Index / Particula / Next / Dynamics / Coagulation / Strategy</p> <p>Auto-generated documentation for particula.next.dynamics.coagulation.strategy module.</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#coagulationstrategy","title":"CoagulationStrategy","text":"<p>Show source in strategy.py:26</p> <p>Abstract class for defining a coagulation strategy. This class defines the methods that must be implemented by any coagulation strategy.</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#methods","title":"Methods","text":"<ul> <li><code>kernel</code> - Calculate the coagulation kernel.</li> <li><code>loss_rate</code> - Calculate the coagulation loss rate.</li> <li><code>gain_rate</code> - Calculate the coagulation gain rate.</li> <li><code>net_rate</code> - Calculate the net coagulation rate.</li> <li><code>diffusive_knudsen</code> - Calculate the diffusive Knudsen number.</li> <li><code>coulomb_potential_ratio</code> - Calculate the Coulomb potential ratio.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature","title":"Signature","text":"<pre><code>class CoagulationStrategy(ABC): ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#coagulationstrategycoulomb_potential_ratio","title":"CoagulationStrategy().coulomb_potential_ratio","text":"<p>Show source in strategy.py:205</p> <p>Calculate the Coulomb potential ratio based on the particle properties and temperature.</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#arguments","title":"Arguments","text":"<ul> <li><code>particle</code> - The particles for which the Coulomb     potential ratio is to be calculated.</li> <li><code>temperature</code> - The temperature of the gas phase [K].</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#returns","title":"Returns","text":"<p>The Coulomb potential ratio for the particle     [dimensionless].</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_1","title":"Signature","text":"<pre><code>def coulomb_potential_ratio(\n    self, particle: ParticleRepresentation, temperature: float\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#coagulationstrategydiffusive_knudsen","title":"CoagulationStrategy().diffusive_knudsen","text":"<p>Show source in strategy.py:169</p> <p>Calculate the diffusive Knudsen number based on the particle properties, temperature, and pressure.</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#arguments_1","title":"Arguments","text":"<ul> <li><code>particle</code> - The particle for which the diffusive     Knudsen number is to be calculated.</li> <li><code>temperature</code> - The temperature of the gas phase [K].</li> <li><code>pressure</code> - The pressure of the gas phase [Pa].</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#returns_1","title":"Returns","text":"<ul> <li><code>NDArray[np.float64]</code> - The diffusive Knudsen number for the particle     [dimensionless].</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_2","title":"Signature","text":"<pre><code>def diffusive_knudsen(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_1","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#coagulationstrategydimensionless_kernel","title":"CoagulationStrategy().dimensionless_kernel","text":"<p>Show source in strategy.py:40</p> <p>Calculate the dimensionless coagulation kernel based on the particle properties interactions, diffusive Knudsen number and Coulomb potential</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#arguments_2","title":"Arguments","text":"<ul> <li>CoagulationStrategy().diffusive_knudsen - The diffusive Knudsen number     for the particle [dimensionless].</li> <li>CoagulationStrategy().coulomb_potential_ratio - The Coulomb potential     ratio for the particle [dimensionless].</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#returns_2","title":"Returns","text":"<p>The dimensionless coagulation kernel for the particle     [dimensionless].</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_3","title":"Signature","text":"<pre><code>@abstractmethod\ndef dimensionless_kernel(\n    self,\n    diffusive_knudsen: NDArray[np.float64],\n    coulomb_potential_ratio: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#coagulationstrategyfriction_factor","title":"CoagulationStrategy().friction_factor","text":"<p>Show source in strategy.py:227</p> <p>Calculate the friction factor based on the particle properties, temperature, and pressure.</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#arguments_3","title":"Arguments","text":"<ul> <li><code>particle</code> - The particle for which the friction factor     is to be calculated.</li> <li><code>temperature</code> - The temperature of the gas phase [K].</li> <li><code>pressure</code> - The pressure of the gas phase [Pa].</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#returns_3","title":"Returns","text":"<p>The friction factor for the particle [dimensionless].</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_4","title":"Signature","text":"<pre><code>def friction_factor(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_2","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#coagulationstrategygain_rate","title":"CoagulationStrategy().gain_rate","text":"<p>Show source in strategy.py:102</p> <p>Calculate the coagulation gain rate based on the particle radius, distribution, and the coagulation kernel.</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#arguments_4","title":"Arguments","text":"<ul> <li><code>particle</code> - The particle for which the coagulation     gain rate is to be calculated.</li> <li>CoagulationStrategy().kernel - The coagulation kernel.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#returns_4","title":"Returns","text":"<p>The coagulation gain rate for the particle [kg/s].</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#notes","title":"Notes","text":"<p>May be abstracted to a separate module when different coagulation     strategies are implemented (super droplet).</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_5","title":"Signature","text":"<pre><code>@abstractmethod\ndef gain_rate(\n    self, particle: ParticleRepresentation, kernel: NDArray[np.float64]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_3","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#coagulationstrategykernel","title":"CoagulationStrategy().kernel","text":"<p>Show source in strategy.py:62</p> <p>Calculate the coagulation kernel based on the particle properties, temperature, and pressure.</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#arguments_5","title":"Arguments","text":"<ul> <li><code>particle</code> - The particle for which the coagulation     kernel is to be calculated.</li> <li><code>temperature</code> - The temperature of the gas phase [K].</li> <li><code>pressure</code> - The pressure of the gas phase [Pa].</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#returns_5","title":"Returns","text":"<p>The coagulation kernel for the particle [m^3/s].</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_6","title":"Signature","text":"<pre><code>@abstractmethod\ndef kernel(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_4","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#coagulationstrategyloss_rate","title":"CoagulationStrategy().loss_rate","text":"<p>Show source in strategy.py:83</p> <p>Calculate the coagulation loss rate based on the particle radius, distribution, and the coagulation kernel.</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#arguments_6","title":"Arguments","text":"<ul> <li><code>particle</code> - The particle for which the coagulation     loss rate is to be calculated.</li> <li>CoagulationStrategy().kernel - The coagulation kernel.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#returns_6","title":"Returns","text":"<p>The coagulation loss rate for the particle [kg/s].</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_7","title":"Signature","text":"<pre><code>@abstractmethod\ndef loss_rate(\n    self, particle: ParticleRepresentation, kernel: NDArray[np.float64]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_5","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#coagulationstrategynet_rate","title":"CoagulationStrategy().net_rate","text":"<p>Show source in strategy.py:125</p> <p>Calculate the net coagulation rate based on the particle radius, distribution, and the coagulation kernel.</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#arguments_7","title":"Arguments","text":"<ul> <li><code>particle</code> - The particle class for which the     coagulation net rate is to be calculated.</li> <li><code>temperature</code> - The temperature of the gas phase [K].</li> <li><code>pressure</code> - The pressure of the gas phase [Pa].</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#returns_7","title":"Returns","text":"<ul> <li><code>Union[float,</code> NDArray[np.float64]] - The net coagulation rate for the     particle [kg/s].</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_8","title":"Signature","text":"<pre><code>@abstractmethod\ndef net_rate(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_6","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#coagulationstrategystep","title":"CoagulationStrategy().step","text":"<p>Show source in strategy.py:147</p> <p>Perform a single step of the coagulation process.</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#arguments_8","title":"Arguments","text":"<ul> <li><code>particle</code> - The particle for which the coagulation step     is to be performed.</li> <li><code>temperature</code> - The temperature of the gas phase [K].</li> <li><code>pressure</code> - The pressure of the gas phase [Pa].</li> <li><code>time_step</code> - The time step for the coagulation process [s].</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#returns_8","title":"Returns","text":"<ul> <li><code>ParticleRepresentation</code> - The particle after the coagulation step.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_9","title":"Signature","text":"<pre><code>@abstractmethod\ndef step(\n    self,\n    particle: ParticleRepresentation,\n    temperature: float,\n    pressure: float,\n    time_step: float,\n) -&gt; ParticleRepresentation: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_7","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#continuousgeneralpdf","title":"ContinuousGeneralPDF","text":"<p>Show source in strategy.py:488</p> <p>Continuous PDF coagulation strategy class. This class implements the methods defined in the CoagulationStrategy abstract class. The kernel strategy is passed as an argument to the class, should use a dimensionless kernel representation.</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#methods_1","title":"Methods","text":"<ul> <li><code>kernel</code> - Calculate the coagulation kernel.</li> <li><code>loss_rate</code> - Calculate the coagulation loss rate.</li> <li><code>gain_rate</code> - Calculate the coagulation gain rate.</li> <li><code>net_rate</code> - Calculate the net coagulation rate.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_10","title":"Signature","text":"<pre><code>class ContinuousGeneralPDF(CoagulationStrategy):\n    def __init__(self, kernel_strategy: KernelStrategy): ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_8","title":"See also","text":"<ul> <li>CoagulationStrategy</li> <li>KernelStrategy</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#continuousgeneralpdfdimensionless_kernel","title":"ContinuousGeneralPDF().dimensionless_kernel","text":"<p>Show source in strategy.py:505</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_11","title":"Signature","text":"<pre><code>def dimensionless_kernel(\n    self,\n    diffusive_knudsen: NDArray[np.float64],\n    coulomb_potential_ratio: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#continuousgeneralpdfgain_rate","title":"ContinuousGeneralPDF().gain_rate","text":"<p>Show source in strategy.py:562</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_12","title":"Signature","text":"<pre><code>def gain_rate(\n    self, particle: ParticleRepresentation, kernel: NDArray[np.float64]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_9","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#continuousgeneralpdfkernel","title":"ContinuousGeneralPDF().kernel","text":"<p>Show source in strategy.py:515</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_13","title":"Signature","text":"<pre><code>def kernel(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_10","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#continuousgeneralpdfloss_rate","title":"ContinuousGeneralPDF().loss_rate","text":"<p>Show source in strategy.py:550</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_14","title":"Signature","text":"<pre><code>def loss_rate(\n    self, particle: ParticleRepresentation, kernel: NDArray[np.float64]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_11","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#continuousgeneralpdfnet_rate","title":"ContinuousGeneralPDF().net_rate","text":"<p>Show source in strategy.py:574</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_15","title":"Signature","text":"<pre><code>def net_rate(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_12","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#continuousgeneralpdfstep","title":"ContinuousGeneralPDF().step","text":"<p>Show source in strategy.py:592</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_16","title":"Signature","text":"<pre><code>def step(\n    self,\n    particle: ParticleRepresentation,\n    temperature: float,\n    pressure: float,\n    time_step: float,\n) -&gt; ParticleRepresentation: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_13","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#discretegeneral","title":"DiscreteGeneral","text":"<p>Show source in strategy.py:364</p> <p>Discrete general coagulation strategy class. This class implements the methods defined in the CoagulationStrategy abstract class. The kernel strategy is passed as an argument to the class, to use a dimensionless kernel representation.</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#attributes","title":"Attributes","text":"<ul> <li><code>-</code> kernel_strategy - The kernel strategy to be used for the coagulation, from the KernelStrategy class.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#methods_2","title":"Methods","text":"<ul> <li><code>-</code> kernel - Calculate the coagulation kernel.</li> <li><code>-</code> loss_rate - Calculate the coagulation loss rate.</li> <li><code>-</code> gain_rate - Calculate the coagulation gain rate.</li> <li><code>-</code> net_rate - Calculate the net coagulation rate.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_17","title":"Signature","text":"<pre><code>class DiscreteGeneral(CoagulationStrategy):\n    def __init__(self, kernel_strategy: KernelStrategy): ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_14","title":"See also","text":"<ul> <li>CoagulationStrategy</li> <li>KernelStrategy</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#discretegeneraldimensionless_kernel","title":"DiscreteGeneral().dimensionless_kernel","text":"<p>Show source in strategy.py:387</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_18","title":"Signature","text":"<pre><code>def dimensionless_kernel(\n    self,\n    diffusive_knudsen: NDArray[np.float64],\n    coulomb_potential_ratio: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#discretegeneralgain_rate","title":"DiscreteGeneral().gain_rate","text":"<p>Show source in strategy.py:443</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_19","title":"Signature","text":"<pre><code>def gain_rate(\n    self, particle: ParticleRepresentation, kernel: NDArray[np.float64]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_15","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#discretegeneralkernel","title":"DiscreteGeneral().kernel","text":"<p>Show source in strategy.py:397</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_20","title":"Signature","text":"<pre><code>def kernel(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_16","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#discretegeneralloss_rate","title":"DiscreteGeneral().loss_rate","text":"<p>Show source in strategy.py:432</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_21","title":"Signature","text":"<pre><code>def loss_rate(\n    self, particle: ParticleRepresentation, kernel: NDArray[np.float64]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_17","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#discretegeneralnet_rate","title":"DiscreteGeneral().net_rate","text":"<p>Show source in strategy.py:455</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_22","title":"Signature","text":"<pre><code>def net_rate(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_18","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#discretegeneralstep","title":"DiscreteGeneral().step","text":"<p>Show source in strategy.py:473</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_23","title":"Signature","text":"<pre><code>def step(\n    self,\n    particle: ParticleRepresentation,\n    temperature: float,\n    pressure: float,\n    time_step: float,\n) -&gt; ParticleRepresentation: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_19","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#discretesimple","title":"DiscreteSimple","text":"<p>Show source in strategy.py:269</p> <p>Discrete Brownian coagulation strategy class. This class implements the methods defined in the CoagulationStrategy abstract class.</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#methods_3","title":"Methods","text":"<ul> <li><code>-</code> kernel - Calculate the coagulation kernel.</li> <li><code>-</code> loss_rate - Calculate the coagulation loss rate.</li> <li><code>-</code> gain_rate - Calculate the coagulation gain rate.</li> <li><code>-</code> net_rate - Calculate the net coagulation rate.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_24","title":"Signature","text":"<pre><code>class DiscreteSimple(CoagulationStrategy): ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_20","title":"See also","text":"<ul> <li>CoagulationStrategy</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#discretesimpledimensionless_kernel","title":"DiscreteSimple().dimensionless_kernel","text":"<p>Show source in strategy.py:282</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_25","title":"Signature","text":"<pre><code>def dimensionless_kernel(\n    self,\n    diffusive_knudsen: NDArray[np.float64],\n    coulomb_potential_ratio: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#discretesimplegain_rate","title":"DiscreteSimple().gain_rate","text":"<p>Show source in strategy.py:319</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_26","title":"Signature","text":"<pre><code>def gain_rate(\n    self, particle: ParticleRepresentation, kernel: NDArray[np.float64]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_21","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#discretesimplekernel","title":"DiscreteSimple().kernel","text":"<p>Show source in strategy.py:294</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_27","title":"Signature","text":"<pre><code>def kernel(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_22","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#discretesimpleloss_rate","title":"DiscreteSimple().loss_rate","text":"<p>Show source in strategy.py:308</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_28","title":"Signature","text":"<pre><code>def loss_rate(\n    self, particle: ParticleRepresentation, kernel: NDArray[np.float64]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_23","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#discretesimplenet_rate","title":"DiscreteSimple().net_rate","text":"<p>Show source in strategy.py:331</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_29","title":"Signature","text":"<pre><code>def net_rate(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_24","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#discretesimplestep","title":"DiscreteSimple().step","text":"<p>Show source in strategy.py:349</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_30","title":"Signature","text":"<pre><code>def step(\n    self,\n    particle: ParticleRepresentation,\n    temperature: float,\n    pressure: float,\n    time_step: float,\n) -&gt; ParticleRepresentation: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_25","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#particleresolved","title":"ParticleResolved","text":"<p>Show source in strategy.py:607</p> <p>Particle-resolved coagulation strategy class. This class implements the methods defined in the CoagulationStrategy abstract class. The kernel strategy is passed as an argument to the class, should use a dimensionless kernel representation.</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#methods_4","title":"Methods","text":"<ul> <li><code>kernel</code> - Calculate the coagulation kernel.</li> <li><code>loss_rate</code> - Not implemented.</li> <li><code>gain_rate</code> - Not implemented.</li> <li><code>net_rate</code> - Not implemented.</li> <li><code>step</code> - Perform a single step of the coagulation process.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_31","title":"Signature","text":"<pre><code>class ParticleResolved(CoagulationStrategy):\n    def __init__(\n        self,\n        kernel_radius: Optional[NDArray[np.float64]] = None,\n        kernel_bins_number: Optional[int] = None,\n        kernel_bins_per_decade: int = 10,\n    ): ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_26","title":"See also","text":"<ul> <li>CoagulationStrategy</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#particleresolveddimensionless_kernel","title":"ParticleResolved().dimensionless_kernel","text":"<p>Show source in strategy.py:672</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_32","title":"Signature","text":"<pre><code>def dimensionless_kernel(\n    self,\n    diffusive_knudsen: NDArray[np.float64],\n    coulomb_potential_ratio: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#particleresolvedgain_rate","title":"ParticleResolved().gain_rate","text":"<p>Show source in strategy.py:712</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_33","title":"Signature","text":"<pre><code>def gain_rate(\n    self, particle: ParticleRepresentation, kernel: NDArray[np.float64]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_27","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#particleresolvedget_kernel_radius","title":"ParticleResolved().get_kernel_radius","text":"<p>Show source in strategy.py:632</p> <p>Get the binning for the kernel radius.</p> <p>If the kernel radius is not set, it will be calculated based on the particle radius.</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#arguments_9","title":"Arguments","text":"<ul> <li><code>particle</code> - The particle for which the kernel radius is to be     calculated.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#returns_9","title":"Returns","text":"<p>The kernel radius for the particle [m].</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_34","title":"Signature","text":"<pre><code>def get_kernel_radius(self, particle: ParticleRepresentation) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_28","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#particleresolvedkernel","title":"ParticleResolved().kernel","text":"<p>Show source in strategy.py:685</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_35","title":"Signature","text":"<pre><code>def kernel(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_29","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#particleresolvedloss_rate","title":"ParticleResolved().loss_rate","text":"<p>Show source in strategy.py:702</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_36","title":"Signature","text":"<pre><code>def loss_rate(\n    self, particle: ParticleRepresentation, kernel: NDArray[np.float64]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_30","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#particleresolvednet_rate","title":"ParticleResolved().net_rate","text":"<p>Show source in strategy.py:722</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_37","title":"Signature","text":"<pre><code>def net_rate(\n    self, particle: ParticleRepresentation, temperature: float, pressure: float\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_31","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#particleresolvedstep","title":"ParticleResolved().step","text":"<p>Show source in strategy.py:733</p>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#signature_38","title":"Signature","text":"<pre><code>def step(\n    self,\n    particle: ParticleRepresentation,\n    temperature: float,\n    pressure: float,\n    time_step: float,\n) -&gt; ParticleRepresentation: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/strategy/#see-also_32","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/","title":"Super Droplet Method","text":"<p>Particula Index / Particula / Next / Dynamics / Coagulation / Super Droplet Method</p> <p>Auto-generated documentation for particula.next.dynamics.coagulation.super_droplet_method module.</p>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#bin_particles","title":"bin_particles","text":"<p>Show source in super_droplet_method.py:449</p> <p>Bin particles by size and return the number of particles in each bin.</p>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#arguments","title":"Arguments","text":"<ul> <li><code>particle_radius</code> - Array of sorted particle radii.</li> <li><code>radius_bins</code> - Array defining the bin edges for particle radii.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#returns","title":"Returns","text":"<p>Tuple:     - Array of the number of particles in each bin.     - Array of bin indices for each particle.</p>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#signature","title":"Signature","text":"<pre><code>def bin_particles(\n    particle_radius: NDArray[np.float64], radius_bins: NDArray[np.float64]\n) -&gt; Tuple[NDArray[np.int64], NDArray[np.int64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#bin_to_particle_indices","title":"bin_to_particle_indices","text":"<p>Show source in super_droplet_method.py:275</p> <p>Convert bin indices to actual particle indices in the particle array.</p> <p>This function calculates the actual indices in the particle array corresponding to the bins specified by <code>lower_bin</code> and <code>upper_bin</code>. The function adjusts the provided bin-relative indices to reflect their position in the full particle array.</p>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#arguments_1","title":"Arguments","text":"<ul> <li><code>lower_indices</code> - Array of indices relative to the start of     the <code>lower_bin</code>.</li> <li><code>upper_indices</code> - Array of indices relative to the start of     the <code>upper_bin</code>.</li> <li><code>lower_bin</code> - Index of the bin containing smaller particles.</li> <li><code>upper_bin</code> - Index of the bin containing larger particles.</li> <li><code>bin_indices</code> - Array containing the start indices of each bin in the     particle array.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#returns_1","title":"Returns","text":"<p>Tuple:     - <code>-</code> <code>small_index</code> - Indices of particles from the <code>lower_bin</code>.     - <code>-</code> <code>large_index</code> - Indices of particles from the <code>upper_bin</code>.</p>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#signature_1","title":"Signature","text":"<pre><code>def bin_to_particle_indices(\n    lower_indices: NDArray[np.int64],\n    upper_indices: NDArray[np.int64],\n    lower_bin: int,\n    upper_bin: int,\n    bin_indices: NDArray[np.int64],\n) -&gt; Tuple[NDArray[np.int64], NDArray[np.int64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#calculate_concentration_in_bins","title":"calculate_concentration_in_bins","text":"<p>Show source in super_droplet_method.py:492</p> <p>Calculate the concentration of particles in each bin.</p>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#arguments_2","title":"Arguments","text":"<ul> <li><code>bin_indices</code> - Array of bin indices for each particle.</li> <li><code>particle_concentration</code> - Array of sorted particle concentrations. number_in_bins : Array of the number of particles in each bin.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#returns_2","title":"Returns","text":"<p>The total concentration in each bin.</p>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#signature_2","title":"Signature","text":"<pre><code>def calculate_concentration_in_bins(\n    bin_indices: NDArray[np.int64],\n    particle_concentration: NDArray[np.float64],\n    number_in_bins: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#coagulation_events","title":"coagulation_events","text":"<p>Show source in super_droplet_method.py:363</p> <p>Calculate coagulation probabilities and filter events based on them.</p> <p>This function calculates the probability of coagulation events occurring between pairs of particles, based on the ratio of the kernel value for each pair to the maximum kernel value for the bins. The function then randomly determines which events occur using these probabilities.</p>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#arguments_3","title":"Arguments","text":"<ul> <li><code>small_index</code> - Array of indices for the first set of particles     (smaller particles) involved in the events.</li> <li><code>large_index</code> - Array of indices for the second set of particles     (larger particles) involved in the events.</li> <li><code>kernel_values</code> - Array of kernel values corresponding to the     particle pairs.</li> <li><code>kernel_max</code> - The maximum kernel value used for normalization     of probabilities.</li> <li><code>generator</code> - A NumPy random generator used to sample random numbers.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#returns_3","title":"Returns","text":"<p>Tuple:     - Filtered <code>small_index</code> array containing indices where         coagulation events occurred.     - Filtered <code>large_index</code> array containing indices where         coagulation events occurred.</p>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#signature_3","title":"Signature","text":"<pre><code>def coagulation_events(\n    small_index: NDArray[np.int64],\n    large_index: NDArray[np.int64],\n    kernel_values: NDArray[np.float64],\n    kernel_max: float,\n    generator: np.random.Generator,\n) -&gt; Tuple[NDArray[np.int64], NDArray[np.int64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#event_pairs","title":"event_pairs","text":"<p>Show source in super_droplet_method.py:102</p> <p>Calculate the number of particle pairs based on kernel value.</p>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#arguments_4","title":"Arguments","text":"<ul> <li><code>lower_bin</code> - Lower bin index.</li> <li><code>upper_bin</code> - Upper bin index.</li> <li><code>kernel_max</code> - Maximum value of the kernel.</li> <li><code>number_in_bins</code> - Number of particles in each bin.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#returns_4","title":"Returns","text":"<p>The number of particle pairs events based on the kernel and number of particles in the bins.</p>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#signature_4","title":"Signature","text":"<pre><code>def event_pairs(\n    lower_bin: int,\n    upper_bin: int,\n    kernel_max: Union[float, NDArray[np.float64]],\n    number_in_bins: Union[NDArray[np.float64], NDArray[np.int64]],\n) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#filter_valid_indices","title":"filter_valid_indices","text":"<p>Show source in super_droplet_method.py:317</p> <p>Filter particles indices based on particle radius and event counters.</p> <p>This function filters out particle indices that are considered invalid based on two criteria: 1. The particle radius must be greater than zero. 2. If provided, the single event counter must be less than one.</p>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#arguments_5","title":"Arguments","text":"<ul> <li><code>small_index</code> - Array of indices for particles in the smaller bin.</li> <li><code>large_index</code> - Array of indices for particles in the larger bin.</li> <li><code>particle_radius</code> - Array containing the radii of particles.</li> <li><code>single_event_counter</code> Optional - Optional array tracking the     number of events for each particle. If provided, only particles     with a counter value less than one are valid.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#returns_5","title":"Returns","text":"<p>Tuple:     - Filtered <code>small_index</code> array containing only valid indices.     - Filtered <code>large_index</code> array containing only valid indices.</p>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#signature_5","title":"Signature","text":"<pre><code>def filter_valid_indices(\n    small_index: NDArray[np.int64],\n    large_index: NDArray[np.int64],\n    particle_radius: NDArray[np.float64],\n    single_event_counter: Optional[NDArray[np.int64]] = None,\n) -&gt; Tuple[NDArray[np.int64], NDArray[np.int64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#get_bin_pairs","title":"get_bin_pairs","text":"<p>Show source in super_droplet_method.py:476</p> <p>Pre-compute the unique bin pairs for vectorized operations.</p>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#arguments_6","title":"Arguments","text":"<ul> <li><code>bin_indices</code> - Array of bin indices.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#returns_6","title":"Returns","text":"<p>Unique bin pairs for vectorized operations.</p>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#signature_6","title":"Signature","text":"<pre><code>def get_bin_pairs(bin_indices: NDArray[np.int64]) -&gt; list[Tuple[int, int]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#random_choice_indices","title":"random_choice_indices","text":"<p>Show source in super_droplet_method.py:165</p> <p>Filter valid indices and select random indices for coagulation events.</p> <p>This function filters particle indices based on bin indices and ensures the selected particles have a positive radius. It then randomly selects indices from both a lower bin and an upper bin for a given number of events.</p>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#arguments_7","title":"Arguments","text":"<ul> <li><code>lower_bin</code> - The index of the lower bin to filter particles from.</li> <li><code>upper_bin</code> - The index of the upper bin to filter particles from.</li> <li><code>events</code> - Number of events (indices) to sample for each bin.</li> <li><code>particle_radius</code> - A NumPy array of particle radii. Only particles with     radius &gt; 0 are considered.</li> <li><code>bin_indices</code> - A NumPy array of bin indices corresponding to each     particle.</li> <li><code>generator</code> - A NumPy random generator used to sample indices.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#returns_7","title":"Returns","text":"<p>Tuple:     - Indices of particles from the lower bin.     - Indices of particles from the upper bin.</p>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#examples","title":"Examples","text":"Example choice indices (update)<pre><code>rng = np.random.default_rng()\nparticle_radius = np.array([0.5, 0.0, 1.2, 0.3, 0.9])\nbin_indices = np.array([1, 1, 1, 2, 2])\nlower_bin = 1\nupper_bin = 2\nevents = 2\nlower_indices, upper_indices = random_choice_indices(\n    lower_bin, upper_bin, events, particle_radius, bin_indices, rng)\n# lower_indices: array([0, 4])\n# upper_indices: array([0, 1])\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#signature_7","title":"Signature","text":"<pre><code>def random_choice_indices(\n    lower_bin: int,\n    upper_bin: int,\n    events: int,\n    particle_radius: NDArray[np.float64],\n    bin_indices: NDArray[np.int64],\n    generator: np.random.Generator,\n) -&gt; Tuple[NDArray[np.int64], NDArray[np.int64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#sample_events","title":"sample_events","text":"<p>Show source in super_droplet_method.py:133</p> <p>Sample the number of coagulation events from a Poisson distribution.</p> <p>This function calculates the expected number of coagulation events based on the number of particle pairs, the simulation volume, and the time step. It then samples the actual number of events using a Poisson distribution.</p>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#arguments_8","title":"Arguments","text":"<ul> <li><code>events</code> - The calculated number of particle pairs that could     interact.</li> <li><code>volume</code> - The volume of the simulation space.</li> <li><code>time_step</code> - The time step over which the events are being simulated.</li> <li><code>generator</code> - A NumPy random generator used to sample from the Poisson     distribution.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#returns_8","title":"Returns","text":"<p>The sampled number of coagulation events as an integer.</p>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#signature_8","title":"Signature","text":"<pre><code>def sample_events(\n    events: float, volume: float, time_step: float, generator: np.random.Generator\n) -&gt; int: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#select_random_indices","title":"select_random_indices","text":"<p>Show source in super_droplet_method.py:228</p> <p>Select random indices for particles involved in coagulation events.</p> <p>This function generates random indices for particles in the specified bins (<code>lower_bin</code> and <code>upper_bin</code>) that are involved in a specified number of events. The indices are selected based on the number of particles in each bin.</p>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#arguments_9","title":"Arguments","text":"<ul> <li><code>lower_bin</code> - Index of the bin containing smaller particles.</li> <li><code>upper_bin</code> - Index of the bin containing larger particles.</li> <li><code>events</code> - The number of events to sample indices for.</li> <li><code>number_in_bins</code> - Array representing the number of particles in     each bin.</li> <li><code>generator</code> - A NumPy random generator used to sample indices.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#returns_9","title":"Returns","text":"<p>Tuple:     - Indices of particles from <code>lower_bin</code>.     - Indices of particles from <code>upper_bin</code>.</p>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#signature_9","title":"Signature","text":"<pre><code>def select_random_indices(\n    lower_bin: int,\n    upper_bin: int,\n    events: int,\n    number_in_bins: NDArray[np.int64],\n    generator: np.random.Generator,\n) -&gt; Tuple[NDArray[np.int64], NDArray[np.int64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#sort_particles","title":"sort_particles","text":"<p>Show source in super_droplet_method.py:411</p> <p>Sort particles by size and optionally sort their concentrations.</p>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#arguments_10","title":"Arguments","text":"<ul> <li><code>particle_radius</code> - Array of particle radii.</li> <li><code>particle_concentration</code> - Optional array of particle concentrations     corresponding to each radius. If provided, it will be sorted to     match the sorted radii.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#returns_10","title":"Returns","text":"<p>Tuple:     - <code>-</code> <code>unsort_indices</code> - Array of indices to revert the sorting.     - <code>-</code> <code>sorted_radius</code> - Array of sorted particle radii.     - <code>-</code> <code>sorted_concentration</code> - Optional array of sorted particle         concentrations (or <code>None</code> if not provided).</p>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#signature_10","title":"Signature","text":"<pre><code>def sort_particles(\n    particle_radius: NDArray[np.float64],\n    particle_concentration: Optional[NDArray[np.float64]] = None,\n) -&gt; Tuple[NDArray[np.int64], NDArray[np.float64], Optional[NDArray[np.float64]]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#super_droplet_coagulation_step","title":"super_droplet_coagulation_step","text":"<p>Show source in super_droplet_method.py:520</p> <p>Perform a single step of the Super Droplet coagulation process.</p> <p>This function processes particles by sorting them, binning by size, computing coagulation events based on the coagulation kernel, and updating particle properties accordingly.</p>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#arguments_11","title":"Arguments","text":"<ul> <li><code>particle_radius</code> - Array of particle radii.</li> <li><code>particle_concentration</code> - Array of particle concentrations     corresponding to each radius.</li> <li><code>kernel</code> - 2D array representing the coagulation kernel values between     different bins.</li> <li><code>kernel_radius</code> - Array defining the radii corresponding to the     kernel bins.</li> <li><code>volume</code> - Volume of the system or relevant scaling factor.</li> <li><code>time_step</code> - Duration of the current time step. random_generator : A NumPy random number generator for     stochastic processes.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#returns_11","title":"Returns","text":"<p>Tuple:     - Updated array of particle radii after coagulation.     - Updated array of particle concentrations after coagulation.</p>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#signature_11","title":"Signature","text":"<pre><code>def super_droplet_coagulation_step(\n    particle_radius: NDArray[np.float64],\n    particle_concentration: NDArray[np.float64],\n    kernel: NDArray[np.float64],\n    kernel_radius: NDArray[np.float64],\n    volume: float,\n    time_step: float,\n    random_generator: np.random.Generator,\n) -&gt; Tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#super_droplet_update_step","title":"super_droplet_update_step","text":"<p>Show source in super_droplet_method.py:14</p> <p>Update the particle radii and concentrations after coagulation events.</p>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#arguments_12","title":"Arguments","text":"<ul> <li><code>particle_radius</code> NDArray[float64] - Array of particle radii.</li> <li><code>concentration</code> NDArray[float64] - Array representing the concentration     of particles.</li> <li><code>single_event_counter</code> NDArray[int64] - Tracks the number of     coagulation events for each particle.</li> <li><code>small_index</code> NDArray[int64] - Indices corresponding to smaller     particles.</li> <li><code>large_index</code> NDArray[int64] - Indices corresponding to larger     particles.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#returns_12","title":"Returns","text":"<ul> <li>Updated array of particle radii.</li> <li>Updated array representing the concentration of particles.</li> <li>Updated array tracking the number of coagulation events.</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/super_droplet_method/#signature_12","title":"Signature","text":"<pre><code>def super_droplet_update_step(\n    particle_radius: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    single_event_counter: NDArray[np.int64],\n    small_index: NDArray[np.int64],\n    large_index: NDArray[np.int64],\n) -&gt; Tuple[NDArray[np.float64], NDArray[np.float64], NDArray[np.int64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/transition_regime/","title":"Transition Regime","text":"<p>Particula Index / Particula / Next / Dynamics / Coagulation / Transition Regime</p> <p>Auto-generated documentation for particula.next.dynamics.coagulation.transition_regime module.</p>"},{"location":"API/particula/next/dynamics/coagulation/transition_regime/#coulomb_chahl2019","title":"coulomb_chahl2019","text":"<p>Show source in transition_regime.py:209</p> <p>Chahl and Gopalakrishnan (2019) approximation for the dimensionless coagulation kernel. Accounts for the Coulomb potential between particles.</p>"},{"location":"API/particula/next/dynamics/coagulation/transition_regime/#arguments","title":"Arguments","text":"<ul> <li><code>-</code> diffusive_knudsen - The diffusive Knudsen number (K_nD) [dimensionless].</li> <li><code>-</code> coulomb_potential_ratio - The Coulomb potential ratio (phi_E) [dimensionless].</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/transition_regime/#returns","title":"Returns","text":"<p>The dimensionless coagulation kernel (H) [dimensionless].</p>"},{"location":"API/particula/next/dynamics/coagulation/transition_regime/#references","title":"References","text":"<ul> <li>Equations X in: Chahl, H. S., &amp; Gopalakrishnan, R. (2019). High potential, near free molecular regime Coulombic collisions in aerosols and dusty plasmas. Aerosol Science and Technology, 53(8), 933-957. https://doi.org/10.1080/02786826.2019.1614522</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/transition_regime/#signature","title":"Signature","text":"<pre><code>def coulomb_chahl2019(\n    diffusive_knudsen: Union[float, NDArray[np.float64]],\n    coulomb_potential_ratio: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/transition_regime/#coulomb_dyachkov2007","title":"coulomb_dyachkov2007","text":"<p>Show source in transition_regime.py:51</p> <p>Dyachkov et al. (2007) approximation for the dimensionless coagulation kernel. Accounts for the Coulomb potential between particles.</p>"},{"location":"API/particula/next/dynamics/coagulation/transition_regime/#arguments_1","title":"Arguments","text":"<ul> <li><code>-</code> diffusive_knudsen - The diffusive Knudsen number (K_nD) [dimensionless].</li> <li><code>-</code> coulomb_potential_ratio - The Coulomb potential ratio (phi_E) [dimensionless].</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/transition_regime/#returns_1","title":"Returns","text":"<p>The dimensionless coagulation kernel (H) [dimensionless].</p>"},{"location":"API/particula/next/dynamics/coagulation/transition_regime/#references_1","title":"References","text":"<p>Equations X in: - Dyachkov, S. A., Kustova, E. V., &amp; Kustov, A. V. (2007). Coagulation of particles in the transition regime: The effect of the Coulomb potential. Journal of Chemical Physics, 126(12). https://doi.org/10.1063/1.2713719</p>"},{"location":"API/particula/next/dynamics/coagulation/transition_regime/#signature_1","title":"Signature","text":"<pre><code>def coulomb_dyachkov2007(\n    diffusive_knudsen: Union[float, NDArray[np.float64]],\n    coulomb_potential_ratio: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/transition_regime/#coulomb_gatti2008","title":"coulomb_gatti2008","text":"<p>Show source in transition_regime.py:106</p> <p>Gatti et al. (2008) approximation for the dimensionless coagulation kernel. Accounts for the Coulomb potential between particles.</p>"},{"location":"API/particula/next/dynamics/coagulation/transition_regime/#arguments_2","title":"Arguments","text":"<ul> <li><code>-</code> diffusive_knudsen - The diffusive Knudsen number (K_nD) [dimensionless].</li> <li><code>-</code> coulomb_potential_ratio - The Coulomb potential ratio (phi_E) [dimensionless].</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/transition_regime/#returns_2","title":"Returns","text":"<p>The dimensionless coagulation kernel (H) [dimensionless].</p>"},{"location":"API/particula/next/dynamics/coagulation/transition_regime/#references_2","title":"References","text":"<ul> <li>Equations X in: Gatti, M., &amp; Kortshagen, U. (2008). Analytical model of particle charging in plasmas over a wide range of collisionality. Physical Review E - Statistical, Nonlinear, and Soft Matter Physics, 78(4). https://doi.org/10.1103/PhysRevE.78.046402</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/transition_regime/#signature_2","title":"Signature","text":"<pre><code>def coulomb_gatti2008(\n    diffusive_knudsen: Union[float, NDArray[np.float64]],\n    coulomb_potential_ratio: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/transition_regime/#coulomb_gopalakrishnan2012","title":"coulomb_gopalakrishnan2012","text":"<p>Show source in transition_regime.py:170</p> <p>Gopalakrishnan and Hogan (2012) approximation for the dimensionless coagulation kernel. Accounts for the Coulomb potential between particles.</p>"},{"location":"API/particula/next/dynamics/coagulation/transition_regime/#arguments_3","title":"Arguments","text":"<ul> <li><code>-</code> diffusive_knudsen - The diffusive Knudsen number (K_nD) [dimensionless].</li> <li><code>-</code> coulomb_potential_ratio - The Coulomb potential ratio (phi_E) [dimensionless].</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/transition_regime/#returns_3","title":"Returns","text":"<p>The dimensionless coagulation kernel (H) [dimensionless].</p>"},{"location":"API/particula/next/dynamics/coagulation/transition_regime/#references_3","title":"References","text":"<ul> <li>Equations X in: Gopalakrishnan, R., &amp; Hogan, C. J. (2012). Coulomb-influenced collisions in aerosols and dusty plasmas. Physical Review E - Statistical, Nonlinear, and Soft Matter Physics, 85(2). https://doi.org/10.1103/PhysRevE.85.026410</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/transition_regime/#signature_3","title":"Signature","text":"<pre><code>def coulomb_gopalakrishnan2012(\n    diffusive_knudsen: Union[float, NDArray[np.float64]],\n    coulomb_potential_ratio: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/coagulation/transition_regime/#hard_sphere","title":"hard_sphere","text":"<p>Show source in transition_regime.py:12</p> <p>Hard sphere approximation for the dimensionless coagulation kernel.</p>"},{"location":"API/particula/next/dynamics/coagulation/transition_regime/#arguments_4","title":"Arguments","text":"<ul> <li><code>-</code> diffusive_knudsen - The diffusive Knudsen number (K_nD) [dimensionless].</li> </ul>"},{"location":"API/particula/next/dynamics/coagulation/transition_regime/#returns_4","title":"Returns","text":"<p>The dimensionless coagulation kernel (H) [dimensionless].</p>"},{"location":"API/particula/next/dynamics/coagulation/transition_regime/#references_4","title":"References","text":"<p>Equations X in: - Dyachkov, S. A., Kustova, E. V., &amp; Kustov, A. V. (2007). Coagulation of particles in the transition regime: The effect of the Coulomb potential. Journal of Chemical Physics, 126(12). https://doi.org/10.1063/1.2713719</p>"},{"location":"API/particula/next/dynamics/coagulation/transition_regime/#signature_4","title":"Signature","text":"<pre><code>def hard_sphere(\n    diffusive_knudsen: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/condensation/","title":"Condensation","text":"<p>Particula Index / Particula / Next / Dynamics / Condensation</p> <p>Auto-generated documentation for particula.next.dynamics.condensation module.</p>"},{"location":"API/particula/next/dynamics/condensation/#modules","title":"Modules","text":"<ul> <li>Condensation Strategies</li> <li>Mass Transfer</li> </ul>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/","title":"Condensation Strategies","text":"<p>Particula Index / Particula / Next / Dynamics / Condensation / Condensation Strategies</p> <p>Auto-generated documentation for particula.next.dynamics.condensation.condensation_strategies module.</p>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#condensationisothermal","title":"CondensationIsothermal","text":"<p>Show source in condensation_strategies.py:288</p> <p>Condensation strategy for isothermal conditions.</p> <p>Condensation strategy for isothermal conditions, where the temperature remains constant. This class implements the mass transfer rate calculation for condensation of particles based on partial pressures. No Latent heat of vaporization effect is considered.</p>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#signature","title":"Signature","text":"<pre><code>class CondensationIsothermal(CondensationStrategy):\n    def __init__(\n        self,\n        molar_mass: Union[float, NDArray[np.float64]],\n        diffusion_coefficient: Union[float, NDArray[np.float64]] = 2e-05,\n        accommodation_coefficient: Union[float, NDArray[np.float64]] = 1.0,\n        update_gases: bool = True,\n    ): ...\n</code></pre>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#see-also","title":"See also","text":"<ul> <li>CondensationStrategy</li> </ul>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#condensationisothermalmass_transfer_rate","title":"CondensationIsothermal().mass_transfer_rate","text":"<p>Show source in condensation_strategies.py:311</p>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#signature_1","title":"Signature","text":"<pre><code>def mass_transfer_rate(\n    self,\n    particle: ParticleRepresentation,\n    gas_species: GasSpecies,\n    temperature: float,\n    pressure: float,\n    dynamic_viscosity: Optional[float] = None,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#see-also_1","title":"See also","text":"<ul> <li>GasSpecies</li> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#condensationisothermalrate","title":"CondensationIsothermal().rate","text":"<p>Show source in condensation_strategies.py:363</p>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#signature_2","title":"Signature","text":"<pre><code>def rate(\n    self,\n    particle: ParticleRepresentation,\n    gas_species: GasSpecies,\n    temperature: float,\n    pressure: float,\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#see-also_2","title":"See also","text":"<ul> <li>GasSpecies</li> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#condensationisothermalstep","title":"CondensationIsothermal().step","text":"<p>Show source in condensation_strategies.py:392</p>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#signature_3","title":"Signature","text":"<pre><code>def step(\n    self,\n    particle: ParticleRepresentation,\n    gas_species: GasSpecies,\n    temperature: float,\n    pressure: float,\n    time_step: float,\n) -&gt; Tuple[ParticleRepresentation, GasSpecies]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#see-also_3","title":"See also","text":"<ul> <li>GasSpecies</li> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#condensationstrategy","title":"CondensationStrategy","text":"<p>Show source in condensation_strategies.py:60</p> <p>Abstract base class for condensation strategies.</p> <p>This class defines the interface for various condensation models used in atmospheric physics. Subclasses should implement specific condensation algorithms based on different physical models and equations.</p>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#arguments","title":"Arguments","text":"<ul> <li><code>molar_mass</code> - The molar mass of the species [kg/mol]. If a single value     is provided, it will be used for all species.</li> <li><code>diffusion_coefficient</code> - The diffusion coefficient of the species     [m^2/s]. If a single value is provided, it will be used for all     species. Default is 2e-5 m^2/s for air.</li> <li><code>accommodation_coefficient</code> - The mass accommodation coefficient of the     species. If a single value is provided, it will be used for all     species. Default is 1.0.</li> </ul>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#signature_4","title":"Signature","text":"<pre><code>class CondensationStrategy(ABC):\n    def __init__(\n        self,\n        molar_mass: Union[float, NDArray[np.float64]],\n        diffusion_coefficient: Union[float, NDArray[np.float64]] = 2e-05,\n        accommodation_coefficient: Union[float, NDArray[np.float64]] = 1.0,\n        update_gases: bool = True,\n    ): ...\n</code></pre>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#condensationstrategyfirst_order_mass_transport","title":"CondensationStrategy().first_order_mass_transport","text":"<p>Show source in condensation_strategies.py:157</p> <p>First-order mass transport coefficient per particle.</p> <p>Calculate the first-order mass transport coefficient, K, for a given particle based on the diffusion coefficient, radius, and vapor transition correction factor.</p>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#arguments_1","title":"Arguments","text":"<ul> <li><code>radius</code> - The radius of the particle [m].</li> <li><code>temperature</code> - The temperature at which the first-order mass transport coefficient is to be calculated.</li> <li><code>pressure</code> - The pressure of the gas phase.</li> <li><code>dynamic_viscosity</code> - The dynamic viscosity of the gas [Pa*s]. If not provided, it will be calculated based on the temperature</li> </ul>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#returns","title":"Returns","text":"<p>The first-order mass transport coefficient per particle (m^3/s).</p>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#references","title":"References","text":"<ul> <li>Aerosol Modeling, Chapter 2, Equation 2.49 (excluding particle     number)</li> </ul>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#signature_5","title":"Signature","text":"<pre><code>def first_order_mass_transport(\n    self,\n    radius: Union[float, NDArray[np.float64]],\n    temperature: float,\n    pressure: float,\n    dynamic_viscosity: Optional[float] = None,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#condensationstrategyknudsen_number","title":"CondensationStrategy().knudsen_number","text":"<p>Show source in condensation_strategies.py:122</p> <p>The Knudsen number for a particle.</p> <p>Calculate the Knudsen number based on the mean free path of the gas molecules and the radius of the particle.</p>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#arguments_2","title":"Arguments","text":"<ul> <li><code>radius</code> - The radius of the particle [m].</li> <li><code>temperature</code> - The temperature of the gas [K].</li> <li><code>pressure</code> - The pressure of the gas [Pa].</li> <li><code>dynamic_viscosity</code> - The dynamic viscosity of the gas [Pa*s]. If     not provided, it will be calculated based on the temperature</li> </ul>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#returns_1","title":"Returns","text":"<p>The Knudsen number, which is the ratio of the mean free path to     the particle radius.</p>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#references_1","title":"References","text":"<p>Knudsen Number</p>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#signature_6","title":"Signature","text":"<pre><code>def knudsen_number(\n    self,\n    radius: Union[float, NDArray[np.float64]],\n    temperature: float,\n    pressure: float,\n    dynamic_viscosity: Optional[float] = None,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#condensationstrategymass_transfer_rate","title":"CondensationStrategy().mass_transfer_rate","text":"<p>Show source in condensation_strategies.py:200</p> <p>Mass transfer rate for a particle.</p> <p>Calculate the mass transfer rate based on the difference in partial pressure and the first-order mass transport coefficient.</p>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#arguments_3","title":"Arguments","text":"<ul> <li><code>particle</code> - The particle for which the mass transfer rate is to be     calculated.</li> <li><code>gas_species</code> - The gas species with which the particle is in contact.</li> <li><code>temperature</code> - The temperature at which the mass transfer rate     is to be calculated.</li> <li><code>pressure</code> - The pressure of the gas phase.</li> <li><code>dynamic_viscosity</code> - The dynamic viscosity of the gas [Pa*s]. If not     provided, it will be calculated based on the temperature</li> </ul>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#returns_2","title":"Returns","text":"<p>The mass transfer rate for the particle [kg/s].</p>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#signature_7","title":"Signature","text":"<pre><code>@abstractmethod\ndef mass_transfer_rate(\n    self,\n    particle: ParticleRepresentation,\n    gas_species: GasSpecies,\n    temperature: float,\n    pressure: float,\n    dynamic_viscosity: Optional[float] = None,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#see-also_4","title":"See also","text":"<ul> <li>GasSpecies</li> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#condensationstrategymean_free_path","title":"CondensationStrategy().mean_free_path","text":"<p>Show source in condensation_strategies.py:91</p> <p>Calculate the mean free path of the gas molecules based on the temperature, pressure, and dynamic viscosity of the gas.</p>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#arguments_4","title":"Arguments","text":"<ul> <li><code>temperature</code> - The temperature of the gas [K].</li> <li><code>pressure</code> - The pressure of the gas [Pa].</li> <li><code>dynamic_viscosity</code> - The dynamic viscosity of the gas [Pa*s]. If not provided, it will be calculated based on the temperature</li> </ul>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#returns_3","title":"Returns","text":"<ul> <li><code>Union[float,</code> NDArray[np.float64]] - The mean free path of the gas     molecules in meters (m).</li> </ul>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#references_2","title":"References","text":"<p>Mean Free Path: Wikipedia</p>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#signature_8","title":"Signature","text":"<pre><code>def mean_free_path(\n    self, temperature: float, pressure: float, dynamic_viscosity: Optional[float] = None\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#condensationstrategyrate","title":"CondensationStrategy().rate","text":"<p>Show source in condensation_strategies.py:229</p> <p>Calculate the rate of mass condensation for each particle due to each condensable gas species.</p> <p>The rate of condensation is determined based on the mass transfer rate, which is a function of particle properties, gas species properties, temperature, and pressure. This rate is then scaled by the concentration of particles in the system to get the overall condensation rate for each particle or bin.</p>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#arguments_5","title":"Arguments","text":"<ul> <li><code>particle</code> ParticleRepresentation - Representation of the particles,     including properties such as size, concentration, and mass.</li> <li><code>gas_species</code> GasSpecies - The species of gas condensing onto the     particles.</li> <li><code>temperature</code> float - The temperature of the system in Kelvin.</li> <li><code>pressure</code> float - The pressure of the system in Pascals.</li> </ul>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#returns_4","title":"Returns","text":"<p>An array of condensation rates for each particle, scaled by     particle concentration.</p>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#signature_9","title":"Signature","text":"<pre><code>@abstractmethod\ndef rate(\n    self,\n    particle: ParticleRepresentation,\n    gas_species: GasSpecies,\n    temperature: float,\n    pressure: float,\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#see-also_5","title":"See also","text":"<ul> <li>GasSpecies</li> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#condensationstrategystep","title":"CondensationStrategy().step","text":"<p>Show source in condensation_strategies.py:261</p> <p>Execute the condensation process for a given time step.</p>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#arguments_6","title":"Arguments","text":"<ul> <li><code>particle</code> ParticleRepresentation - The particle to modify.</li> <li><code>gas_species</code> GasSpecies - The gas species to condense onto the     particle.</li> <li><code>temperature</code> float - The temperature of the system in Kelvin.</li> <li><code>pressure</code> float - The pressure of the system in Pascals.</li> <li><code>time_step</code> float - The time step for the process in seconds.</li> </ul>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#returns_5","title":"Returns","text":"<ul> <li><code>(ParticleRepresentation,</code> GasSpecies) - The modified particle     instance and the modified gas species instance.</li> </ul>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#signature_10","title":"Signature","text":"<pre><code>@abstractmethod\ndef step(\n    self,\n    particle: ParticleRepresentation,\n    gas_species: GasSpecies,\n    temperature: float,\n    pressure: float,\n    time_step: float,\n) -&gt; Tuple[ParticleRepresentation, GasSpecies]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/condensation/condensation_strategies/#see-also_6","title":"See also","text":"<ul> <li>GasSpecies</li> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/dynamics/condensation/mass_transfer/","title":"Mass Transfer","text":"<p>Particula Index / Particula / Next / Dynamics / Condensation / Mass Transfer</p> <p>Auto-generated documentation for particula.next.dynamics.condensation.mass_transfer module.</p>"},{"location":"API/particula/next/dynamics/condensation/mass_transfer/#calculate_mass_transfer","title":"calculate_mass_transfer","text":"<p>Show source in mass_transfer.py:140</p> <p>Helper function that routes the mass transfer calculation to either the single-species or multi-species calculation functions based on the input dimensions of gas_mass.</p>"},{"location":"API/particula/next/dynamics/condensation/mass_transfer/#arguments","title":"Arguments","text":"<ul> <li><code>mass_rate</code> - The rate of mass transfer per particle (kg/s).</li> <li><code>time_step</code> - The time step for the mass transfer calculation (seconds).</li> <li><code>gas_mass</code> - The available mass of gas species (kg).</li> <li><code>particle_mass</code> - The mass of each particle (kg).</li> <li><code>particle_concentration</code> - The concentration of particles (number/m^3).</li> </ul>"},{"location":"API/particula/next/dynamics/condensation/mass_transfer/#returns","title":"Returns","text":"<p>The amount of mass transferred, accounting for gas and particle     limitations.</p>"},{"location":"API/particula/next/dynamics/condensation/mass_transfer/#signature","title":"Signature","text":"<pre><code>def calculate_mass_transfer(\n    mass_rate: NDArray[np.float64],\n    time_step: float,\n    gas_mass: NDArray[np.float64],\n    particle_mass: NDArray[np.float64],\n    particle_concentration: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/condensation/mass_transfer/#calculate_mass_transfer_multiple_species","title":"calculate_mass_transfer_multiple_species","text":"<p>Show source in mass_transfer.py:225</p> <p>Calculate mass transfer for multiple gas species.</p>"},{"location":"API/particula/next/dynamics/condensation/mass_transfer/#arguments_1","title":"Arguments","text":"<ul> <li><code>mass_rate</code> - The rate of mass transfer per particle for each gas species     (kg/s).</li> <li><code>time_step</code> - The time step for the mass transfer calculation (seconds).</li> <li><code>gas_mass</code> - The available mass of each gas species (kg).</li> <li><code>particle_mass</code> - The mass of each particle for each gas species (kg).</li> <li><code>particle_concentration</code> - The concentration of particles for each gas     species (number/m^3).</li> </ul>"},{"location":"API/particula/next/dynamics/condensation/mass_transfer/#returns_1","title":"Returns","text":"<p>The amount of mass transferred for multiple gas species.</p>"},{"location":"API/particula/next/dynamics/condensation/mass_transfer/#signature_1","title":"Signature","text":"<pre><code>def calculate_mass_transfer_multiple_species(\n    mass_rate: NDArray[np.float64],\n    time_step: float,\n    gas_mass: NDArray[np.float64],\n    particle_mass: NDArray[np.float64],\n    particle_concentration: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/condensation/mass_transfer/#calculate_mass_transfer_single_species","title":"calculate_mass_transfer_single_species","text":"<p>Show source in mass_transfer.py:181</p> <p>Calculate mass transfer for a single gas species (m=1).</p>"},{"location":"API/particula/next/dynamics/condensation/mass_transfer/#arguments_2","title":"Arguments","text":"<ul> <li><code>mass_rate</code> - The rate of mass transfer per particle (number*kg/s).</li> <li><code>time_step</code> - The time step for the mass transfer calculation (seconds).</li> <li><code>gas_mass</code> - The available mass of gas species (kg).</li> <li><code>particle_mass</code> - The mass of each particle (kg).</li> <li><code>particle_concentration</code> - The concentration of particles (number/m^3).</li> </ul>"},{"location":"API/particula/next/dynamics/condensation/mass_transfer/#returns_2","title":"Returns","text":"<p>The amount of mass transferred for a single gas species.</p>"},{"location":"API/particula/next/dynamics/condensation/mass_transfer/#signature_2","title":"Signature","text":"<pre><code>def calculate_mass_transfer_single_species(\n    mass_rate: NDArray[np.float64],\n    time_step: float,\n    gas_mass: NDArray[np.float64],\n    particle_mass: NDArray[np.float64],\n    particle_concentration: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/condensation/mass_transfer/#first_order_mass_transport_k","title":"first_order_mass_transport_k","text":"<p>Show source in mass_transfer.py:46</p> <p>First-order mass transport coefficient per particle.</p> <p>Calculate the first-order mass transport coefficient, K, for a given radius diffusion coefficient, and vapor transition correction factor. For a single particle.</p>"},{"location":"API/particula/next/dynamics/condensation/mass_transfer/#arguments_3","title":"Arguments","text":"<ul> <li><code>radius</code> - The radius of the particle [m].</li> <li><code>diffusion_coefficient</code> - The diffusion coefficient of the vapor [m^2/s],     default to air.</li> <li><code>vapor_transition</code> - The vapor transition correction factor. [unitless]</li> </ul>"},{"location":"API/particula/next/dynamics/condensation/mass_transfer/#returns_3","title":"Returns","text":"<ul> <li><code>Union[float,</code> NDArray[np.float64]] - The first-order mass transport coefficient per particle (m^3/s).</li> </ul>"},{"location":"API/particula/next/dynamics/condensation/mass_transfer/#references","title":"References","text":"<ul> <li>Aerosol Modeling: Chapter 2, Equation 2.49 (excluding number)</li> <li>Mass Diffusivity:     Wikipedia</li> </ul>"},{"location":"API/particula/next/dynamics/condensation/mass_transfer/#signature_3","title":"Signature","text":"<pre><code>def first_order_mass_transport_k(\n    radius: Union[float, NDArray[np.float64]],\n    vapor_transition: Union[float, NDArray[np.float64]],\n    diffusion_coefficient: Union[float, NDArray[np.float64]] = 2e-05,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/condensation/mass_transfer/#mass_transfer_rate","title":"mass_transfer_rate","text":"<p>Show source in mass_transfer.py:83</p> <p>Calculate the mass transfer rate for a particle.</p> <p>Calculate the mass transfer rate based on the difference in partial pressure and the first-order mass transport coefficient.</p>"},{"location":"API/particula/next/dynamics/condensation/mass_transfer/#arguments_4","title":"Arguments","text":"<ul> <li><code>pressure_delta</code> - The difference in partial pressure between the gas     phase and the particle phase.</li> <li><code>first_order_mass_transport</code> - The first-order mass transport coefficient     per particle.</li> <li><code>temperature</code> - The temperature at which the mass transfer rate is to be     calculated.</li> </ul>"},{"location":"API/particula/next/dynamics/condensation/mass_transfer/#returns_4","title":"Returns","text":"<p>The mass transfer rate for the particle [kg/s].</p>"},{"location":"API/particula/next/dynamics/condensation/mass_transfer/#references_1","title":"References","text":"<ul> <li>Aerosol Modeling Chapter 2, Equation 2.41 (excluding particle number)</li> <li>Seinfeld and Pandis: \"Atmospheric Chemistry and Physics\",     Equation 13.3</li> </ul>"},{"location":"API/particula/next/dynamics/condensation/mass_transfer/#signature_4","title":"Signature","text":"<pre><code>def mass_transfer_rate(\n    pressure_delta: Union[float, NDArray[np.float64]],\n    first_order_mass_transport: Union[float, NDArray[np.float64]],\n    temperature: Union[float, NDArray[np.float64]],\n    molar_mass: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/condensation/mass_transfer/#radius_transfer_rate","title":"radius_transfer_rate","text":"<p>Show source in mass_transfer.py:117</p> <p>Convert mass rate to radius transfer rate.</p> <p>Convert the mass rate to a radius transfer rate based on the volume of the particle.</p>"},{"location":"API/particula/next/dynamics/condensation/mass_transfer/#arguments_5","title":"Arguments","text":"<ul> <li><code>mass_rate</code> - The mass transfer rate for the particle [kg/s].</li> <li><code>radius</code> - The radius of the particle [m].</li> <li><code>density</code> - The density of the particle [kg/m^3].</li> </ul>"},{"location":"API/particula/next/dynamics/condensation/mass_transfer/#returns_5","title":"Returns","text":"<p>The radius growth rate for the particle [m/s].</p>"},{"location":"API/particula/next/dynamics/condensation/mass_transfer/#signature_5","title":"Signature","text":"<pre><code>def radius_transfer_rate(\n    mass_rate: Union[float, NDArray[np.float64]],\n    radius: Union[float, NDArray[np.float64]],\n    density: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/properties/","title":"Properties","text":"<p>Particula Index / Particula / Next / Dynamics / Properties</p> <p>Auto-generated documentation for particula.next.dynamics.properties module.</p>"},{"location":"API/particula/next/dynamics/properties/#modules","title":"Modules","text":"<ul> <li>Wall Loss Coefficient</li> </ul>"},{"location":"API/particula/next/dynamics/properties/wall_loss_coefficient/","title":"Wall Loss Coefficient","text":"<p>Particula Index / Particula / Next / Dynamics / Properties / Wall Loss Coefficient</p> <p>Auto-generated documentation for particula.next.dynamics.properties.wall_loss_coefficient module.</p>"},{"location":"API/particula/next/dynamics/properties/wall_loss_coefficient/#rectangle_wall_loss_coefficient","title":"rectangle_wall_loss_coefficient","text":"<p>Show source in wall_loss_coefficient.py:65</p> <p>Calculate the wall loss coefficient, \u03b2\u2080, for a rectangular chamber.</p> <p>This function computes the wall loss coefficient for a rectangular-prism chamber, considering the wall eddy diffusivity, particle diffusion coefficient, and terminal settling velocity. The chamber dimensions (length, width, and height) are used to account for the geometry's impact on particle loss.</p>"},{"location":"API/particula/next/dynamics/properties/wall_loss_coefficient/#arguments","title":"Arguments","text":"<ul> <li><code>wall_eddy_diffusivity</code> - Rate of wall diffusivity parameter in     units of inverse seconds (s^-1).</li> <li><code>diffusion_coefficient</code> - The particle diffusion coefficient     in units of square meters per second (m\u00b2/s).</li> <li><code>settling_velocity</code> - The terminal settling velocity of the     particles, in units of meters per second (m/s).</li> <li><code>chamber_dimensions</code> - A tuple of three floats representing the length     (L), width (W), and height (H) of the rectangular chamber,     in units of meters (m).</li> </ul>"},{"location":"API/particula/next/dynamics/properties/wall_loss_coefficient/#returns","title":"Returns","text":"<p>The calculated wall loss rate (\u03b2\u2080) for the rectangular chamber.</p>"},{"location":"API/particula/next/dynamics/properties/wall_loss_coefficient/#references","title":"References","text":"<ul> <li>Crump, J. G., &amp; Seinfeld, J. H. (1981). TURBULENT DEPOSITION AND     GRAVITATIONAL SEDIMENTATION OF AN AEROSOL IN A VESSEL OF ARBITRARY     SHAPE. In J Aerosol Sct (Vol. 12, Issue 5).     https://doi.org/10.1016/0021-8502(81)90036-7</li> </ul>"},{"location":"API/particula/next/dynamics/properties/wall_loss_coefficient/#signature","title":"Signature","text":"<pre><code>def rectangle_wall_loss_coefficient(\n    wall_eddy_diffusivity: Union[float, NDArray[np.float64]],\n    diffusion_coefficient: Union[float, NDArray[np.float64]],\n    settling_velocity: Union[float, NDArray[np.float64]],\n    chamber_dimensions: Tuple[float, float, float],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/properties/wall_loss_coefficient/#rectangle_wall_loss_coefficient_via_system_state","title":"rectangle_wall_loss_coefficient_via_system_state","text":"<p>Show source in wall_loss_coefficient.py:177</p> <p>Calculate the wall loss coefficient for a rectangular chamber based on the system state.</p> <p>This function computes the wall loss coefficient for a rectangular chamber using the system's physical state, including the wall eddy diffusivity, particle properties (radius, density), and environmental conditions (temperature, pressure). The chamber dimensions (length, width, height) are also considered.</p>"},{"location":"API/particula/next/dynamics/properties/wall_loss_coefficient/#arguments_1","title":"Arguments","text":"<ul> <li><code>wall_eddy_diffusivity</code> - The rate of wall eddy diffusivity in inverse     seconds (s\u207b\u00b9).</li> <li><code>particle_radius</code> - The radius of the particle in meters (m).</li> <li><code>particle_density</code> - The density of the particle in kilograms per cubic     meter (kg/m\u00b3).</li> <li><code>temperature</code> - The temperature of the system in Kelvin (K).</li> <li><code>pressure</code> - The pressure of the system in Pascals (Pa).</li> <li><code>chamber_dimensions</code> - A tuple containing the length, width, and height     of the rectangular chamber in meters (m).</li> </ul>"},{"location":"API/particula/next/dynamics/properties/wall_loss_coefficient/#returns_1","title":"Returns","text":"<p>The calculated wall loss coefficient for the rectangular chamber.</p>"},{"location":"API/particula/next/dynamics/properties/wall_loss_coefficient/#references_1","title":"References","text":"<ul> <li>Crump, J. G., &amp; Seinfeld, J. H. (1981). TURBULENT DEPOSITION AND     GRAVITATIONAL SEDIMENTATION OF AN AEROSOL IN A VESSEL OF ARBITRARY     SHAPE. In J Aerosol Sct (Vol. 12, Issue 5).     https://doi.org/10.1016/0021-8502(81)90036-7</li> </ul>"},{"location":"API/particula/next/dynamics/properties/wall_loss_coefficient/#signature_1","title":"Signature","text":"<pre><code>def rectangle_wall_loss_coefficient_via_system_state(\n    wall_eddy_diffusivity: float,\n    particle_radius: Union[float, NDArray[np.float64]],\n    particle_density: Union[float, NDArray[np.float64]],\n    temperature: float,\n    pressure: float,\n    chamber_dimensions: Tuple[float, float, float],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/properties/wall_loss_coefficient/#spherical_wall_loss_coefficient","title":"spherical_wall_loss_coefficient","text":"<p>Show source in wall_loss_coefficient.py:28</p> <p>Calculate the wall loss coefficient for a spherical chamber approximation.</p>"},{"location":"API/particula/next/dynamics/properties/wall_loss_coefficient/#arguments_2","title":"Arguments","text":"<ul> <li><code>wall_eddy_diffusivity</code> - Rate of the wall eddy diffusivity.</li> <li><code>diffusion_coefficient</code> - Diffusion coefficient of the     particle.</li> <li><code>settling_velocity</code> - Settling velocity of the particle.</li> <li><code>chamber_radius</code> - Radius of the chamber.</li> </ul>"},{"location":"API/particula/next/dynamics/properties/wall_loss_coefficient/#returns_2","title":"Returns","text":"<p>The calculated wall loss rate for a spherical chamber.</p>"},{"location":"API/particula/next/dynamics/properties/wall_loss_coefficient/#references_2","title":"References","text":"<ul> <li>Crump, J. G., Flagan, R. C., &amp; Seinfeld, J. H. (1982). Particle wall     loss rates in vessels. Aerosol Science and Technology, 2(3),     303-309. https://doi.org/10.1080/02786828308958636</li> </ul>"},{"location":"API/particula/next/dynamics/properties/wall_loss_coefficient/#signature_2","title":"Signature","text":"<pre><code>def spherical_wall_loss_coefficient(\n    wall_eddy_diffusivity: Union[float, NDArray[np.float64]],\n    diffusion_coefficient: Union[float, NDArray[np.float64]],\n    settling_velocity: Union[float, NDArray[np.float64]],\n    chamber_radius: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/dynamics/properties/wall_loss_coefficient/#spherical_wall_loss_coefficient_via_system_state","title":"spherical_wall_loss_coefficient_via_system_state","text":"<p>Show source in wall_loss_coefficient.py:120</p> <p>Calculate the wall loss coefficient for a spherical chamber based on the system state.</p> <p>This function computes the wall loss coefficient for a spherical chamber using the system's physical state, including the wall eddy diffusivity, particle properties (radius, density), and environmental conditions (temperature, pressure). The chamber radius is also taken into account.</p>"},{"location":"API/particula/next/dynamics/properties/wall_loss_coefficient/#arguments_3","title":"Arguments","text":"<ul> <li><code>wall_eddy_diffusivity</code> - The rate of wall eddy diffusivity in inverse     seconds (s\u207b\u00b9).</li> <li><code>particle_radius</code> - The radius of the particle in meters (m).</li> <li><code>particle_density</code> - The density of the particle in kilograms per cubic     meter (kg/m\u00b3).</li> <li><code>temperature</code> - The temperature of the system in Kelvin (K).</li> <li><code>pressure</code> - The pressure of the system in Pascals (Pa).</li> <li><code>chamber_radius</code> - The radius of the spherical chamber in meters (m).</li> </ul>"},{"location":"API/particula/next/dynamics/properties/wall_loss_coefficient/#returns_3","title":"Returns","text":"<p>The calculated wall loss coefficient for the spherical chamber.</p>"},{"location":"API/particula/next/dynamics/properties/wall_loss_coefficient/#signature_3","title":"Signature","text":"<pre><code>def spherical_wall_loss_coefficient_via_system_state(\n    wall_eddy_diffusivity: float,\n    particle_radius: Union[float, NDArray[np.float64]],\n    particle_density: Union[float, NDArray[np.float64]],\n    temperature: float,\n    pressure: float,\n    chamber_radius: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/gas/","title":"Gas","text":"<p>Particula Index / Particula / Next / Gas</p> <p>Auto-generated documentation for particula.next.gas module.</p>"},{"location":"API/particula/next/gas/#modules","title":"Modules","text":"<ul> <li>Atmosphere</li> <li>Atmosphere Builders</li> <li>Properties</li> <li>Species</li> <li>Species Builders</li> <li>Species Factories</li> <li>Vapor Pressure Builders</li> <li>Vapor Pressure Factories</li> <li>Vapor Pressure Strategies</li> </ul>"},{"location":"API/particula/next/gas/atmosphere/","title":"Atmosphere","text":"<p>Particula Index / Particula / Next / Gas / Atmosphere</p> <p>Auto-generated documentation for particula.next.gas.atmosphere module.</p>"},{"location":"API/particula/next/gas/atmosphere/#atmosphere_1","title":"Atmosphere","text":"<p>Show source in atmosphere.py:8</p> <p>Represents a mixture of gas species under specific conditions.</p> <p>This class represents the atmospheric environment by detailing properties such as temperature and pressure, alongside a dynamic list of gas species present.</p>"},{"location":"API/particula/next/gas/atmosphere/#attributes","title":"Attributes","text":"<ul> <li><code>temperature</code> - Temperature of the gas mixture in Kelvin.</li> <li><code>total_pressure</code> - Total atmospheric pressure of the mixture inPascals.</li> <li><code>species</code> - List of GasSpecies objects representing the     various species within the gas mixture.</li> </ul>"},{"location":"API/particula/next/gas/atmosphere/#methods","title":"Methods","text":"<ul> <li><code>add_species(self,</code> species - GasSpecies) -&gt; None:     Adds a GasSpecies object to the mixture.</li> <li><code>remove_species(self,</code> index - int) -&gt; None:     Removes a GasSpecies object from the mixture based on its index.</li> </ul>"},{"location":"API/particula/next/gas/atmosphere/#signature","title":"Signature","text":"<pre><code>class Atmosphere: ...\n</code></pre>"},{"location":"API/particula/next/gas/atmosphere/#atmospheregetitem","title":"Atmosphere().getitem","text":"<p>Show source in atmosphere.py:64</p> <p>Retrieves a gas species by index.</p>"},{"location":"API/particula/next/gas/atmosphere/#arguments","title":"Arguments","text":"<ul> <li><code>index</code> - The index of the gas species to retrieve.</li> </ul>"},{"location":"API/particula/next/gas/atmosphere/#returns","title":"Returns","text":"<ul> <li><code>GasSpecies</code> - The gas species at the specified index.</li> </ul>"},{"location":"API/particula/next/gas/atmosphere/#signature_1","title":"Signature","text":"<pre><code>def __getitem__(self, index: int) -&gt; GasSpecies: ...\n</code></pre>"},{"location":"API/particula/next/gas/atmosphere/#see-also","title":"See also","text":"<ul> <li>GasSpecies</li> </ul>"},{"location":"API/particula/next/gas/atmosphere/#atmosphereiter","title":"Atmosphere().iter","text":"<p>Show source in atmosphere.py:55</p> <p>Allows iteration over the species in the gas mixture.</p>"},{"location":"API/particula/next/gas/atmosphere/#returns_1","title":"Returns","text":"<ul> <li><code>Iterator[GasSpecies]</code> - An iterator over the gas species objects.</li> </ul>"},{"location":"API/particula/next/gas/atmosphere/#signature_2","title":"Signature","text":"<pre><code>def __iter__(self): ...\n</code></pre>"},{"location":"API/particula/next/gas/atmosphere/#atmospherelen","title":"Atmosphere().len","text":"<p>Show source in atmosphere.py:75</p> <p>Returns the number of species in the gas mixture.</p>"},{"location":"API/particula/next/gas/atmosphere/#returns_2","title":"Returns","text":"<ul> <li><code>int</code> - The number of gas species in the mixture.</li> </ul>"},{"location":"API/particula/next/gas/atmosphere/#signature_3","title":"Signature","text":"<pre><code>def __len__(self) -&gt; int: ...\n</code></pre>"},{"location":"API/particula/next/gas/atmosphere/#atmospherestr","title":"Atmosphere().str","text":"<p>Show source in atmosphere.py:83</p> <p>Provides a string representation of the Atmosphere object.</p>"},{"location":"API/particula/next/gas/atmosphere/#returns_3","title":"Returns","text":"<ul> <li><code>str</code> - A string that includes the temperature, pressure, and a     list of species in the mixture.</li> </ul>"},{"location":"API/particula/next/gas/atmosphere/#signature_4","title":"Signature","text":"<pre><code>def __str__(self) -&gt; str: ...\n</code></pre>"},{"location":"API/particula/next/gas/atmosphere/#atmosphereadd_species","title":"Atmosphere().add_species","text":"<p>Show source in atmosphere.py:32</p> <p>Adds a GasSpecies object to the mixture.</p>"},{"location":"API/particula/next/gas/atmosphere/#arguments_1","title":"Arguments","text":"<ul> <li><code>gas_species</code> - The gas species to be added.</li> </ul>"},{"location":"API/particula/next/gas/atmosphere/#signature_5","title":"Signature","text":"<pre><code>def add_species(self, gas_species: GasSpecies) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/next/gas/atmosphere/#see-also_1","title":"See also","text":"<ul> <li>GasSpecies</li> </ul>"},{"location":"API/particula/next/gas/atmosphere/#atmosphereremove_species","title":"Atmosphere().remove_species","text":"<p>Show source in atmosphere.py:40</p> <p>Removes a gas species from the mixture by its index.</p>"},{"location":"API/particula/next/gas/atmosphere/#arguments_2","title":"Arguments","text":"<ul> <li><code>index</code> - Index of the gas species to remove. Must be within             the current range of the list.</li> </ul>"},{"location":"API/particula/next/gas/atmosphere/#raises","title":"Raises","text":"<ul> <li><code>IndexError</code> - If the provided index is out of bounds.</li> </ul>"},{"location":"API/particula/next/gas/atmosphere/#signature_6","title":"Signature","text":"<pre><code>def remove_species(self, index: int) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/next/gas/atmosphere_builders/","title":"Atmosphere Builders","text":"<p>Particula Index / Particula / Next / Gas / Atmosphere Builders</p> <p>Auto-generated documentation for particula.next.gas.atmosphere_builders module.</p>"},{"location":"API/particula/next/gas/atmosphere_builders/#atmospherebuilder","title":"AtmosphereBuilder","text":"<p>Show source in atmosphere_builders.py:17</p> <p>Builder class for creating Atmosphere objects using a fluent interface.</p> <p>This class provides methods to configure and build an Atmosphere object, allowing for step-by-step setting of atmospheric properties and species composition.</p>"},{"location":"API/particula/next/gas/atmosphere_builders/#attributes","title":"Attributes","text":"<ul> <li><code>temperature</code> - Temperature of the gas mixture in Kelvin.</li> <li><code>total_pressure</code> float - Total pressure of the gas mixture in Pascals.</li> <li><code>species</code> list[GasSpecies] - List of GasSpecies objects in the mixture.     Starts empty.</li> </ul>"},{"location":"API/particula/next/gas/atmosphere_builders/#methods","title":"Methods","text":"<ul> <li><code>set_temperature(temperature,temperature_units)</code> - Sets the temperature.</li> <li><code>set_pressure(pressure,pressure_units)</code> - Sets the total pressure.</li> <li><code>add_species(species)</code> - Adds a GasSpecies object to the gas mixture.</li> <li><code>set_parameters(parameters)</code> - Sets multiple parameters from a dictionary.</li> <li><code>build()</code> - Validates the set parameters and returns an Atmosphere object.</li> </ul>"},{"location":"API/particula/next/gas/atmosphere_builders/#signature","title":"Signature","text":"<pre><code>class AtmosphereBuilder(BuilderABC, BuilderTemperatureMixin, BuilderPressureMixin):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/gas/atmosphere_builders/#see-also","title":"See also","text":"<ul> <li>BuilderABC</li> <li>BuilderPressureMixin</li> <li>BuilderTemperatureMixin</li> </ul>"},{"location":"API/particula/next/gas/atmosphere_builders/#atmospherebuilderadd_species","title":"AtmosphereBuilder().add_species","text":"<p>Show source in atmosphere_builders.py:49</p> <p>Adds a GasSpecies object to the gas mixture.</p>"},{"location":"API/particula/next/gas/atmosphere_builders/#arguments","title":"Arguments","text":"<ul> <li><code>species</code> GasSpecies - The GasSpecies object to be added.</li> </ul>"},{"location":"API/particula/next/gas/atmosphere_builders/#returns","title":"Returns","text":"<ul> <li>AtmosphereBuilder - Instance of this builder for chaining.</li> </ul>"},{"location":"API/particula/next/gas/atmosphere_builders/#signature_1","title":"Signature","text":"<pre><code>def add_species(self, species: GasSpecies) -&gt; \"AtmosphereBuilder\": ...\n</code></pre>"},{"location":"API/particula/next/gas/atmosphere_builders/#see-also_1","title":"See also","text":"<ul> <li>GasSpecies</li> </ul>"},{"location":"API/particula/next/gas/atmosphere_builders/#atmospherebuilderbuild","title":"AtmosphereBuilder().build","text":"<p>Show source in atmosphere_builders.py:61</p> <p>Validates the configuration and constructs the Atmosphere object.</p> <p>This method checks that all necessary conditions are met for a valid Atmosphere instance(e.g., at least one species must be present) and then initializes the Atmosphere.</p>"},{"location":"API/particula/next/gas/atmosphere_builders/#returns_1","title":"Returns","text":"<ul> <li><code>Atmosphere</code> - The newly created Atmosphere object, configured as specified.</li> </ul>"},{"location":"API/particula/next/gas/atmosphere_builders/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code> - If no species have been added to the mixture.</li> </ul>"},{"location":"API/particula/next/gas/atmosphere_builders/#signature_2","title":"Signature","text":"<pre><code>def build(self) -&gt; Atmosphere: ...\n</code></pre>"},{"location":"API/particula/next/gas/atmosphere_builders/#see-also_2","title":"See also","text":"<ul> <li>Atmosphere</li> </ul>"},{"location":"API/particula/next/gas/species/","title":"Species","text":"<p>Particula Index / Particula / Next / Gas / Species</p> <p>Auto-generated documentation for particula.next.gas.species module.</p>"},{"location":"API/particula/next/gas/species/#gasspecies","title":"GasSpecies","text":"<p>Show source in species.py:17</p> <p>GasSpecies represents an individual or array of gas species with properties like name, molar mass, vapor pressure, and condensability.</p>"},{"location":"API/particula/next/gas/species/#attributes","title":"Attributes","text":"<ul> <li>name (str): The name of the gas species.</li> <li>molar_mass (float): The molar mass of the gas species.</li> <li>pure_vapor_pressure_strategy (VaporPressureStrategy): The strategy for     calculating the pure vapor pressure of the gas species. Can be a single     strategy or a list of strategies. Default is a constant vapor pressure     strategy with a vapor pressure of 0.0 Pa.</li> <li>condensable (bool): Indicates whether the gas species is condensable.     Default is True.</li> <li>concentration (float): The concentration of the gas species in the     mixture. Default is 0.0 kg/m^3.</li> </ul>"},{"location":"API/particula/next/gas/species/#methods","title":"Methods","text":"<ul> <li><code>-</code> get_molar_mass - Get the molar mass of the gas species.</li> <li><code>-</code> get_condensable - Check if the gas species is condensable.</li> <li><code>-</code> get_concentration - Get the concentration of the gas species in the     mixture.</li> <li><code>-</code> get_pure_vapor_pressure - Calculate the pure vapor pressure of the gas     species at a given temperature.</li> <li><code>-</code> get_partial_pressure - Calculate the partial pressure of the gas species.</li> <li><code>-</code> get_saturation_ratio - Calculate the saturation ratio of the gas species.</li> <li><code>-</code> get_saturation_concentration - Calculate the saturation concentration of     the gas species.</li> <li><code>-</code> add_concentration - Add concentration to the gas species.</li> </ul>"},{"location":"API/particula/next/gas/species/#signature","title":"Signature","text":"<pre><code>class GasSpecies:\n    def __init__(\n        self,\n        name: Union[str, NDArray[np.str_]],\n        molar_mass: Union[float, NDArray[np.float64]],\n        vapor_pressure_strategy: Union[\n            VaporPressureStrategy, list[VaporPressureStrategy]\n        ] = ConstantVaporPressureStrategy(0.0),\n        condensable: Union[bool, NDArray[np.bool_]] = True,\n        concentration: Union[float, NDArray[np.float64]] = 0.0,\n    ) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/next/gas/species/#see-also","title":"See also","text":"<ul> <li>VaporPressureStrategy</li> </ul>"},{"location":"API/particula/next/gas/species/#gasspecieslen","title":"GasSpecies().len","text":"<p>Show source in species.py:70</p> <p>Return the number of gas species.</p>"},{"location":"API/particula/next/gas/species/#signature_1","title":"Signature","text":"<pre><code>def __len__(self): ...\n</code></pre>"},{"location":"API/particula/next/gas/species/#gasspeciesstr","title":"GasSpecies().str","text":"<p>Show source in species.py:66</p> <p>Return a string representation of the GasSpecies object.</p>"},{"location":"API/particula/next/gas/species/#signature_2","title":"Signature","text":"<pre><code>def __str__(self): ...\n</code></pre>"},{"location":"API/particula/next/gas/species/#gasspeciesadd_concentration","title":"GasSpecies().add_concentration","text":"<p>Show source in species.py:272</p> <p>Add concentration to the gas species.</p>"},{"location":"API/particula/next/gas/species/#arguments","title":"Arguments","text":"<ul> <li>added_concentration (float): The concentration to add to the gas     species.</li> </ul>"},{"location":"API/particula/next/gas/species/#signature_3","title":"Signature","text":"<pre><code>def add_concentration(self, added_concentration: Union[float, NDArray[np.float64]]): ...\n</code></pre>"},{"location":"API/particula/next/gas/species/#gasspeciesget_concentration","title":"GasSpecies().get_concentration","text":"<p>Show source in species.py:101</p> <p>Get the concentration of the gas species in the mixture, in kg/m^3.</p>"},{"location":"API/particula/next/gas/species/#returns","title":"Returns","text":"<ul> <li>concentration (float or NDArray[np.float64]): The concentration of     the gas species in the mixture.</li> </ul>"},{"location":"API/particula/next/gas/species/#signature_4","title":"Signature","text":"<pre><code>def get_concentration(self) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/gas/species/#gasspeciesget_condensable","title":"GasSpecies().get_condensable","text":"<p>Show source in species.py:93</p> <p>Check if the gas species is condensable or not.</p>"},{"location":"API/particula/next/gas/species/#returns_1","title":"Returns","text":"<ul> <li>condensable (bool): True if the gas species is condensable, False     otherwise.</li> </ul>"},{"location":"API/particula/next/gas/species/#signature_5","title":"Signature","text":"<pre><code>def get_condensable(self) -&gt; Union[bool, NDArray[np.bool_]]: ...\n</code></pre>"},{"location":"API/particula/next/gas/species/#gasspeciesget_molar_mass","title":"GasSpecies().get_molar_mass","text":"<p>Show source in species.py:85</p> <p>Get the molar mass of the gas species in kg/mol.</p>"},{"location":"API/particula/next/gas/species/#returns_2","title":"Returns","text":"<ul> <li>molar_mass (float or NDArray[np.float64]): The molar mass of the gas     species, in kg/mol.</li> </ul>"},{"location":"API/particula/next/gas/species/#signature_6","title":"Signature","text":"<pre><code>def get_molar_mass(self) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/gas/species/#gasspeciesget_name","title":"GasSpecies().get_name","text":"<p>Show source in species.py:78</p> <p>Get the name of the gas species.</p>"},{"location":"API/particula/next/gas/species/#returns_3","title":"Returns","text":"<ul> <li>name (str or NDArray[np.str_]): The name of the gas species.</li> </ul>"},{"location":"API/particula/next/gas/species/#signature_7","title":"Signature","text":"<pre><code>def get_name(self) -&gt; Union[str, NDArray[np.str_]]: ...\n</code></pre>"},{"location":"API/particula/next/gas/species/#gasspeciesget_partial_pressure","title":"GasSpecies().get_partial_pressure","text":"<p>Show source in species.py:146</p> <p>Calculate the partial pressure of the gas based on the vapor pressure strategy. This method accounts for multiple strategies if assigned and calculates partial pressure for each strategy based on the corresponding concentration and molar mass.</p>"},{"location":"API/particula/next/gas/species/#arguments_1","title":"Arguments","text":"<ul> <li>temperature (float or NDArray[np.float64]): The temperature in Kelvin at which to calculate the partial pressure.</li> </ul>"},{"location":"API/particula/next/gas/species/#returns_4","title":"Returns","text":"<ul> <li>partial_pressure (float or NDArray[np.float64]): Partial pressure of the gas in Pascals.</li> </ul>"},{"location":"API/particula/next/gas/species/#raises","title":"Raises","text":"<ul> <li><code>-</code> ValueError - If the vapor pressure strategy is not set.</li> </ul>"},{"location":"API/particula/next/gas/species/#signature_8","title":"Signature","text":"<pre><code>def get_partial_pressure(\n    self, temperature: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/gas/species/#gasspeciesget_pure_vapor_pressure","title":"GasSpecies().get_pure_vapor_pressure","text":"<p>Show source in species.py:110</p> <p>Calculate the pure vapor pressure of the gas species at a given temperature in Kelvin.</p> <p>This method supports both a single strategy or a list of strategies for calculating vapor pressure.</p>"},{"location":"API/particula/next/gas/species/#arguments_2","title":"Arguments","text":"<ul> <li>temperature (float or NDArray[np.float64]): The temperature in Kelvin at which to calculate vapor pressure.</li> </ul>"},{"location":"API/particula/next/gas/species/#returns_5","title":"Returns","text":"<ul> <li>vapor_pressure (float or NDArray[np.float64]): The calculated pure vapor pressure in Pascals.</li> </ul>"},{"location":"API/particula/next/gas/species/#raises_1","title":"Raises","text":"<ul> <li><code>ValueError</code> - If no vapor pressure strategy is set.</li> </ul>"},{"location":"API/particula/next/gas/species/#signature_9","title":"Signature","text":"<pre><code>def get_pure_vapor_pressure(\n    self, temperature: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/gas/species/#gasspeciesget_saturation_concentration","title":"GasSpecies().get_saturation_concentration","text":"<p>Show source in species.py:232</p> <p>Calculate the saturation concentration of the gas based on the vapor pressure strategy. This method accounts for multiple strategies if assigned and calculates saturation concentration for each strategy based on the molar mass.</p>"},{"location":"API/particula/next/gas/species/#arguments_3","title":"Arguments","text":"<ul> <li>temperature (float or NDArray[np.float64]): The temperature in Kelvin at which to calculate the partial pressure.</li> </ul>"},{"location":"API/particula/next/gas/species/#returns_6","title":"Returns","text":"<ul> <li>saturation_concentration (float or NDArray[np.float64]): The saturation concentration of the gas</li> </ul>"},{"location":"API/particula/next/gas/species/#raises_2","title":"Raises","text":"<ul> <li><code>-</code> ValueError - If the vapor pressure strategy is not set.</li> </ul>"},{"location":"API/particula/next/gas/species/#signature_10","title":"Signature","text":"<pre><code>def get_saturation_concentration(\n    self, temperature: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/gas/species/#gasspeciesget_saturation_ratio","title":"GasSpecies().get_saturation_ratio","text":"<p>Show source in species.py:189</p> <p>Calculate the saturation ratio of the gas based on the vapor pressure strategy. This method accounts for multiple strategies if assigned and calculates saturation ratio for each strategy based on the corresponding concentration and molar mass.</p>"},{"location":"API/particula/next/gas/species/#arguments_4","title":"Arguments","text":"<ul> <li>temperature (float or NDArray[np.float64]): The temperature in Kelvin at which to calculate the partial pressure.</li> </ul>"},{"location":"API/particula/next/gas/species/#returns_7","title":"Returns","text":"<ul> <li>saturation_ratio (float or NDArray[np.float64]): The saturation ratio of the gas</li> </ul>"},{"location":"API/particula/next/gas/species/#raises_3","title":"Raises","text":"<ul> <li><code>-</code> ValueError - If the vapor pressure strategy is not set.</li> </ul>"},{"location":"API/particula/next/gas/species/#signature_11","title":"Signature","text":"<pre><code>def get_saturation_ratio(\n    self, temperature: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/gas/species_builders/","title":"Species Builders","text":"<p>Particula Index / Particula / Next / Gas / Species Builders</p> <p>Auto-generated documentation for particula.next.gas.species_builders module.</p>"},{"location":"API/particula/next/gas/species_builders/#gasspeciesbuilder","title":"GasSpeciesBuilder","text":"<p>Show source in species_builders.py:26</p> <p>Builder class for GasSpecies objects, allowing for a more fluent and readable creation of GasSpecies instances with optional parameters.</p>"},{"location":"API/particula/next/gas/species_builders/#attributes","title":"Attributes","text":"<ul> <li><code>name</code> - The name of the gas species.</li> <li><code>molar_mass</code> - The molar mass of the gas species in kg/mol.</li> <li><code>vapor_pressure_strategy</code> - The vapor pressure strategy for the     gas species.</li> <li><code>condensable</code> - Whether the gas species is condensable.</li> <li><code>concentration</code> - The concentration of the gas species in the     mixture, in kg/m^3.</li> </ul>"},{"location":"API/particula/next/gas/species_builders/#methods","title":"Methods","text":"<ul> <li><code>set_name</code> - Set the name of the gas species.</li> <li><code>set_molar_mass</code> - Set the molar mass of the gas species in kg/mol.</li> <li><code>set_vapor_pressure_strategy</code> - Set the vapor pressure strategy     for the gas species.</li> <li><code>set_condensable</code> - Set the condensable bool of the gas species.</li> <li><code>set_concentration</code> - Set the concentration of the gas species in the     mixture, in kg/m^3.</li> <li><code>set_parameters</code> - Set the parameters of the GasSpecies object from     a dictionary including optional units.</li> </ul>"},{"location":"API/particula/next/gas/species_builders/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code> - If any required key is missing. During check_keys and     pre_build_check. Or if trying to set an invalid parameter.</li> <li><code>Warning</code> - If using default units for any parameter.</li> </ul>"},{"location":"API/particula/next/gas/species_builders/#signature","title":"Signature","text":"<pre><code>class GasSpeciesBuilder(BuilderABC, BuilderMolarMassMixin, BuilderConcentrationMixin):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/gas/species_builders/#see-also","title":"See also","text":"<ul> <li>BuilderABC</li> <li>BuilderConcentrationMixin</li> <li>BuilderMolarMassMixin</li> </ul>"},{"location":"API/particula/next/gas/species_builders/#gasspeciesbuilderbuild","title":"GasSpeciesBuilder().build","text":"<p>Show source in species_builders.py:94</p> <p>Validate and return the GasSpecies object.</p>"},{"location":"API/particula/next/gas/species_builders/#signature_1","title":"Signature","text":"<pre><code>def build(self) -&gt; GasSpecies: ...\n</code></pre>"},{"location":"API/particula/next/gas/species_builders/#see-also_1","title":"See also","text":"<ul> <li>GasSpecies</li> </ul>"},{"location":"API/particula/next/gas/species_builders/#gasspeciesbuilderset_condensable","title":"GasSpeciesBuilder().set_condensable","text":"<p>Show source in species_builders.py:86</p> <p>Set the condensable bool of the gas species.</p>"},{"location":"API/particula/next/gas/species_builders/#signature_2","title":"Signature","text":"<pre><code>def set_condensable(self, condensable: Union[bool, NDArray[np.bool_]]): ...\n</code></pre>"},{"location":"API/particula/next/gas/species_builders/#gasspeciesbuilderset_name","title":"GasSpeciesBuilder().set_name","text":"<p>Show source in species_builders.py:73</p> <p>Set the name of the gas species.</p>"},{"location":"API/particula/next/gas/species_builders/#signature_3","title":"Signature","text":"<pre><code>def set_name(self, name: Union[str, NDArray[np.str_]]): ...\n</code></pre>"},{"location":"API/particula/next/gas/species_builders/#gasspeciesbuilderset_vapor_pressure_strategy","title":"GasSpeciesBuilder().set_vapor_pressure_strategy","text":"<p>Show source in species_builders.py:78</p> <p>Set the vapor pressure strategy for the gas species.</p>"},{"location":"API/particula/next/gas/species_builders/#signature_4","title":"Signature","text":"<pre><code>def set_vapor_pressure_strategy(\n    self, strategy: Union[VaporPressureStrategy, list[VaporPressureStrategy]]\n): ...\n</code></pre>"},{"location":"API/particula/next/gas/species_builders/#see-also_2","title":"See also","text":"<ul> <li>VaporPressureStrategy</li> </ul>"},{"location":"API/particula/next/gas/species_builders/#presetgasspeciesbuilder","title":"PresetGasSpeciesBuilder","text":"<p>Show source in species_builders.py:107</p> <p>Builder class for GasSpecies objects, allowing for a more fluent and readable creation of GasSpecies instances with optional parameters.</p>"},{"location":"API/particula/next/gas/species_builders/#signature_5","title":"Signature","text":"<pre><code>class PresetGasSpeciesBuilder(GasSpeciesBuilder):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/gas/species_builders/#see-also_3","title":"See also","text":"<ul> <li>GasSpeciesBuilder</li> </ul>"},{"location":"API/particula/next/gas/species_builders/#presetgasspeciesbuilderbuild","title":"PresetGasSpeciesBuilder().build","text":"<p>Show source in species_builders.py:125</p>"},{"location":"API/particula/next/gas/species_builders/#signature_6","title":"Signature","text":"<pre><code>def build(self) -&gt; GasSpecies: ...\n</code></pre>"},{"location":"API/particula/next/gas/species_builders/#see-also_4","title":"See also","text":"<ul> <li>GasSpecies</li> </ul>"},{"location":"API/particula/next/gas/species_factories/","title":"Species Factories","text":"<p>Particula Index / Particula / Next / Gas / Species Factories</p> <p>Auto-generated documentation for particula.next.gas.species_factories module.</p>"},{"location":"API/particula/next/gas/species_factories/#gasspeciesfactory","title":"GasSpeciesFactory","text":"<p>Show source in species_factories.py:12</p> <p>Factory class to create species builders</p> <p>Factory class to create species builders for creating gas species.</p>"},{"location":"API/particula/next/gas/species_factories/#methods","title":"Methods","text":"<ul> <li><code>get_builders</code> - Returns the mapping of strategy types to builder instances.</li> <li><code>get_strategy</code> - Gets the strategy instance for the specified strategy type.<ul> <li><code>strategy_type</code> - Type of species builder to use, can be 'gas_species' or 'preset_gas_species'.</li> <li><code>parameters</code> - Parameters required for the builder, dependent on the chosen strategy type.</li> </ul> </li> </ul>"},{"location":"API/particula/next/gas/species_factories/#returns","title":"Returns","text":"<ul> <li><code>GasSpecies</code> - An instance of the specified GasSpecies.</li> </ul>"},{"location":"API/particula/next/gas/species_factories/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code> - If an unknown strategy type is provided.</li> </ul>"},{"location":"API/particula/next/gas/species_factories/#signature","title":"Signature","text":"<pre><code>class GasSpeciesFactory(\n    StrategyFactory[Union[GasSpeciesBuilder, PresetGasSpeciesBuilder], GasSpecies]\n): ...\n</code></pre>"},{"location":"API/particula/next/gas/species_factories/#see-also","title":"See also","text":"<ul> <li>GasSpeciesBuilder</li> <li>GasSpecies</li> <li>PresetGasSpeciesBuilder</li> </ul>"},{"location":"API/particula/next/gas/species_factories/#gasspeciesfactoryget_builders","title":"GasSpeciesFactory().get_builders","text":"<p>Show source in species_factories.py:42</p> <p>Returns the mapping of strategy types to builder instances.</p>"},{"location":"API/particula/next/gas/species_factories/#returns_1","title":"Returns","text":"<p>A dictionary mapping strategy types to builder instances.     - <code>-</code> gas_species - GasSpeciesBuilder     - <code>-</code> preset_gas_species - PresetGasSpeciesBuilder</p>"},{"location":"API/particula/next/gas/species_factories/#signature_1","title":"Signature","text":"<pre><code>def get_builders(self): ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_builders/","title":"Vapor Pressure Builders","text":"<p>Particula Index / Particula / Next / Gas / Vapor Pressure Builders</p> <p>Auto-generated documentation for particula.next.gas.vapor_pressure_builders module.</p>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#antoinebuilder","title":"AntoineBuilder","text":"<p>Show source in vapor_pressure_builders.py:17</p> <p>Builder class for AntoineVaporPressureStrategy. It allows setting the coefficients 'a', 'b', and 'c' separately and then building the strategy object.</p> <ul> <li>Equation: log10(P_mmHG) = a - b / (Temperature_K - c)</li> <li>Units: 'a_units' = None, 'b_units' = 'K', 'c_units' = 'K'</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#methods","title":"Methods","text":"<ul> <li>set_a(a, a_units): Set the coefficient 'a' of the Antoine equation.</li> <li>set_b(b, b_units): Set the coefficient 'b' of the Antoine equation.</li> <li>set_c(c, c_units): Set the coefficient 'c' of the Antoine equation.</li> <li><code>-</code> set_parameters(params) - Set coefficients from a dictionary including     optional units.</li> <li><code>-</code> build() - Build the AntoineVaporPressureStrategy object with the set     coefficients.</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#signature","title":"Signature","text":"<pre><code>class AntoineBuilder(BuilderABC):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#see-also","title":"See also","text":"<ul> <li>BuilderABC</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#antoinebuilderbuild","title":"AntoineBuilder().build","text":"<p>Show source in vapor_pressure_builders.py:70</p> <p>Build the AntoineVaporPressureStrategy object with the set coefficients.</p>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#signature_1","title":"Signature","text":"<pre><code>def build(self): ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#antoinebuilderset_a","title":"AntoineBuilder().set_a","text":"<p>Show source in vapor_pressure_builders.py:44</p> <p>Set the coefficient 'a' of the Antoine equation.</p>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#signature_2","title":"Signature","text":"<pre><code>def set_a(self, a: float, a_units: Optional[str] = None): ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#antoinebuilderset_b","title":"AntoineBuilder().set_b","text":"<p>Show source in vapor_pressure_builders.py:54</p> <p>Set the coefficient 'b' of the Antoine equation.</p>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#signature_3","title":"Signature","text":"<pre><code>def set_b(self, b: float, b_units: str = \"K\"): ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#antoinebuilderset_c","title":"AntoineBuilder().set_c","text":"<p>Show source in vapor_pressure_builders.py:62</p> <p>Set the coefficient 'c' of the Antoine equation.</p>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#signature_4","title":"Signature","text":"<pre><code>def set_c(self, c: float, c_units: str = \"K\"): ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#clausiusclapeyronbuilder","title":"ClausiusClapeyronBuilder","text":"<p>Show source in vapor_pressure_builders.py:78</p> <p>Builder class for ClausiusClapeyronStrategy. This class facilitates setting the latent heat of vaporization, initial temperature, and initial pressure with unit handling and then builds the strategy object.</p> <ul> <li>Equation: dP/dT = L / (R * T^2)</li> <li>Units: 'latent_heat_units' = 'J/kg', 'temperature_initial_units' = 'K',     'pressure_initial_units' = 'Pa'</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#methods_1","title":"Methods","text":"<ul> <li>set_latent_heat(latent_heat, latent_heat_units): Set the latent heat of     vaporization.</li> <li>set_temperature_initial(temperature_initial, temperature_initial_units):     Set the initial temperature.</li> <li>set_pressure_initial(pressure_initial, pressure_initial_units): Set the     initial pressure.</li> <li><code>-</code> set_parameters(parameters) - Set parameters from a dictionary including     optional units.</li> <li><code>-</code> build() - Build the ClausiusClapeyronStrategy object with the set     parameters.</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#signature_5","title":"Signature","text":"<pre><code>class ClausiusClapeyronBuilder(BuilderABC):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#see-also_1","title":"See also","text":"<ul> <li>BuilderABC</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#clausiusclapeyronbuilderbuild","title":"ClausiusClapeyronBuilder().build","text":"<p>Show source in vapor_pressure_builders.py:149</p> <p>Build and return a ClausiusClapeyronStrategy object with the set parameters.</p>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#signature_6","title":"Signature","text":"<pre><code>def build(self): ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#clausiusclapeyronbuilderset_latent_heat","title":"ClausiusClapeyronBuilder().set_latent_heat","text":"<p>Show source in vapor_pressure_builders.py:111</p> <p>Set the latent heat of vaporization: Default units J/kg.</p>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#signature_7","title":"Signature","text":"<pre><code>def set_latent_heat(self, latent_heat: float, latent_heat_units: str = \"J/kg\"): ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#clausiusclapeyronbuilderset_pressure_initial","title":"ClausiusClapeyronBuilder().set_pressure_initial","text":"<p>Show source in vapor_pressure_builders.py:136</p> <p>Set the initial pressure. Default units: Pa.</p>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#signature_8","title":"Signature","text":"<pre><code>def set_pressure_initial(\n    self, pressure_initial: float, pressure_initial_units: str = \"Pa\"\n): ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#clausiusclapeyronbuilderset_temperature_initial","title":"ClausiusClapeyronBuilder().set_temperature_initial","text":"<p>Show source in vapor_pressure_builders.py:123</p> <p>Set the initial temperature. Default units: K.</p>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#signature_9","title":"Signature","text":"<pre><code>def set_temperature_initial(\n    self, temperature_initial: float, temperature_initial_units: str = \"K\"\n): ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#constantbuilder","title":"ConstantBuilder","text":"<p>Show source in vapor_pressure_builders.py:160</p> <p>Builder class for ConstantVaporPressureStrategy. This class facilitates setting the constant vapor pressure and then building the strategy object.</p> <ul> <li>Equation: P = vapor_pressure</li> <li>Units: 'vapor_pressure_units' = 'Pa'</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#methods_2","title":"Methods","text":"<ul> <li>set_vapor_pressure(constant, constant_units): Set the constant vapor pressure.</li> <li><code>-</code> set_parameters(parameters) - Set parameters from a dictionary including     optional units.</li> <li><code>-</code> build() - Build the ConstantVaporPressureStrategy object with the set     parameters.</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#signature_10","title":"Signature","text":"<pre><code>class ConstantBuilder(BuilderABC):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#see-also_2","title":"See also","text":"<ul> <li>BuilderABC</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#constantbuilderbuild","title":"ConstantBuilder().build","text":"<p>Show source in vapor_pressure_builders.py:194</p> <p>Build and return a ConstantVaporPressureStrategy object with the set parameters.</p>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#signature_11","title":"Signature","text":"<pre><code>def build(self): ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#constantbuilderset_vapor_pressure","title":"ConstantBuilder().set_vapor_pressure","text":"<p>Show source in vapor_pressure_builders.py:182</p> <p>Set the constant vapor pressure.</p>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#signature_12","title":"Signature","text":"<pre><code>def set_vapor_pressure(\n    self, vapor_pressure: float, vapor_pressure_units: str = \"Pa\"\n): ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#waterbuckbuilder","title":"WaterBuckBuilder","text":"<p>Show source in vapor_pressure_builders.py:201</p> <p>Builder class for WaterBuckStrategy. This class facilitates the building of the WaterBuckStrategy object. Which as of now has no additional parameters to set. But could be extended in the future for ice only calculations. We keep the builder for consistency.</p>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#methods_3","title":"Methods","text":"<ul> <li><code>-</code> build() - Build the WaterBuckStrategy object.</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#signature_13","title":"Signature","text":"<pre><code>class WaterBuckBuilder(BuilderABC):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#see-also_3","title":"See also","text":"<ul> <li>BuilderABC</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#waterbuckbuilderbuild","title":"WaterBuckBuilder().build","text":"<p>Show source in vapor_pressure_builders.py:215</p> <p>Build and return a WaterBuckStrategy object.</p>"},{"location":"API/particula/next/gas/vapor_pressure_builders/#signature_14","title":"Signature","text":"<pre><code>def build(self): ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_factories/","title":"Vapor Pressure Factories","text":"<p>Particula Index / Particula / Next / Gas / Vapor Pressure Factories</p> <p>Auto-generated documentation for particula.next.gas.vapor_pressure_factories module.</p>"},{"location":"API/particula/next/gas/vapor_pressure_factories/#vaporpressurefactory","title":"VaporPressureFactory","text":"<p>Show source in vapor_pressure_factories.py:20</p> <p>Factory class to create vapor pressure strategy builders</p> <p>Factory class to create vapor pressure strategy builders for calculating vapor pressure of gas species.</p>"},{"location":"API/particula/next/gas/vapor_pressure_factories/#methods","title":"Methods","text":"<ul> <li><code>get_builders()</code> - Returns the mapping of strategy types to builder instances.</li> <li><code>get_strategy(strategy_type,</code> parameters) - Gets the strategy instance for the specified strategy type.<ul> <li><code>strategy_type</code> - Type of vapor pressure strategy to use, can be 'constant', 'antoine', 'clausius_clapeyron', or 'water_buck'. parameters(Dict[str, Any], optional): Parameters required for the builder, dependent on the chosen strategy type.<ul> <li><code>-</code> constant - constant_vapor_pressure</li> <li><code>-</code> antoine - A, B, C</li> <li><code>-</code> clausius_clapeyron - A, B, C</li> <li><code>-</code> water_buck - No parameters are required.</li> </ul> </li> </ul> </li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_factories/#returns","title":"Returns","text":"<ul> <li><code>VaporPressureStrategy</code> - An instance of the specified     VaporPressureStrategy.</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_factories/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code> - If an unknown strategy type is provided.</li> <li><code>ValueError</code> - If any required key is missing during check_keys or     pre_build_check, or if trying to set an invalid parameter.</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_factories/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; strategy_is = VaporPressureFactory().get_strategy(\"constant\")\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_factories/#signature","title":"Signature","text":"<pre><code>class VaporPressureFactory(\n    StrategyFactory[\n        Union[\n            ConstantBuilder, AntoineBuilder, ClausiusClapeyronBuilder, WaterBuckBuilder\n        ],\n        Union[\n            ConstantVaporPressureStrategy,\n            AntoineVaporPressureStrategy,\n            ClausiusClapeyronStrategy,\n            WaterBuckStrategy,\n        ],\n    ]\n): ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_factories/#see-also","title":"See also","text":"<ul> <li>AntoineBuilder</li> <li>AntoineVaporPressureStrategy</li> <li>ClausiusClapeyronBuilder</li> <li>ClausiusClapeyronStrategy</li> <li>ConstantBuilder</li> <li>ConstantVaporPressureStrategy</li> <li>WaterBuckBuilder</li> <li>WaterBuckStrategy</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_factories/#vaporpressurefactoryget_builders","title":"VaporPressureFactory().get_builders","text":"<p>Show source in vapor_pressure_factories.py:68</p> <p>Returns the mapping of strategy types to builder instances.</p>"},{"location":"API/particula/next/gas/vapor_pressure_factories/#returns_1","title":"Returns","text":"<p>A dictionary mapping strategy types to builder instances.     - <code>-</code> constant - ConstantBuilder     - <code>-</code> antoine - AntoineBuilder     - <code>-</code> clausius_clapeyron - ClausiusClapeyronBuilder     - <code>-</code> water_buck - WaterBuckBuilder</p>"},{"location":"API/particula/next/gas/vapor_pressure_factories/#signature_1","title":"Signature","text":"<pre><code>def get_builders(self): ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/","title":"Vapor Pressure Strategies","text":"<p>Particula Index / Particula / Next / Gas / Vapor Pressure Strategies</p> <p>Auto-generated documentation for particula.next.gas.vapor_pressure_strategies module.</p>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#antoinevaporpressurestrategy","title":"AntoineVaporPressureStrategy","text":"<p>Show source in vapor_pressure_strategies.py:162</p> <p>Concrete implementation of the VaporPressureStrategy using the Antoine equation for vapor pressure calculations.</p>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#signature","title":"Signature","text":"<pre><code>class AntoineVaporPressureStrategy(VaporPressureStrategy):\n    def __init__(\n        self,\n        a: Union[float, NDArray[np.float64]] = 0.0,\n        b: Union[float, NDArray[np.float64]] = 0.0,\n        c: Union[float, NDArray[np.float64]] = 0.0,\n    ): ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#see-also","title":"See also","text":"<ul> <li>VaporPressureStrategy</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#antoinevaporpressurestrategypure_vapor_pressure","title":"AntoineVaporPressureStrategy().pure_vapor_pressure","text":"<p>Show source in vapor_pressure_strategies.py:178</p> <p>Calculate vapor pressure using the Antoine equation.</p>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#arguments","title":"Arguments","text":"<p>a, b, c: Antoine equation parameters. - <code>temperature</code> - Temperature in Kelvin.</p>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#returns","title":"Returns","text":"<p>Vapor pressure in Pascals.</p>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#references","title":"References","text":"<ul> <li><code>-</code> Equation - log10(P) = a - b / (T - c)</li> <li>https://en.wikipedia.org/wiki/Antoine_equation (but in Kelvin)</li> <li>Kelvin form:     https://onlinelibrary.wiley.com/doi/pdf/10.1002/9781118135341.app1</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#signature_1","title":"Signature","text":"<pre><code>def pure_vapor_pressure(\n    self, temperature: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#clausiusclapeyronstrategy","title":"ClausiusClapeyronStrategy","text":"<p>Show source in vapor_pressure_strategies.py:202</p> <p>Concrete implementation of the VaporPressureStrategy using the Clausius-Clapeyron equation for vapor pressure calculations.</p>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#signature_2","title":"Signature","text":"<pre><code>class ClausiusClapeyronStrategy(VaporPressureStrategy):\n    def __init__(\n        self,\n        latent_heat: Union[float, NDArray[np.float64]],\n        temperature_initial: Union[float, NDArray[np.float64]],\n        pressure_initial: Union[float, NDArray[np.float64]],\n    ): ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#see-also_1","title":"See also","text":"<ul> <li>VaporPressureStrategy</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#clausiusclapeyronstrategypure_vapor_pressure","title":"ClausiusClapeyronStrategy().pure_vapor_pressure","text":"<p>Show source in vapor_pressure_strategies.py:231</p> <p>Calculate vapor pressure using Clausius-Clapeyron equation.</p>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#arguments_1","title":"Arguments","text":"<ul> <li><code>latent_heat</code> - Latent heat of vaporization in J/mol.</li> <li><code>temperature_initial</code> - Initial temperature in Kelvin.</li> <li><code>pressure_initial</code> - Initial vapor pressure in Pascals.</li> <li><code>temperature</code> - Final temperature in Kelvin.</li> <li><code>gas_constant</code> - gas constant (default is 8.314 J/(mol\u00b7K)).</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#returns_1","title":"Returns","text":"<p>Pure vapor pressure in Pascals.</p>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#references_1","title":"References","text":"<ul> <li>https://en.wikipedia.org/wiki/Clausius%E2%80%93Clapeyron_relation</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#signature_3","title":"Signature","text":"<pre><code>def pure_vapor_pressure(\n    self, temperature: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#constantvaporpressurestrategy","title":"ConstantVaporPressureStrategy","text":"<p>Show source in vapor_pressure_strategies.py:136</p> <p>Concrete implementation of the VaporPressureStrategy using a constant vapor pressure value.</p>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#signature_4","title":"Signature","text":"<pre><code>class ConstantVaporPressureStrategy(VaporPressureStrategy):\n    def __init__(self, vapor_pressure: Union[float, NDArray[np.float64]]): ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#see-also_2","title":"See also","text":"<ul> <li>VaporPressureStrategy</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#constantvaporpressurestrategypure_vapor_pressure","title":"ConstantVaporPressureStrategy().pure_vapor_pressure","text":"<p>Show source in vapor_pressure_strategies.py:143</p> <p>Return the constant vapor pressure value.</p>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#arguments_2","title":"Arguments","text":"<ul> <li>temperature (float or NDArray[np.float64]): Not used.</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#returns_2","title":"Returns","text":"<ul> <li>vapor_pressure (float or NDArray[np.float64]): The constant vapor pressure value in Pascals.</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#signature_5","title":"Signature","text":"<pre><code>def pure_vapor_pressure(\n    self, temperature: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#vaporpressurestrategy","title":"VaporPressureStrategy","text":"<p>Show source in vapor_pressure_strategies.py:28</p> <p>Abstract class for vapor pressure calculations. The methods defined here must be implemented by subclasses below.</p>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#signature_6","title":"Signature","text":"<pre><code>class VaporPressureStrategy(ABC): ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#vaporpressurestrategyconcentration","title":"VaporPressureStrategy().concentration","text":"<p>Show source in vapor_pressure_strategies.py:56</p> <p>Calculate the concentration of the gas at a given pressure and temperature.</p>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#arguments_3","title":"Arguments","text":"<ul> <li>VaporPressureStrategy().partial_pressure - Pressure in Pascals.</li> <li><code>molar_mass</code> - Molar mass of the gas in kg/mol.</li> <li><code>temperature</code> - Temperature in Kelvin.</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#returns_3","title":"Returns","text":"<ul> <li><code>concentration</code> - The concentration of the gas in kg/m^3.</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#signature_7","title":"Signature","text":"<pre><code>def concentration(\n    self,\n    partial_pressure: Union[float, NDArray[np.float64]],\n    molar_mass: Union[float, NDArray[np.float64]],\n    temperature: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#vaporpressurestrategypartial_pressure","title":"VaporPressureStrategy().partial_pressure","text":"<p>Show source in vapor_pressure_strategies.py:32</p> <p>Calculate the partial pressure of the gas from its concentration, molar mass, and temperature.</p>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#arguments_4","title":"Arguments","text":"<p>concentration (float or NDArray[np.float64]): Concentration of the     gas in kg/m^3. molar_mass (float or NDArray[np.float64]): Molar mass of the gas in     kg/mol. temperature (float or NDArray[np.float64]): Temperature in Kelvin.</p>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#returns_4","title":"Returns","text":"<ul> <li><code>partial_pressure</code> - Partial pressure of the gas in Pascals.</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#signature_8","title":"Signature","text":"<pre><code>def partial_pressure(\n    self,\n    concentration: Union[float, NDArray[np.float64]],\n    molar_mass: Union[float, NDArray[np.float64]],\n    temperature: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#vaporpressurestrategypure_vapor_pressure","title":"VaporPressureStrategy().pure_vapor_pressure","text":"<p>Show source in vapor_pressure_strategies.py:124</p> <p>Calculate the pure (saturation) vapor pressure at a given temperature. Units are in Pascals Pa=kg/(m\u00b7s\u00b2).</p>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#arguments_5","title":"Arguments","text":"<p>temperature (float or NDArray[np.float64]): Temperature in Kelvin.</p>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#signature_9","title":"Signature","text":"<pre><code>@abstractmethod\ndef pure_vapor_pressure(\n    self, temperature: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#vaporpressurestrategysaturation_concentration","title":"VaporPressureStrategy().saturation_concentration","text":"<p>Show source in vapor_pressure_strategies.py:99</p> <p>Calculate the saturation concentration of the gas at a given temperature.</p>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#arguments_6","title":"Arguments","text":"<ul> <li>molar_mass (float or NDArray[np.float64]): Molar mass of the gas in kg/mol.</li> <li>temperature (float or NDArray[np.float64]): Temperature in Kelvin.</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#returns_5","title":"Returns","text":"<ul> <li>saturation_concentration (float or NDArray[np.float64]): The saturation concentration of the gas in kg/m^3.</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#signature_10","title":"Signature","text":"<pre><code>def saturation_concentration(\n    self,\n    molar_mass: Union[float, NDArray[np.float64]],\n    temperature: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#vaporpressurestrategysaturation_ratio","title":"VaporPressureStrategy().saturation_ratio","text":"<p>Show source in vapor_pressure_strategies.py:78</p> <p>Calculate the saturation ratio of the gas at a given pressure and temperature.</p>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#arguments_7","title":"Arguments","text":"<ul> <li><code>pressure</code> - Pressure in Pascals.</li> <li><code>temperature</code> - Temperature in Kelvin.</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#returns_6","title":"Returns","text":"<ul> <li><code>saturation_ratio</code> - The saturation ratio of the gas.</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#signature_11","title":"Signature","text":"<pre><code>def saturation_ratio(\n    self,\n    concentration: Union[float, NDArray[np.float64]],\n    molar_mass: Union[float, NDArray[np.float64]],\n    temperature: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#waterbuckstrategy","title":"WaterBuckStrategy","text":"<p>Show source in vapor_pressure_strategies.py:258</p> <p>Concrete implementation of the VaporPressureStrategy using the Buck equation for water vapor pressure calculations.</p>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#signature_12","title":"Signature","text":"<pre><code>class WaterBuckStrategy(VaporPressureStrategy): ...\n</code></pre>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#see-also_3","title":"See also","text":"<ul> <li>VaporPressureStrategy</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#waterbuckstrategypure_vapor_pressure","title":"WaterBuckStrategy().pure_vapor_pressure","text":"<p>Show source in vapor_pressure_strategies.py:262</p> <p>Calculate vapor pressure using the Buck equation for water vapor.</p>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#arguments_8","title":"Arguments","text":"<ul> <li><code>temperature</code> - Temperature in Kelvin.</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#returns_7","title":"Returns","text":"<p>Vapor pressure in Pascals.</p>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#references_2","title":"References","text":"<ul> <li>Buck, A. L., 1981: New Equations for Computing Vapor Pressure and     Enhancement Factor. J. Appl. Meteor. Climatol., 20, 1527-1532,     https://doi.org/10.1175/1520-0450(1981)020&lt;1527:NEFCVP&gt;2.0.CO;2.</li> <li>https://en.wikipedia.org/wiki/Arden_Buck_equation</li> </ul>"},{"location":"API/particula/next/gas/vapor_pressure_strategies/#signature_13","title":"Signature","text":"<pre><code>def pure_vapor_pressure(\n    self, temperature: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/gas/properties/","title":"Properties","text":"<p>Particula Index / Particula / Next / Gas / Properties</p> <p>Auto-generated documentation for particula.next.gas.properties module.</p>"},{"location":"API/particula/next/gas/properties/#modules","title":"Modules","text":"<ul> <li>Concentration Function</li> <li>Dynamic Viscosity</li> <li>Mean Free Path</li> <li>Pressure Function</li> <li>Thermal Conductivity</li> <li>Vapor Pressure Module</li> </ul>"},{"location":"API/particula/next/gas/properties/concentration_function/","title":"Concentration Function","text":"<p>Particula Index / Particula / Next / Gas / Properties / Concentration Function</p> <p>Auto-generated documentation for particula.next.gas.properties.concentration_function module.</p>"},{"location":"API/particula/next/gas/properties/concentration_function/#calculate_concentration","title":"calculate_concentration","text":"<p>Show source in concentration_function.py:11</p> <p>Calculate the concentration of a gas from its partial pressure, molar mass, and temperature using the ideal gas law.</p>"},{"location":"API/particula/next/gas/properties/concentration_function/#arguments","title":"Arguments","text":"<ul> <li>pressure (float or NDArray[np.float64]): Partial pressure of the gas in Pascals (Pa).</li> <li>molar_mass (float or NDArray[np.float64]): Molar mass of the gas in kg/mol</li> <li>temperature (float or NDArray[np.float64]): Temperature in Kelvin.</li> </ul>"},{"location":"API/particula/next/gas/properties/concentration_function/#returns","title":"Returns","text":"<ul> <li>concentration (float or NDArray[np.float64]): Concentration of the gas in kg/m^3.</li> </ul>"},{"location":"API/particula/next/gas/properties/concentration_function/#signature","title":"Signature","text":"<pre><code>def calculate_concentration(\n    partial_pressure: Union[float, NDArray[np.float64]],\n    molar_mass: Union[float, NDArray[np.float64]],\n    temperature: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/gas/properties/dynamic_viscosity/","title":"Dynamic Viscosity","text":"<p>Particula Index / Particula / Next / Gas / Properties / Dynamic Viscosity</p> <p>Auto-generated documentation for particula.next.gas.properties.dynamic_viscosity module.</p>"},{"location":"API/particula/next/gas/properties/dynamic_viscosity/#get_dynamic_viscosity","title":"get_dynamic_viscosity","text":"<p>Show source in dynamic_viscosity.py:22</p> <p>Calculates the dynamic viscosity of air via Sutherland's formula, which is a common method in fluid dynamics for gases that involves temperature adjustments.</p>"},{"location":"API/particula/next/gas/properties/dynamic_viscosity/#arguments","title":"Arguments","text":"<ul> <li><code>-</code> temperature - Desired air temperature [K]. Must be greater than 0.</li> <li><code>-</code> reference_viscosity - Gas viscosity [Pa*s] at the reference temperature (default is STP).</li> <li><code>-</code> reference_temperature - Gas temperature [K] for the reference viscosity (default is STP).</li> </ul>"},{"location":"API/particula/next/gas/properties/dynamic_viscosity/#returns","title":"Returns","text":"<ul> <li><code>-</code> float - The dynamic viscosity of air at the given temperature [Pa*s].</li> </ul>"},{"location":"API/particula/next/gas/properties/dynamic_viscosity/#raises","title":"Raises","text":"<ul> <li><code>-</code> ValueError - If the temperature is less than or equal to 0.</li> </ul>"},{"location":"API/particula/next/gas/properties/dynamic_viscosity/#references","title":"References","text":"<p>https://resources.wolframcloud.com/FormulaRepository/resources/Sutherlands-Formula</p>"},{"location":"API/particula/next/gas/properties/dynamic_viscosity/#signature","title":"Signature","text":"<pre><code>def get_dynamic_viscosity(\n    temperature: float,\n    reference_viscosity: float = REF_VISCOSITY_AIR_STP.m,\n    reference_temperature: float = REF_TEMPERATURE_STP.m,\n) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/next/gas/properties/mean_free_path/","title":"Mean Free Path","text":"<p>Particula Index / Particula / Next / Gas / Properties / Mean Free Path</p> <p>Auto-generated documentation for particula.next.gas.properties.mean_free_path module.</p>"},{"location":"API/particula/next/gas/properties/mean_free_path/#molecule_mean_free_path","title":"molecule_mean_free_path","text":"<p>Show source in mean_free_path.py:27</p> <p>Calculate the mean free path of a gas molecule in air based on the temperature, pressure, and molar mass of the gas. The mean free path is the average distance traveled by a molecule between collisions with other molecules present in a medium (air).</p>"},{"location":"API/particula/next/gas/properties/mean_free_path/#arguments","title":"Arguments","text":"<ul> <li>molar_mass (Union[float, NDArray[np.float64]]): The molar mass of the gas molecule [kg/mol]. Default is the molecular weight of air.</li> <li>temperature (float): The temperature of the gas [K]. Default is 298.15 K.</li> <li>pressure (float): The pressure of the gas [Pa]. Default is 101325 Pa.</li> <li>dynamic_viscosity (Optional[float]): The dynamic viscosity of the gas [Pa*s]. If not provided, it will be calculated based on the temperature.</li> </ul>"},{"location":"API/particula/next/gas/properties/mean_free_path/#returns","title":"Returns","text":"<ul> <li>Union[float, NDArray[np.float64]]: The mean free path of the gas molecule in meters (m).</li> </ul>"},{"location":"API/particula/next/gas/properties/mean_free_path/#references","title":"References","text":"<ul> <li>https://en.wikipedia.org/wiki/Mean_free_path</li> </ul>"},{"location":"API/particula/next/gas/properties/mean_free_path/#signature","title":"Signature","text":"<pre><code>def molecule_mean_free_path(\n    molar_mass: ignore = MOLECULAR_WEIGHT_AIR.m,\n    temperature: float = 298.15,\n    pressure: float = 101325,\n    dynamic_viscosity: Optional[float] = None,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/gas/properties/pressure_function/","title":"Pressure Function","text":"<p>Particula Index / Particula / Next / Gas / Properties / Pressure Function</p> <p>Auto-generated documentation for particula.next.gas.properties.pressure_function module.</p>"},{"location":"API/particula/next/gas/properties/pressure_function/#calculate_partial_pressure","title":"calculate_partial_pressure","text":"<p>Show source in pressure_function.py:10</p> <p>Calculate the partial pressure of a gas from its concentration, molar mass, and temperature.</p>"},{"location":"API/particula/next/gas/properties/pressure_function/#arguments","title":"Arguments","text":"<ul> <li>concentration (float): Concentration of the gas in kg/m^3.</li> <li>molar_mass (float): Molar mass of the gas in kg/mol.</li> <li>temperature (float): Temperature in Kelvin.</li> </ul>"},{"location":"API/particula/next/gas/properties/pressure_function/#returns","title":"Returns","text":"<ul> <li><code>-</code> float - Partial pressure of the gas in Pascals (Pa).</li> </ul>"},{"location":"API/particula/next/gas/properties/pressure_function/#signature","title":"Signature","text":"<pre><code>def calculate_partial_pressure(\n    concentration: Union[float, NDArray[np.float64]],\n    molar_mass: Union[float, NDArray[np.float64]],\n    temperature: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/gas/properties/pressure_function/#calculate_saturation_ratio","title":"calculate_saturation_ratio","text":"<p>Show source in pressure_function.py:31</p> <p>Calculate the saturation ratio of the gas at a given pressure and temperature.</p>"},{"location":"API/particula/next/gas/properties/pressure_function/#arguments_1","title":"Arguments","text":"<ul> <li><code>partial_pressure</code> - Pressure in Pascals.</li> <li><code>pure_vapor_pressure</code> - Pure vapor pressure of the gas in Pascals.</li> </ul>"},{"location":"API/particula/next/gas/properties/pressure_function/#returns_1","title":"Returns","text":"<ul> <li><code>saturation_ratio</code> - The saturation ratio of the gas.</li> </ul>"},{"location":"API/particula/next/gas/properties/pressure_function/#signature_1","title":"Signature","text":"<pre><code>def calculate_saturation_ratio(\n    partial_pressure: Union[float, NDArray[np.float64]],\n    pure_vapor_pressure: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/gas/properties/thermal_conductivity/","title":"Thermal Conductivity","text":"<p>Particula Index / Particula / Next / Gas / Properties / Thermal Conductivity</p> <p>Auto-generated documentation for particula.next.gas.properties.thermal_conductivity module.</p>"},{"location":"API/particula/next/gas/properties/thermal_conductivity/#get_thermal_conductivity","title":"get_thermal_conductivity","text":"<p>Show source in thermal_conductivity.py:11</p> <p>Calculate the thermal conductivity of air as a function of temperature. Based on a simplified linear relation from atmospheric science literature. Only valid for temperatures within the range typically found on Earth's surface.</p>"},{"location":"API/particula/next/gas/properties/thermal_conductivity/#arguments","title":"Arguments","text":"<ul> <li>temperature (Union[float, NDArray[np.float64]]): The temperature at which the thermal conductivity of air is to be calculated, in Kelvin (K).</li> </ul>"},{"location":"API/particula/next/gas/properties/thermal_conductivity/#returns","title":"Returns","text":"<ul> <li>Union[float, NDArray[np.float64]]: The thermal conductivity of air at the specified temperature in Watts per meter-Kelvin (W/m\u00b7K) or J/(m s K).</li> </ul>"},{"location":"API/particula/next/gas/properties/thermal_conductivity/#raises","title":"Raises","text":"<ul> <li><code>-</code> ValueError - If the temperature is below absolute zero (0 K).</li> </ul>"},{"location":"API/particula/next/gas/properties/thermal_conductivity/#references","title":"References","text":"<ul> <li>Seinfeld and Pandis, \"Atmospheric Chemistry and Physics\", Equation 17.54.</li> </ul>"},{"location":"API/particula/next/gas/properties/thermal_conductivity/#signature","title":"Signature","text":"<pre><code>def get_thermal_conductivity(\n    temperature: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/gas/properties/vapor_pressure_module/","title":"Vapor Pressure Module","text":"<p>Particula Index / Particula / Next / Gas / Properties / Vapor Pressure Module</p> <p>Auto-generated documentation for particula.next.gas.properties.vapor_pressure_module module.</p>"},{"location":"API/particula/next/gas/properties/vapor_pressure_module/#antoine_vapor_pressure","title":"antoine_vapor_pressure","text":"<p>Show source in vapor_pressure_module.py:14</p> <p>Calculate vapor pressure using the Antoine equation.</p>"},{"location":"API/particula/next/gas/properties/vapor_pressure_module/#arguments","title":"Arguments","text":"<p>a, b, c: Antoine equation parameters. - <code>temperature</code> - Temperature in Kelvin.</p>"},{"location":"API/particula/next/gas/properties/vapor_pressure_module/#returns","title":"Returns","text":"<p>Vapor pressure in Pascals.</p>"},{"location":"API/particula/next/gas/properties/vapor_pressure_module/#references","title":"References","text":"<ul> <li><code>-</code> Equation - log10(P) = a - b / (T - c)</li> <li>https://en.wikipedia.org/wiki/Antoine_equation (but in Kelvin)</li> <li>Kelvin form:     https://onlinelibrary.wiley.com/doi/pdf/10.1002/9781118135341.app1</li> </ul>"},{"location":"API/particula/next/gas/properties/vapor_pressure_module/#signature","title":"Signature","text":"<pre><code>def antoine_vapor_pressure(\n    a: Union[float, NDArray[np.float64]],\n    b: Union[float, NDArray[np.float64]],\n    c: Union[float, NDArray[np.float64]],\n    temperature: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/gas/properties/vapor_pressure_module/#buck_vapor_pressure","title":"buck_vapor_pressure","text":"<p>Show source in vapor_pressure_module.py:72</p> <p>Calculate vapor pressure using the Buck equation for water vapor.</p>"},{"location":"API/particula/next/gas/properties/vapor_pressure_module/#arguments_1","title":"Arguments","text":"<ul> <li><code>temperature</code> - Temperature in Kelvin.</li> </ul>"},{"location":"API/particula/next/gas/properties/vapor_pressure_module/#returns_1","title":"Returns","text":"<p>Vapor pressure in Pascals.</p>"},{"location":"API/particula/next/gas/properties/vapor_pressure_module/#references_1","title":"References","text":"<ul> <li>Buck, A. L., 1981: New Equations for Computing Vapor Pressure and     Enhancement Factor. J. Appl. Meteor. Climatol., 20, 1527-1532,     https://doi.org/10.1175/1520-0450(1981)020&lt;1527:NEFCVP&gt;2.0.CO;2.</li> <li>https://en.wikipedia.org/wiki/Arden_Buck_equation</li> </ul>"},{"location":"API/particula/next/gas/properties/vapor_pressure_module/#signature_1","title":"Signature","text":"<pre><code>def buck_vapor_pressure(\n    temperature: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/gas/properties/vapor_pressure_module/#clausius_clapeyron_vapor_pressure","title":"clausius_clapeyron_vapor_pressure","text":"<p>Show source in vapor_pressure_module.py:42</p> <p>Calculate vapor pressure using Clausius-Clapeyron equation.</p>"},{"location":"API/particula/next/gas/properties/vapor_pressure_module/#arguments_2","title":"Arguments","text":"<ul> <li><code>latent_heat</code> - Latent heat of vaporization in J/mol.</li> <li><code>temperature_initial</code> - Initial temperature in Kelvin.</li> <li><code>pressure_initial</code> - Initial vapor pressure in Pascals.</li> <li><code>temperature</code> - Final temperature in Kelvin.</li> <li><code>gas_constant</code> - gas constant (default is 8.314 J/(mol\u00b7K)).</li> </ul>"},{"location":"API/particula/next/gas/properties/vapor_pressure_module/#returns_2","title":"Returns","text":"<p>Pure vapor pressure in Pascals.</p>"},{"location":"API/particula/next/gas/properties/vapor_pressure_module/#references_2","title":"References","text":"<ul> <li>https://en.wikipedia.org/wiki/Clausius%E2%80%93Clapeyron_relation</li> </ul>"},{"location":"API/particula/next/gas/properties/vapor_pressure_module/#signature_2","title":"Signature","text":"<pre><code>def clausius_clapeyron_vapor_pressure(\n    latent_heat: Union[float, NDArray[np.float64]],\n    temperature_initial: Union[float, NDArray[np.float64]],\n    pressure_initial: Union[float, NDArray[np.float64]],\n    temperature: Union[float, NDArray[np.float64]],\n    gas_constant: float = GAS_CONSTANT.m,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/","title":"Particles","text":"<p>Particula Index / Particula / Next / Particles</p> <p>Auto-generated documentation for particula.next.particles module.</p>"},{"location":"API/particula/next/particles/#modules","title":"Modules","text":"<ul> <li>Activity Builders</li> <li>Activity Factories</li> <li>Activity Strategies</li> <li>Distribution Builders</li> <li>Distribution Factories</li> <li>Distribution Strategies</li> <li>Properties</li> <li>Representation</li> <li>Representation Builders</li> <li>Representation Factories</li> <li>Surface Builders</li> <li>Surface Factories</li> <li>Surface Strategies</li> </ul>"},{"location":"API/particula/next/particles/activity_builders/","title":"Activity Builders","text":"<p>Particula Index / Particula / Next / Particles / Activity Builders</p> <p>Auto-generated documentation for particula.next.particles.activity_builders module.</p>"},{"location":"API/particula/next/particles/activity_builders/#activityidealmassbuilder","title":"ActivityIdealMassBuilder","text":"<p>Show source in activity_builders.py:27</p> <p>Builder class for IdealActivityMass objects. No additional parameters.</p>"},{"location":"API/particula/next/particles/activity_builders/#methods","title":"Methods","text":"<ul> <li><code>build()</code> - Validate and return the IdealActivityMass object.</li> </ul>"},{"location":"API/particula/next/particles/activity_builders/#signature","title":"Signature","text":"<pre><code>class ActivityIdealMassBuilder(BuilderABC):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/particles/activity_builders/#see-also","title":"See also","text":"<ul> <li>BuilderABC</li> </ul>"},{"location":"API/particula/next/particles/activity_builders/#activityidealmassbuilderbuild","title":"ActivityIdealMassBuilder().build","text":"<p>Show source in activity_builders.py:38</p> <p>Validate and return the IdealActivityMass object.</p>"},{"location":"API/particula/next/particles/activity_builders/#returns","title":"Returns","text":"<ul> <li><code>IdealActivityMass</code> - The validated IdealActivityMass object.</li> </ul>"},{"location":"API/particula/next/particles/activity_builders/#signature_1","title":"Signature","text":"<pre><code>def build(self) -&gt; ActivityStrategy: ...\n</code></pre>"},{"location":"API/particula/next/particles/activity_builders/#see-also_1","title":"See also","text":"<ul> <li>ActivityStrategy</li> </ul>"},{"location":"API/particula/next/particles/activity_builders/#activityidealmolarbuilder","title":"ActivityIdealMolarBuilder","text":"<p>Show source in activity_builders.py:47</p> <p>Builder class for IdealActivityMolar objects.</p>"},{"location":"API/particula/next/particles/activity_builders/#methods_1","title":"Methods","text":"<ul> <li><code>set_molar_mass(molar_mass,</code> molar_mass_units) - Set the molar mass of the     particle in kg/mol. Default units are 'kg/mol'.</li> <li><code>set_parameters(params)</code> - Set the parameters of the IdealActivityMolar     object from a dictionary including optional units.</li> <li><code>build()</code> - Validate and return the IdealActivityMolar object.</li> </ul>"},{"location":"API/particula/next/particles/activity_builders/#signature_2","title":"Signature","text":"<pre><code>class ActivityIdealMolarBuilder(BuilderABC, BuilderMolarMassMixin):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/particles/activity_builders/#see-also_2","title":"See also","text":"<ul> <li>BuilderABC</li> <li>BuilderMolarMassMixin</li> </ul>"},{"location":"API/particula/next/particles/activity_builders/#activityidealmolarbuilderbuild","title":"ActivityIdealMolarBuilder().build","text":"<p>Show source in activity_builders.py:63</p> <p>Validate and return the IdealActivityMolar object.</p>"},{"location":"API/particula/next/particles/activity_builders/#returns_1","title":"Returns","text":"<ul> <li><code>IdealActivityMolar</code> - The validated IdealActivityMolar object.</li> </ul>"},{"location":"API/particula/next/particles/activity_builders/#signature_3","title":"Signature","text":"<pre><code>def build(self) -&gt; ActivityStrategy: ...\n</code></pre>"},{"location":"API/particula/next/particles/activity_builders/#see-also_3","title":"See also","text":"<ul> <li>ActivityStrategy</li> </ul>"},{"location":"API/particula/next/particles/activity_builders/#activitykappaparameterbuilder","title":"ActivityKappaParameterBuilder","text":"<p>Show source in activity_builders.py:73</p> <p>Builder class for KappaParameterActivity objects.</p>"},{"location":"API/particula/next/particles/activity_builders/#methods_2","title":"Methods","text":"<ul> <li><code>set_kappa(kappa)</code> - Set the kappa parameter for the activity calculation.</li> <li><code>set_density(density,density_units)</code> - Set the density of the species in     kg/m^3. Default units are 'kg/m^3'.</li> <li><code>set_molar_mass(molar_mass,molar_mass_units)</code> - Set the molar mass of the     species in kg/mol. Default units are 'kg/mol'.</li> <li><code>set_water_index(water_index)</code> - Set the array index of the species.</li> <li><code>set_parameters(dict)</code> - Set the parameters of the KappaParameterActivity     object from a dictionary including optional units.</li> <li><code>build()</code> - Validate and return the KappaParameterActivity object.</li> </ul>"},{"location":"API/particula/next/particles/activity_builders/#signature_4","title":"Signature","text":"<pre><code>class ActivityKappaParameterBuilder(\n    BuilderABC, BuilderDensityMixin, BuilderMolarMassMixin\n):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/particles/activity_builders/#see-also_4","title":"See also","text":"<ul> <li>BuilderABC</li> <li>BuilderDensityMixin</li> <li>BuilderMolarMassMixin</li> </ul>"},{"location":"API/particula/next/particles/activity_builders/#activitykappaparameterbuilderbuild","title":"ActivityKappaParameterBuilder().build","text":"<p>Show source in activity_builders.py:136</p> <p>Validate and return the KappaParameterActivity object.</p>"},{"location":"API/particula/next/particles/activity_builders/#returns_2","title":"Returns","text":"<ul> <li><code>KappaParameterActivity</code> - The validated KappaParameterActivity object.</li> </ul>"},{"location":"API/particula/next/particles/activity_builders/#signature_5","title":"Signature","text":"<pre><code>def build(self) -&gt; ActivityStrategy: ...\n</code></pre>"},{"location":"API/particula/next/particles/activity_builders/#see-also_5","title":"See also","text":"<ul> <li>ActivityStrategy</li> </ul>"},{"location":"API/particula/next/particles/activity_builders/#activitykappaparameterbuilderset_kappa","title":"ActivityKappaParameterBuilder().set_kappa","text":"<p>Show source in activity_builders.py:98</p> <p>Set the kappa parameter for the activity calculation.</p>"},{"location":"API/particula/next/particles/activity_builders/#arguments","title":"Arguments","text":"<ul> <li><code>kappa</code> - The kappa parameter for the activity calculation.</li> <li><code>kappa_units</code> - Not used. (for interface consistency)</li> </ul>"},{"location":"API/particula/next/particles/activity_builders/#signature_6","title":"Signature","text":"<pre><code>def set_kappa(\n    self, kappa: Union[float, NDArray[np.float64]], kappa_units: Optional[str] = None\n): ...\n</code></pre>"},{"location":"API/particula/next/particles/activity_builders/#activitykappaparameterbuilderset_water_index","title":"ActivityKappaParameterBuilder().set_water_index","text":"<p>Show source in activity_builders.py:118</p> <p>Set the array index of the species.</p>"},{"location":"API/particula/next/particles/activity_builders/#arguments_1","title":"Arguments","text":"<ul> <li><code>water_index</code> - The array index of the species.</li> <li><code>water_index_units</code> - Not used. (for interface consistency)</li> </ul>"},{"location":"API/particula/next/particles/activity_builders/#signature_7","title":"Signature","text":"<pre><code>def set_water_index(self, water_index: int, water_index_units: Optional[str] = None): ...\n</code></pre>"},{"location":"API/particula/next/particles/activity_factories/","title":"Activity Factories","text":"<p>Particula Index / Particula / Next / Particles / Activity Factories</p> <p>Auto-generated documentation for particula.next.particles.activity_factories module.</p>"},{"location":"API/particula/next/particles/activity_factories/#activityfactory","title":"ActivityFactory","text":"<p>Show source in activity_factories.py:20</p> <p>Factory class to create activity strategy builders</p> <p>Factory class to create activity strategy builders for calculating activity and partial pressure of species in a mixture of liquids.</p>"},{"location":"API/particula/next/particles/activity_factories/#methods","title":"Methods","text":"<ul> <li><code>get_builders()</code> - Returns the mapping of strategy types to builder instances.</li> <li><code>get_strategy(strategy_type,</code> parameters) - Gets the strategy instance for the specified strategy type.<ul> <li><code>strategy_type</code> - Type of activity strategy to use, can be 'mass_ideal' (default), 'molar_ideal', or 'kappa_parameter'. parameters(Dict[str, Any], optional): Parameters required for the builder, dependent on the chosen strategy type.<ul> <li><code>mass_ideal</code> - No parameters are required.</li> <li><code>molar_ideal</code> - molar_mass kappa | kappa_parameter: kappa, density, molar_mass, water_index</li> </ul> </li> </ul> </li> </ul>"},{"location":"API/particula/next/particles/activity_factories/#returns","title":"Returns","text":"<ul> <li><code>ActivityStrategy</code> - An instance of the specified ActivityStrategy.</li> </ul>"},{"location":"API/particula/next/particles/activity_factories/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code> - If an unknown strategy type is provided.</li> <li><code>ValueError</code> - If any required key is missing during check_keys or     pre_build_check, or if trying to set an invalid parameter.</li> </ul>"},{"location":"API/particula/next/particles/activity_factories/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; strategy_is = ActivityFactory().get_strategy(\"mass_ideal\")\n</code></pre>"},{"location":"API/particula/next/particles/activity_factories/#signature","title":"Signature","text":"<pre><code>class ActivityFactory(\n    StrategyFactory[\n        Union[\n            ActivityIdealMassBuilder,\n            ActivityIdealMolarBuilder,\n            ActivityKappaParameterBuilder,\n        ],\n        Union[ActivityIdealMass, ActivityIdealMolar, ActivityKappaParameter],\n    ]\n): ...\n</code></pre>"},{"location":"API/particula/next/particles/activity_factories/#see-also","title":"See also","text":"<ul> <li>ActivityIdealMassBuilder</li> <li>ActivityIdealMass</li> <li>ActivityIdealMolarBuilder</li> <li>ActivityIdealMolar</li> <li>ActivityKappaParameterBuilder</li> <li>ActivityKappaParameter</li> </ul>"},{"location":"API/particula/next/particles/activity_factories/#activityfactoryget_builders","title":"ActivityFactory().get_builders","text":"<p>Show source in activity_factories.py:61</p> <p>Returns the mapping of strategy types to builder instances.</p>"},{"location":"API/particula/next/particles/activity_factories/#returns_1","title":"Returns","text":"<ul> <li><code>Dict[str,</code> Any] - A dictionary mapping strategy types to builder instances.<ul> <li><code>mass_ideal</code> - IdealActivityMassBuilder</li> <li><code>molar_ideal</code> - IdealActivityMolarBuilder</li> <li><code>kappa_parameter</code> - KappaParameterActivityBuilder</li> </ul> </li> </ul>"},{"location":"API/particula/next/particles/activity_factories/#signature_1","title":"Signature","text":"<pre><code>def get_builders(self): ...\n</code></pre>"},{"location":"API/particula/next/particles/activity_strategies/","title":"Activity Strategies","text":"<p>Particula Index / Particula / Next / Particles / Activity Strategies</p> <p>Auto-generated documentation for particula.next.particles.activity_strategies module.</p>"},{"location":"API/particula/next/particles/activity_strategies/#activityidealmass","title":"ActivityIdealMass","text":"<p>Show source in activity_strategies.py:115</p> <p>Calculate ideal activity based on mass fractions.</p> <p>This strategy utilizes mass fractions to determine the activity, consistent with the principles outlined in Raoult's Law.</p>"},{"location":"API/particula/next/particles/activity_strategies/#references","title":"References","text":"<p>Mass Based Raoult's Law</p>"},{"location":"API/particula/next/particles/activity_strategies/#signature","title":"Signature","text":"<pre><code>class ActivityIdealMass(ActivityStrategy): ...\n</code></pre>"},{"location":"API/particula/next/particles/activity_strategies/#see-also","title":"See also","text":"<ul> <li>ActivityStrategy</li> </ul>"},{"location":"API/particula/next/particles/activity_strategies/#activityidealmassactivity","title":"ActivityIdealMass().activity","text":"<p>Show source in activity_strategies.py:125</p> <p>Calculate the activity of a species based on mass concentration.</p>"},{"location":"API/particula/next/particles/activity_strategies/#arguments","title":"Arguments","text":"<ul> <li><code>mass_concentration</code> - Concentration of the species in kilograms per cubic meter (kg/m^3).</li> </ul>"},{"location":"API/particula/next/particles/activity_strategies/#returns","title":"Returns","text":"<ul> <li><code>Union[float,</code> NDArray[np.float64]] - Activity of the particle, unitless.</li> </ul>"},{"location":"API/particula/next/particles/activity_strategies/#signature_1","title":"Signature","text":"<pre><code>def activity(\n    self, mass_concentration: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/activity_strategies/#activityidealmolar","title":"ActivityIdealMolar","text":"<p>Show source in activity_strategies.py:79</p> <p>Calculate ideal activity based on mole fractions.</p> <p>This strategy uses mole fractions to compute the activity, adhering to the principles of Raoult's Law.</p>"},{"location":"API/particula/next/particles/activity_strategies/#arguments_1","title":"Arguments","text":"<p>molar_mass (Union[float, NDArray[np.float64]]): Molar mass of the species [kg/mol]. A single value applies to all species if only one is provided.</p>"},{"location":"API/particula/next/particles/activity_strategies/#references_1","title":"References","text":"<p>Molar Raoult's Law</p>"},{"location":"API/particula/next/particles/activity_strategies/#signature_2","title":"Signature","text":"<pre><code>class ActivityIdealMolar(ActivityStrategy):\n    def __init__(self, molar_mass: Union[float, NDArray[np.float64]] = 0.0): ...\n</code></pre>"},{"location":"API/particula/next/particles/activity_strategies/#see-also_1","title":"See also","text":"<ul> <li>ActivityStrategy</li> </ul>"},{"location":"API/particula/next/particles/activity_strategies/#activityidealmolaractivity","title":"ActivityIdealMolar().activity","text":"<p>Show source in activity_strategies.py:97</p> <p>Calculate the activity of a species based on mass concentration.</p>"},{"location":"API/particula/next/particles/activity_strategies/#arguments_2","title":"Arguments","text":"<ul> <li><code>mass_concentration</code> - Concentration of the species in kilograms per cubic meter (kg/m^3).</li> </ul>"},{"location":"API/particula/next/particles/activity_strategies/#returns_1","title":"Returns","text":"<ul> <li><code>Union[float,</code> NDArray[np.float64]] - Activity of the species, unitless.</li> </ul>"},{"location":"API/particula/next/particles/activity_strategies/#signature_3","title":"Signature","text":"<pre><code>def activity(\n    self, mass_concentration: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/activity_strategies/#activityidealvolume","title":"ActivityIdealVolume","text":"<p>Show source in activity_strategies.py:141</p> <p>Calculate ideal activity based on volume fractions.</p> <p>This strategy uses volume fractions to compute the activity, following the principles of Raoult's Law.</p>"},{"location":"API/particula/next/particles/activity_strategies/#references_2","title":"References","text":"<p>Volume Based     Raoult's Law</p>"},{"location":"API/particula/next/particles/activity_strategies/#signature_4","title":"Signature","text":"<pre><code>class ActivityIdealVolume(ActivityStrategy):\n    def __init__(self, density: Union[float, NDArray[np.float64]] = 0.0): ...\n</code></pre>"},{"location":"API/particula/next/particles/activity_strategies/#see-also_2","title":"See also","text":"<ul> <li>ActivityStrategy</li> </ul>"},{"location":"API/particula/next/particles/activity_strategies/#activityidealvolumeactivity","title":"ActivityIdealVolume().activity","text":"<p>Show source in activity_strategies.py:155</p> <p>Calculate the activity of a species based on mass concentration.</p>"},{"location":"API/particula/next/particles/activity_strategies/#arguments_3","title":"Arguments","text":"<ul> <li><code>mass_concentration</code> - Concentration of the species in kilograms per     cubic meter (kg/m^3).</li> <li><code>density</code> - Density of the species in kilograms per cubic meter     (kg/m^3).</li> </ul>"},{"location":"API/particula/next/particles/activity_strategies/#returns_2","title":"Returns","text":"<ul> <li><code>Union[float,</code> NDArray[np.float64]] - Activity of the particle, unitless.</li> </ul>"},{"location":"API/particula/next/particles/activity_strategies/#signature_5","title":"Signature","text":"<pre><code>def activity(\n    self, mass_concentration: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/activity_strategies/#activitykappaparameter","title":"ActivityKappaParameter","text":"<p>Show source in activity_strategies.py:176</p> <p>Non-ideal activity strategy based on the kappa hygroscopic parameter.</p> <p>This strategy calculates the activity using the kappa hygroscopic parameter, a measure of hygroscopicity. The activity is determined by the species' mass concentration along with the hygroscopic parameter.</p>"},{"location":"API/particula/next/particles/activity_strategies/#arguments_4","title":"Arguments","text":"<ul> <li><code>kappa</code> - Kappa hygroscopic parameter, unitless.     Includes a value for water which is excluded in calculations.</li> <li><code>density</code> - Density of the species in kilograms per     cubic meter (kg/m^3).</li> <li><code>molar_mass</code> - Molar mass of the species in kilograms     per mole (kg/mol).</li> <li><code>water_index</code> - Index of water in the mass concentration array.</li> </ul>"},{"location":"API/particula/next/particles/activity_strategies/#signature_6","title":"Signature","text":"<pre><code>class ActivityKappaParameter(ActivityStrategy):\n    def __init__(\n        self,\n        kappa: NDArray[np.float64] = np.array([0.0], dtype=np.float64),\n        density: NDArray[np.float64] = np.array([0.0], dtype=np.float64),\n        molar_mass: NDArray[np.float64] = np.array([0.0], dtype=np.float64),\n        water_index: int = 0,\n    ): ...\n</code></pre>"},{"location":"API/particula/next/particles/activity_strategies/#see-also_3","title":"See also","text":"<ul> <li>ActivityStrategy</li> </ul>"},{"location":"API/particula/next/particles/activity_strategies/#activitykappaparameteractivity","title":"ActivityKappaParameter().activity","text":"<p>Show source in activity_strategies.py:205</p> <p>Calculate the activity of a species based on mass concentration.</p>"},{"location":"API/particula/next/particles/activity_strategies/#arguments_5","title":"Arguments","text":"<ul> <li><code>mass_concentration</code> - Concentration of the species in kilograms per cubic meter (kg/m^3).</li> </ul>"},{"location":"API/particula/next/particles/activity_strategies/#returns_3","title":"Returns","text":"<ul> <li><code>Union[float,</code> NDArray[np.float64]] - Activity of the particle, unitless.</li> </ul>"},{"location":"API/particula/next/particles/activity_strategies/#references_3","title":"References","text":"<p>Petters, M. D., &amp; Kreidenweis, S. M. (2007). A single parameter representation of hygroscopic growth and cloud condensation nucleus activity. Atmospheric Chemistry and Physics, 7(8), 1961-1971. DOI, see EQ 2 and 7.</p>"},{"location":"API/particula/next/particles/activity_strategies/#signature_7","title":"Signature","text":"<pre><code>def activity(\n    self, mass_concentration: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/activity_strategies/#activitystrategy","title":"ActivityStrategy","text":"<p>Show source in activity_strategies.py:22</p> <p>Abstract base class for vapor pressure strategies.</p> <p>This interface is used for implementing strategies based on particle activity calculations, specifically for calculating vapor pressures.</p>"},{"location":"API/particula/next/particles/activity_strategies/#methods","title":"Methods","text":"<ul> <li><code>get_name</code> - Return the type of the activity strategy.</li> <li><code>activity</code> - Calculate the activity of a species.</li> <li><code>partial_pressure</code> - Calculate the partial pressure of a species in     the mixture.</li> </ul>"},{"location":"API/particula/next/particles/activity_strategies/#signature_8","title":"Signature","text":"<pre><code>class ActivityStrategy(ABC): ...\n</code></pre>"},{"location":"API/particula/next/particles/activity_strategies/#activitystrategyactivity","title":"ActivityStrategy().activity","text":"<p>Show source in activity_strategies.py:35</p> <p>Calculate the activity of a species based on its mass concentration.</p>"},{"location":"API/particula/next/particles/activity_strategies/#arguments_6","title":"Arguments","text":"<ul> <li><code>mass_concentration</code> - Concentration of the species [kg/m^3]</li> </ul>"},{"location":"API/particula/next/particles/activity_strategies/#returns_4","title":"Returns","text":"<p>float or NDArray[float]: Activity of the particle, unitless.</p>"},{"location":"API/particula/next/particles/activity_strategies/#signature_9","title":"Signature","text":"<pre><code>@abstractmethod\ndef activity(\n    self, mass_concentration: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/activity_strategies/#activitystrategyget_name","title":"ActivityStrategy().get_name","text":"<p>Show source in activity_strategies.py:48</p> <p>Return the type of the activity strategy.</p>"},{"location":"API/particula/next/particles/activity_strategies/#signature_10","title":"Signature","text":"<pre><code>def get_name(self) -&gt; str: ...\n</code></pre>"},{"location":"API/particula/next/particles/activity_strategies/#activitystrategypartial_pressure","title":"ActivityStrategy().partial_pressure","text":"<p>Show source in activity_strategies.py:52</p> <p>Calculate the vapor pressure of species in the particle phase.</p> <p>This method computes the vapor pressure based on the species' activity considering its pure vapor pressure and mass concentration.</p>"},{"location":"API/particula/next/particles/activity_strategies/#arguments_7","title":"Arguments","text":"<ul> <li><code>pure_vapor_pressure</code> - Pure vapor pressure of the species in pascals (Pa).</li> <li><code>mass_concentration</code> - Concentration of the species in kilograms per cubic meter (kg/m^3).</li> </ul>"},{"location":"API/particula/next/particles/activity_strategies/#returns_5","title":"Returns","text":"<ul> <li><code>Union[float,</code> NDArray[np.float64]] - Vapor pressure of the particle in pascals (Pa).</li> </ul>"},{"location":"API/particula/next/particles/activity_strategies/#signature_11","title":"Signature","text":"<pre><code>def partial_pressure(\n    self,\n    pure_vapor_pressure: Union[float, NDArray[np.float64]],\n    mass_concentration: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_builders/","title":"Distribution Builders","text":"<p>Particula Index / Particula / Next / Particles / Distribution Builders</p> <p>Auto-generated documentation for particula.next.particles.distribution_builders module.</p>"},{"location":"API/particula/next/particles/distribution_builders/#massbasedmovingbinbuilder","title":"MassBasedMovingBinBuilder","text":"<p>Show source in distribution_builders.py:14</p> <p>Builds a MassBasedMovingBin instance.</p>"},{"location":"API/particula/next/particles/distribution_builders/#signature","title":"Signature","text":"<pre><code>class MassBasedMovingBinBuilder(BuilderABC):\n    def __init__(self) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_builders/#see-also","title":"See also","text":"<ul> <li>BuilderABC</li> </ul>"},{"location":"API/particula/next/particles/distribution_builders/#massbasedmovingbinbuilderbuild","title":"MassBasedMovingBinBuilder().build","text":"<p>Show source in distribution_builders.py:21</p> <p>Builds a MassBasedMovingBin instance.</p>"},{"location":"API/particula/next/particles/distribution_builders/#signature_1","title":"Signature","text":"<pre><code>def build(self) -&gt; MassBasedMovingBin: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_builders/#see-also_1","title":"See also","text":"<ul> <li>MassBasedMovingBin</li> </ul>"},{"location":"API/particula/next/particles/distribution_builders/#particleresolvedspeciatedmassbuilder","title":"ParticleResolvedSpeciatedMassBuilder","text":"<p>Show source in distribution_builders.py:50</p> <p>Builds a ParticleResolvedSpeciatedMass instance.</p>"},{"location":"API/particula/next/particles/distribution_builders/#signature_2","title":"Signature","text":"<pre><code>class ParticleResolvedSpeciatedMassBuilder(BuilderABC):\n    def __init__(self) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_builders/#see-also_2","title":"See also","text":"<ul> <li>BuilderABC</li> </ul>"},{"location":"API/particula/next/particles/distribution_builders/#particleresolvedspeciatedmassbuilderbuild","title":"ParticleResolvedSpeciatedMassBuilder().build","text":"<p>Show source in distribution_builders.py:57</p>"},{"location":"API/particula/next/particles/distribution_builders/#signature_3","title":"Signature","text":"<pre><code>def build(self) -&gt; ParticleResolvedSpeciatedMass: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_builders/#see-also_3","title":"See also","text":"<ul> <li>ParticleResolvedSpeciatedMass</li> </ul>"},{"location":"API/particula/next/particles/distribution_builders/#radiibasedmovingbinbuilder","title":"RadiiBasedMovingBinBuilder","text":"<p>Show source in distribution_builders.py:26</p> <p>Builds a RadiiBasedMovingBin instance.</p>"},{"location":"API/particula/next/particles/distribution_builders/#signature_4","title":"Signature","text":"<pre><code>class RadiiBasedMovingBinBuilder(BuilderABC):\n    def __init__(self) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_builders/#see-also_4","title":"See also","text":"<ul> <li>BuilderABC</li> </ul>"},{"location":"API/particula/next/particles/distribution_builders/#radiibasedmovingbinbuilderbuild","title":"RadiiBasedMovingBinBuilder().build","text":"<p>Show source in distribution_builders.py:33</p> <p>Builds a RadiiBasedMovingBin instance.</p>"},{"location":"API/particula/next/particles/distribution_builders/#signature_5","title":"Signature","text":"<pre><code>def build(self) -&gt; RadiiBasedMovingBin: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_builders/#see-also_5","title":"See also","text":"<ul> <li>RadiiBasedMovingBin</li> </ul>"},{"location":"API/particula/next/particles/distribution_builders/#speciatedmassmovingbinbuilder","title":"SpeciatedMassMovingBinBuilder","text":"<p>Show source in distribution_builders.py:38</p> <p>Builds a SpeciatedMassMovingBin instance.</p>"},{"location":"API/particula/next/particles/distribution_builders/#signature_6","title":"Signature","text":"<pre><code>class SpeciatedMassMovingBinBuilder(BuilderABC):\n    def __init__(self) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_builders/#see-also_6","title":"See also","text":"<ul> <li>BuilderABC</li> </ul>"},{"location":"API/particula/next/particles/distribution_builders/#speciatedmassmovingbinbuilderbuild","title":"SpeciatedMassMovingBinBuilder().build","text":"<p>Show source in distribution_builders.py:45</p> <p>Builds a SpeciatedMassMovingBin instance.</p>"},{"location":"API/particula/next/particles/distribution_builders/#signature_7","title":"Signature","text":"<pre><code>def build(self) -&gt; SpeciatedMassMovingBin: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_builders/#see-also_7","title":"See also","text":"<ul> <li>SpeciatedMassMovingBin</li> </ul>"},{"location":"API/particula/next/particles/distribution_factories/","title":"Distribution Factories","text":"<p>Particula Index / Particula / Next / Particles / Distribution Factories</p> <p>Auto-generated documentation for particula.next.particles.distribution_factories module.</p>"},{"location":"API/particula/next/particles/distribution_factories/#distributionfactory","title":"DistributionFactory","text":"<p>Show source in distribution_factories.py:17</p> <p>Factory class to create distribution strategy from builders.</p> <p>Used for calculating particle distributions based on the specified representation type.</p>"},{"location":"API/particula/next/particles/distribution_factories/#methods","title":"Methods","text":"<ul> <li><code>get_builders()</code> - Returns the mapping of strategy types to builder instances.</li> <li><code>get_strategy(strategy_type,</code> parameters) - Gets the strategy instance for the specified strategy type.<ul> <li><code>strategy_type</code> - Type of distribution strategy to use, can be 'mass_based_moving_bin', 'radii_based_moving_bin', 'speciated_mass_moving_bin', 'particle_resolved_speciated_mass'. parameters(Dict[str, Any], optional): Parameters required for the builder, dependent on the chosen strategy type.<ul> <li><code>mass_based_moving_bin</code> - None</li> <li><code>radii_based_moving_bin</code> - None</li> <li><code>speciated_mass_moving_bin</code> - None</li> <li><code>particle_resolved_speciated_mass</code> - None</li> </ul> </li> </ul> </li> </ul>"},{"location":"API/particula/next/particles/distribution_factories/#returns","title":"Returns","text":"<ul> <li><code>DistributionStrategy</code> - An instance of the specified DistributionStrategy.</li> </ul>"},{"location":"API/particula/next/particles/distribution_factories/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code> - If an unknown strategy type is provided.</li> <li><code>ValueError</code> - If any required key is missing during check_keys or pre_build_check, or if trying to set an invalid parameter.</li> </ul>"},{"location":"API/particula/next/particles/distribution_factories/#signature","title":"Signature","text":"<pre><code>class DistributionFactory(\n    StrategyFactory[\n        Union[\n            MassBasedMovingBinBuilder,\n            RadiiBasedMovingBinBuilder,\n            SpeciatedMassMovingBinBuilder,\n            ParticleResolvedSpeciatedMassBuilder,\n        ],\n        Union[\n            MassBasedMovingBin,\n            RadiiBasedMovingBin,\n            SpeciatedMassMovingBin,\n            ParticleResolvedSpeciatedMass,\n        ],\n    ]\n): ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_factories/#see-also","title":"See also","text":"<ul> <li>MassBasedMovingBinBuilder</li> <li>MassBasedMovingBin</li> <li>ParticleResolvedSpeciatedMassBuilder</li> <li>ParticleResolvedSpeciatedMass</li> <li>RadiiBasedMovingBinBuilder</li> <li>RadiiBasedMovingBin</li> <li>SpeciatedMassMovingBinBuilder</li> <li>SpeciatedMassMovingBin</li> </ul>"},{"location":"API/particula/next/particles/distribution_factories/#distributionfactoryget_builders","title":"DistributionFactory().get_builders","text":"<p>Show source in distribution_factories.py:62</p> <p>Returns the mapping of strategy types to builder instances.</p>"},{"location":"API/particula/next/particles/distribution_factories/#returns_1","title":"Returns","text":"<ul> <li><code>Dict[str,</code> BuilderABC] - Mapping of strategy types to builder instances.<ul> <li><code>'mass_based_moving_bin'</code> - MassBasedMovingBinBuilder</li> <li><code>'radii_based_moving_bin'</code> - RadiiBasedMovingBinBuilder</li> <li><code>'speciated_mass_moving_bin'</code> - SpeciatedMassMovingBinBuilder</li> </ul> </li> </ul>"},{"location":"API/particula/next/particles/distribution_factories/#signature_1","title":"Signature","text":"<pre><code>def get_builders(self): ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/","title":"Distribution Strategies","text":"<p>Particula Index / Particula / Next / Particles / Distribution Strategies</p> <p>Auto-generated documentation for particula.next.particles.distribution_strategies module.</p>"},{"location":"API/particula/next/particles/distribution_strategies/#distributionstrategy","title":"DistributionStrategy","text":"<p>Show source in distribution_strategies.py:13</p> <p>Abstract base class for particle strategy, defining the common interface for mass, radius, and total mass calculations for different particle representations.</p>"},{"location":"API/particula/next/particles/distribution_strategies/#methods","title":"Methods","text":"<ul> <li><code>get_name</code> - Returns the type of the distribution strategy.</li> <li><code>get_mass</code> - Calculates the mass of particles.</li> <li><code>get_radius</code> - Calculates the radius of particles.</li> <li><code>get_total_mass</code> - Calculates the total mass of particles.</li> <li><code>add_mass</code> - Adds mass to the distribution of particles.</li> </ul>"},{"location":"API/particula/next/particles/distribution_strategies/#signature","title":"Signature","text":"<pre><code>class DistributionStrategy(ABC): ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#distributionstrategyadd_concentration","title":"DistributionStrategy().add_concentration","text":"<p>Show source in distribution_strategies.py:120</p> <p>Adds concentration to the distribution of particles.</p>"},{"location":"API/particula/next/particles/distribution_strategies/#arguments","title":"Arguments","text":"<ul> <li><code>distribution</code> - The distribution of particle sizes or masses.</li> <li><code>concentration</code> - The concentration of each particle size or mass in     the distribution.</li> <li><code>added_distribution</code> - The distribution to be added.</li> <li><code>added_concentration</code> - The concentration to be added.</li> </ul>"},{"location":"API/particula/next/particles/distribution_strategies/#returns","title":"Returns","text":"<ul> <li><code>(distribution,</code> concentration) - The new distribution array and the     new concentration array.</li> </ul>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_1","title":"Signature","text":"<pre><code>@abstractmethod\ndef add_concentration(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    added_distribution: NDArray[np.float64],\n    added_concentration: NDArray[np.float64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#distributionstrategyadd_mass","title":"DistributionStrategy().add_mass","text":"<p>Show source in distribution_strategies.py:98</p> <p>Adds mass to the distribution of particles.</p>"},{"location":"API/particula/next/particles/distribution_strategies/#arguments_1","title":"Arguments","text":"<ul> <li><code>distribution</code> - The distribution of particle sizes or masses.</li> <li><code>concentration</code> - The concentration of each particle size or mass in     the distribution.</li> <li><code>density</code> - The density of the particles.</li> <li><code>added_mass</code> - The mass to be added per distribution bin.</li> </ul>"},{"location":"API/particula/next/particles/distribution_strategies/#returns_1","title":"Returns","text":"<ul> <li><code>(distribution,</code> concentration) - The new distribution array and the     new concentration array.</li> </ul>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_2","title":"Signature","text":"<pre><code>@abstractmethod\ndef add_mass(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    density: NDArray[np.float64],\n    added_mass: NDArray[np.float64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#distributionstrategycollide_pairs","title":"DistributionStrategy().collide_pairs","text":"<p>Show source in distribution_strategies.py:142</p> <p>Collides index pairs.</p>"},{"location":"API/particula/next/particles/distribution_strategies/#arguments_2","title":"Arguments","text":"<ul> <li><code>distribution</code> - The distribution of particle sizes or masses.</li> <li><code>concentration</code> - The concentration of each particle size or mass in     the distribution.</li> <li><code>density</code> - The density of the particles.</li> <li><code>indices</code> - The indices of the particles to collide.</li> </ul>"},{"location":"API/particula/next/particles/distribution_strategies/#returns_2","title":"Returns","text":"<ul> <li><code>(distribution,</code> concentration) - The new distribution array and the     new concentration array.</li> </ul>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_3","title":"Signature","text":"<pre><code>@abstractmethod\ndef collide_pairs(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    density: NDArray[np.float64],\n    indices: NDArray[np.int64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#distributionstrategyget_mass","title":"DistributionStrategy().get_mass","text":"<p>Show source in distribution_strategies.py:45</p> <p>Calculates the mass of the particles (or bin).</p>"},{"location":"API/particula/next/particles/distribution_strategies/#arguments_3","title":"Arguments","text":"<ul> <li><code>distribution</code> - The distribution of particle sizes or masses.</li> <li><code>density</code> - The density of the particles.</li> </ul>"},{"location":"API/particula/next/particles/distribution_strategies/#returns_3","title":"Returns","text":"<ul> <li><code>NDArray[np.float64]</code> - The mass of the particles.</li> </ul>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_4","title":"Signature","text":"<pre><code>def get_mass(\n    self, distribution: NDArray[np.float64], density: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#distributionstrategyget_name","title":"DistributionStrategy().get_name","text":"<p>Show source in distribution_strategies.py:27</p> <p>Return the type of the distribution strategy.</p>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_5","title":"Signature","text":"<pre><code>def get_name(self) -&gt; str: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#distributionstrategyget_radius","title":"DistributionStrategy().get_radius","text":"<p>Show source in distribution_strategies.py:84</p> <p>Calculates the radius of the particles.</p>"},{"location":"API/particula/next/particles/distribution_strategies/#arguments_4","title":"Arguments","text":"<ul> <li><code>distribution</code> - The distribution of particle sizes or masses.</li> <li><code>density</code> - The density of the particles.</li> </ul>"},{"location":"API/particula/next/particles/distribution_strategies/#returns_4","title":"Returns","text":"<ul> <li><code>NDArray[np.float64]</code> - The radius of the particles.</li> </ul>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_6","title":"Signature","text":"<pre><code>@abstractmethod\ndef get_radius(\n    self, distribution: NDArray[np.float64], density: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#distributionstrategyget_species_mass","title":"DistributionStrategy().get_species_mass","text":"<p>Show source in distribution_strategies.py:31</p> <p>The mass per species in the particles (or bin).</p>"},{"location":"API/particula/next/particles/distribution_strategies/#arguments_5","title":"Arguments","text":"<ul> <li><code>distribution</code> - The distribution of particle sizes or masses.</li> <li><code>density</code> - The density of the particles.</li> </ul>"},{"location":"API/particula/next/particles/distribution_strategies/#returns_5","title":"Returns","text":"<ul> <li><code>NDArray[np.float64]</code> - The mass of the particles</li> </ul>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_7","title":"Signature","text":"<pre><code>@abstractmethod\ndef get_species_mass(\n    self, distribution: NDArray[np.float64], density: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#distributionstrategyget_total_mass","title":"DistributionStrategy().get_total_mass","text":"<p>Show source in distribution_strategies.py:63</p> <p>Calculates the total mass of all particles (or bin).</p>"},{"location":"API/particula/next/particles/distribution_strategies/#arguments_6","title":"Arguments","text":"<ul> <li><code>distribution</code> - The distribution of particle sizes or masses.</li> <li><code>concentration</code> - The concentration of each particle size or mass in the distribution.</li> <li><code>density</code> - The density of the particles.</li> </ul>"},{"location":"API/particula/next/particles/distribution_strategies/#returns_6","title":"Returns","text":"<ul> <li><code>np.float64</code> - The total mass of the particles.</li> </ul>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_8","title":"Signature","text":"<pre><code>def get_total_mass(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    density: NDArray[np.float64],\n) -&gt; np.float64: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#massbasedmovingbin","title":"MassBasedMovingBin","text":"<p>Show source in distribution_strategies.py:165</p> <p>A strategy for particles represented by their mass distribution.</p> <p>This strategy calculates particle mass, radius, and total mass based on the particle's mass, number concentration, and density. It also moves the bins when adding mass to the distribution.</p>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_9","title":"Signature","text":"<pre><code>class MassBasedMovingBin(DistributionStrategy): ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#see-also","title":"See also","text":"<ul> <li>DistributionStrategy</li> </ul>"},{"location":"API/particula/next/particles/distribution_strategies/#massbasedmovingbinadd_concentration","title":"MassBasedMovingBin().add_concentration","text":"<p>Show source in distribution_strategies.py:197</p>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_10","title":"Signature","text":"<pre><code>def add_concentration(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    added_distribution: NDArray[np.float64],\n    added_concentration: NDArray[np.float64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#massbasedmovingbinadd_mass","title":"MassBasedMovingBin().add_mass","text":"<p>Show source in distribution_strategies.py:187</p>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_11","title":"Signature","text":"<pre><code>def add_mass(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    density: NDArray[np.float64],\n    added_mass: NDArray[np.float64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#massbasedmovingbincollide_pairs","title":"MassBasedMovingBin().collide_pairs","text":"<p>Show source in distribution_strategies.py:234</p>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_12","title":"Signature","text":"<pre><code>def collide_pairs(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    density: NDArray[np.float64],\n    indices: NDArray[np.int64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#massbasedmovingbinget_radius","title":"MassBasedMovingBin().get_radius","text":"<p>Show source in distribution_strategies.py:179</p>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_13","title":"Signature","text":"<pre><code>def get_radius(\n    self, distribution: NDArray[np.float64], density: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#massbasedmovingbinget_species_mass","title":"MassBasedMovingBin().get_species_mass","text":"<p>Show source in distribution_strategies.py:173</p>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_14","title":"Signature","text":"<pre><code>def get_species_mass(\n    self, distribution: NDArray[np.float64], density: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#particleresolvedspeciatedmass","title":"ParticleResolvedSpeciatedMass","text":"<p>Show source in distribution_strategies.py:432</p> <p>Strategy for resolved particles via speciated mass.</p> <p>Strategy for resolved particles with speciated mass. Particles may have different densities and their mass is distributed across different species. This strategy calculates mass, radius, and total mass based on the species at each mass, density, the particle concentration.</p>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_15","title":"Signature","text":"<pre><code>class ParticleResolvedSpeciatedMass(DistributionStrategy): ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#see-also_1","title":"See also","text":"<ul> <li>DistributionStrategy</li> </ul>"},{"location":"API/particula/next/particles/distribution_strategies/#particleresolvedspeciatedmassadd_concentration","title":"ParticleResolvedSpeciatedMass().add_concentration","text":"<p>Show source in distribution_strategies.py:479</p>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_16","title":"Signature","text":"<pre><code>def add_concentration(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    added_distribution: NDArray[np.float64],\n    added_concentration: NDArray[np.float64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#particleresolvedspeciatedmassadd_mass","title":"ParticleResolvedSpeciatedMass().add_mass","text":"<p>Show source in distribution_strategies.py:457</p>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_17","title":"Signature","text":"<pre><code>def add_mass(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    density: NDArray[np.float64],\n    added_mass: NDArray[np.float64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#particleresolvedspeciatedmasscollide_pairs","title":"ParticleResolvedSpeciatedMass().collide_pairs","text":"<p>Show source in distribution_strategies.py:541</p>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_18","title":"Signature","text":"<pre><code>def collide_pairs(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    density: NDArray[np.float64],\n    indices: NDArray[np.int64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#particleresolvedspeciatedmassget_radius","title":"ParticleResolvedSpeciatedMass().get_radius","text":"<p>Show source in distribution_strategies.py:447</p>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_19","title":"Signature","text":"<pre><code>def get_radius(\n    self, distribution: NDArray[np.float64], density: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#particleresolvedspeciatedmassget_species_mass","title":"ParticleResolvedSpeciatedMass().get_species_mass","text":"<p>Show source in distribution_strategies.py:442</p>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_20","title":"Signature","text":"<pre><code>def get_species_mass(\n    self, distribution: NDArray[np.float64], density: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#radiibasedmovingbin","title":"RadiiBasedMovingBin","text":"<p>Show source in distribution_strategies.py:249</p> <p>A strategy for particles represented by their radius.</p> <p>This strategy calculates particle mass, radius, and total mass based on the particle's radius, number concentration, and density.</p>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_21","title":"Signature","text":"<pre><code>class RadiiBasedMovingBin(DistributionStrategy): ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#see-also_2","title":"See also","text":"<ul> <li>DistributionStrategy</li> </ul>"},{"location":"API/particula/next/particles/distribution_strategies/#radiibasedmovingbinadd_concentration","title":"RadiiBasedMovingBin().add_concentration","text":"<p>Show source in distribution_strategies.py:288</p>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_22","title":"Signature","text":"<pre><code>def add_concentration(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    added_distribution: NDArray[np.float64],\n    added_concentration: NDArray[np.float64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#radiibasedmovingbinadd_mass","title":"RadiiBasedMovingBin().add_mass","text":"<p>Show source in distribution_strategies.py:270</p>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_23","title":"Signature","text":"<pre><code>def add_mass(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    density: NDArray[np.float64],\n    added_mass: NDArray[np.float64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#radiibasedmovingbincollide_pairs","title":"RadiiBasedMovingBin().collide_pairs","text":"<p>Show source in distribution_strategies.py:323</p>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_24","title":"Signature","text":"<pre><code>def collide_pairs(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    density: NDArray[np.float64],\n    indices: NDArray[np.int64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#radiibasedmovingbinget_radius","title":"RadiiBasedMovingBin().get_radius","text":"<p>Show source in distribution_strategies.py:263</p>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_25","title":"Signature","text":"<pre><code>def get_radius(\n    self, distribution: NDArray[np.float64], density: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#radiibasedmovingbinget_species_mass","title":"RadiiBasedMovingBin().get_species_mass","text":"<p>Show source in distribution_strategies.py:256</p>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_26","title":"Signature","text":"<pre><code>def get_species_mass(\n    self, distribution: NDArray[np.float64], density: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#speciatedmassmovingbin","title":"SpeciatedMassMovingBin","text":"<p>Show source in distribution_strategies.py:338</p> <p>Strategy for particles with speciated mass distribution.</p> <p>Strategy for particles with speciated mass distribution. Some particles may have different densities and their mass is distributed across different species. This strategy calculates mass, radius, and total mass based on the species at each mass, density, the particle concentration.</p>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_27","title":"Signature","text":"<pre><code>class SpeciatedMassMovingBin(DistributionStrategy): ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#see-also_3","title":"See also","text":"<ul> <li>DistributionStrategy</li> </ul>"},{"location":"API/particula/next/particles/distribution_strategies/#speciatedmassmovingbinadd_concentration","title":"SpeciatedMassMovingBin().add_concentration","text":"<p>Show source in distribution_strategies.py:382</p>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_28","title":"Signature","text":"<pre><code>def add_concentration(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    added_distribution: NDArray[np.float64],\n    added_concentration: NDArray[np.float64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#speciatedmassmovingbinadd_mass","title":"SpeciatedMassMovingBin().add_mass","text":"<p>Show source in distribution_strategies.py:360</p>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_29","title":"Signature","text":"<pre><code>def add_mass(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    density: NDArray[np.float64],\n    added_mass: NDArray[np.float64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#speciatedmassmovingbincollide_pairs","title":"SpeciatedMassMovingBin().collide_pairs","text":"<p>Show source in distribution_strategies.py:417</p>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_30","title":"Signature","text":"<pre><code>def collide_pairs(\n    self,\n    distribution: NDArray[np.float64],\n    concentration: NDArray[np.float64],\n    density: NDArray[np.float64],\n    indices: NDArray[np.int64],\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#speciatedmassmovingbinget_radius","title":"SpeciatedMassMovingBin().get_radius","text":"<p>Show source in distribution_strategies.py:353</p>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_31","title":"Signature","text":"<pre><code>def get_radius(\n    self, distribution: NDArray[np.float64], density: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/particles/distribution_strategies/#speciatedmassmovingbinget_species_mass","title":"SpeciatedMassMovingBin().get_species_mass","text":"<p>Show source in distribution_strategies.py:348</p>"},{"location":"API/particula/next/particles/distribution_strategies/#signature_32","title":"Signature","text":"<pre><code>def get_species_mass(\n    self, distribution: NDArray[np.float64], density: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/particles/representation/","title":"Representation","text":"<p>Particula Index / Particula / Next / Particles / Representation</p> <p>Auto-generated documentation for particula.next.particles.representation module.</p>"},{"location":"API/particula/next/particles/representation/#particlerepresentation","title":"ParticleRepresentation","text":"<p>Show source in representation.py:17</p> <p>Everything needed to represent a particle or a collection of particles.</p> <p>Represents a particle or a collection of particles, encapsulating the strategy for calculating mass, radius, and total mass based on a specified particle distribution, density, and concentration. This class allows for flexibility in representing particles.</p>"},{"location":"API/particula/next/particles/representation/#attributes","title":"Attributes","text":"<ul> <li><code>strategy</code> - The computation strategy for particle representations.</li> <li><code>activity</code> - The activity strategy for the partial pressure calculations.</li> <li><code>surface</code> - The surface strategy for surface tension and Kelvin effect.</li> <li><code>distribution</code> - The distribution data for the particles, which could     represent sizes, masses, or another relevant metric.</li> <li><code>density</code> - The density of the material from which the particles are made.</li> <li><code>concentration</code> - The concentration of particles within the distribution.</li> <li><code>charge</code> - The charge on each particle.</li> <li><code>volume</code> - The air volume for simulation of particles in the air,     default is 1 m^3. This is only used in ParticleResolved Strategies.</li> </ul>"},{"location":"API/particula/next/particles/representation/#signature","title":"Signature","text":"<pre><code>class ParticleRepresentation:\n    def __init__(\n        self,\n        strategy: DistributionStrategy,\n        activity: ActivityStrategy,\n        surface: SurfaceStrategy,\n        distribution: NDArray[np.float64],\n        density: NDArray[np.float64],\n        concentration: NDArray[np.float64],\n        charge: NDArray[np.float64],\n        volume: float = 1,\n    ): ...\n</code></pre>"},{"location":"API/particula/next/particles/representation/#see-also","title":"See also","text":"<ul> <li>ActivityStrategy</li> <li>DistributionStrategy</li> <li>SurfaceStrategy</li> </ul>"},{"location":"API/particula/next/particles/representation/#particlerepresentationstr","title":"ParticleRepresentation().str","text":"<p>Show source in representation.py:58</p> <p>Returns a string representation of the particle representation.</p>"},{"location":"API/particula/next/particles/representation/#returns","title":"Returns","text":"<ul> <li><code>str</code> - A string representation of the particle representation.</li> </ul>"},{"location":"API/particula/next/particles/representation/#signature_1","title":"Signature","text":"<pre><code>def __str__(self) -&gt; str: ...\n</code></pre>"},{"location":"API/particula/next/particles/representation/#particlerepresentationadd_concentration","title":"ParticleRepresentation().add_concentration","text":"<p>Show source in representation.py:309</p> <p>Adds concentration to the particle distribution.</p>"},{"location":"API/particula/next/particles/representation/#arguments","title":"Arguments","text":"<ul> <li><code>added_concentration</code> - The concentration to be     added per distribution bin.</li> </ul>"},{"location":"API/particula/next/particles/representation/#signature_2","title":"Signature","text":"<pre><code>def add_concentration(\n    self,\n    added_concentration: NDArray[np.float64],\n    added_distribution: Optional[NDArray[np.float64]] = None,\n) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/next/particles/representation/#particlerepresentationadd_mass","title":"ParticleRepresentation().add_mass","text":"<p>Show source in representation.py:294</p> <p>Adds mass to the particle distribution, and updates parameters.</p>"},{"location":"API/particula/next/particles/representation/#arguments_1","title":"Arguments","text":"<ul> <li><code>added_mass</code> - The mass to be added per     distribution bin.</li> </ul>"},{"location":"API/particula/next/particles/representation/#signature_3","title":"Signature","text":"<pre><code>def add_mass(self, added_mass: NDArray[np.float64]) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/next/particles/representation/#particlerepresentationcollide_pairs","title":"ParticleRepresentation().collide_pairs","text":"<p>Show source in representation.py:334</p> <p>Collide pairs of indices, used for ParticleResolved Strategies.</p>"},{"location":"API/particula/next/particles/representation/#arguments_2","title":"Arguments","text":"<ul> <li><code>indices</code> - The indices to collide.</li> </ul>"},{"location":"API/particula/next/particles/representation/#signature_4","title":"Signature","text":"<pre><code>def collide_pairs(self, indices: NDArray[np.int64]) -&gt; None: ...\n</code></pre>"},{"location":"API/particula/next/particles/representation/#particlerepresentationget_activity","title":"ParticleRepresentation().get_activity","text":"<p>Show source in representation.py:96</p> <p>Returns the activity strategy used for partial pressure calculations.</p>"},{"location":"API/particula/next/particles/representation/#arguments_3","title":"Arguments","text":"<ul> <li><code>clone</code> - If True, then return a deepcopy of the activity strategy.</li> </ul>"},{"location":"API/particula/next/particles/representation/#returns_1","title":"Returns","text":"<p>The activity strategy used for partial pressure calculations.</p>"},{"location":"API/particula/next/particles/representation/#signature_5","title":"Signature","text":"<pre><code>def get_activity(self, clone: bool = False) -&gt; ActivityStrategy: ...\n</code></pre>"},{"location":"API/particula/next/particles/representation/#see-also_1","title":"See also","text":"<ul> <li>ActivityStrategy</li> </ul>"},{"location":"API/particula/next/particles/representation/#particlerepresentationget_activity_name","title":"ParticleRepresentation().get_activity_name","text":"<p>Show source in representation.py:110</p> <p>Returns the name of the activity strategy used for partial pressure calculations.</p>"},{"location":"API/particula/next/particles/representation/#returns_2","title":"Returns","text":"<p>The name of the activity strategy used for partial pressure calculations.</p>"},{"location":"API/particula/next/particles/representation/#signature_6","title":"Signature","text":"<pre><code>def get_activity_name(self) -&gt; str: ...\n</code></pre>"},{"location":"API/particula/next/particles/representation/#particlerepresentationget_charge","title":"ParticleRepresentation().get_charge","text":"<p>Show source in representation.py:198</p> <p>Returns the charge per particle.</p>"},{"location":"API/particula/next/particles/representation/#arguments_4","title":"Arguments","text":"<ul> <li><code>clone</code> - If True, then return a copy of the charge array.</li> </ul>"},{"location":"API/particula/next/particles/representation/#returns_3","title":"Returns","text":"<p>The charge of the particles.</p>"},{"location":"API/particula/next/particles/representation/#signature_7","title":"Signature","text":"<pre><code>def get_charge(self, clone: bool = False) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/particles/representation/#particlerepresentationget_concentration","title":"ParticleRepresentation().get_concentration","text":"<p>Show source in representation.py:170</p> <p>Returns the volume concentration of the particles.</p> <p>For ParticleResolved Strategies, the concentration is the number of particles per self.volume to get concentration/m^3. For other Strategies, the concentration is the already per 1/m^3.</p>"},{"location":"API/particula/next/particles/representation/#arguments_5","title":"Arguments","text":"<ul> <li><code>clone</code> - If True, then return a copy of the concentration array.</li> </ul>"},{"location":"API/particula/next/particles/representation/#returns_4","title":"Returns","text":"<p>The concentration of the particles.</p>"},{"location":"API/particula/next/particles/representation/#signature_8","title":"Signature","text":"<pre><code>def get_concentration(self, clone: bool = False) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/particles/representation/#particlerepresentationget_density","title":"ParticleRepresentation().get_density","text":"<p>Show source in representation.py:157</p> <p>Returns the density of the particles.</p>"},{"location":"API/particula/next/particles/representation/#arguments_6","title":"Arguments","text":"<ul> <li><code>clone</code> - If True, then return a copy of the density array.</li> </ul>"},{"location":"API/particula/next/particles/representation/#returns_5","title":"Returns","text":"<p>The density of the particles.</p>"},{"location":"API/particula/next/particles/representation/#signature_9","title":"Signature","text":"<pre><code>def get_density(self, clone: bool = False) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/particles/representation/#particlerepresentationget_distribution","title":"ParticleRepresentation().get_distribution","text":"<p>Show source in representation.py:144</p> <p>Returns the distribution of the particles.</p>"},{"location":"API/particula/next/particles/representation/#arguments_7","title":"Arguments","text":"<ul> <li><code>clone</code> - If True, then return a copy of the distribution array.</li> </ul>"},{"location":"API/particula/next/particles/representation/#returns_6","title":"Returns","text":"<p>The distribution of the particles.</p>"},{"location":"API/particula/next/particles/representation/#signature_10","title":"Signature","text":"<pre><code>def get_distribution(self, clone: bool = False) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/particles/representation/#particlerepresentationget_mass","title":"ParticleRepresentation().get_mass","text":"<p>Show source in representation.py:239</p> <p>Returns the mass of the particles as calculated by the strategy.</p>"},{"location":"API/particula/next/particles/representation/#arguments_8","title":"Arguments","text":"<ul> <li><code>clone</code> - If True, then return a copy of the mass array.</li> </ul>"},{"location":"API/particula/next/particles/representation/#returns_7","title":"Returns","text":"<p>The mass of the particles.</p>"},{"location":"API/particula/next/particles/representation/#signature_11","title":"Signature","text":"<pre><code>def get_mass(self, clone: bool = False) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/particles/representation/#particlerepresentationget_mass_concentration","title":"ParticleRepresentation().get_mass_concentration","text":"<p>Show source in representation.py:254</p> <p>Returns the total mass / volume simulated.</p> <p>The mass concentration is as calculated by the strategy, taking into account the distribution and concentration.</p>"},{"location":"API/particula/next/particles/representation/#arguments_9","title":"Arguments","text":"<ul> <li><code>clone</code> - If True, then return a copy of the mass concentration.</li> </ul>"},{"location":"API/particula/next/particles/representation/#returns_8","title":"Returns","text":"<ul> <li><code>np.float64</code> - The mass concentration of the particles, kg/m^3.</li> </ul>"},{"location":"API/particula/next/particles/representation/#signature_12","title":"Signature","text":"<pre><code>def get_mass_concentration(self, clone: bool = False) -&gt; np.float64: ...\n</code></pre>"},{"location":"API/particula/next/particles/representation/#particlerepresentationget_radius","title":"ParticleRepresentation().get_radius","text":"<p>Show source in representation.py:280</p> <p>Returns the radius of the particles as calculated by the strategy.</p>"},{"location":"API/particula/next/particles/representation/#arguments_10","title":"Arguments","text":"<ul> <li><code>clone</code> - If True, then return a copy of the radius array</li> </ul>"},{"location":"API/particula/next/particles/representation/#returns_9","title":"Returns","text":"<p>The radius of the particles.</p>"},{"location":"API/particula/next/particles/representation/#signature_13","title":"Signature","text":"<pre><code>def get_radius(self, clone: bool = False) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/particles/representation/#particlerepresentationget_species_mass","title":"ParticleRepresentation().get_species_mass","text":"<p>Show source in representation.py:224</p> <p>Returns the masses per species in the particles.</p>"},{"location":"API/particula/next/particles/representation/#arguments_11","title":"Arguments","text":"<ul> <li><code>clone</code> - If True, then return a copy of the mass array.</li> </ul>"},{"location":"API/particula/next/particles/representation/#returns_10","title":"Returns","text":"<p>The mass of the particles per species.</p>"},{"location":"API/particula/next/particles/representation/#signature_14","title":"Signature","text":"<pre><code>def get_species_mass(self, clone: bool = False) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/particles/representation/#particlerepresentationget_strategy","title":"ParticleRepresentation().get_strategy","text":"<p>Show source in representation.py:75</p> <p>Returns the strategy used for particle representation.</p>"},{"location":"API/particula/next/particles/representation/#arguments_12","title":"Arguments","text":"<ul> <li><code>clone</code> - If True, then return a deepcopy of the strategy.</li> </ul>"},{"location":"API/particula/next/particles/representation/#returns_11","title":"Returns","text":"<p>The strategy used for particle representation.</p>"},{"location":"API/particula/next/particles/representation/#signature_15","title":"Signature","text":"<pre><code>def get_strategy(self, clone: bool = False) -&gt; DistributionStrategy: ...\n</code></pre>"},{"location":"API/particula/next/particles/representation/#see-also_2","title":"See also","text":"<ul> <li>DistributionStrategy</li> </ul>"},{"location":"API/particula/next/particles/representation/#particlerepresentationget_strategy_name","title":"ParticleRepresentation().get_strategy_name","text":"<p>Show source in representation.py:88</p> <p>Returns the name of the strategy used for particle representation.</p>"},{"location":"API/particula/next/particles/representation/#returns_12","title":"Returns","text":"<p>The name of the strategy used for particle representation.</p>"},{"location":"API/particula/next/particles/representation/#signature_16","title":"Signature","text":"<pre><code>def get_strategy_name(self) -&gt; str: ...\n</code></pre>"},{"location":"API/particula/next/particles/representation/#particlerepresentationget_surface","title":"ParticleRepresentation().get_surface","text":"<p>Show source in representation.py:120</p> <p>Returns the surface strategy used for surface tension and Kelvin effect.</p>"},{"location":"API/particula/next/particles/representation/#arguments_13","title":"Arguments","text":"<ul> <li><code>clone</code> - If True, then return a deepcopy of the surface strategy.</li> </ul>"},{"location":"API/particula/next/particles/representation/#returns_13","title":"Returns","text":"<p>The surface strategy used for surface tension and Kelvin effect.</p>"},{"location":"API/particula/next/particles/representation/#signature_17","title":"Signature","text":"<pre><code>def get_surface(self, clone: bool = False) -&gt; SurfaceStrategy: ...\n</code></pre>"},{"location":"API/particula/next/particles/representation/#see-also_3","title":"See also","text":"<ul> <li>SurfaceStrategy</li> </ul>"},{"location":"API/particula/next/particles/representation/#particlerepresentationget_surface_name","title":"ParticleRepresentation().get_surface_name","text":"<p>Show source in representation.py:134</p> <p>Returns the name of the surface strategy used for surface tension and Kelvin effect.</p>"},{"location":"API/particula/next/particles/representation/#returns_14","title":"Returns","text":"<p>The name of the surface strategy used for surface tension and Kelvin effect.</p>"},{"location":"API/particula/next/particles/representation/#signature_18","title":"Signature","text":"<pre><code>def get_surface_name(self) -&gt; str: ...\n</code></pre>"},{"location":"API/particula/next/particles/representation/#particlerepresentationget_total_concentration","title":"ParticleRepresentation().get_total_concentration","text":"<p>Show source in representation.py:187</p> <p>Returns the total concentration of the particles.</p>"},{"location":"API/particula/next/particles/representation/#arguments_14","title":"Arguments","text":"<ul> <li><code>clone</code> - If True, then return a copy of the concentration array.</li> </ul>"},{"location":"API/particula/next/particles/representation/#returns_15","title":"Returns","text":"<p>The concentration of the particles.</p>"},{"location":"API/particula/next/particles/representation/#signature_19","title":"Signature","text":"<pre><code>def get_total_concentration(self, clone: bool = False) -&gt; np.float64: ...\n</code></pre>"},{"location":"API/particula/next/particles/representation/#particlerepresentationget_volume","title":"ParticleRepresentation().get_volume","text":"<p>Show source in representation.py:211</p> <p>Returns the volume of the particles.</p>"},{"location":"API/particula/next/particles/representation/#arguments_15","title":"Arguments","text":"<ul> <li><code>clone</code> - If True, then return a copy of the volume array.</li> </ul>"},{"location":"API/particula/next/particles/representation/#returns_16","title":"Returns","text":"<p>The volume of the particles.</p>"},{"location":"API/particula/next/particles/representation/#signature_20","title":"Signature","text":"<pre><code>def get_volume(self, clone: bool = False) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/next/particles/representation_builders/","title":"Representation Builders","text":"<p>Particula Index / Particula / Next / Particles / Representation Builders</p> <p>Auto-generated documentation for particula.next.particles.representation_builders module.</p>"},{"location":"API/particula/next/particles/representation_builders/#particlemassrepresentationbuilder","title":"ParticleMassRepresentationBuilder","text":"<p>Show source in representation_builders.py:56</p> <p>General ParticleRepresentation objects with mass-based bins.</p>"},{"location":"API/particula/next/particles/representation_builders/#attributes","title":"Attributes","text":"<ul> <li><code>distribution_strategy</code> - Set the DistributionStrategy.</li> <li><code>activity_strategy</code> - Set the ActivityStrategy.</li> <li><code>surface_strategy</code> - Set the SurfaceStrategy.</li> <li><code>mass</code> - Set the mass of the particles. Default units are 'kg'.</li> <li><code>density</code> - Set the density of the particles. Default units are 'kg/m^3'.</li> <li><code>concentration</code> - Set the concentration of the particles.     Default units are '1/m^3'.</li> <li><code>charge</code> - Set the number of charges.</li> </ul>"},{"location":"API/particula/next/particles/representation_builders/#signature","title":"Signature","text":"<pre><code>class ParticleMassRepresentationBuilder(\n    BuilderABC,\n    BuilderDistributionStrategyMixin,\n    BuilderActivityStrategyMixin,\n    BuilderSurfaceStrategyMixin,\n    BuilderMassMixin,\n    BuilderDensityMixin,\n    BuilderConcentrationMixin,\n    BuilderChargeMixin,\n):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/particles/representation_builders/#see-also","title":"See also","text":"<ul> <li>BuilderABC</li> <li>BuilderActivityStrategyMixin</li> <li>BuilderChargeMixin</li> <li>BuilderConcentrationMixin</li> <li>BuilderDensityMixin</li> <li>BuilderDistributionStrategyMixin</li> <li>BuilderMassMixin</li> <li>BuilderSurfaceStrategyMixin</li> </ul>"},{"location":"API/particula/next/particles/representation_builders/#particlemassrepresentationbuilderbuild","title":"ParticleMassRepresentationBuilder().build","text":"<p>Show source in representation_builders.py:98</p> <p>Validate and return the ParticleRepresentation object.</p>"},{"location":"API/particula/next/particles/representation_builders/#returns","title":"Returns","text":"<p>The validated ParticleRepresentation object.</p>"},{"location":"API/particula/next/particles/representation_builders/#signature_1","title":"Signature","text":"<pre><code>def build(self) -&gt; ParticleRepresentation: ...\n</code></pre>"},{"location":"API/particula/next/particles/representation_builders/#see-also_1","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/particles/representation_builders/#particleradiusrepresentationbuilder","title":"ParticleRadiusRepresentationBuilder","text":"<p>Show source in representation_builders.py:116</p> <p>General ParticleRepresentation objects with radius-based bins.</p>"},{"location":"API/particula/next/particles/representation_builders/#attributes_1","title":"Attributes","text":"<ul> <li><code>distribution_strategy</code> - Set the DistributionStrategy.</li> <li><code>activity_strategy</code> - Set the ActivityStrategy.</li> <li><code>surface_strategy</code> - Set the SurfaceStrategy.</li> <li><code>radius</code> - Set the radius of the particles. Default units are 'm'.</li> <li><code>density</code> - Set the density of the particles. Default units are 'kg/m**3'.</li> <li><code>concentration</code> - Set the concentration of the particles. Default units     are '1/m^3'.</li> <li><code>charge</code> - Set the number of charges.</li> </ul>"},{"location":"API/particula/next/particles/representation_builders/#signature_2","title":"Signature","text":"<pre><code>class ParticleRadiusRepresentationBuilder(\n    BuilderABC,\n    BuilderDistributionStrategyMixin,\n    BuilderActivityStrategyMixin,\n    BuilderSurfaceStrategyMixin,\n    BuilderRadiusMixin,\n    BuilderDensityMixin,\n    BuilderConcentrationMixin,\n    BuilderChargeMixin,\n):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/particles/representation_builders/#see-also_2","title":"See also","text":"<ul> <li>BuilderABC</li> <li>BuilderActivityStrategyMixin</li> <li>BuilderChargeMixin</li> <li>BuilderConcentrationMixin</li> <li>BuilderDensityMixin</li> <li>BuilderDistributionStrategyMixin</li> <li>BuilderRadiusMixin</li> <li>BuilderSurfaceStrategyMixin</li> </ul>"},{"location":"API/particula/next/particles/representation_builders/#particleradiusrepresentationbuilderbuild","title":"ParticleRadiusRepresentationBuilder().build","text":"<p>Show source in representation_builders.py:158</p> <p>Validate and return the ParticleRepresentation object.</p>"},{"location":"API/particula/next/particles/representation_builders/#returns_1","title":"Returns","text":"<p>The validated ParticleRepresentation object.</p>"},{"location":"API/particula/next/particles/representation_builders/#signature_3","title":"Signature","text":"<pre><code>def build(self) -&gt; ParticleRepresentation: ...\n</code></pre>"},{"location":"API/particula/next/particles/representation_builders/#see-also_3","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/particles/representation_builders/#presetparticleradiusbuilder","title":"PresetParticleRadiusBuilder","text":"<p>Show source in representation_builders.py:176</p> <p>General ParticleRepresentation objects with radius-based bins.</p>"},{"location":"API/particula/next/particles/representation_builders/#attributes_2","title":"Attributes","text":"<ul> <li><code>mode</code> - Set the mode(s) of the distribution.     Default is np.array([100e-9, 1e-6]) meters.</li> <li><code>geometric_standard_deviation</code> - Set the geometric standard deviation(s)     of the distribution. Default is np.array([1.2, 1.4]).</li> <li><code>number_concentration</code> - Set the number concentration of the distribution.     Default is np.array([1e4x1e6, 1e3x1e6]) particles/m^3.</li> <li><code>radius_bins</code> - Set the radius bins of the distribution. Default is     np.logspace(-9, -4, 250), meters.</li> </ul>"},{"location":"API/particula/next/particles/representation_builders/#signature_4","title":"Signature","text":"<pre><code>class PresetParticleRadiusBuilder(\n    BuilderABC,\n    BuilderDistributionStrategyMixin,\n    BuilderActivityStrategyMixin,\n    BuilderSurfaceStrategyMixin,\n    BuilderRadiusMixin,\n    BuilderDensityMixin,\n    BuilderConcentrationMixin,\n    BuilderChargeMixin,\n    BuilderLognormalMixin,\n):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/particles/representation_builders/#see-also_4","title":"See also","text":"<ul> <li>BuilderABC</li> <li>BuilderActivityStrategyMixin</li> <li>BuilderChargeMixin</li> <li>BuilderConcentrationMixin</li> <li>BuilderDensityMixin</li> <li>BuilderDistributionStrategyMixin</li> <li>BuilderLognormalMixin</li> <li>BuilderRadiusMixin</li> <li>BuilderSurfaceStrategyMixin</li> </ul>"},{"location":"API/particula/next/particles/representation_builders/#presetparticleradiusbuilderbuild","title":"PresetParticleRadiusBuilder().build","text":"<p>Show source in representation_builders.py:266</p> <p>Validate and return the ParticleRepresentation object.</p> <p>This will build a distribution of particles with a lognormal size distribution, before returning the ParticleRepresentation object.</p>"},{"location":"API/particula/next/particles/representation_builders/#returns_2","title":"Returns","text":"<p>The validated ParticleRepresentation object.</p>"},{"location":"API/particula/next/particles/representation_builders/#signature_5","title":"Signature","text":"<pre><code>def build(self) -&gt; ParticleRepresentation: ...\n</code></pre>"},{"location":"API/particula/next/particles/representation_builders/#see-also_5","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/particles/representation_builders/#presetparticleradiusbuilderset_distribution_type","title":"PresetParticleRadiusBuilder().set_distribution_type","text":"<p>Show source in representation_builders.py:247</p> <p>Set the distribution type for the particle representation.</p>"},{"location":"API/particula/next/particles/representation_builders/#arguments","title":"Arguments","text":"<ul> <li><code>distribution_type</code> - The type of distribution to use.</li> </ul>"},{"location":"API/particula/next/particles/representation_builders/#signature_6","title":"Signature","text":"<pre><code>def set_distribution_type(\n    self, distribution_type: str, distribution_type_units: Optional[str] = None\n): ...\n</code></pre>"},{"location":"API/particula/next/particles/representation_builders/#presetparticleradiusbuilderset_radius_bins","title":"PresetParticleRadiusBuilder().set_radius_bins","text":"<p>Show source in representation_builders.py:230</p> <p>Set the radius bins for the distribution</p>"},{"location":"API/particula/next/particles/representation_builders/#arguments_1","title":"Arguments","text":"<ul> <li><code>radius_bins</code> - The radius bins for the distribution.</li> </ul>"},{"location":"API/particula/next/particles/representation_builders/#signature_7","title":"Signature","text":"<pre><code>def set_radius_bins(\n    self, radius_bins: NDArray[np.float64], radius_bins_units: str = \"m\"\n): ...\n</code></pre>"},{"location":"API/particula/next/particles/representation_builders/#presetresolvedparticlemassbuilder","title":"PresetResolvedParticleMassBuilder","text":"<p>Show source in representation_builders.py:382</p> <p>General ParticleRepresentation objects with particle resolved masses.</p> <p>This class has preset values for all the attributes, and allows you to override them as needed. This is useful when you want to quickly particle representation object with resolved masses.</p>"},{"location":"API/particula/next/particles/representation_builders/#attributes_3","title":"Attributes","text":"<ul> <li><code>distribution_strategy</code> - Set the DistributionStrategy.</li> <li><code>activity_strategy</code> - Set the ActivityStrategy.</li> <li><code>surface_strategy</code> - Set the SurfaceStrategy.</li> <li><code>mass</code> - Set the mass of the particles Default     units are 'kg'.</li> <li><code>density</code> - Set the density of the particles.     Default units are 'kg/m^3'.</li> <li><code>charge</code> - Set the number of charges.</li> <li><code>mode</code> - Set the mode(s) of the distribution.     Default is np.array([100e-9, 1e-6]) meters.</li> <li><code>geometric_standard_deviation</code> - Set the geometric standard     deviation(s) of the distribution. Default is np.array([1.2, 1.4]).</li> <li><code>number_concentration</code> - Set the number concentration of the     distribution. Default is np.array([1e4 1e6, 1e3 1e6])     particles/m^3.</li> <li><code>particle_resolved_count</code> - Set the number of resolved particles.</li> </ul>"},{"location":"API/particula/next/particles/representation_builders/#signature_8","title":"Signature","text":"<pre><code>class PresetResolvedParticleMassBuilder(\n    BuilderABC,\n    BuilderDistributionStrategyMixin,\n    BuilderActivityStrategyMixin,\n    BuilderSurfaceStrategyMixin,\n    BuilderDensityMixin,\n    BuilderChargeMixin,\n    BuilderLognormalMixin,\n    BuilderVolumeMixin,\n    BuilderParticleResolvedCountMixin,\n):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/particles/representation_builders/#see-also_6","title":"See also","text":"<ul> <li>BuilderABC</li> <li>BuilderActivityStrategyMixin</li> <li>BuilderChargeMixin</li> <li>BuilderDensityMixin</li> <li>BuilderDistributionStrategyMixin</li> <li>BuilderLognormalMixin</li> <li>BuilderParticleResolvedCountMixin</li> <li>BuilderSurfaceStrategyMixin</li> <li>BuilderVolumeMixin</li> </ul>"},{"location":"API/particula/next/particles/representation_builders/#presetresolvedparticlemassbuilderbuild","title":"PresetResolvedParticleMassBuilder().build","text":"<p>Show source in representation_builders.py:450</p> <p>Validate and return the ParticleRepresentation object.</p> <p>This will build a distribution of particles with a lognormal size distribution, before returning the ParticleRepresentation object.</p>"},{"location":"API/particula/next/particles/representation_builders/#returns_3","title":"Returns","text":"<p>The validated ParticleRepresentation object.</p>"},{"location":"API/particula/next/particles/representation_builders/#signature_9","title":"Signature","text":"<pre><code>def build(self) -&gt; ParticleRepresentation: ...\n</code></pre>"},{"location":"API/particula/next/particles/representation_builders/#see-also_7","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/particles/representation_builders/#resolvedparticlemassrepresentationbuilder","title":"ResolvedParticleMassRepresentationBuilder","text":"<p>Show source in representation_builders.py:306</p> <p>Builder class for constructing ParticleRepresentation objects with resolved masses.</p> <p>This class allows you to set various attributes for a particle representation, such as distribution strategy, mass, density, charge, volume, and more. These attributes are validated and there a no presets.</p>"},{"location":"API/particula/next/particles/representation_builders/#attributes_4","title":"Attributes","text":"<ul> <li><code>distribution_strategy</code> - Set the distribution strategy for particles.</li> <li><code>activity_strategy</code> - Set the activity strategy for the particles.</li> <li><code>surface_strategy</code> - Set the surface strategy for the particles.</li> <li><code>mass</code> - Set the particle mass. Defaults to 'kg'.</li> <li><code>density</code> - Set the particle density. Defaults to 'kg/m^3'.</li> <li><code>charge</code> - Set the particle charge.</li> <li><code>volume</code> - Set the particle volume. Defaults to 'm^3'.</li> </ul>"},{"location":"API/particula/next/particles/representation_builders/#signature_10","title":"Signature","text":"<pre><code>class ResolvedParticleMassRepresentationBuilder(\n    BuilderABC,\n    BuilderDistributionStrategyMixin,\n    BuilderActivityStrategyMixin,\n    BuilderSurfaceStrategyMixin,\n    BuilderDensityMixin,\n    BuilderChargeMixin,\n    BuilderVolumeMixin,\n    BuilderMassMixin,\n):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/particles/representation_builders/#see-also_8","title":"See also","text":"<ul> <li>BuilderABC</li> <li>BuilderActivityStrategyMixin</li> <li>BuilderChargeMixin</li> <li>BuilderDensityMixin</li> <li>BuilderDistributionStrategyMixin</li> <li>BuilderMassMixin</li> <li>BuilderSurfaceStrategyMixin</li> <li>BuilderVolumeMixin</li> </ul>"},{"location":"API/particula/next/particles/representation_builders/#resolvedparticlemassrepresentationbuilderbuild","title":"ResolvedParticleMassRepresentationBuilder().build","text":"<p>Show source in representation_builders.py:353</p> <p>Validate and return a ParticleRepresentation object.</p> <p>This method validates all the required attributes and builds a particle representation with a lognormal size distribution.</p>"},{"location":"API/particula/next/particles/representation_builders/#returns_4","title":"Returns","text":"<ul> <li><code>ParticleRepresentation</code> - A validated particle representation object.</li> </ul>"},{"location":"API/particula/next/particles/representation_builders/#signature_11","title":"Signature","text":"<pre><code>def build(self) -&gt; ParticleRepresentation: ...\n</code></pre>"},{"location":"API/particula/next/particles/representation_builders/#see-also_9","title":"See also","text":"<ul> <li>ParticleRepresentation</li> </ul>"},{"location":"API/particula/next/particles/representation_factories/","title":"Representation Factories","text":"<p>Particula Index / Particula / Next / Particles / Representation Factories</p> <p>Auto-generated documentation for particula.next.particles.representation_factories module.</p>"},{"location":"API/particula/next/particles/representation_factories/#particlerepresentationfactory","title":"ParticleRepresentationFactory","text":"<p>Show source in representation_factories.py:17</p> <p>Factory class to create particle representation builders.</p>"},{"location":"API/particula/next/particles/representation_factories/#methods","title":"Methods","text":"<ul> <li><code>get_builders</code> - Returns the mapping of strategy types to builder     instances.</li> <li><code>get_strategy</code> - Gets the strategy instance for the specified strategy.<ul> <li><code>strategy_type</code> - Type of particle representation strategy to use, can be 'radius' (default) or 'mass'.</li> <li><code>parameters</code> - Parameters required for the builder</li> </ul> </li> </ul>"},{"location":"API/particula/next/particles/representation_factories/#returns","title":"Returns","text":"<ul> <li><code>ParticleRepresentation</code> - An instance of the specified ParticleRepresentation.</li> </ul>"},{"location":"API/particula/next/particles/representation_factories/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code> - If an unknown strategy type is provided.</li> <li><code>ValueError</code> - If any required key is missing during check_keys or     pre_build_check, or if trying to set an invalid parameter.</li> </ul>"},{"location":"API/particula/next/particles/representation_factories/#signature","title":"Signature","text":"<pre><code>class ParticleRepresentationFactory(\n    StrategyFactory[\n        Union[\n            ParticleMassRepresentationBuilder,\n            ParticleRadiusRepresentationBuilder,\n            PresetParticleRadiusBuilder,\n            ResolvedParticleMassRepresentationBuilder,\n            PresetResolvedParticleMassBuilder,\n        ],\n        ParticleRepresentation,\n    ]\n): ...\n</code></pre>"},{"location":"API/particula/next/particles/representation_factories/#see-also","title":"See also","text":"<ul> <li>ParticleMassRepresentationBuilder</li> <li>ParticleRadiusRepresentationBuilder</li> <li>ParticleRepresentation</li> <li>PresetParticleRadiusBuilder</li> <li>PresetResolvedParticleMassBuilder</li> <li>ResolvedParticleMassRepresentationBuilder</li> </ul>"},{"location":"API/particula/next/particles/representation_factories/#particlerepresentationfactoryget_builders","title":"ParticleRepresentationFactory().get_builders","text":"<p>Show source in representation_factories.py:50</p> <p>Returns the mapping of strategy types to builder instances.</p>"},{"location":"API/particula/next/particles/representation_factories/#returns_1","title":"Returns","text":"<ul> <li><code>dict[str,</code> Any] - A dictionary with the strategy types as keys and the builder instances as values.</li> <li><code>-</code> 'mass' - MassParticleRepresentationBuilder</li> <li><code>-</code> 'radius' - RadiusParticleRepresentationBuilder</li> <li><code>-</code> 'preset_radius' - LimitedRadiusParticleBuilder</li> <li><code>-</code> 'resolved_mass' - ResolvedMassParticleRepresentationBuilder</li> <li><code>-</code> 'preset_resolved_mass' - PresetResolvedMassParticleBuilder</li> </ul>"},{"location":"API/particula/next/particles/representation_factories/#signature_1","title":"Signature","text":"<pre><code>def get_builders(self): ...\n</code></pre>"},{"location":"API/particula/next/particles/surface_builders/","title":"Surface Builders","text":"<p>Particula Index / Particula / Next / Particles / Surface Builders</p> <p>Auto-generated documentation for particula.next.particles.surface_builders module.</p>"},{"location":"API/particula/next/particles/surface_builders/#surfacestrategymassbuilder","title":"SurfaceStrategyMassBuilder","text":"<p>Show source in surface_builders.py:65</p> <p>Builder class for SurfaceStrategyMass objects.</p>"},{"location":"API/particula/next/particles/surface_builders/#methods","title":"Methods","text":"<ul> <li><code>set_surface_tension(surface_tension,</code> surface_tension_units) - Set the     surface tension of the particle in N/m. Default units are 'N/m'.</li> <li><code>set_density(density,</code> density_units) - Set the density of the particle in     kg/m^3. Default units are 'kg/m^3'.</li> <li><code>set_parameters(params)</code> - Set the parameters of the SurfaceStrategyMass     object from a dictionary including optional units.</li> <li><code>build()</code> - Validate and return the SurfaceStrategyMass object.</li> </ul>"},{"location":"API/particula/next/particles/surface_builders/#signature","title":"Signature","text":"<pre><code>class SurfaceStrategyMassBuilder(\n    BuilderABC, BuilderSurfaceTensionMixin, BuilderDensityMixin\n):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/particles/surface_builders/#see-also","title":"See also","text":"<ul> <li>BuilderABC</li> <li>BuilderDensityMixin</li> <li>BuilderSurfaceTensionMixin</li> </ul>"},{"location":"API/particula/next/particles/surface_builders/#surfacestrategymassbuilderbuild","title":"SurfaceStrategyMassBuilder().build","text":"<p>Show source in surface_builders.py:88</p> <p>Validate and return the SurfaceStrategyMass object.</p>"},{"location":"API/particula/next/particles/surface_builders/#returns","title":"Returns","text":"<ul> <li><code>SurfaceStrategyMass</code> - Instance of the SurfaceStrategyMass object.</li> </ul>"},{"location":"API/particula/next/particles/surface_builders/#signature_1","title":"Signature","text":"<pre><code>def build(self) -&gt; SurfaceStrategyMass: ...\n</code></pre>"},{"location":"API/particula/next/particles/surface_builders/#see-also_1","title":"See also","text":"<ul> <li>SurfaceStrategyMass</li> </ul>"},{"location":"API/particula/next/particles/surface_builders/#surfacestrategymolarbuilder","title":"SurfaceStrategyMolarBuilder","text":"<p>Show source in surface_builders.py:24</p> <p>Builder class for SurfaceStrategyMolar objects.</p>"},{"location":"API/particula/next/particles/surface_builders/#methods_1","title":"Methods","text":"<ul> <li><code>set_surface_tension(surface_tension,</code> surface_tension_units) - Set the     surface tension of the particle in N/m. Default units are 'N/m'.</li> <li><code>set_density(density,</code> density_units) - Set the density of the particle in     kg/m^3. Default units are 'kg/m^3'.</li> <li><code>set_molar_mass(molar_mass,</code> molar_mass_units) - Set the molar mass of the     particle in kg/mol. Default units are 'kg/mol'.</li> <li><code>set_parameters(params)</code> - Set the parameters of the SurfaceStrategyMolar     object from a dictionary including optional units.</li> <li><code>build()</code> - Validate and return the SurfaceStrategyMolar object.</li> </ul>"},{"location":"API/particula/next/particles/surface_builders/#signature_2","title":"Signature","text":"<pre><code>class SurfaceStrategyMolarBuilder(\n    BuilderABC, BuilderDensityMixin, BuilderSurfaceTensionMixin, BuilderMolarMassMixin\n):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/particles/surface_builders/#see-also_2","title":"See also","text":"<ul> <li>BuilderABC</li> <li>BuilderDensityMixin</li> <li>BuilderMolarMassMixin</li> <li>BuilderSurfaceTensionMixin</li> </ul>"},{"location":"API/particula/next/particles/surface_builders/#surfacestrategymolarbuilderbuild","title":"SurfaceStrategyMolarBuilder().build","text":"<p>Show source in surface_builders.py:51</p> <p>Validate and return the SurfaceStrategyMass object.</p>"},{"location":"API/particula/next/particles/surface_builders/#returns_1","title":"Returns","text":"<ul> <li><code>SurfaceStrategyMolar</code> - Instance of the SurfaceStrategyMolar object.</li> </ul>"},{"location":"API/particula/next/particles/surface_builders/#signature_3","title":"Signature","text":"<pre><code>def build(self) -&gt; SurfaceStrategyMolar: ...\n</code></pre>"},{"location":"API/particula/next/particles/surface_builders/#see-also_3","title":"See also","text":"<ul> <li>SurfaceStrategyMolar</li> </ul>"},{"location":"API/particula/next/particles/surface_builders/#surfacestrategyvolumebuilder","title":"SurfaceStrategyVolumeBuilder","text":"<p>Show source in surface_builders.py:101</p> <p>Builder class for SurfaceStrategyVolume objects.</p>"},{"location":"API/particula/next/particles/surface_builders/#methods_2","title":"Methods","text":"<ul> <li><code>set_surface_tension(surface_tension,</code> surface_tension_units) - Set the     surface tension of the particle in N/m. Default units are 'N/m'.</li> <li><code>set_density(density,</code> density_units) - Set the density of the particle in     kg/m^3. Default units are 'kg/m^3'.</li> <li><code>set_parameters(params)</code> - Set the parameters of the SurfaceStrategyVolume     object from a dictionary including optional units.</li> <li><code>build()</code> - Validate and return the SurfaceStrategyVolume object.</li> </ul>"},{"location":"API/particula/next/particles/surface_builders/#signature_4","title":"Signature","text":"<pre><code>class SurfaceStrategyVolumeBuilder(\n    BuilderABC, BuilderSurfaceTensionMixin, BuilderDensityMixin\n):\n    def __init__(self): ...\n</code></pre>"},{"location":"API/particula/next/particles/surface_builders/#see-also_4","title":"See also","text":"<ul> <li>BuilderABC</li> <li>BuilderDensityMixin</li> <li>BuilderSurfaceTensionMixin</li> </ul>"},{"location":"API/particula/next/particles/surface_builders/#surfacestrategyvolumebuilderbuild","title":"SurfaceStrategyVolumeBuilder().build","text":"<p>Show source in surface_builders.py:124</p> <p>Validate and return the SurfaceStrategyVolume object.</p>"},{"location":"API/particula/next/particles/surface_builders/#returns_2","title":"Returns","text":"<ul> <li><code>SurfaceStrategyVolume</code> - Instance of the SurfaceStrategyVolume     object.</li> </ul>"},{"location":"API/particula/next/particles/surface_builders/#signature_5","title":"Signature","text":"<pre><code>def build(self) -&gt; SurfaceStrategyVolume: ...\n</code></pre>"},{"location":"API/particula/next/particles/surface_builders/#see-also_5","title":"See also","text":"<ul> <li>SurfaceStrategyVolume</li> </ul>"},{"location":"API/particula/next/particles/surface_factories/","title":"Surface Factories","text":"<p>Particula Index / Particula / Next / Particles / Surface Factories</p> <p>Auto-generated documentation for particula.next.particles.surface_factories module.</p>"},{"location":"API/particula/next/particles/surface_factories/#surfacefactory","title":"SurfaceFactory","text":"<p>Show source in surface_factories.py:17</p> <p>Factory class to call and create surface tension strategies.</p> <p>Factory class to create surface tension strategy builders for calculating surface tension and the Kelvin effect for species in particulate phases.</p>"},{"location":"API/particula/next/particles/surface_factories/#methods","title":"Methods","text":"<ul> <li><code>get_builders()</code> - Returns the mapping of strategy types to builder instances.</li> <li><code>get_strategy(strategy_type,</code> parameters) - Gets the strategy instance for the specified strategy type.<ul> <li><code>strategy_type</code> - Type of surface tension strategy to use, can be 'volume', 'mass', or 'molar'. parameters(Dict[str, Any], optional): Parameters required for the builder, dependent on the chosen strategy type.<ul> <li><code>volume</code> - density, surface_tension</li> <li><code>mass</code> - density, surface_tension</li> <li><code>molar</code> - molar_mass, density, surface_tension</li> </ul> </li> </ul> </li> </ul>"},{"location":"API/particula/next/particles/surface_factories/#returns","title":"Returns","text":"<ul> <li><code>SurfaceStrategy</code> - An instance of the specified SurfaceStrategy.</li> </ul>"},{"location":"API/particula/next/particles/surface_factories/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code> - If an unknown strategy type is provided.</li> <li><code>ValueError</code> - If any required key is missing during check_keys or     pre_build_check, or if trying to set an invalid parameter.</li> </ul>"},{"location":"API/particula/next/particles/surface_factories/#signature","title":"Signature","text":"<pre><code>class SurfaceFactory(\n    StrategyFactory[\n        Union[\n            SurfaceStrategyVolumeBuilder,\n            SurfaceStrategyMassBuilder,\n            SurfaceStrategyMolarBuilder,\n        ],\n        Union[SurfaceStrategyVolume, SurfaceStrategyMass, SurfaceStrategyMolar],\n    ]\n): ...\n</code></pre>"},{"location":"API/particula/next/particles/surface_factories/#see-also","title":"See also","text":"<ul> <li>SurfaceStrategyMassBuilder</li> <li>SurfaceStrategyMass</li> <li>SurfaceStrategyMolarBuilder</li> <li>SurfaceStrategyMolar</li> <li>SurfaceStrategyVolumeBuilder</li> <li>SurfaceStrategyVolume</li> </ul>"},{"location":"API/particula/next/particles/surface_factories/#surfacefactoryget_builders","title":"SurfaceFactory().get_builders","text":"<p>Show source in surface_factories.py:58</p> <p>Returns the mapping of strategy types to builder instances.</p>"},{"location":"API/particula/next/particles/surface_factories/#returns_1","title":"Returns","text":"<ul> <li><code>Dict[str,</code> BuilderT] - A dictionary mapping strategy types to builder instances.<ul> <li><code>volume</code> - SurfaceStrategyVolumeBuilder</li> <li><code>mass</code> - SurfaceStrategyMassBuilder</li> <li><code>molar</code> - SurfaceStrategyMolarBuilder</li> </ul> </li> </ul>"},{"location":"API/particula/next/particles/surface_factories/#signature_1","title":"Signature","text":"<pre><code>def get_builders(self): ...\n</code></pre>"},{"location":"API/particula/next/particles/surface_strategies/","title":"Surface Strategies","text":"<p>Particula Index / Particula / Next / Particles / Surface Strategies</p> <p>Auto-generated documentation for particula.next.particles.surface_strategies module.</p>"},{"location":"API/particula/next/particles/surface_strategies/#surfacestrategy","title":"SurfaceStrategy","text":"<p>Show source in surface_strategies.py:18</p> <p>ABC class for Surface Strategies.</p> <p>Abstract class for implementing strategies to calculate surface tension and the Kelvin effect for species in particulate phases.</p>"},{"location":"API/particula/next/particles/surface_strategies/#methods","title":"Methods","text":"<ul> <li><code>effective_surface_tension</code> - Calculate the effective surface tension of     species based on their concentration.</li> <li><code>effective_density</code> - Calculate the effective density of species based on     their concentration.</li> <li><code>get_name</code> - Return the type of the surface strategy.</li> <li><code>kelvin_radius</code> - Calculate the Kelvin radius which determines the     curvature effect on vapor pressure.</li> <li><code>kelvin_term</code> - Calculate the Kelvin term, which quantifies the effect of     particle curvature on vapor pressure.</li> </ul>"},{"location":"API/particula/next/particles/surface_strategies/#signature","title":"Signature","text":"<pre><code>class SurfaceStrategy(ABC): ...\n</code></pre>"},{"location":"API/particula/next/particles/surface_strategies/#surfacestrategyeffective_density","title":"SurfaceStrategy().effective_density","text":"<p>Show source in surface_strategies.py:49</p> <p>Calculate the effective density of the species mixture.</p>"},{"location":"API/particula/next/particles/surface_strategies/#arguments","title":"Arguments","text":"<ul> <li><code>mass_concentration</code> - Concentration of the species [kg/m^3].</li> </ul>"},{"location":"API/particula/next/particles/surface_strategies/#returns","title":"Returns","text":"<p>float or NDArray[float]: Effective density of the species [kg/m^3].</p>"},{"location":"API/particula/next/particles/surface_strategies/#signature_1","title":"Signature","text":"<pre><code>@abstractmethod\ndef effective_density(\n    self, mass_concentration: Union[float, NDArray[np.float64]]\n) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/next/particles/surface_strategies/#surfacestrategyeffective_surface_tension","title":"SurfaceStrategy().effective_surface_tension","text":"<p>Show source in surface_strategies.py:36</p> <p>Calculate the effective surface tension of the species mixture.</p>"},{"location":"API/particula/next/particles/surface_strategies/#arguments_1","title":"Arguments","text":"<ul> <li><code>mass_concentration</code> - Concentration of the species [kg/m^3].</li> </ul>"},{"location":"API/particula/next/particles/surface_strategies/#returns_1","title":"Returns","text":"<p>float or NDArray[float]: Effective surface tension [N/m].</p>"},{"location":"API/particula/next/particles/surface_strategies/#signature_2","title":"Signature","text":"<pre><code>@abstractmethod\ndef effective_surface_tension(\n    self, mass_concentration: Union[float, NDArray[np.float64]]\n) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/next/particles/surface_strategies/#surfacestrategyget_name","title":"SurfaceStrategy().get_name","text":"<p>Show source in surface_strategies.py:62</p> <p>Return the type of the surface strategy.</p>"},{"location":"API/particula/next/particles/surface_strategies/#signature_3","title":"Signature","text":"<pre><code>def get_name(self) -&gt; str: ...\n</code></pre>"},{"location":"API/particula/next/particles/surface_strategies/#surfacestrategykelvin_radius","title":"SurfaceStrategy().kelvin_radius","text":"<p>Show source in surface_strategies.py:66</p> <p>Calculate the Kelvin radius which determines the curvature effect.</p> <p>The kelvin radius is molecule specific and depends on the surface tension, molar mass, density, and temperature of the system. It is used to calculate the Kelvin term, which quantifies the effect of particle curvature on vapor pressure.</p>"},{"location":"API/particula/next/particles/surface_strategies/#arguments_2","title":"Arguments","text":"<ul> <li><code>surface_tension</code> - Surface tension of the mixture [N/m].</li> <li><code>molar_mass</code> - Molar mass of the species [kg/mol].</li> <li><code>mass_concentration</code> - Concentration of the species [kg/m^3].</li> <li><code>temperature</code> - Temperature of the system [K].</li> </ul>"},{"location":"API/particula/next/particles/surface_strategies/#returns_2","title":"Returns","text":"<p>float or NDArray[float]: Kelvin radius [m].</p>"},{"location":"API/particula/next/particles/surface_strategies/#references","title":"References","text":"<ul> <li>Based on Neil Donahue's approach to the Kelvin equation: r = 2 * surface_tension * molar_mass / (R * T * density) Kelvin Wikipedia</li> </ul>"},{"location":"API/particula/next/particles/surface_strategies/#signature_4","title":"Signature","text":"<pre><code>def kelvin_radius(\n    self,\n    molar_mass: Union[float, NDArray[np.float64]],\n    mass_concentration: Union[float, NDArray[np.float64]],\n    temperature: float,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/surface_strategies/#surfacestrategykelvin_term","title":"SurfaceStrategy().kelvin_term","text":"<p>Show source in surface_strategies.py:100</p> <p>Calculate the Kelvin term, which multiplies the vapor pressure.</p> <p>The Kelvin term is used to adjust the vapor pressure of a species due to the curvature of the particle.</p>"},{"location":"API/particula/next/particles/surface_strategies/#arguments_3","title":"Arguments","text":"<ul> <li><code>radius</code> - Radius of the particle [m].</li> <li><code>molar_mass</code> - Molar mass of the species a [kg/mol].</li> <li><code>mass_concentration</code> - Concentration of the species [kg/m^3].</li> <li><code>temperature</code> - Temperature of the system [K].</li> </ul>"},{"location":"API/particula/next/particles/surface_strategies/#returns_3","title":"Returns","text":"<p>float or NDArray[float]: The exponential factor adjusting vapor     pressure due to curvature.</p>"},{"location":"API/particula/next/particles/surface_strategies/#references_1","title":"References","text":"<p>Based on Neil Donahue's approach to the Kelvin equation: exp(kelvin_radius / particle_radius) Kelvin Eq Wikipedia</p>"},{"location":"API/particula/next/particles/surface_strategies/#signature_5","title":"Signature","text":"<pre><code>def kelvin_term(\n    self,\n    radius: Union[float, NDArray[np.float64]],\n    molar_mass: Union[float, NDArray[np.float64]],\n    mass_concentration: Union[float, NDArray[np.float64]],\n    temperature: float,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/surface_strategies/#surfacestrategymass","title":"SurfaceStrategyMass","text":"<p>Show source in surface_strategies.py:186</p> <p>Surface tension and density, based on mass fraction weighted values.</p>"},{"location":"API/particula/next/particles/surface_strategies/#arguments_4","title":"Arguments","text":"<ul> <li><code>surface_tension</code> - Surface tension of the species [N/m]. If a single     value is provided, it will be used for all species.</li> <li><code>density</code> - Density of the species [kg/m^3]. If a single value is     provided, it will be used for all species.</li> </ul>"},{"location":"API/particula/next/particles/surface_strategies/#references_2","title":"References","text":"<p>Mass Fractions</p>"},{"location":"API/particula/next/particles/surface_strategies/#signature_6","title":"Signature","text":"<pre><code>class SurfaceStrategyMass(SurfaceStrategy):\n    def __init__(\n        self,\n        surface_tension: Union[float, NDArray[np.float64]] = 0.072,\n        density: Union[float, NDArray[np.float64]] = 1000,\n    ): ...\n</code></pre>"},{"location":"API/particula/next/particles/surface_strategies/#see-also","title":"See also","text":"<ul> <li>SurfaceStrategy</li> </ul>"},{"location":"API/particula/next/particles/surface_strategies/#surfacestrategymasseffective_density","title":"SurfaceStrategyMass().effective_density","text":"<p>Show source in surface_strategies.py:219</p>"},{"location":"API/particula/next/particles/surface_strategies/#signature_7","title":"Signature","text":"<pre><code>def effective_density(\n    self, mass_concentration: Union[float, NDArray[np.float64]]\n) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/next/particles/surface_strategies/#surfacestrategymasseffective_surface_tension","title":"SurfaceStrategyMass().effective_surface_tension","text":"<p>Show source in surface_strategies.py:207</p>"},{"location":"API/particula/next/particles/surface_strategies/#signature_8","title":"Signature","text":"<pre><code>def effective_surface_tension(\n    self, mass_concentration: Union[float, NDArray[np.float64]]\n) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/next/particles/surface_strategies/#surfacestrategymolar","title":"SurfaceStrategyMolar","text":"<p>Show source in surface_strategies.py:134</p> <p>Surface tension and density, based on mole fraction weighted values.</p>"},{"location":"API/particula/next/particles/surface_strategies/#arguments_5","title":"Arguments","text":"<ul> <li><code>surface_tension</code> - Surface tension of the species [N/m]. If a single     value is provided, it will be used for all species.</li> <li><code>density</code> - Density of the species [kg/m^3]. If a single value is     provided, it will be used for all species.</li> <li><code>molar_mass</code> - Molar mass of the species [kg/mol]. If a single value is     provided, it will be used for all species.</li> </ul>"},{"location":"API/particula/next/particles/surface_strategies/#references_3","title":"References","text":"<p>Mole Fractions</p>"},{"location":"API/particula/next/particles/surface_strategies/#signature_9","title":"Signature","text":"<pre><code>class SurfaceStrategyMolar(SurfaceStrategy):\n    def __init__(\n        self,\n        surface_tension: Union[float, NDArray[np.float64]] = 0.072,\n        density: Union[float, NDArray[np.float64]] = 1000,\n        molar_mass: Union[float, NDArray[np.float64]] = 0.01815,\n    ): ...\n</code></pre>"},{"location":"API/particula/next/particles/surface_strategies/#see-also_1","title":"See also","text":"<ul> <li>SurfaceStrategy</li> </ul>"},{"location":"API/particula/next/particles/surface_strategies/#surfacestrategymolareffective_density","title":"SurfaceStrategyMolar().effective_density","text":"<p>Show source in surface_strategies.py:172</p>"},{"location":"API/particula/next/particles/surface_strategies/#signature_10","title":"Signature","text":"<pre><code>def effective_density(\n    self, mass_concentration: Union[float, NDArray[np.float64]]\n) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/next/particles/surface_strategies/#surfacestrategymolareffective_surface_tension","title":"SurfaceStrategyMolar().effective_surface_tension","text":"<p>Show source in surface_strategies.py:159</p>"},{"location":"API/particula/next/particles/surface_strategies/#signature_11","title":"Signature","text":"<pre><code>def effective_surface_tension(\n    self, mass_concentration: Union[float, NDArray[np.float64]]\n) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/next/particles/surface_strategies/#surfacestrategyvolume","title":"SurfaceStrategyVolume","text":"<p>Show source in surface_strategies.py:230</p> <p>Surface tension and density, based on volume fraction weighted values.</p>"},{"location":"API/particula/next/particles/surface_strategies/#arguments_6","title":"Arguments","text":"<ul> <li><code>surface_tension</code> - Surface tension of the species [N/m]. If a single     value is provided, it will be used for all species.</li> <li><code>density</code> - Density of the species [kg/m^3]. If a single value is     provided, it will be used for all species.</li> </ul>"},{"location":"API/particula/next/particles/surface_strategies/#references_4","title":"References","text":"<p>Volume Fractions</p>"},{"location":"API/particula/next/particles/surface_strategies/#signature_12","title":"Signature","text":"<pre><code>class SurfaceStrategyVolume(SurfaceStrategy):\n    def __init__(\n        self,\n        surface_tension: Union[float, NDArray[np.float64]] = 0.072,\n        density: Union[float, NDArray[np.float64]] = 1000,\n    ): ...\n</code></pre>"},{"location":"API/particula/next/particles/surface_strategies/#see-also_2","title":"See also","text":"<ul> <li>SurfaceStrategy</li> </ul>"},{"location":"API/particula/next/particles/surface_strategies/#surfacestrategyvolumeeffective_density","title":"SurfaceStrategyVolume().effective_density","text":"<p>Show source in surface_strategies.py:264</p>"},{"location":"API/particula/next/particles/surface_strategies/#signature_13","title":"Signature","text":"<pre><code>def effective_density(\n    self, mass_concentration: Union[float, NDArray[np.float64]]\n) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/next/particles/surface_strategies/#surfacestrategyvolumeeffective_surface_tension","title":"SurfaceStrategyVolume().effective_surface_tension","text":"<p>Show source in surface_strategies.py:251</p>"},{"location":"API/particula/next/particles/surface_strategies/#signature_14","title":"Signature","text":"<pre><code>def effective_surface_tension(\n    self, mass_concentration: Union[float, NDArray[np.float64]]\n) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/next/particles/properties/","title":"Properties","text":"<p>Particula Index / Particula / Next / Particles / Properties</p> <p>Auto-generated documentation for particula.next.particles.properties module.</p>"},{"location":"API/particula/next/particles/properties/#modules","title":"Modules","text":"<ul> <li>Activity Module</li> <li>Aerodynamic Mobility Module</li> <li>Aerodynamic Size</li> <li>Coulomb Enhancement</li> <li>Diffusion Coefficient</li> <li>Diffusive Knudsen Module</li> <li>Friction Factor Module</li> <li>Kelvin Effect Module</li> <li>Knudsen Number Module</li> <li>Lognormal Size Distribution</li> <li>Mean Thermal Speed Module</li> <li>Partial Pressure Module</li> <li>Settling Velocity</li> <li>Slip Correction Module</li> <li>Special Functions</li> <li>Vapor Correction Module</li> </ul>"},{"location":"API/particula/next/particles/properties/activity_module/","title":"Activity Module","text":"<p>Particula Index / Particula / Next / Particles / Properties / Activity Module</p> <p>Auto-generated documentation for particula.next.particles.properties.activity_module module.</p>"},{"location":"API/particula/next/particles/properties/activity_module/#calculate_partial_pressure","title":"calculate_partial_pressure","text":"<p>Show source in activity_module.py:223</p> <p>Calculate the partial pressure of a species based on its activity and pure     vapor pressure.</p>"},{"location":"API/particula/next/particles/properties/activity_module/#arguments","title":"Arguments","text":"<p>pure_vapor_pressure (float or NDArray[np.float64]): Pure vapor pressure     of the species in pascals (Pa). activity (float or NDArray[np.float64]): Activity of the species,     unitless.</p>"},{"location":"API/particula/next/particles/properties/activity_module/#returns","title":"Returns","text":"<p>float or NDArray[np.float64]: Partial pressure of the species in pascals (Pa).</p>"},{"location":"API/particula/next/particles/properties/activity_module/#examples","title":"Examples","text":"Example<pre><code>calculate_partial_pressure(1000.0, 0.95)\n# 950.0\n</code></pre>"},{"location":"API/particula/next/particles/properties/activity_module/#signature","title":"Signature","text":"<pre><code>def calculate_partial_pressure(\n    pure_vapor_pressure: Union[float, NDArray[np.float64]],\n    activity: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/properties/activity_module/#ideal_activity_mass","title":"ideal_activity_mass","text":"<p>Show source in activity_module.py:88</p> <p>Calculate the ideal activity of a species based on mass fractions.</p> <p>This function computes the activity based on the mass fractions of species consistent with Raoult's Law.</p>"},{"location":"API/particula/next/particles/properties/activity_module/#arguments_1","title":"Arguments","text":"<p>mass_concentration (float or NDArray[np.float64]): Mass concentration     of the species in kilograms per cubic meter (kg/m^3).</p>"},{"location":"API/particula/next/particles/properties/activity_module/#returns_1","title":"Returns","text":"<p>float or NDArray[np.float64]]: Activity of the species, unitless.</p>"},{"location":"API/particula/next/particles/properties/activity_module/#examples_1","title":"Examples","text":"Example<pre><code>ideal_activity_mass(np.array([1.0, 2.0]))\narray([0.3333, 0.6667])\n</code></pre>"},{"location":"API/particula/next/particles/properties/activity_module/#references","title":"References","text":"<ul> <li><code>Raoult's</code> Law - https://en.wikipedia.org/wiki/Raoult%27s_law</li> </ul>"},{"location":"API/particula/next/particles/properties/activity_module/#signature_1","title":"Signature","text":"<pre><code>def ideal_activity_mass(\n    mass_concentration: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/properties/activity_module/#ideal_activity_molar","title":"ideal_activity_molar","text":"<p>Show source in activity_module.py:10</p> <p>Calculate the ideal activity of a species based on mole fractions.</p> <p>This function computes the activity based on the mole fractions of species according to Raoult's Law.</p>"},{"location":"API/particula/next/particles/properties/activity_module/#arguments_2","title":"Arguments","text":"<p>mass_concentration (float or NDArray[np.float64]): Mass concentration     of the species in kilograms per cubic meter (kg/m^3). molar_mass (float or NDArray[np.float64]): Molar mass of the species in     kilograms per mole (kg/mol). A single value applies to all species     if only one is provided.</p>"},{"location":"API/particula/next/particles/properties/activity_module/#returns_2","title":"Returns","text":"<p>float or NDArray[np.float64]: Activity of the species, unitless.</p>"},{"location":"API/particula/next/particles/properties/activity_module/#examples_2","title":"Examples","text":"Example<pre><code>ideal_activity_molar(\n    mass_concentration=np.array([1.0, 2.0]),\n    molar_mass=np.array([18.015, 28.97]))\n# array([0.0525, 0.0691])\n</code></pre>"},{"location":"API/particula/next/particles/properties/activity_module/#references_1","title":"References","text":"<ul> <li><code>Raoult's</code> Law - https://en.wikipedia.org/wiki/Raoult%27s_law</li> </ul>"},{"location":"API/particula/next/particles/properties/activity_module/#signature_2","title":"Signature","text":"<pre><code>def ideal_activity_molar(\n    mass_concentration: Union[float, NDArray[np.float64]],\n    molar_mass: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/properties/activity_module/#ideal_activity_volume","title":"ideal_activity_volume","text":"<p>Show source in activity_module.py:49</p> <p>Calculate the ideal activity of a species based on volume fractions.</p> <p>This function computes the activity based on the volume fractions of species consistent with Raoult's Law.</p>"},{"location":"API/particula/next/particles/properties/activity_module/#arguments_3","title":"Arguments","text":"<p>mass_concentration (float or NDArray[np.float64]): Mass concentration     of the species in kilograms per cubic meter (kg/m^3). density (float or NDArray[np.float64]): Density of the species in     kilograms per cubic meter (kg/m^3). A single value applies to all     species if only one is provided.</p>"},{"location":"API/particula/next/particles/properties/activity_module/#returns_3","title":"Returns","text":"<p>float or NDArray[np.float64]: Activity of the species, unitless.</p>"},{"location":"API/particula/next/particles/properties/activity_module/#examples_3","title":"Examples","text":"Example<pre><code>ideal_activity_volume(\n    mass_concentration=np.array([1.0, 2.0]),\n    density=np.array([1000.0, 1200.0]))\n# array([0.001, 0.002])\n</code></pre>"},{"location":"API/particula/next/particles/properties/activity_module/#references_2","title":"References","text":"<ul> <li><code>Raoult's</code> Law - https://en.wikipedia.org/wiki/Raoult%27s_law</li> </ul>"},{"location":"API/particula/next/particles/properties/activity_module/#signature_3","title":"Signature","text":"<pre><code>def ideal_activity_volume(\n    mass_concentration: Union[float, NDArray[np.float64]],\n    density: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/properties/activity_module/#kappa_activity","title":"kappa_activity","text":"<p>Show source in activity_module.py:121</p> <p>Calculate the activity of species based on the kappa hygroscopic parameter.</p> <p>This function computes the activity using the kappa parameter and the species' mass concentrations, considering the volume fractions and water content.</p>"},{"location":"API/particula/next/particles/properties/activity_module/#arguments_4","title":"Arguments","text":"<p>mass_concentration (float or NDArray[np.float64]]): Mass concentration     of the species in kilograms per cubic meter (kg/m^3). - <code>kappa</code> NDArray[np.float64] - Kappa hygroscopic parameter, unitless. - <code>density</code> NDArray[np.float64] - Density of the species in kilograms per     cubic meter (kg/m^3). - <code>molar_mass</code> NDArray[np.float64] - Molar mass of the species in     kilograms per mole (kg/mol). - <code>water_index</code> int - Index of water in the mass concentration array.</p>"},{"location":"API/particula/next/particles/properties/activity_module/#returns_4","title":"Returns","text":"<ul> <li><code>NDArray[np.float64]</code> - Activity of the species, unitless.</li> </ul>"},{"location":"API/particula/next/particles/properties/activity_module/#examples_4","title":"Examples","text":"Example<pre><code>kappa_activity(\n    mass_concentration=np.array([[1.0, 2.0], [3.0, 4.0]]),\n    kappa=np.array([0.0, 0.2]),\n    density=np.array([1000.0, 1200.0]),\n    molar_mass=np.array([18.015, 28.97]),\n    water_index=0\n)\n# array([[0.95, 0.75], [0.85, 0.65]])\n</code></pre>"},{"location":"API/particula/next/particles/properties/activity_module/#references_3","title":"References","text":"<p>Petters, M. D., &amp; Kreidenweis, S. M. (2007). A single parameter representation of hygroscopic growth and cloud condensation nucleus activity. Atmospheric Chemistry and Physics, 7(8), 1961-1971. - <code>DOI</code> - https://doi.org/10.5194/acp-7-1961-2007</p>"},{"location":"API/particula/next/particles/properties/activity_module/#signature_4","title":"Signature","text":"<pre><code>def kappa_activity(\n    mass_concentration: NDArray[np.float64],\n    kappa: NDArray[np.float64],\n    density: NDArray[np.float64],\n    molar_mass: NDArray[np.float64],\n    water_index: int,\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/particles/properties/aerodynamic_mobility_module/","title":"Aerodynamic Mobility Module","text":"<p>Particula Index / Particula / Next / Particles / Properties / Aerodynamic Mobility Module</p> <p>Auto-generated documentation for particula.next.particles.properties.aerodynamic_mobility_module module.</p>"},{"location":"API/particula/next/particles/properties/aerodynamic_mobility_module/#particle_aerodynamic_mobility","title":"particle_aerodynamic_mobility","text":"<p>Show source in aerodynamic_mobility_module.py:9</p> <p>Calculate the aerodynamic mobility of a particle, defined as the ratio of the slip correction factor to the product of the dynamic viscosity of the fluid, the particle radius, and a slip correction constant derived.</p> <p>This mobility quantifies the ease with which a particle can move through a fluid.</p>"},{"location":"API/particula/next/particles/properties/aerodynamic_mobility_module/#arguments","title":"Arguments","text":"<p>radius : The radius of the particle (m). slip_correction_factor : The slip correction factor for the particle     in the fluid (dimensionless). dynamic_viscosity : The dynamic viscosity of the fluid (Pa.s).</p>"},{"location":"API/particula/next/particles/properties/aerodynamic_mobility_module/#returns","title":"Returns","text":"<p>The particle aerodynamic mobility (m^2/s).</p>"},{"location":"API/particula/next/particles/properties/aerodynamic_mobility_module/#signature","title":"Signature","text":"<pre><code>def particle_aerodynamic_mobility(\n    radius: Union[float, NDArray[np.float64]],\n    slip_correction_factor: Union[float, NDArray[np.float64]],\n    dynamic_viscosity: float,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/properties/aerodynamic_size/","title":"Aerodynamic Size","text":"<p>Particula Index / Particula / Next / Particles / Properties / Aerodynamic Size</p> <p>Auto-generated documentation for particula.next.particles.properties.aerodynamic_size module.</p>"},{"location":"API/particula/next/particles/properties/aerodynamic_size/#get_aerodynamic_shape_factor","title":"get_aerodynamic_shape_factor","text":"<p>Show source in aerodynamic_size.py:68</p> <p>Retrieve the aerodynamic shape factor for a given particle shape.</p>"},{"location":"API/particula/next/particles/properties/aerodynamic_size/#arguments","title":"Arguments","text":"<ul> <li><code>shape_key</code> - The shape of the particle as a string.</li> </ul>"},{"location":"API/particula/next/particles/properties/aerodynamic_size/#returns","title":"Returns","text":"<p>The shape factor of the particle as a float.</p>"},{"location":"API/particula/next/particles/properties/aerodynamic_size/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code> - If the shape is not found in the predefined shape     factor dictionary.</li> </ul>"},{"location":"API/particula/next/particles/properties/aerodynamic_size/#signature","title":"Signature","text":"<pre><code>def get_aerodynamic_shape_factor(shape_key: str) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/next/particles/properties/aerodynamic_size/#particle_aerodynamic_length","title":"particle_aerodynamic_length","text":"<p>Show source in aerodynamic_size.py:24</p> <p>Calculate the aerodynamic length scale of a particle.</p> <p>The aerodynamic size is used to compare the aerodynamic properties of particles with their physical properties, particularly when interpreting aerodynamic particle sizer measurements. This is either the aerodynamic diameter or radius, depending on length scale input.</p>"},{"location":"API/particula/next/particles/properties/aerodynamic_size/#arguments_1","title":"Arguments","text":"<ul> <li><code>physical_length</code> - Physical length scale of the particle (m).</li> <li><code>physical_slip_correction_factor</code> - Slip correction factor for the     particle's physical radius in the fluid (dimensionless).</li> <li><code>aerodynamic_slip_correction_factor</code> - Slip correction factor for the     particle's aerodynamic radius in the fluid (dimensionless).</li> <li><code>density</code> - Density of the particle (kg/m^3).</li> <li><code>reference_density</code> - Reference density for the particle, typically the     density of water (1000 kg/m^3 by default).</li> <li><code>aerodynamic_shape_factor</code> - Shape factor of the particle, accounting for     non-sphericity (dimensionless, default is 1.0 for spherical     particles).</li> </ul>"},{"location":"API/particula/next/particles/properties/aerodynamic_size/#returns_1","title":"Returns","text":"<p>Aerodynamic radius of the particle (m).</p>"},{"location":"API/particula/next/particles/properties/aerodynamic_size/#references","title":"References","text":"<ul> <li>https://en.wikipedia.org/wiki/Aerosol#Aerodynamic_diameter</li> <li>Hinds, W.C. (1998) Aerosol Technology: Properties, behavior, and     measurement of airborne particles. Wiley-Interscience, New York.     pp 51-53, section 3.6.</li> </ul>"},{"location":"API/particula/next/particles/properties/aerodynamic_size/#signature_1","title":"Signature","text":"<pre><code>def particle_aerodynamic_length(\n    physical_length: Union[float, NDArray[np.float64]],\n    physical_slip_correction_factor: Union[float, NDArray[np.float64]],\n    aerodynamic_slip_correction_factor: Union[float, NDArray[np.float64]],\n    density: Union[float, NDArray[np.float64]],\n    reference_density: float = 1000,\n    aerodynamic_shape_factor: float = 1.0,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/properties/coulomb_enhancement/","title":"Coulomb Enhancement","text":"<p>Particula Index / Particula / Next / Particles / Properties / Coulomb Enhancement</p> <p>Auto-generated documentation for particula.next.particles.properties.coulomb_enhancement module.</p>"},{"location":"API/particula/next/particles/properties/coulomb_enhancement/#continuum","title":"continuum","text":"<p>Show source in coulomb_enhancement.py:89</p> <p>Calculates the Coulombic enhancement continuum limit. For all particle- particle interactions.</p>"},{"location":"API/particula/next/particles/properties/coulomb_enhancement/#arguments","title":"Arguments","text":"<ul> <li><code>coulomb_potential</code> - The Coulomb potential ratio [dimensionless].</li> </ul>"},{"location":"API/particula/next/particles/properties/coulomb_enhancement/#returns","title":"Returns","text":"<p>The Coulomb enhancement for the continuum limit [dimensionless].</p>"},{"location":"API/particula/next/particles/properties/coulomb_enhancement/#references","title":"References","text":"<p>Equation 6b in: Gopalakrishnan, R., &amp; Hogan, C. J. (2012). Coulomb-influenced collisions in aerosols and dusty plasmas. Physical Review E - Statistical, Nonlinear, and Soft Matter Physics, 85(2). (https://doi.org/10.1103/PhysRevE.85.026410)</p>"},{"location":"API/particula/next/particles/properties/coulomb_enhancement/#signature","title":"Signature","text":"<pre><code>def continuum(\n    coulomb_potential: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/properties/coulomb_enhancement/#kinetic","title":"kinetic","text":"<p>Show source in coulomb_enhancement.py:61</p> <p>Calculates the Coulombic enhancement kinetic limit. For all particle- particle interactions.</p>"},{"location":"API/particula/next/particles/properties/coulomb_enhancement/#arguments_1","title":"Arguments","text":"<ul> <li><code>coulomb_potential</code> - The Coulomb potential ratio [dimensionless].</li> </ul>"},{"location":"API/particula/next/particles/properties/coulomb_enhancement/#returns_1","title":"Returns","text":"<p>The Coulomb enhancement for the kinetic limit [dimensionless].</p>"},{"location":"API/particula/next/particles/properties/coulomb_enhancement/#references_1","title":"References","text":"<p>Equation 6d and 6e in, Gopalakrishnan, R., &amp; Hogan, C. J. (2012). Coulomb-influenced collisions in aerosols and dusty plasmas. Physical Review E - Statistical, Nonlinear, and Soft Matter Physics, 85(2). (https://doi.org/10.1103/PhysRevE.85.026410)</p>"},{"location":"API/particula/next/particles/properties/coulomb_enhancement/#signature_1","title":"Signature","text":"<pre><code>def kinetic(\n    coulomb_potential: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/properties/coulomb_enhancement/#ratio","title":"ratio","text":"<p>Show source in coulomb_enhancement.py:22</p> <p>Calculates the Coulomb potential ratio, phi_E. For all particle- particle interactions.</p>"},{"location":"API/particula/next/particles/properties/coulomb_enhancement/#arguments_2","title":"Arguments","text":"<ul> <li><code>radius</code> - The radius of the particle [m].</li> <li><code>charge</code> - The number of charges on the particle [dimensionless].</li> <li><code>temperature</code> - The temperature of the system [K].</li> </ul>"},{"location":"API/particula/next/particles/properties/coulomb_enhancement/#returns_2","title":"Returns","text":"<p>The Coulomb potential ratio [dimensionless].</p>"},{"location":"API/particula/next/particles/properties/coulomb_enhancement/#references_2","title":"References","text":"<ul> <li><code>Equation</code> 7 - Gopalakrishnan, R., &amp; Hogan, C. J. (2012).     Coulomb-influenced collisions in aerosols and dusty plasmas.     Physical Review E - Statistical, Nonlinear, and Soft Matter     Physics, 85(2). (https://doi.org/10.1103/PhysRevE.85.026410)</li> </ul>"},{"location":"API/particula/next/particles/properties/coulomb_enhancement/#signature_2","title":"Signature","text":"<pre><code>def ratio(\n    radius: Union[float, NDArray[np.float64]],\n    charge: Union[int, NDArray[np.float64]] = 0,\n    temperature: float = 298.15,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/properties/diffusion_coefficient/","title":"Diffusion Coefficient","text":"<p>Particula Index / Particula / Next / Particles / Properties / Diffusion Coefficient</p> <p>Auto-generated documentation for particula.next.particles.properties.diffusion_coefficient module.</p>"},{"location":"API/particula/next/particles/properties/diffusion_coefficient/#particle_diffusion_coefficient","title":"particle_diffusion_coefficient","text":"<p>Show source in diffusion_coefficient.py:25</p> <p>Calculate the diffusion coefficient of a particle.</p>"},{"location":"API/particula/next/particles/properties/diffusion_coefficient/#arguments","title":"Arguments","text":"<ul> <li><code>temperature</code> - The temperature at which the particle is     diffusing, in Kelvin. Defaults to 298.15 K.</li> <li><code>boltzmann_constant</code> - The Boltzmann constant. Defaults to the     standard value of 1.380649 x 10^-23 J/K.</li> <li><code>aerodynamic_mobility</code> - The aerodynamic mobility of     the particle [m^2/s].</li> </ul>"},{"location":"API/particula/next/particles/properties/diffusion_coefficient/#returns","title":"Returns","text":"<p>The diffusion coefficient of the particle [m^2/s].</p>"},{"location":"API/particula/next/particles/properties/diffusion_coefficient/#signature","title":"Signature","text":"<pre><code>def particle_diffusion_coefficient(\n    temperature: Union[float, NDArray[np.float64]],\n    aerodynamic_mobility: Union[float, NDArray[np.float64]],\n    boltzmann_constant: float = BOLTZMANN_CONSTANT.m,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/properties/diffusion_coefficient/#particle_diffusion_coefficient_via_system_state","title":"particle_diffusion_coefficient_via_system_state","text":"<p>Show source in diffusion_coefficient.py:49</p> <p>Calculate the diffusion coefficient of a particle.</p>"},{"location":"API/particula/next/particles/properties/diffusion_coefficient/#arguments_1","title":"Arguments","text":"<ul> <li><code>temperature</code> - The temperature of the system in Kelvin (K).</li> <li><code>particle_radius</code> - The radius of the particle in meters (m).</li> <li><code>pressure</code> - The pressure of the system in Pascals (Pa).</li> </ul>"},{"location":"API/particula/next/particles/properties/diffusion_coefficient/#returns_1","title":"Returns","text":"<p>The diffusion coefficient of the particle in square meters per second (m\u00b2/s).</p>"},{"location":"API/particula/next/particles/properties/diffusion_coefficient/#signature_1","title":"Signature","text":"<pre><code>def particle_diffusion_coefficient_via_system_state(\n    particle_radius: Union[float, NDArray[np.float64]],\n    temperature: float,\n    pressure: float,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/properties/diffusive_knudsen_module/","title":"Diffusive Knudsen Module","text":"<p>Particula Index / Particula / Next / Particles / Properties / Diffusive Knudsen Module</p> <p>Auto-generated documentation for particula.next.particles.properties.diffusive_knudsen_module module.</p>"},{"location":"API/particula/next/particles/properties/diffusive_knudsen_module/#diffusive_knudsen_number","title":"diffusive_knudsen_number","text":"<p>Show source in diffusive_knudsen_module.py:13</p> <p>Diffusive Knudsen number. The diffusive Knudsen number is different from Knudsen number. Ratio of: mean persistence of one particle to the effective length scale of particle--particle Coulombic interaction</p>"},{"location":"API/particula/next/particles/properties/diffusive_knudsen_module/#arguments","title":"Arguments","text":"<ul> <li><code>-</code> radius - The radius of the particle [m].</li> <li><code>-</code> mass_particle - The mass of the particle [kg].</li> <li><code>-</code> friction_factor - The friction factor of the particle [dimensionless].</li> <li><code>-</code> coulomb_potential_ratio - The Coulomb potential ratio, zero if  no charges [dimensionless].</li> <li><code>-</code> temperature - The temperature of the system [K].</li> </ul>"},{"location":"API/particula/next/particles/properties/diffusive_knudsen_module/#returns","title":"Returns","text":"<p>The diffusive Knudsen number [dimensionless], as a square matrix, of all particle-particle interactions.</p>"},{"location":"API/particula/next/particles/properties/diffusive_knudsen_module/#references","title":"References","text":"<ul> <li>Equation 5 in, with charges: Chahl, H. S., &amp; Gopalakrishnan, R. (2019). High potential, near free molecular regime Coulombic collisions in aerosols and dusty plasmas. Aerosol Science and Technology, 53(8), 933-957. https://doi.org/10.1080/02786826.2019.1614522</li> <li>Equation 3b in, no charges: Gopalakrishnan, R., &amp; Hogan, C. J. (2012). Coulomb-influenced collisions in aerosols and dusty plasmas. Physical Review E - Statistical, Nonlinear, and Soft Matter Physics, 85(2). https://doi.org/10.1103/PhysRevE.85.026410</li> </ul>"},{"location":"API/particula/next/particles/properties/diffusive_knudsen_module/#signature","title":"Signature","text":"<pre><code>def diffusive_knudsen_number(\n    radius: Union[float, NDArray[np.float64]],\n    mass_particle: Union[float, NDArray[np.float64]],\n    friction_factor: Union[float, NDArray[np.float64]],\n    coulomb_potential_ratio: Union[float, NDArray[np.float64]] = 0.0,\n    temperature: float = 298.15,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/properties/friction_factor_module/","title":"Friction Factor Module","text":"<p>Particula Index / Particula / Next / Particles / Properties / Friction Factor Module</p> <p>Auto-generated documentation for particula.next.particles.properties.friction_factor_module module.</p>"},{"location":"API/particula/next/particles/properties/friction_factor_module/#friction_factor","title":"friction_factor","text":"<p>Show source in friction_factor_module.py:15</p> <p>Returns a particle's friction factor. Property of the particle's size and surrounding medium. Multiplying the friction factor by the fluid velocity yields the drag force on the particle.</p>"},{"location":"API/particula/next/particles/properties/friction_factor_module/#arguments","title":"Arguments","text":"<ul> <li>radius : The radius of the particle [m].</li> <li>dynamic_viscosity : The dynamic viscosity of the fluid [Pa s].</li> <li>slip_correction : The slip correction factor [unitless].</li> </ul>"},{"location":"API/particula/next/particles/properties/friction_factor_module/#returns","title":"Returns","text":"<p>The friction factor of the particle [N s/m].</p>"},{"location":"API/particula/next/particles/properties/friction_factor_module/#references","title":"References","text":"<p>It is best thought of as an inverse of mobility or the ratio between thermal energy and diffusion coefficient. The modified Stoke's diffusion coefficient is defined as kT / (6 * np.pi * dyn_vis_air * radius / slip_corr) and thus the friction factor can be defined as (6 * np.pi * dyn_vis_air * radius / slip_corr).</p> <p>In the continuum limit (Kn -&gt; 0; Cc -&gt; 1): 6 * np.pi * dyn_vis_air * radius</p> <p>In the kinetic limit (Kn -&gt; inf): 8.39 * (dyn_vis_air/mfp_air) * const * radius**2</p> <p>Zhang, C., Thajudeen, T., Larriba, C., Schwartzentruber, T. E., &amp; Hogan, C. J. (2012). Determination of the Scalar Friction Factor for Nonspherical Particles and Aggregates Across the Entire Knudsen Number Range by Direct Simulation Monte Carlo (DSMC). Aerosol Science and Technology, 46(10), 1065-1078. https://doi.org/10.1080/02786826.2012.690543</p>"},{"location":"API/particula/next/particles/properties/friction_factor_module/#signature","title":"Signature","text":"<pre><code>def friction_factor(\n    radius: Union[float, NDArray[np.float64]],\n    dynamic_viscosity: float,\n    slip_correction: Union[float, NDArray[np.float64]],\n): ...\n</code></pre>"},{"location":"API/particula/next/particles/properties/kelvin_effect_module/","title":"Kelvin Effect Module","text":"<p>Particula Index / Particula / Next / Particles / Properties / Kelvin Effect Module</p> <p>Auto-generated documentation for particula.next.particles.properties.kelvin_effect_module module.</p>"},{"location":"API/particula/next/particles/properties/kelvin_effect_module/#kelvin_radius","title":"kelvin_radius","text":"<p>Show source in kelvin_effect_module.py:10</p> <p>Calculate the Kelvin radius which determines the curvature effect on vapor pressure.</p>"},{"location":"API/particula/next/particles/properties/kelvin_effect_module/#arguments","title":"Arguments","text":"<ul> <li>surface_tension (float or NDArray[float]): Surface tension of the mixture [N/m].</li> <li>molar_mass (float or NDArray[float]): Molar mass of the species [kg/mol].</li> <li>mass_concentration (float or NDArray[float]): Concentration of the species [kg/m^3].</li> <li>temperature (float): Temperature of the system [K].</li> </ul>"},{"location":"API/particula/next/particles/properties/kelvin_effect_module/#returns","title":"Returns","text":"<ul> <li>float or NDArray[float]: Kelvin radius [m].</li> </ul>"},{"location":"API/particula/next/particles/properties/kelvin_effect_module/#references","title":"References","text":"<ul> <li>Based on Neil Donahue's approach to the Kelvin equation: r = 2 * surface_tension * molar_mass / (R * T * density)</li> <li><code>See</code> more - https://en.wikipedia.org/wiki/Kelvin_equation</li> </ul>"},{"location":"API/particula/next/particles/properties/kelvin_effect_module/#signature","title":"Signature","text":"<pre><code>def kelvin_radius(\n    effective_surface_tension: Union[float, NDArray[np.float64]],\n    effective_density: Union[float, NDArray[np.float64]],\n    molar_mass: Union[float, NDArray[np.float64]],\n    temperature: float,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/properties/kelvin_effect_module/#kelvin_term","title":"kelvin_term","text":"<p>Show source in kelvin_effect_module.py:45</p> <p>Calculate the Kelvin term, which quantifies the effect of particle curvature on vapor pressure.</p>"},{"location":"API/particula/next/particles/properties/kelvin_effect_module/#arguments_1","title":"Arguments","text":"<ul> <li>radius (float or NDArray[float]): Radius of the particle [m].</li> <li>kelvin_radius (float or NDArray[float]): Kelvin radius [m].</li> </ul>"},{"location":"API/particula/next/particles/properties/kelvin_effect_module/#returns_1","title":"Returns","text":"<ul> <li>float or NDArray[float]: The exponential factor adjusting vapor pressure due to curvature.</li> </ul>"},{"location":"API/particula/next/particles/properties/kelvin_effect_module/#references_1","title":"References","text":"<p>Based on Neil Donahue's collection of terms in the Kelvin equation: exp(kelvin_radius / particle_radius) - <code>See</code> more - https://en.wikipedia.org/wiki/Kelvin_equation</p>"},{"location":"API/particula/next/particles/properties/kelvin_effect_module/#signature_1","title":"Signature","text":"<pre><code>def kelvin_term(\n    radius: Union[float, NDArray[np.float64]],\n    kelvin_radius_value: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/properties/knudsen_number_module/","title":"Knudsen Number Module","text":"<p>Particula Index / Particula / Next / Particles / Properties / Knudsen Number Module</p> <p>Auto-generated documentation for particula.next.particles.properties.knudsen_number_module module.</p>"},{"location":"API/particula/next/particles/properties/knudsen_number_module/#calculate_knudsen_number","title":"calculate_knudsen_number","text":"<p>Show source in knudsen_number_module.py:12</p> <p>Calculate the Knudsen number using the mean free path of the gas and the radius of the particle. The Knudsen number is a dimensionless number that indicates the regime of gas flow relative to the size of particles.</p>"},{"location":"API/particula/next/particles/properties/knudsen_number_module/#arguments","title":"Arguments","text":"<ul> <li>mean_free_path (Union[float, NDArray[np.float64]]): The mean free path of the gas molecules [meters (m)].</li> <li>particle_radius (Union[float, NDArray[np.float64]]): The radius of the particle [meters (m)].</li> </ul>"},{"location":"API/particula/next/particles/properties/knudsen_number_module/#returns","title":"Returns","text":"<ul> <li>Union[float, NDArray[np.float64]]: The Knudsen number, which is the ratio of the mean free path to the particle radius.</li> </ul>"},{"location":"API/particula/next/particles/properties/knudsen_number_module/#references","title":"References","text":"<ul> <li>For more information at https://en.wikipedia.org/wiki/Knudsen_number</li> </ul>"},{"location":"API/particula/next/particles/properties/knudsen_number_module/#signature","title":"Signature","text":"<pre><code>def calculate_knudsen_number(\n    mean_free_path: Union[float, NDArray[np.float64]],\n    particle_radius: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/properties/lognormal_size_distribution/","title":"Lognormal Size Distribution","text":"<p>Particula Index / Particula / Next / Particles / Properties / Lognormal Size Distribution</p> <p>Auto-generated documentation for particula.next.particles.properties.lognormal_size_distribution module.</p>"},{"location":"API/particula/next/particles/properties/lognormal_size_distribution/#lognormal_pdf_distribution","title":"lognormal_pdf_distribution","text":"<p>Show source in lognormal_size_distribution.py:12</p> <p>Probability Density Function for the lognormal distribution of particles for varying modes, geometric standard deviations, and numbers of particles, across a range of x_values.</p>"},{"location":"API/particula/next/particles/properties/lognormal_size_distribution/#arguments","title":"Arguments","text":"<ul> <li><code>x_values</code> - The size interval of the distribution.</li> <li><code>mode</code> - Scales corresponding to the mode in lognormal for different     modes.</li> <li><code>geometric_standard_deviation</code> - Geometric standard deviations of the     distribution for different modes.</li> <li><code>number_of_particles</code> - Number of particles for each mode.</li> </ul>"},{"location":"API/particula/next/particles/properties/lognormal_size_distribution/#returns","title":"Returns","text":"<p>The normalized lognormal distribution of the particles, summed across all modes.</p>"},{"location":"API/particula/next/particles/properties/lognormal_size_distribution/#references","title":"References","text":"<ul> <li>Log-normal Distribution Wikipedia</li> <li>Probability Density Function Wikipedia</li> </ul>"},{"location":"API/particula/next/particles/properties/lognormal_size_distribution/#signature","title":"Signature","text":"<pre><code>def lognormal_pdf_distribution(\n    x_values: NDArray[np.float64],\n    mode: NDArray[np.float64],\n    geometric_standard_deviation: NDArray[np.float64],\n    number_of_particles: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/particles/properties/lognormal_size_distribution/#lognormal_pmf_distribution","title":"lognormal_pmf_distribution","text":"<p>Show source in lognormal_size_distribution.py:67</p> <p>Probability Mass function for lognormal distribution of particles for varying modes, geometric standard deviations, and numbers of particles, across a range of x_values.</p>"},{"location":"API/particula/next/particles/properties/lognormal_size_distribution/#arguments_1","title":"Arguments","text":"<ul> <li><code>x_values</code> - The size interval of the distribution.</li> <li><code>mode</code> - Scales corresponding to the mode in lognormal for different     modes.</li> <li><code>geometric_standard_deviation</code> - Geometric standard deviations of the     distribution for different modes.</li> <li><code>number_of_particles</code> - Number of particles for each mode.</li> </ul>"},{"location":"API/particula/next/particles/properties/lognormal_size_distribution/#returns_1","title":"Returns","text":"<p>The normalized lognormal distribution of the particles, summed across all modes.</p>"},{"location":"API/particula/next/particles/properties/lognormal_size_distribution/#references_1","title":"References","text":"<ul> <li>Log-normal Distribution Wikipedia</li> <li>Probability Mass Function Wikipedia</li> </ul>"},{"location":"API/particula/next/particles/properties/lognormal_size_distribution/#signature_1","title":"Signature","text":"<pre><code>def lognormal_pmf_distribution(\n    x_values: NDArray[np.float64],\n    mode: NDArray[np.float64],\n    geometric_standard_deviation: NDArray[np.float64],\n    number_of_particles: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/particles/properties/lognormal_size_distribution/#lognormal_sample_distribution","title":"lognormal_sample_distribution","text":"<p>Show source in lognormal_size_distribution.py:117</p> <p>Sample a Probability Density Function for the lognormal distribution.</p> <p>Samples a set of samples (particle) to represent the lognormal distribution for varying modes, geometric standard deviations, and numbers of particles, across a range of x_values.</p>"},{"location":"API/particula/next/particles/properties/lognormal_size_distribution/#arguments_2","title":"Arguments","text":"<ul> <li><code>mode</code> - Scales corresponding to the mode in lognormal for different     modes.</li> <li><code>geometric_standard_deviation</code> - Geometric standard deviations of the     distribution for different modes.</li> <li><code>number_of_particles</code> - Number of particles for each mode.</li> <li><code>number_of_samples</code> - Number of samples to generate.</li> </ul>"},{"location":"API/particula/next/particles/properties/lognormal_size_distribution/#returns_2","title":"Returns","text":"<p>The normalized lognormal distribution of the particles, summed across all modes.</p>"},{"location":"API/particula/next/particles/properties/lognormal_size_distribution/#references_2","title":"References","text":"<ul> <li>Log-normal Distribution Wikipedia</li> <li>Probability Density Function Wikipedia</li> </ul>"},{"location":"API/particula/next/particles/properties/lognormal_size_distribution/#signature_2","title":"Signature","text":"<pre><code>def lognormal_sample_distribution(\n    mode: NDArray[np.float64],\n    geometric_standard_deviation: NDArray[np.float64],\n    number_of_particles: NDArray[np.float64],\n    number_of_samples: int,\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/next/particles/properties/mean_thermal_speed_module/","title":"Mean Thermal Speed Module","text":"<p>Particula Index / Particula / Next / Particles / Properties / Mean Thermal Speed Module</p> <p>Auto-generated documentation for particula.next.particles.properties.mean_thermal_speed_module module.</p>"},{"location":"API/particula/next/particles/properties/mean_thermal_speed_module/#mean_thermal_speed","title":"mean_thermal_speed","text":"<p>Show source in mean_thermal_speed_module.py:11</p> <p>Returns the particles mean thermal speed. Due to the the impact of air molecules on the particles, the particles will have a mean thermal speed.</p>"},{"location":"API/particula/next/particles/properties/mean_thermal_speed_module/#args","title":"Args","text":"<p>mass : The per particle mass of the particles [kg]. temperature : The temperature of the air [K].</p>"},{"location":"API/particula/next/particles/properties/mean_thermal_speed_module/#returns","title":"Returns","text":"<p>The mean thermal speed of the particles [m/s].</p>"},{"location":"API/particula/next/particles/properties/mean_thermal_speed_module/#references","title":"References","text":"<p>Seinfeld, J. H., &amp; Pandis, S. N. (2016). Atmospheric chemistry and physics, Section 9.5.3 Mean Free Path of an Aerosol Particle Equation 9.87.</p>"},{"location":"API/particula/next/particles/properties/mean_thermal_speed_module/#signature","title":"Signature","text":"<pre><code>def mean_thermal_speed(\n    mass: Union[float, NDArray[np.float64]],\n    temperature: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/properties/partial_pressure_module/","title":"Partial Pressure Module","text":"<p>Particula Index / Particula / Next / Particles / Properties / Partial Pressure Module</p> <p>Auto-generated documentation for particula.next.particles.properties.partial_pressure_module module.</p>"},{"location":"API/particula/next/particles/properties/partial_pressure_module/#partial_pressure_delta","title":"partial_pressure_delta","text":"<p>Show source in partial_pressure_module.py:9</p> <p>Calculate the difference in partial pressure of a species between the gas phase and the particle phase, which is used in the calculation of the rate of change of mass of an aerosol particle.</p>"},{"location":"API/particula/next/particles/properties/partial_pressure_module/#arguments","title":"Arguments","text":"<ul> <li><code>partial_pressure_gas</code> - The partial pressure of the species in the     gas phase.</li> <li><code>partial_pressure_particle</code> - The partial pressure of the species in     the particle phase.</li> <li><code>kelvin_term</code> - Kelvin effect to account for the curvature of     the particle.</li> </ul>"},{"location":"API/particula/next/particles/properties/partial_pressure_module/#returns","title":"Returns","text":"<p>The difference in partial pressure between the gas phase and the     particle phase.</p>"},{"location":"API/particula/next/particles/properties/partial_pressure_module/#signature","title":"Signature","text":"<pre><code>def partial_pressure_delta(\n    partial_pressure_gas: Union[float, NDArray[np.float64]],\n    partial_pressure_particle: Union[float, NDArray[np.float64]],\n    kelvin_term: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/properties/settling_velocity/","title":"Settling Velocity","text":"<p>Particula Index / Particula / Next / Particles / Properties / Settling Velocity</p> <p>Auto-generated documentation for particula.next.particles.properties.settling_velocity module.</p>"},{"location":"API/particula/next/particles/properties/settling_velocity/#particle_settling_velocity","title":"particle_settling_velocity","text":"<p>Show source in settling_velocity.py:22</p> <p>Calculate the settling velocity of a particle in a fluid.</p>"},{"location":"API/particula/next/particles/properties/settling_velocity/#arguments","title":"Arguments","text":"<ul> <li><code>particle_radius</code> - The radius of the particle [m].</li> <li><code>particle_density</code> - The density of the particle [kg/m\u00b3].</li> <li><code>slip_correction_factor</code> - The slip correction factor to     account for non-continuum effects [dimensionless].</li> <li><code>gravitational_acceleration</code> - The gravitational acceleration.     Defaults to standard gravity [9.80665 m/s\u00b2].</li> <li><code>dynamic_viscosity</code> - The dynamic viscosity of the fluid [Pa*s].</li> </ul>"},{"location":"API/particula/next/particles/properties/settling_velocity/#returns","title":"Returns","text":"<p>The settling velocity of the particle in the fluid [m/s].</p>"},{"location":"API/particula/next/particles/properties/settling_velocity/#signature","title":"Signature","text":"<pre><code>def particle_settling_velocity(\n    particle_radius: Union[float, NDArray[np.float64]],\n    particle_density: Union[float, NDArray[np.float64]],\n    slip_correction_factor: Union[float, NDArray[np.float64]],\n    dynamic_viscosity: float,\n    gravitational_acceleration: float = STANDARD_GRAVITY.m,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/properties/settling_velocity/#particle_settling_velocity_via_system_state","title":"particle_settling_velocity_via_system_state","text":"<p>Show source in settling_velocity.py:58</p> <p>Calculate the settling velocity of a particle.</p>"},{"location":"API/particula/next/particles/properties/settling_velocity/#arguments_1","title":"Arguments","text":"<ul> <li><code>particle_radius</code> - The radius of the particle in meters (m).</li> <li><code>particle_density</code> - The density of the particle (kg/m\u00b3).</li> <li><code>temperature</code> - The temperature of the system in Kelvin (K).</li> <li><code>pressure</code> - The pressure of the system in Pascals (Pa).</li> </ul>"},{"location":"API/particula/next/particles/properties/settling_velocity/#returns_1","title":"Returns","text":"<p>The settling velocity of the particle in meters per second (m/s).</p>"},{"location":"API/particula/next/particles/properties/settling_velocity/#signature_1","title":"Signature","text":"<pre><code>def particle_settling_velocity_via_system_state(\n    particle_radius: Union[float, NDArray[np.float64]],\n    particle_density: Union[float, NDArray[np.float64]],\n    temperature: float,\n    pressure: float,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/properties/slip_correction_module/","title":"Slip Correction Module","text":"<p>Particula Index / Particula / Next / Particles / Properties / Slip Correction Module</p> <p>Auto-generated documentation for particula.next.particles.properties.slip_correction_module module.</p>"},{"location":"API/particula/next/particles/properties/slip_correction_module/#cunningham_slip_correction","title":"cunningham_slip_correction","text":"<p>Show source in slip_correction_module.py:9</p> <p>Calculate the Cunningham slip correction factor. Accounts for non-continuum effects on small particles.</p>"},{"location":"API/particula/next/particles/properties/slip_correction_module/#arguments","title":"Arguments","text":"<ul> <li><code>-</code> knudsen_number - Knudsen number [unitless].</li> </ul>"},{"location":"API/particula/next/particles/properties/slip_correction_module/#returns","title":"Returns","text":"<ul> <li>Slip correction factor [unitless].</li> </ul>"},{"location":"API/particula/next/particles/properties/slip_correction_module/#reference","title":"Reference:","text":"<ul> <li>Dimensionless quantity accounting for non-continuum effects on small particles. It is a deviation from Stokes' Law. Stokes assumes a no-slip condition that is not correct at high Knudsen numbers. The slip correction factor is used to calculate the friction factor. Thus, the slip correction factor is about unity (1) for larger particles (Kn -&gt; 0). Its behavior on the other end of the spectrum (smaller particles; Kn -&gt; inf) is more nuanced, though it tends to scale linearly on a log-log scale, log Cc vs log Kn.</li> <li>https://en.wikipedia.org/wiki/Cunningham_correction_factor</li> </ul>"},{"location":"API/particula/next/particles/properties/slip_correction_module/#signature","title":"Signature","text":"<pre><code>def cunningham_slip_correction(\n    knudsen_number: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/properties/special_functions/","title":"Special Functions","text":"<p>Particula Index / Particula / Next / Particles / Properties / Special Functions</p> <p>Auto-generated documentation for particula.next.particles.properties.special_functions module.</p>"},{"location":"API/particula/next/particles/properties/special_functions/#debye_function","title":"debye_function","text":"<p>Show source in special_functions.py:10</p> <p>Calculate the Debye function for a given variable.</p> <p>The generalized Debye function where <code>x</code> is a dimensionless variable and <code>n</code> is an integer exponent. By default, <code>n</code> is 1, which corresponds to the most common form of the Debye function.</p>"},{"location":"API/particula/next/particles/properties/special_functions/#arguments","title":"Arguments","text":"<ul> <li><code>variable</code> - The upper limit of integration. Can be a float or a     numpy array. If a numpy array is provided, the function will     return an array of Debye function values.</li> <li><code>integration_points</code> - The number of points to use in the numerical     integration. Default is 1000.</li> <li><code>n</code> - The exponent in the Debye function. Default is 1.</li> </ul>"},{"location":"API/particula/next/particles/properties/special_functions/#returns","title":"Returns","text":"<p>The value of the Debye function evaluation for the given input. If the input is a float, a float is returned. If the input is an array, an array of the same shape is returned.</p>"},{"location":"API/particula/next/particles/properties/special_functions/#examples","title":"Examples","text":"Dubye function with n=1 for a single float value<pre><code>out = debye_function(1.0)\nprint(out)\n# Output: 0.7765038970390566\n</code></pre> Dubye function with n=2 for a single float value<pre><code>out = debye_function(1.0, n=2)\nprint(out)\n# Output: 0.6007582206816492\n</code></pre> Dubye function with n=1 for a numpy array<pre><code>out = debye_function(np.array([1.0, 2.0, 3.0]))\nprint(out)\n# Output: [0.84140566 0.42278434 0.28784241]\n</code></pre>"},{"location":"API/particula/next/particles/properties/special_functions/#references","title":"References","text":"<ul> <li>https://en.wikipedia.org/wiki/Debye_function</li> <li>https://mathworld.wolfram.com/DebyeFunctions.html</li> </ul>"},{"location":"API/particula/next/particles/properties/special_functions/#signature","title":"Signature","text":"<pre><code>def debye_function(\n    variable: Union[float, NDArray[np.float64]],\n    integration_points: int = 1000,\n    n: int = 1,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/next/particles/properties/vapor_correction_module/","title":"Vapor Correction Module","text":"<p>Particula Index / Particula / Next / Particles / Properties / Vapor Correction Module</p> <p>Auto-generated documentation for particula.next.particles.properties.vapor_correction_module module.</p>"},{"location":"API/particula/next/particles/properties/vapor_correction_module/#vapor_transition_correction","title":"vapor_transition_correction","text":"<p>Show source in vapor_correction_module.py:11</p> <p>Calculate the transition correction factor, f(Kn, alpha), for a given Knudsen number and mass accommodation coefficient. This function is used to account for the intermediate regime between continuum and free molecular flow. This is the Suchs and Futugin transition function.</p>"},{"location":"API/particula/next/particles/properties/vapor_correction_module/#arguments","title":"Arguments","text":"<ul> <li>knudsen_number (Union[float, NDArray[np.float64]]): The Knudsen number, which quantifies the relative importance of the mean free path of gas molecules to the size of the particle.</li> <li>mass_accommodation (Union[float, NDArray[np.float64]]): The mass accommodation coefficient, representing the probability of a gas molecule sticking to the particle upon collision.</li> </ul>"},{"location":"API/particula/next/particles/properties/vapor_correction_module/#returns","title":"Returns","text":"<ul> <li>Union[float, NDArray[np.float64]]: The transition correction value calculated based on the specified inputs.</li> </ul>"},{"location":"API/particula/next/particles/properties/vapor_correction_module/#references","title":"References","text":"<ul> <li>Seinfeld and Pandis, \"Atmospheric Chemistry and Physics\", Chapter 12, equation 12.43.</li> <li><code>Note</code> - There are various formulations for this correction, so further extensions of this function might be necessary depending on specific requirements.</li> <li>Original reference: FUCHS, N. A., &amp; SUTUGIN, A. G. (1971). HIGH-DISPERSED AEROSOLS. In Topics in Current Aerosol Research (p. 1). Elsevier. https://doi.org/10.1016/B978-0-08-016674-2.50006-6</li> </ul>"},{"location":"API/particula/next/particles/properties/vapor_correction_module/#signature","title":"Signature","text":"<pre><code>def vapor_transition_correction(\n    knudsen_number: Union[float, NDArray[np.float64]],\n    mass_accommodation: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/util/","title":"Util","text":"<p>Particula Index / Particula / Util</p> <p>Auto-generated documentation for particula.util module.</p>"},{"location":"API/particula/util/#modules","title":"Modules","text":"<ul> <li>Aerodynamic Mobility</li> <li>Approx Coagulation</li> <li>CoagulationRate</li> <li>Colors</li> <li>Condensation Force</li> <li>Convert</li> <li>Converting</li> <li>CoulombEnhancement</li> <li>Debye Function</li> <li>Diffusion Coefficient</li> <li>DiffusiveKnudsen</li> <li>Dilution Loss</li> <li>DimensionlessCoagulation</li> <li>Distribution Discretization</li> <li>Dynamic Viscosity</li> <li>Friction Factor</li> <li>Fuchs Sutugin</li> <li>Input Handling</li> <li>Kelvin Correction</li> <li>Knudsen Number</li> <li>Lf2013 Coagulation</li> <li>Machine Limit</li> <li>Mean Free Path</li> <li>Molecular Enhancement</li> <li>Particle Mass</li> <li>Particle Surface</li> <li>Radius Cutoff</li> <li>Reduced Quantity</li> <li>Rms Speed</li> <li>Settling Velocity</li> <li>SimpleSolver</li> <li>Size Distribution Convert</li> <li>Slip Correction</li> <li>Species Properties</li> <li>Stats</li> <li>Surface Tension</li> <li>Time Manage</li> <li>Vapor Flux</li> <li>Wall Loss</li> </ul>"},{"location":"API/particula/util/aerodynamic_mobility/","title":"Aerodynamic Mobility","text":"<p>Particula Index / Particula / Util / Aerodynamic Mobility</p> <p>Auto-generated documentation for particula.util.aerodynamic_mobility module.</p>"},{"location":"API/particula/util/aerodynamic_mobility/#pam","title":"pam","text":"<p>Show source in aerodynamic_mobility.py:10</p> <p>particle aerodynamic mobility</p>"},{"location":"API/particula/util/aerodynamic_mobility/#signature","title":"Signature","text":"<pre><code>def pam(radius=None, scf_val=None, vis_val=None, **kwargs): ...\n</code></pre>"},{"location":"API/particula/util/approx_coagulation/","title":"Approx Coagulation","text":"<p>Particula Index / Particula / Util / Approx Coagulation</p> <p>Auto-generated documentation for particula.util.approx_coagulation module.</p>"},{"location":"API/particula/util/approx_coagulation/#approx_coag_less","title":"approx_coag_less","text":"<p>Show source in approx_coagulation.py:10</p> <p>dy2007 approx. Dimensionless particle--particle coagulation kernel.</p> <p>gh2012: https://journals.aps.org/pre/abstract/10.1103/PhysRevE.85.026410</p> <p>gk2008: https://journals.aps.org/pre/abstract/10.1103/PhysRevE.78.046402</p> <p>dy2007: https://aip.scitation.org/doi/10.1063/1.2713719</p> <p>cg2019: https://www.tandfonline.com/doi/suppl/10.1080/02786826.2019.1614522</p> <p>todolater: - quick fixes for corner cases - examine better solutions?</p>"},{"location":"API/particula/util/approx_coagulation/#signature","title":"Signature","text":"<pre><code>def approx_coag_less(diff_knu=None, cpr=None, approx=\"hardsphere\"): ...\n</code></pre>"},{"location":"API/particula/util/coagulation_rate/","title":"CoagulationRate","text":"<p>Particula Index / Particula / Util / CoagulationRate</p> <p>Auto-generated documentation for particula.util.coagulation_rate module.</p>"},{"location":"API/particula/util/coagulation_rate/#coagulationrate_1","title":"CoagulationRate","text":"<p>Show source in coagulation_rate.py:8</p> <p>A class to calculate the coagulation rate.</p>"},{"location":"API/particula/util/coagulation_rate/#arguments","title":"Arguments","text":"<ul> <li><code>distribution</code> float - The distribution of particles.</li> <li><code>radius</code> float - The radius of the particles.</li> <li><code>kernel</code> float - The kernel of the particles.</li> </ul>"},{"location":"API/particula/util/coagulation_rate/#signature","title":"Signature","text":"<pre><code>class CoagulationRate:\n    def __init__(self, distribution, radius, kernel, lazy=True): ...\n</code></pre>"},{"location":"API/particula/util/coagulation_rate/#coagulationratecoag_gain","title":"CoagulationRate().coag_gain","text":"<p>Show source in coagulation_rate.py:76</p> <p>Returns the coagulation gain rate</p> <p>Equation:</p> <p>gain_rate(other_radius) = (     other_radius**2 *     integral( # from some_radius=0 to other_radius/2**(\u2153)         kernel(some_radius, (other_radius**3-some_radius**3)(\u2153)         dist(some_radius) *         dist((other_radius**3 - some_radius**3)(\u2153)) /         (other_radius**3 - some_radius**3)(\u2154),         some_radius     ) )</p> <p>Units:     m**-4/s</p> <p>This equation necessitates the use of a for-loop due to the convoluted use of different radii at different stages. This is the costliest step of all coagulation calculations. Note, to estimate the kernel and distribution at (other_radius**3 - some_radius**3)*(\u2153) we use interporlation techniques.</p> <p>Using <code>RectBivariateSpline</code> accelerates this significantly.</p>"},{"location":"API/particula/util/coagulation_rate/#signature_1","title":"Signature","text":"<pre><code>def coag_gain(self): ...\n</code></pre>"},{"location":"API/particula/util/coagulation_rate/#coagulationratecoag_loss","title":"CoagulationRate().coag_loss","text":"<p>Show source in coagulation_rate.py:54</p> <p>Returns the coagulation loss rate</p> <p>Equation:</p> <p>loss_rate(other_radius) = (     dist(other_radius) *     integral( # over all space         kernel(radius, other_radius) *         dist(radius),         radius     )</p> <p>Units:</p> <p>m**-4/s</p>"},{"location":"API/particula/util/coagulation_rate/#signature_2","title":"Signature","text":"<pre><code>def coag_loss(self): ...\n</code></pre>"},{"location":"API/particula/util/coagulation_rate/#coagulationratecoag_prep","title":"CoagulationRate().coag_prep","text":"<p>Show source in coagulation_rate.py:44</p> <p>Repackage the parameters</p>"},{"location":"API/particula/util/coagulation_rate/#signature_3","title":"Signature","text":"<pre><code>def coag_prep(self): ...\n</code></pre>"},{"location":"API/particula/util/colors/","title":"Colors","text":"<p>Particula Index / Particula / Util / Colors</p> <p>Auto-generated documentation for particula.util.colors module.</p>"},{"location":"API/particula/util/condensation_force/","title":"Condensation Force","text":"<p>Particula Index / Particula / Util / Condensation Force</p> <p>Auto-generated documentation for particula.util.condensation_force module.</p>"},{"location":"API/particula/util/condensation_force/#condensation_force","title":"condensation_force","text":"<p>Show source in condensation_force.py:9</p> <p>calculate the condensation driving force</p> <p>Equation (9) in https://www.nature.com/articles/nature18271</p>"},{"location":"API/particula/util/condensation_force/#signature","title":"Signature","text":"<pre><code>def condensation_force(\n    vapor_concentraton, sat_vapor_concentration, particle_activity=None, **kwargs\n): ...\n</code></pre>"},{"location":"API/particula/util/condensation_force/#particle_activity_fun","title":"particle_activity_fun","text":"<p>Show source in condensation_force.py:29</p> <p>calculate the particle activity</p> <p>Equation (9--10) in https://www.nature.com/articles/nature18271</p>"},{"location":"API/particula/util/condensation_force/#signature_1","title":"Signature","text":"<pre><code>def particle_activity_fun(\n    mass_fraction, activity_coefficient, kelvin_term=None, **kwargs\n): ...\n</code></pre>"},{"location":"API/particula/util/convert/","title":"Convert","text":"<p>Particula Index / Particula / Util / Convert</p> <p>Auto-generated documentation for particula.util.convert module.</p>"},{"location":"API/particula/util/convert/#coerce_type","title":"coerce_type","text":"<p>Show source in convert.py:9</p> <p>Coerces data to dtype if it is not already of that type.</p>"},{"location":"API/particula/util/convert/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; coerce_type(1, float)\n1.0\n&gt;&gt;&gt; coerce_type([1, 2, 3], np.ndarray)\narray([1, 2, 3])\n</code></pre>"},{"location":"API/particula/util/convert/#arguments","title":"Arguments","text":"<ul> <li><code>data</code> - The data to be coerced.</li> <li><code>dtype</code> - The desired data type.</li> </ul>"},{"location":"API/particula/util/convert/#returns","title":"Returns","text":"<p>The coerced data.</p>"},{"location":"API/particula/util/convert/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code> - If the data cannot be coerced to the desired type.</li> </ul>"},{"location":"API/particula/util/convert/#signature","title":"Signature","text":"<pre><code>def coerce_type(data, dtype): ...\n</code></pre>"},{"location":"API/particula/util/convert/#convert_sizer_dn","title":"convert_sizer_dn","text":"<p>Show source in convert.py:440</p> <p>Converts the sizer data from dn/dlogdp to d_num.</p> <p>The bin width is defined as the  difference between the upper and lower diameter limits of each bin. This function calculates the bin widths based on the input diameter array. Assumes a log10 scale for dp edges.</p>"},{"location":"API/particula/util/convert/#arguments_1","title":"Arguments","text":"<ul> <li><code>diameter</code> np.ndarray - Array of particle diameters.</li> <li><code>dn_dlogdp</code> np.ndarray - Array of number concentration of particles per unit logarithmic diameter.</li> <li><code>inverse</code> bool - If True, converts from d_num to dn/dlogdp.</li> </ul>"},{"location":"API/particula/util/convert/#returns_1","title":"Returns","text":"<ul> <li><code>np.ndarray</code> - Array of number concentration of particles per unit diameter.</li> </ul>"},{"location":"API/particula/util/convert/#references","title":"References","text":"<ul> <li><code>Eq</code> - dN/dlogD_p = dN/( log(D_{p-upper}) - log(D_{p-lower}) ) https://tsi.com/getmedia/1621329b-f410-4dce-992b-e21e1584481a/ PR-001-RevA_Aerosol-Statistics-AppNote?ext=.pdf</li> </ul>"},{"location":"API/particula/util/convert/#signature_1","title":"Signature","text":"<pre><code>def convert_sizer_dn(\n    diameter: np.ndarray, dn_dlogdp: np.ndarray, inverse: bool = False\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/util/convert/#data_shape_check","title":"data_shape_check","text":"<p>Show source in convert.py:543</p> <p>Check the shape of the input data and header list, and reshape the data if necessary. The data array can be 1D or 2D. If the data array is 2D, the time array must match the last dimensions of the data array. If the data array is 1D, the header list must be a single entry.</p>"},{"location":"API/particula/util/convert/#arguments_2","title":"Arguments","text":"<ul> <li><code>time</code> np.ndarray - 1D array of time values.</li> <li><code>data</code> np.ndarray - 1D or 2D array of data values.</li> <li><code>header</code> list - List of header values.</li> </ul>"},{"location":"API/particula/util/convert/#returns_2","title":"Returns","text":"<p>Reshaped data array.</p>"},{"location":"API/particula/util/convert/#raises_1","title":"Raises","text":"<ul> <li><code>ValueError</code> - If the length of the header list does not match the first dimension of the data array.</li> </ul>"},{"location":"API/particula/util/convert/#signature_2","title":"Signature","text":"<pre><code>def data_shape_check(time: np.ndarray, data: np.ndarray, header: list) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/util/convert/#distribution_convert_pdf_pms","title":"distribution_convert_pdf_pms","text":"<p>Show source in convert.py:603</p> <p>Convert between a probability density function (PDF) and a probability mass spectrum (PMS) based on the specified direction.</p>"},{"location":"API/particula/util/convert/#arguments_3","title":"Arguments","text":"<p>x_array : An array of radii corresponding to the bins of the     distribution, shape (m). distribution : The concentration values of the distribution     (either PDF or PMS) at the given radii. Supports broadcasting     across x_array (n,m). to_PDF : Direction of conversion. If True, converts PMS to PDF.     If False, converts PDF to PMS.</p>"},{"location":"API/particula/util/convert/#returns_3","title":"Returns","text":"<p>converted_distribution : The converted distribution array     (either PDF or PMS).</p>"},{"location":"API/particula/util/convert/#signature_3","title":"Signature","text":"<pre><code>def distribution_convert_pdf_pms(\n    x_array: np.ndarray, distribution: np.ndarray, to_pdf: bool = True\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/util/convert/#effective_refractive_index","title":"effective_refractive_index","text":"<p>Show source in convert.py:402</p> <p>Calculate the effective refractive index of a mixture of two solutes, given the refractive index of each solute and the volume of each solute. The mixing is based on volume-weighted molar refraction.</p>"},{"location":"API/particula/util/convert/#arguments_4","title":"Arguments","text":"<ul> <li><code>m_zero</code> - The refractive index of solute 0.</li> <li><code>m_one</code> - The refractive index of solute 1.</li> <li><code>volume_zero</code> - The volume of solute 0.</li> <li><code>volume_one</code> - The volume of solute 1.</li> </ul>"},{"location":"API/particula/util/convert/#returns_4","title":"Returns","text":"<p>The effective refractive index of the mixture.</p>"},{"location":"API/particula/util/convert/#references_1","title":"References","text":"<p>Liu, Y., &amp; Daum, P. H. (2008). Relationship of refractive index to mass density and self-consistency mixing rules for multicomponent mixtures like ambient aerosols. Journal of Aerosol Science, 39(11), 974-986. https://doi.org/10.1016/j.jaerosci.2008.06.006</p>"},{"location":"API/particula/util/convert/#signature_4","title":"Signature","text":"<pre><code>def effective_refractive_index(\n    m_zero: Union[float, complex],\n    m_one: Union[float, complex],\n    volume_zero: float,\n    volume_one: float,\n) -&gt; Union[float, complex]: ...\n</code></pre>"},{"location":"API/particula/util/convert/#get_values_in_dict","title":"get_values_in_dict","text":"<p>Show source in convert.py:509</p> <p>Returns a list of values for keys in a dictionary.</p>"},{"location":"API/particula/util/convert/#examples_1","title":"Examples","text":"<pre><code>&gt;&gt;&gt; my_dict = {'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; get_values_in_dict(['a', 'c'], my_dict)\n[1, 3]\n</code></pre>"},{"location":"API/particula/util/convert/#arguments_5","title":"Arguments","text":"<ul> <li><code>key_list</code> - List of keys to check in the dictionary.</li> <li><code>dict_to_check</code> - The dictionary to check for the given keys.</li> </ul>"},{"location":"API/particula/util/convert/#returns_5","title":"Returns","text":"<ul> <li><code>List</code> - A list of values for keys in the dictionary.</li> </ul>"},{"location":"API/particula/util/convert/#raises_2","title":"Raises","text":"<ul> <li><code>KeyError</code> - If any of the keys in the <code>key_list</code> are not present in the dictionary.</li> </ul>"},{"location":"API/particula/util/convert/#signature_5","title":"Signature","text":"<pre><code>def get_values_in_dict(\n    key_list: List[str], dict_to_check: Dict[str, Any]\n) -&gt; List[Any]: ...\n</code></pre>"},{"location":"API/particula/util/convert/#kappa_from_volume","title":"kappa_from_volume","text":"<p>Show source in convert.py:206</p> <p>Calculate the kappa parameter from the volume of solute and water, given the water activity.</p>"},{"location":"API/particula/util/convert/#arguments_6","title":"Arguments","text":"<ul> <li><code>volume_solute</code> - The volume of solute.</li> <li><code>volume_water</code> - The volume of water.</li> <li><code>water_activity</code> - The water activity.</li> </ul>"},{"location":"API/particula/util/convert/#returns_6","title":"Returns","text":"<pre><code>The kappa parameter as a float.\n</code></pre>"},{"location":"API/particula/util/convert/#signature_6","title":"Signature","text":"<pre><code>def kappa_from_volume(\n    volume_solute: Union[float, np.ndarray],\n    volume_water: Union[float, np.ndarray],\n    water_activity: Union[float, np.ndarray],\n) -&gt; Union[float, np.ndarray]: ...\n</code></pre>"},{"location":"API/particula/util/convert/#kappa_volume_solute","title":"kappa_volume_solute","text":"<p>Show source in convert.py:148</p> <p>Calculate the volume of solute in a volume of total solution, given the kappa parameter and water activity.</p>"},{"location":"API/particula/util/convert/#arguments_7","title":"Arguments","text":"<ul> <li><code>volume_total</code> - The volume of the total solution.</li> <li><code>kappa</code> - The kappa parameter.</li> <li><code>water_activity</code> - The water activity.</li> </ul>"},{"location":"API/particula/util/convert/#returns_7","title":"Returns","text":"<pre><code>The volume of solute as a numpy array.\n</code></pre>"},{"location":"API/particula/util/convert/#signature_7","title":"Signature","text":"<pre><code>def kappa_volume_solute(\n    volume_total: Union[float, np.ndarray],\n    kappa: Union[float, np.ndarray],\n    water_activity: Union[float, np.ndarray],\n) -&gt; Union[float, np.ndarray]: ...\n</code></pre>"},{"location":"API/particula/util/convert/#kappa_volume_water","title":"kappa_volume_water","text":"<p>Show source in convert.py:178</p> <p>Calculate the volume of water given volume of solute, kappa parameter, and water activity.</p>"},{"location":"API/particula/util/convert/#arguments_8","title":"Arguments","text":"<ul> <li><code>volume_solute</code> - The volume of solute.</li> <li><code>kappa</code> - The kappa parameter.</li> <li><code>water_activity</code> - The water activity.</li> </ul>"},{"location":"API/particula/util/convert/#returns_8","title":"Returns","text":"<pre><code>The volume of water as a float.\n</code></pre>"},{"location":"API/particula/util/convert/#signature_8","title":"Signature","text":"<pre><code>def kappa_volume_water(\n    volume_solute: Union[float, NDArray[np.float64]],\n    kappa: Union[float, NDArray[np.float64]],\n    water_activity: Union[float, NDArray[np.float64]],\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/util/convert/#length_to_volume","title":"length_to_volume","text":"<p>Show source in convert.py:125</p> <p>Convert radius or diameter to volume.</p>"},{"location":"API/particula/util/convert/#arguments_9","title":"Arguments","text":"<ul> <li><code>length</code> - The length to be converted.</li> <li><code>length_type</code> - The type of length ('radius' or 'diameter').     Default is 'radius'.</li> </ul>"},{"location":"API/particula/util/convert/#returns_9","title":"Returns","text":"<pre><code>The volume.\n</code></pre>"},{"location":"API/particula/util/convert/#signature_9","title":"Signature","text":"<pre><code>def length_to_volume(\n    length: Union[float, np.ndarray], length_type: str = \"radius\"\n) -&gt; Union[float, np.ndarray]: ...\n</code></pre>"},{"location":"API/particula/util/convert/#list_to_dict","title":"list_to_dict","text":"<p>Show source in convert.py:486</p> <p>Converts a list of strings to a dictionary. The keys are the strings and the values are the index of the string in the list.</p>"},{"location":"API/particula/util/convert/#arguments_10","title":"Arguments","text":"<ul> <li><code>list_of_str</code> list - A non-empty list of strings.</li> </ul>"},{"location":"API/particula/util/convert/#returns_10","title":"Returns","text":"<ul> <li><code>dict</code> - A dictionary where the keys are the strings and the values are     the index of the string in the list.</li> </ul>"},{"location":"API/particula/util/convert/#signature_10","title":"Signature","text":"<pre><code>def list_to_dict(list_of_str: list) -&gt; dict: ...\n</code></pre>"},{"location":"API/particula/util/convert/#mass_concentration_to_mole_fraction","title":"mass_concentration_to_mole_fraction","text":"<p>Show source in convert.py:284</p> <p>Convert mass concentrations to mole fractions for N components.</p>"},{"location":"API/particula/util/convert/#arguments_11","title":"Arguments","text":"<ul> <li><code>mass_concentrations</code> - A list or ndarray of mass concentrations (e.g., kg/m^3).</li> <li><code>molar_masses</code> - A list or ndarray of molecular weights (e.g., g/mol).</li> </ul>"},{"location":"API/particula/util/convert/#returns_11","title":"Returns","text":"<p>An ndarray of mole fractions.</p>"},{"location":"API/particula/util/convert/#notes","title":"Notes","text":"<p>The mole fraction of a component is given by the ratio of its molar concentration to the total molar concentration of all components.</p>"},{"location":"API/particula/util/convert/#signature_11","title":"Signature","text":"<pre><code>def mass_concentration_to_mole_fraction(\n    mass_concentrations: NDArray[np.float64], molar_masses: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/util/convert/#mass_concentration_to_volume_fraction","title":"mass_concentration_to_volume_fraction","text":"<p>Show source in convert.py:311</p> <p>Convert mass concentrations to volume fractions for N components.</p>"},{"location":"API/particula/util/convert/#arguments_12","title":"Arguments","text":"<ul> <li><code>mass_concentrations</code> - A list or ndarray of mass concentrations (e.g., kg/m^3).</li> <li><code>densities</code> - A list or ndarray of densities of each component (e.g., kg/m^3).</li> </ul>"},{"location":"API/particula/util/convert/#returns_12","title":"Returns","text":"<p>An ndarray of volume fractions.</p>"},{"location":"API/particula/util/convert/#notes_1","title":"Notes","text":"<p>The volume fraction of a component is calculated by dividing the volume of that component (derived from mass concentration and density) by the total volume of all components.</p>"},{"location":"API/particula/util/convert/#signature_12","title":"Signature","text":"<pre><code>def mass_concentration_to_volume_fraction(\n    mass_concentrations: NDArray[np.float64], densities: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/util/convert/#mass_fraction_to_volume_fraction","title":"mass_fraction_to_volume_fraction","text":"<p>Show source in convert.py:342</p> <p>Converts the mass fraction of a solute to the volume fraction in a binary mixture.</p>"},{"location":"API/particula/util/convert/#arguments_13","title":"Arguments","text":"<ul> <li><code>mass_fraction</code> float - The mass fraction of the solute in the mixture.</li> <li><code>density_solute</code> float - The density of the solute.</li> <li><code>density_solvent</code> float - The density of the solvent.</li> </ul>"},{"location":"API/particula/util/convert/#returns_13","title":"Returns","text":"<ul> <li><code>Tuple[float,</code> float] - A tuple containing the volume fraction of the     solute and solvent in the mixture.</li> </ul>"},{"location":"API/particula/util/convert/#examples_2","title":"Examples","text":"<p>If <code>mass_fraction</code> is 0.5, <code>density_solute</code> is 1.5 g/cm^3, and <code>density_solvent</code> is 2 g/cm^3, this function returns (0.5714, 0.4285), indicating that the solute and solvent occupy 57% and 42% of the mixture's volume, respectively.</p>"},{"location":"API/particula/util/convert/#signature_13","title":"Signature","text":"<pre><code>def mass_fraction_to_volume_fraction(\n    mass_fraction: float, density_solute: float, density_solvent: float\n) -&gt; Tuple[float, float]: ...\n</code></pre>"},{"location":"API/particula/util/convert/#mole_fraction_to_mass_fraction","title":"mole_fraction_to_mass_fraction","text":"<p>Show source in convert.py:233</p> <p>Convert mole fraction to mass fraction.</p>"},{"location":"API/particula/util/convert/#arguments_14","title":"Arguments","text":"<ul> <li><code>mole_fraction0</code> - The mole fraction of the first component.</li> <li><code>molecular_weight0</code> - The molecular weight of the first component.</li> <li><code>molecular_weight1</code> - The molecular weight of the second component.</li> </ul>"},{"location":"API/particula/util/convert/#returns_14","title":"Returns","text":"<p>A tuple containing the mass fractions of the two components as floats.</p>"},{"location":"API/particula/util/convert/#signature_14","title":"Signature","text":"<pre><code>def mole_fraction_to_mass_fraction(\n    mole_fraction0: float, molecular_weight0: float, molecular_weight1: float\n) -&gt; Tuple[float, float]: ...\n</code></pre>"},{"location":"API/particula/util/convert/#mole_fraction_to_mass_fraction_multi","title":"mole_fraction_to_mass_fraction_multi","text":"<p>Show source in convert.py:259</p> <p>Convert mole fractions to mass fractions for N components. Assumes that sum(mole_fractions) == 1.</p>"},{"location":"API/particula/util/convert/#arguments_15","title":"Arguments","text":"<ul> <li><code>mole_fractions</code> - A list of mole fractions.</li> <li><code>molecular_weights</code> - A list of molecular weights.</li> </ul>"},{"location":"API/particula/util/convert/#returns_15","title":"Returns","text":"<p>A list of mass fractions.</p>"},{"location":"API/particula/util/convert/#signature_15","title":"Signature","text":"<pre><code>def mole_fraction_to_mass_fraction_multi(\n    mole_fractions: list[float], molecular_weights: list[float]\n) -&gt; list[float]: ...\n</code></pre>"},{"location":"API/particula/util/convert/#radius_diameter","title":"radius_diameter","text":"<p>Show source in convert.py:87</p> <p>Convert a radius to a diameter, or vice versa.</p>"},{"location":"API/particula/util/convert/#arguments_16","title":"Arguments","text":"<ul> <li><code>value</code> - The value to be converted.</li> <li><code>to_diameter</code> - If True, convert from radius to diameter. If False, convert from diameter to radius.</li> </ul>"},{"location":"API/particula/util/convert/#returns_16","title":"Returns","text":"<p>The converted value.</p>"},{"location":"API/particula/util/convert/#signature_16","title":"Signature","text":"<pre><code>def radius_diameter(value: float, to_diameter: bool = True) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/util/convert/#round_arbitrary","title":"round_arbitrary","text":"<p>Show source in convert.py:37</p> <p>Rounds the input values to the nearest multiple of the base.</p> <p>For values exactly halfway between rounded decimal values, \"Bankers rounding applies\" rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0, -0.5 and 0.5 round to 0.0, etc.</p>"},{"location":"API/particula/util/convert/#arguments_17","title":"Arguments","text":"<ul> <li><code>values</code> - The values to be rounded.</li> <li><code>base</code> - The base to which the values should be rounded.</li> <li><code>mode</code> - The rounding mode: 'round', 'floor', 'ceil'</li> <li><code>nonzero_edge</code> - If true the zero values are replaced by the original values.</li> </ul>"},{"location":"API/particula/util/convert/#returns_17","title":"Returns","text":"<ul> <li><code>rounded</code> - The rounded values.</li> </ul>"},{"location":"API/particula/util/convert/#signature_17","title":"Signature","text":"<pre><code>def round_arbitrary(\n    values: Union[float, list[float], np.ndarray],\n    base: Union[float, np.float64] = 1.0,\n    mode: str = \"round\",\n    nonzero_edge: bool = False,\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/util/convert/#volume_to_length","title":"volume_to_length","text":"<p>Show source in convert.py:102</p> <p>Convert a volume to a radius or diameter.</p>"},{"location":"API/particula/util/convert/#arguments_18","title":"Arguments","text":"<ul> <li><code>volume</code> - The volume to be converted.</li> <li><code>length_type</code> - The type of length to convert to ('radius' or 'diameter') Default is 'radius'.</li> </ul>"},{"location":"API/particula/util/convert/#returns_18","title":"Returns","text":"<p>The converted length.</p>"},{"location":"API/particula/util/convert/#signature_18","title":"Signature","text":"<pre><code>def volume_to_length(\n    volume: Union[float, NDArray[np.float64]], length_type: str = \"radius\"\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/util/convert/#volume_water_from_volume_fraction","title":"volume_water_from_volume_fraction","text":"<p>Show source in convert.py:376</p> <p>Calculates the volume of water in a volume of solute, given the volume fraction of water in the mixture.</p>"},{"location":"API/particula/util/convert/#arguments_19","title":"Arguments","text":"<ul> <li><code>volume_solute_dry</code> float - The volume of the solute, excluding water.</li> <li><code>volume_fraction_water</code> float - The volume fraction of water in the                     mixture, expressed as a decimal between 0 and 1.</li> </ul>"},{"location":"API/particula/util/convert/#returns_19","title":"Returns","text":"<ul> <li><code>float</code> - The volume of water in the mixture, in the same units as     <code>volume_solute_dry</code>.</li> </ul>"},{"location":"API/particula/util/convert/#examples_3","title":"Examples","text":"<p>If <code>volume_solute_dry</code> is 100 mL and <code>volume_fraction_water</code> is 0.8, this function returns 400 mL, indicating that there are 400 mL of water in the total 100 mL + 400 mL mixture.</p>"},{"location":"API/particula/util/convert/#signature_19","title":"Signature","text":"<pre><code>def volume_water_from_volume_fraction(\n    volume_solute_dry: float, volume_fraction_water: float\n) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/util/coulomb_enhancement/","title":"CoulombEnhancement","text":"<p>Particula Index / Particula / Util / CoulombEnhancement</p> <p>Auto-generated documentation for particula.util.coulomb_enhancement module.</p>"},{"location":"API/particula/util/coulomb_enhancement/#coulombenhancement_1","title":"CoulombEnhancement","text":"<p>Show source in coulomb_enhancement.py:24</p> <p>Calculate coulomb-related enhancements</p>"},{"location":"API/particula/util/coulomb_enhancement/#attributes","title":"Attributes","text":"<p>radius          (float) [m] other_radius    (float) [m]             (default: radius) charge          (float) [dimensionless] (default: 0) other_charge    (float) [dimensionless] (default: 0) temperature     (float) [K]             (default: 298)</p>"},{"location":"API/particula/util/coulomb_enhancement/#signature","title":"Signature","text":"<pre><code>class CoulombEnhancement:\n    def __init__(\n        self,\n        radius=None,\n        other_radius=None,\n        charge=0,\n        other_charge=0,\n        temperature=298,\n        elementary_charge_value=ELEMENTARY_CHARGE_VALUE,\n        electric_permittivity=ELECTRIC_PERMITTIVITY,\n        boltzmann_constant=BOLTZMANN_CONSTANT,\n        **kwargs\n    ): ...\n</code></pre>"},{"location":"API/particula/util/coulomb_enhancement/#see-also","title":"See also","text":"<ul> <li>BOLTZMANN_CONSTANT</li> <li>ELECTRIC_PERMITTIVITY</li> <li>ELEMENTARY_CHARGE_VALUE</li> </ul>"},{"location":"API/particula/util/coulomb_enhancement/#coulombenhancementcoulomb_enhancement_continuum_limit","title":"CoulombEnhancement().coulomb_enhancement_continuum_limit","text":"<p>Show source in coulomb_enhancement.py:133</p> <p>Coulombic coagulation enhancement continuum limit.</p>"},{"location":"API/particula/util/coulomb_enhancement/#arguments","title":"Arguments","text":"<p>radius          (float) [m] other_radius    (float) [m]             (default: radius) charge          (float) [dimensionless] (default: 0) other_charge    (float) [dimensionless] (default: 0) temperature     (float) [K]             (default: 298)</p>"},{"location":"API/particula/util/coulomb_enhancement/#returns","title":"Returns","text":"<p>(float) [dimensionless]</p>"},{"location":"API/particula/util/coulomb_enhancement/#signature_1","title":"Signature","text":"<pre><code>def coulomb_enhancement_continuum_limit(self): ...\n</code></pre>"},{"location":"API/particula/util/coulomb_enhancement/#coulombenhancementcoulomb_enhancement_kinetic_limit","title":"CoulombEnhancement().coulomb_enhancement_kinetic_limit","text":"<p>Show source in coulomb_enhancement.py:112</p> <p>Coulombic coagulation enhancement kinetic limit.</p>"},{"location":"API/particula/util/coulomb_enhancement/#arguments_1","title":"Arguments","text":"<p>radius          (float) [m] other_radius    (float) [m]             (default: radius) charge          (float) [dimensionless] (default: 0) other_charge    (float) [dimensionless] (default: 0) temperature     (float) [K]             (default: 298)</p>"},{"location":"API/particula/util/coulomb_enhancement/#returns_1","title":"Returns","text":"<p>(float) [dimensionless]</p>"},{"location":"API/particula/util/coulomb_enhancement/#signature_2","title":"Signature","text":"<pre><code>def coulomb_enhancement_kinetic_limit(self): ...\n</code></pre>"},{"location":"API/particula/util/coulomb_enhancement/#coulombenhancementcoulomb_potential_ratio","title":"CoulombEnhancement().coulomb_potential_ratio","text":"<p>Show source in coulomb_enhancement.py:83</p> <p>Calculates the Coulomb potential ratio.</p>"},{"location":"API/particula/util/coulomb_enhancement/#arguments_2","title":"Arguments","text":"<p>radius          (float) [m] other_radius    (float) [m]             (default: radius) charge          (int)   [dimensionless] (default: 0) other_charge    (int)   [dimensionless] (default: 0) temperature     (float) [K]             (default: 298)</p>"},{"location":"API/particula/util/coulomb_enhancement/#returns_2","title":"Returns","text":"<p>(float) [dimensionless]</p>"},{"location":"API/particula/util/coulomb_enhancement/#signature_3","title":"Signature","text":"<pre><code>def coulomb_potential_ratio(self): ...\n</code></pre>"},{"location":"API/particula/util/coulomb_enhancement/#cecl","title":"cecl","text":"<p>Show source in coulomb_enhancement.py:166</p> <p>Calculate coulombic enhancement continuum limit</p>"},{"location":"API/particula/util/coulomb_enhancement/#signature_4","title":"Signature","text":"<pre><code>def cecl(**kwargs): ...\n</code></pre>"},{"location":"API/particula/util/coulomb_enhancement/#cekl","title":"cekl","text":"<p>Show source in coulomb_enhancement.py:161</p> <p>Calculate coulombic enhancement kinetic limit</p>"},{"location":"API/particula/util/coulomb_enhancement/#signature_5","title":"Signature","text":"<pre><code>def cekl(**kwargs): ...\n</code></pre>"},{"location":"API/particula/util/coulomb_enhancement/#coulomb_enhancement_all","title":"coulomb_enhancement_all","text":"<p>Show source in coulomb_enhancement.py:171</p> <p>Return all the values above in one call</p>"},{"location":"API/particula/util/coulomb_enhancement/#signature_6","title":"Signature","text":"<pre><code>def coulomb_enhancement_all(**kwargs): ...\n</code></pre>"},{"location":"API/particula/util/coulomb_enhancement/#cpr","title":"cpr","text":"<p>Show source in coulomb_enhancement.py:156</p> <p>Calculate coulomb potential ratio</p>"},{"location":"API/particula/util/coulomb_enhancement/#signature_7","title":"Signature","text":"<pre><code>def cpr(**kwargs): ...\n</code></pre>"},{"location":"API/particula/util/debye_function/","title":"Debye Function","text":"<p>Particula Index / Particula / Util / Debye Function</p> <p>Auto-generated documentation for particula.util.debye_function module.</p>"},{"location":"API/particula/util/debye_function/#df1","title":"df1","text":"<p>Show source in debye_function.py:8</p> <p>debye function</p>"},{"location":"API/particula/util/debye_function/#signature","title":"Signature","text":"<pre><code>def df1(var): ...\n</code></pre>"},{"location":"API/particula/util/diffusion_coefficient/","title":"Diffusion Coefficient","text":"<p>Particula Index / Particula / Util / Diffusion Coefficient</p> <p>Auto-generated documentation for particula.util.diffusion_coefficient module.</p>"},{"location":"API/particula/util/diffusion_coefficient/#pdc","title":"pdc","text":"<p>Show source in diffusion_coefficient.py:11</p> <p>particle diffusion coefficient</p>"},{"location":"API/particula/util/diffusion_coefficient/#signature","title":"Signature","text":"<pre><code>def pdc(temperature=298.15, bolk=BOLTZMANN_CONSTANT, pam_val=None, **kwargs): ...\n</code></pre>"},{"location":"API/particula/util/diffusion_coefficient/#see-also","title":"See also","text":"<ul> <li>BOLTZMANN_CONSTANT</li> </ul>"},{"location":"API/particula/util/diffusive_knudsen/","title":"DiffusiveKnudsen","text":"<p>Particula Index / Particula / Util / DiffusiveKnudsen</p> <p>Auto-generated documentation for particula.util.diffusive_knudsen module.</p>"},{"location":"API/particula/util/diffusive_knudsen/#diffusiveknudsen_1","title":"DiffusiveKnudsen","text":"<p>Show source in diffusive_knudsen.py:14</p> <p>A class for Diff..Knu</p>"},{"location":"API/particula/util/diffusive_knudsen/#signature","title":"Signature","text":"<pre><code>class DiffusiveKnudsen(CoulombEnhancement):\n    def __init__(self, density=1000, other_density=None, **kwargs): ...\n</code></pre>"},{"location":"API/particula/util/diffusive_knudsen/#see-also","title":"See also","text":"<ul> <li>CoulombEnhancement</li> </ul>"},{"location":"API/particula/util/diffusive_knudsen/#diffusiveknudsenget_celimits","title":"DiffusiveKnudsen().get_celimits","text":"<p>Show source in diffusive_knudsen.py:73</p> <p>get coag enh limits</p>"},{"location":"API/particula/util/diffusive_knudsen/#signature_1","title":"Signature","text":"<pre><code>def get_celimits(self): ...\n</code></pre>"},{"location":"API/particula/util/diffusive_knudsen/#diffusiveknudsenget_ces","title":"DiffusiveKnudsen().get_ces","text":"<p>Show source in diffusive_knudsen.py:67</p> <p>get coulomb enhancement parameters</p>"},{"location":"API/particula/util/diffusive_knudsen/#signature_2","title":"Signature","text":"<pre><code>def get_ces(self): ...\n</code></pre>"},{"location":"API/particula/util/diffusive_knudsen/#diffusiveknudsenget_diff_knu","title":"DiffusiveKnudsen().get_diff_knu","text":"<p>Show source in diffusive_knudsen.py:80</p> <p>calculate it</p>"},{"location":"API/particula/util/diffusive_knudsen/#signature_3","title":"Signature","text":"<pre><code>def get_diff_knu(self): ...\n</code></pre>"},{"location":"API/particula/util/diffusive_knudsen/#diffusiveknudsenget_red_frifac","title":"DiffusiveKnudsen().get_red_frifac","text":"<p>Show source in diffusive_knudsen.py:51</p> <p>get the reduced friction factor</p>"},{"location":"API/particula/util/diffusive_knudsen/#signature_4","title":"Signature","text":"<pre><code>def get_red_frifac(self): ...\n</code></pre>"},{"location":"API/particula/util/diffusive_knudsen/#diffusiveknudsenget_red_mass","title":"DiffusiveKnudsen().get_red_mass","text":"<p>Show source in diffusive_knudsen.py:34</p> <p>get the reduced mass</p>"},{"location":"API/particula/util/diffusive_knudsen/#signature_5","title":"Signature","text":"<pre><code>def get_red_mass(self): ...\n</code></pre>"},{"location":"API/particula/util/diffusive_knudsen/#diffusiveknudsenget_rxr","title":"DiffusiveKnudsen().get_rxr","text":"<p>Show source in diffusive_knudsen.py:45</p> <p>add two radii</p>"},{"location":"API/particula/util/diffusive_knudsen/#signature_6","title":"Signature","text":"<pre><code>def get_rxr(self): ...\n</code></pre>"},{"location":"API/particula/util/diffusive_knudsen/#celimits","title":"celimits","text":"<p>Show source in diffusive_knudsen.py:163</p> <p>get coag enh limits</p>"},{"location":"API/particula/util/diffusive_knudsen/#signature_7","title":"Signature","text":"<pre><code>def celimits(**kwargs): ...\n</code></pre>"},{"location":"API/particula/util/diffusive_knudsen/#ces","title":"ces","text":"<p>Show source in diffusive_knudsen.py:156</p> <p>get the coulomb enhancement limits</p>"},{"location":"API/particula/util/diffusive_knudsen/#signature_8","title":"Signature","text":"<pre><code>def ces(**kwargs): ...\n</code></pre>"},{"location":"API/particula/util/diffusive_knudsen/#diff_knu","title":"diff_knu","text":"<p>Show source in diffusive_knudsen.py:94</p> <p>Diffusive Knudsen number.</p> <p>The diffusive Knudsen number is different from Knudsen number. Ratio of:     - numerator: mean persistence of one particle     - denominator: effective length scale of         particle--particle Coulombic interaction</p>"},{"location":"API/particula/util/diffusive_knudsen/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from particula import u\n&gt;&gt;&gt; from particula.util.diffusive_knudsen import diff_knu\n&gt;&gt;&gt; # with only one radius\n&gt;&gt;&gt; diff_knu(radius=1e-9)\n&lt;Quantity(29.6799, 'dimensionless')&gt;\n&gt;&gt;&gt; # with two radii\n&gt;&gt;&gt; diff_knu(radius=1e-9, other_radius=1e-8)\n&lt;Quantity(3.85387845, 'dimensionless')&gt;\n&gt;&gt;&gt; # with radii and charges\n&gt;&gt;&gt; diff_knu(radius=1e-9, other_radius=1e-8, charge=-1, other_charge=1)\n&lt;Quantity(4.58204028, 'dimensionless')&gt;\n</code></pre>"},{"location":"API/particula/util/diffusive_knudsen/#arguments","title":"Arguments","text":"<p>radius          (float) [m] other_radius    (float) [m]             (default: radius) density         (float) [kg/m^3]        (default: 1000) other_density   (float) [kg/m^3]        (default: density) charge          (int)   [dimensionless] (default: 0) other_charge    (int)   [dimensionless] (default: 0) temperature     (float) [K]             (default: 298)</p>"},{"location":"API/particula/util/diffusive_knudsen/#returns","title":"Returns","text":"<p>(float) [dimensionless]</p>"},{"location":"API/particula/util/diffusive_knudsen/#notes","title":"Notes","text":"<p>this function uses the friction factor and the coulomb enhancement calculations; for more information, please see the documentation of the respective functions:     - particula.util.friction_factor.frifac(**kwargs)     - particula.util.coulomb_enhancement.cekl(**kwargs)     - particula.util.coulomb_enhancement.cecl(**kwargs)</p>"},{"location":"API/particula/util/diffusive_knudsen/#signature_9","title":"Signature","text":"<pre><code>def diff_knu(**kwargs): ...\n</code></pre>"},{"location":"API/particula/util/diffusive_knudsen/#red_frifac","title":"red_frifac","text":"<p>Show source in diffusive_knudsen.py:149</p> <p>get the reduced friction factor</p>"},{"location":"API/particula/util/diffusive_knudsen/#signature_10","title":"Signature","text":"<pre><code>def red_frifac(**kwargs): ...\n</code></pre>"},{"location":"API/particula/util/diffusive_knudsen/#red_mass","title":"red_mass","text":"<p>Show source in diffusive_knudsen.py:142</p> <p>get the reduced mass</p>"},{"location":"API/particula/util/diffusive_knudsen/#signature_11","title":"Signature","text":"<pre><code>def red_mass(**kwargs): ...\n</code></pre>"},{"location":"API/particula/util/diffusive_knudsen/#rxr","title":"rxr","text":"<p>Show source in diffusive_knudsen.py:170</p> <p>add two radii</p>"},{"location":"API/particula/util/diffusive_knudsen/#signature_12","title":"Signature","text":"<pre><code>def rxr(**kwargs): ...\n</code></pre>"},{"location":"API/particula/util/dilution_loss/","title":"Dilution Loss","text":"<p>Particula Index / Particula / Util / Dilution Loss</p> <p>Auto-generated documentation for particula.util.dilution_loss module.</p>"},{"location":"API/particula/util/dilution_loss/#drc","title":"drc","text":"<p>Show source in dilution_loss.py:5</p> <p>calculate the dilution loss coefficient</p>"},{"location":"API/particula/util/dilution_loss/#signature","title":"Signature","text":"<pre><code>def drc(value=0.0): ...\n</code></pre>"},{"location":"API/particula/util/dimensionless_coagulation/","title":"DimensionlessCoagulation","text":"<p>Particula Index / Particula / Util / DimensionlessCoagulation</p> <p>Auto-generated documentation for particula.util.dimensionless_coagulation module.</p>"},{"location":"API/particula/util/dimensionless_coagulation/#dimensionlesscoagulation_1","title":"DimensionlessCoagulation","text":"<p>Show source in dimensionless_coagulation.py:12</p> <p>dimensionless coagulation</p>"},{"location":"API/particula/util/dimensionless_coagulation/#signature","title":"Signature","text":"<pre><code>class DimensionlessCoagulation(DKn):\n    def __init__(self, dkn_val=None, coag_approx=\"hardsphere\", **kwargs): ...\n</code></pre>"},{"location":"API/particula/util/dimensionless_coagulation/#see-also","title":"See also","text":"<ul> <li>DiffusiveKnudsen</li> </ul>"},{"location":"API/particula/util/dimensionless_coagulation/#dimensionlesscoagulationcoag_full","title":"DimensionlessCoagulation().coag_full","text":"<p>Show source in dimensionless_coagulation.py:58</p> <p>Retrun the dimensioned coagulation kernel</p>"},{"location":"API/particula/util/dimensionless_coagulation/#signature_1","title":"Signature","text":"<pre><code>def coag_full(self): ...\n</code></pre>"},{"location":"API/particula/util/dimensionless_coagulation/#dimensionlesscoagulationcoag_less","title":"DimensionlessCoagulation().coag_less","text":"<p>Show source in dimensionless_coagulation.py:43</p> <p>Return the dimensionless coagulation kernel.</p>"},{"location":"API/particula/util/dimensionless_coagulation/#signature_2","title":"Signature","text":"<pre><code>def coag_less(self): ...\n</code></pre>"},{"location":"API/particula/util/dimensionless_coagulation/#full_coag","title":"full_coag","text":"<p>Show source in dimensionless_coagulation.py:102</p> <p>Return the dimensioned coagulation kernel</p>"},{"location":"API/particula/util/dimensionless_coagulation/#signature_3","title":"Signature","text":"<pre><code>def full_coag(**kwargs): ...\n</code></pre>"},{"location":"API/particula/util/dimensionless_coagulation/#less_coag","title":"less_coag","text":"<p>Show source in dimensionless_coagulation.py:73</p> <p>Return the dimensionless coagulation kernel.</p> <p>The dimensionless coagulation kernel is defined as a function of the diffusive knudsen number; for more info, please see the documentation of the respective function:     - particula.util.diffusive_knudsen.diff_knu(**kwargs)</p>"},{"location":"API/particula/util/dimensionless_coagulation/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from particula import u\n&gt;&gt;&gt; from particula.util.dimensionless_coagulation import less_coag\n&gt;&gt;&gt; # only for hardsphere coagulation for now\n&gt;&gt;&gt; # with only one radius\n&gt;&gt;&gt; less_coag(radius=1e-9)\n&lt;Quantity(147.877572, 'dimensionless')&gt;\n&gt;&gt;&gt; # with two radii\n&gt;&gt;&gt; less_coag(radius=1e-9, other_radius=1e-8)\n&lt;Quantity(18.4245966, 'dimensionless')&gt;\n&gt;&gt;&gt; # with two radii and charges\n&gt;&gt;&gt; less_coag(\n... radius=1e-9, other_radius=1e-8, charge=1, other_charge=-1\n... )\n&lt;Quantity(22.0727435, 'dimensionless')&gt;\n\n#### Signature\n\n```python\ndef less_coag(**kwargs): ...\n</code></pre>"},{"location":"API/particula/util/distribution_discretization/","title":"Distribution Discretization","text":"<p>Particula Index / Particula / Util / Distribution Discretization</p> <p>Auto-generated documentation for particula.util.distribution_discretization module.</p>"},{"location":"API/particula/util/distribution_discretization/#discretize","title":"discretize","text":"<p>Show source in distribution_discretization.py:9</p> <p>discretize the distribution of the particles</p>"},{"location":"API/particula/util/distribution_discretization/#arguments","title":"Arguments","text":"<p>interval    (float) the size interval of the distribution distype     (str)   the type of distribution, \"lognormal\" for now gsigma      (float) geometric standard deviation of distribution mode        (float) pdf scale (corresponds to mode in lognormal)</p>"},{"location":"API/particula/util/distribution_discretization/#signature","title":"Signature","text":"<pre><code>def discretize(\n    interval=None,\n    disttype=\"lognormal\",\n    gsigma=in_scalar(1.25).m,\n    mode=in_radius(1e-07),\n    nparticles=in_scalar(100000.0).m,\n    **kwargs\n): ...\n</code></pre>"},{"location":"API/particula/util/dynamic_viscosity/","title":"Dynamic Viscosity","text":"<p>Particula Index / Particula / Util / Dynamic Viscosity</p> <p>Auto-generated documentation for particula.util.dynamic_viscosity module.</p>"},{"location":"API/particula/util/dynamic_viscosity/#dyn_vis","title":"dyn_vis","text":"<p>Show source in dynamic_viscosity.py:21</p> <p>The dynamic viscosity of air via Sutherland formula. This formula depends on temperature (temp) and the reference temperature (t_ref) as well as the reference viscosity (mu_ref).</p>"},{"location":"API/particula/util/dynamic_viscosity/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from particula import u\n&gt;&gt;&gt; from particula.util.dynamic_viscosity import dyn_vis\n&gt;&gt;&gt; # with units\n&gt;&gt;&gt; dyn_vis(\n... temperature=298.15*u.K,\n... reference_viscosity=1.716e-5*u.Pa*u.s\n... )\n&lt;Quantity(1.83714937e-05, 'kilogram / meter / second')&gt;\n&gt;&gt;&gt; # without units and taking magnitude\n&gt;&gt;&gt; dyn_vis(\n... temperature=298.15,\n... reference_viscosity=1.716e-5\n... ).magnitude\n1.8371493734583912e-05\n&gt;&gt;&gt; # without units, all keyword arguments\n&gt;&gt;&gt; dyn_vis(\n... temperature=298.15,\n... reference_viscosity=1.716e-5,\n... reference_temperature=273.15\n... )\n&lt;Quantity(1.83714937e-05, 'kilogram / meter / second')&gt;\n&gt;&gt;&gt; # for a list of temperatures\n&gt;&gt;&gt; dyn_vis(temperature=[200, 250, 300, 400]).m\narray([1.32849751e-05, 1.59905239e-05, 1.84591625e-05, 2.28516090e-05])\n</code></pre> <p>Inputs:     temperature             (float) [K]     (default: 298.15)     reference_viscosity     (float) [Pa*s]  (default: constants)     reference_temperature   (float) [K]     (default: constants)     sutherland_constant     (float) [K]     (default: constants)</p>"},{"location":"API/particula/util/dynamic_viscosity/#returns","title":"Returns","text":"<p>(float) [Pa*s]</p> <p>Using particula.constants:     REF_VISCOSITY_AIR_STP   (float) [Pa*s]     REF_TEMPERATURE_STP     (float) [K]     SUTHERLAND_CONSTANT     (float) [K]</p>"},{"location":"API/particula/util/dynamic_viscosity/#signature","title":"Signature","text":"<pre><code>def dyn_vis(\n    temperature=298.15 * u.K,\n    reference_viscosity=REF_VISCOSITY_AIR_STP,\n    reference_temperature=REF_TEMPERATURE_STP,\n    sutherland_constant=SUTHERLAND_CONSTANT,\n    **kwargs\n): ...\n</code></pre>"},{"location":"API/particula/util/dynamic_viscosity/#see-also","title":"See also","text":"<ul> <li>REF_TEMPERATURE_STP</li> <li>REF_VISCOSITY_AIR_STP</li> <li>SUTHERLAND_CONSTANT</li> </ul>"},{"location":"API/particula/util/friction_factor/","title":"Friction Factor","text":"<p>Particula Index / Particula / Util / Friction Factor</p> <p>Auto-generated documentation for particula.util.friction_factor module.</p>"},{"location":"API/particula/util/friction_factor/#frifac","title":"frifac","text":"<p>Show source in friction_factor.py:10</p> <p>Returns a particle's friction factor.</p> <p>Property of the particle's size and surrounding medium. Multiplying the friction factor by the fluid velocity yields the drag force on the particle.</p> <p>It is best thought of as an inverse of mobility or the ratio between thermal energy and diffusion coefficient. The modified Stoke's diffusion coefficient is defined as kT / (6 * np.pi * dyn_vis_air * radius / slip_corr) and thus the friction factor can be defined as (6 * np.pi * dyn_vis_air * radius / slip_corr).</p> <p>In the continuum limit (Kn -&gt; 0; Cc -&gt; 1):     6 * np.pi * dyn_vis_air * radius</p> <p>In the kinetic limit (Kn -&gt; inf):     8.39 * (dyn_vis_air/mfp_air) * const * radius**2</p> <p>See more: DOI: 10.1080/02786826.2012.690543 (const=1.36)</p>"},{"location":"API/particula/util/friction_factor/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from particula import u\n&gt;&gt;&gt; from particula.util.friction_factor import frifac\n&gt;&gt;&gt; # with 1e-9 m radius\n&gt;&gt;&gt; frifac(radius=1e-9)\n&lt;Quantity(3.12763919e-15, 'kilogram / second')&gt;\n&gt;&gt;&gt; # with 1e-9 m radius and 1e-5 N/m^2 dynamic viscosity\n&gt;&gt;&gt; frifac(radius=1e-9, dynamic_viscosity=1e-5)\n&lt;Quantity(3.114213e-15, 'kilogram / second')&gt;\n&gt;&gt;&gt; # using dyn_vis(**kwargs)\n&gt;&gt;&gt; frifac(\n... radius=1e-9,\n... temperature=298.15,\n... reference_viscosity=1.716e-5,\n... reference_temperature=273.15\n)\n&lt;Quantity(3.12763919e-15, 'kilogram / second')&gt;\n&gt;&gt;&gt; # overriding sfc(**kwargs)\n&gt;&gt;&gt; frifac(radius=1e-9, slip_correction=1.5)\n&lt;Quantity(3.12763919e-15, 'kilogram / second')&gt;\n</code></pre>"},{"location":"API/particula/util/friction_factor/#arguments","title":"Arguments","text":"<p>radius            (float) [m] dynamic_viscosity (float) [kg/m/s]  (default: util) slip_corr_factor  (float) [ ]       (default: util)</p>"},{"location":"API/particula/util/friction_factor/#returns","title":"Returns","text":"<p>(float) [N*s/m]</p>"},{"location":"API/particula/util/friction_factor/#notes","title":"Notes","text":"<p>dynamic_viscosity can be calculated using the utility function particula.util.dynamic_viscosity.dyn_vis(**kwargs) and slip_corr_factor can be calculated using the utility function particula.util.slip_correction.scf(**kwargs); see respective documentation for more information.</p>"},{"location":"API/particula/util/friction_factor/#signature","title":"Signature","text":"<pre><code>def frifac(radius=None, dynamic_viscosity=None, scf_val=None, **kwargs): ...\n</code></pre>"},{"location":"API/particula/util/fuchs_sutugin/","title":"Fuchs Sutugin","text":"<p>Particula Index / Particula / Util / Fuchs Sutugin</p> <p>Auto-generated documentation for particula.util.fuchs_sutugin module.</p>"},{"location":"API/particula/util/fuchs_sutugin/#fsc","title":"fsc","text":"<p>Show source in fuchs_sutugin.py:9</p> <p>Returns the Fuchs-Sutugin model transition regime correction.</p>"},{"location":"API/particula/util/fuchs_sutugin/#arguments","title":"Arguments","text":"<p>knu     (float)  [ ] (default: util) alpha   (float)  [ ] (default: 1)</p>"},{"location":"API/particula/util/fuchs_sutugin/#returns","title":"Returns","text":"<p>(float)  [ ]</p>"},{"location":"API/particula/util/fuchs_sutugin/#notes","title":"Notes","text":"<p>knu can be calculated using knu(**kwargs); refer to particula.util.knudsen_number.knu for more info.</p>"},{"location":"API/particula/util/fuchs_sutugin/#signature","title":"Signature","text":"<pre><code>def fsc(knu_val=None, alpha=1, **kwargs): ...\n</code></pre>"},{"location":"API/particula/util/input_handling/","title":"Input Handling","text":"<p>Particula Index / Particula / Util / Input Handling</p> <p>Auto-generated documentation for particula.util.input_handling module.</p>"},{"location":"API/particula/util/input_handling/#convert_units","title":"convert_units","text":"<p>Show source in input_handling.py:77</p> <p>generic pint function to convert units</p>"},{"location":"API/particula/util/input_handling/#arguments","title":"Arguments","text":"<p>old     [str | u.Quantity] new     [str | u.Quantity] value   (float) [optional]</p>"},{"location":"API/particula/util/input_handling/#returns","title":"Returns","text":"<p>multiplier     (float)</p>"},{"location":"API/particula/util/input_handling/#notes","title":"Notes","text":"<ul> <li>If unit is correct, take to base units</li> <li>Throws ValueError if unit is wrong</li> <li>Assigning default base units to scalar input</li> </ul>"},{"location":"API/particula/util/input_handling/#signature","title":"Signature","text":"<pre><code>def convert_units(\n    old: Union[str, u.Quantity],\n    new: Union[str, u.Quantity],\n    value: Optional[float] = None,\n) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/util/input_handling/#in_acceleration","title":"in_acceleration","text":"<p>Show source in input_handling.py:128</p>"},{"location":"API/particula/util/input_handling/#signature_1","title":"Signature","text":"<pre><code>def in_acceleration(acc): ...\n</code></pre>"},{"location":"API/particula/util/input_handling/#in_area","title":"in_area","text":"<p>Show source in input_handling.py:133</p>"},{"location":"API/particula/util/input_handling/#signature_2","title":"Signature","text":"<pre><code>def in_area(area): ...\n</code></pre>"},{"location":"API/particula/util/input_handling/#in_concentration","title":"in_concentration","text":"<p>Show source in input_handling.py:135</p>"},{"location":"API/particula/util/input_handling/#signature_3","title":"Signature","text":"<pre><code>def in_concentration(conc): ...\n</code></pre>"},{"location":"API/particula/util/input_handling/#in_density","title":"in_density","text":"<p>Show source in input_handling.py:130</p>"},{"location":"API/particula/util/input_handling/#signature_4","title":"Signature","text":"<pre><code>def in_density(density): ...\n</code></pre>"},{"location":"API/particula/util/input_handling/#in_gas_constant","title":"in_gas_constant","text":"<p>Show source in input_handling.py:134</p>"},{"location":"API/particula/util/input_handling/#signature_5","title":"Signature","text":"<pre><code>def in_gas_constant(con): ...\n</code></pre>"},{"location":"API/particula/util/input_handling/#in_handling","title":"in_handling","text":"<p>Show source in input_handling.py:44</p> <p>generic function to handle inputs</p>"},{"location":"API/particula/util/input_handling/#arguments_1","title":"Arguments","text":"<p>value     (float)       [u.Quantity | dimensionless] units     (u.Quantity)</p>"},{"location":"API/particula/util/input_handling/#returns_1","title":"Returns","text":"<p>value     (float)       [u.Quantity]</p>"},{"location":"API/particula/util/input_handling/#notes_1","title":"Notes","text":"<ul> <li>If unit is correct, take to base units</li> <li>Throws ValueError if unit is wrong</li> <li>Assigning default base units to scalar input</li> </ul>"},{"location":"API/particula/util/input_handling/#signature_6","title":"Signature","text":"<pre><code>def in_handling(value, units: u.Quantity): ...\n</code></pre>"},{"location":"API/particula/util/input_handling/#in_latent_heat","title":"in_latent_heat","text":"<p>Show source in input_handling.py:137</p>"},{"location":"API/particula/util/input_handling/#signature_7","title":"Signature","text":"<pre><code>def in_latent_heat(latheat): ...\n</code></pre>"},{"location":"API/particula/util/input_handling/#in_length","title":"in_length","text":"<p>Show source in input_handling.py:132</p>"},{"location":"API/particula/util/input_handling/#signature_8","title":"Signature","text":"<pre><code>def in_length(length): ...\n</code></pre>"},{"location":"API/particula/util/input_handling/#in_mass","title":"in_mass","text":"<p>Show source in input_handling.py:124</p>"},{"location":"API/particula/util/input_handling/#signature_9","title":"Signature","text":"<pre><code>def in_mass(mass): ...\n</code></pre>"},{"location":"API/particula/util/input_handling/#in_molecular_weight","title":"in_molecular_weight","text":"<p>Show source in input_handling.py:129</p>"},{"location":"API/particula/util/input_handling/#signature_10","title":"Signature","text":"<pre><code>def in_molecular_weight(molw): ...\n</code></pre>"},{"location":"API/particula/util/input_handling/#in_pressure","title":"in_pressure","text":"<p>Show source in input_handling.py:123</p>"},{"location":"API/particula/util/input_handling/#signature_11","title":"Signature","text":"<pre><code>def in_pressure(pres): ...\n</code></pre>"},{"location":"API/particula/util/input_handling/#in_radius","title":"in_radius","text":"<p>Show source in input_handling.py:8</p> <p>Handles radius input</p>"},{"location":"API/particula/util/input_handling/#arguments_2","title":"Arguments","text":"<p>radius    (float) [m | dimensionless]</p>"},{"location":"API/particula/util/input_handling/#returns_2","title":"Returns","text":"<p>radius    (float) [m]</p>"},{"location":"API/particula/util/input_handling/#notes_2","title":"Notes","text":"<ul> <li>If unit is correct, take to base units in m</li> <li>Throws ValueError if unit is wrong</li> <li>Assigning m units to scalar input</li> </ul>"},{"location":"API/particula/util/input_handling/#signature_12","title":"Signature","text":"<pre><code>def in_radius(radius): ...\n</code></pre>"},{"location":"API/particula/util/input_handling/#in_scalar","title":"in_scalar","text":"<p>Show source in input_handling.py:131</p>"},{"location":"API/particula/util/input_handling/#signature_13","title":"Signature","text":"<pre><code>def in_scalar(scalar): ...\n</code></pre>"},{"location":"API/particula/util/input_handling/#in_surface_tension","title":"in_surface_tension","text":"<p>Show source in input_handling.py:136</p>"},{"location":"API/particula/util/input_handling/#signature_14","title":"Signature","text":"<pre><code>def in_surface_tension(surften): ...\n</code></pre>"},{"location":"API/particula/util/input_handling/#in_temperature","title":"in_temperature","text":"<p>Show source in input_handling.py:121</p>"},{"location":"API/particula/util/input_handling/#signature_15","title":"Signature","text":"<pre><code>def in_temperature(temp): ...\n</code></pre>"},{"location":"API/particula/util/input_handling/#in_time","title":"in_time","text":"<p>Show source in input_handling.py:126</p>"},{"location":"API/particula/util/input_handling/#signature_16","title":"Signature","text":"<pre><code>def in_time(time): ...\n</code></pre>"},{"location":"API/particula/util/input_handling/#in_velocity","title":"in_velocity","text":"<p>Show source in input_handling.py:127</p>"},{"location":"API/particula/util/input_handling/#signature_17","title":"Signature","text":"<pre><code>def in_velocity(vel): ...\n</code></pre>"},{"location":"API/particula/util/input_handling/#in_viscosity","title":"in_viscosity","text":"<p>Show source in input_handling.py:122</p>"},{"location":"API/particula/util/input_handling/#signature_18","title":"Signature","text":"<pre><code>def in_viscosity(vis): ...\n</code></pre>"},{"location":"API/particula/util/input_handling/#in_volume","title":"in_volume","text":"<p>Show source in input_handling.py:125</p>"},{"location":"API/particula/util/input_handling/#signature_19","title":"Signature","text":"<pre><code>def in_volume(vol): ...\n</code></pre>"},{"location":"API/particula/util/kelvin_correction/","title":"Kelvin Correction","text":"<p>Particula Index / Particula / Util / Kelvin Correction</p> <p>Auto-generated documentation for particula.util.kelvin_correction module.</p>"},{"location":"API/particula/util/kelvin_correction/#kelvin_radius","title":"kelvin_radius","text":"<p>Show source in kelvin_correction.py:11</p> <p>Kelvin radius (Neil's definition) https://en.wikipedia.org/wiki/Kelvin_equation</p>"},{"location":"API/particula/util/kelvin_correction/#signature","title":"Signature","text":"<pre><code>def kelvin_radius(\n    surface_tension=0.072 * u.N / u.m,\n    molecular_weight=0.01815 * u.kg / u.mol,\n    density=1000 * u.kg / u.m**3,\n    temperature=298.15 * u.K,\n): ...\n</code></pre>"},{"location":"API/particula/util/kelvin_correction/#kelvin_term","title":"kelvin_term","text":"<p>Show source in kelvin_correction.py:31</p> <p>Kelvin term (Neil's definition) https://en.wikipedia.org/wiki/Kelvin_equation</p>"},{"location":"API/particula/util/kelvin_correction/#signature_1","title":"Signature","text":"<pre><code>def kelvin_term(radius=None, **kwargs): ...\n</code></pre>"},{"location":"API/particula/util/knudsen_number/","title":"Knudsen Number","text":"<p>Particula Index / Particula / Util / Knudsen Number</p> <p>Auto-generated documentation for particula.util.knudsen_number module.</p>"},{"location":"API/particula/util/knudsen_number/#knu","title":"knu","text":"<p>Show source in knudsen_number.py:18</p> <p>Returns particle's Knudsen number.</p> <p>The Knudsen number reflects the relative length scales of the particle and the suspending fluid (air, water, etc.). This is calculated by the mean free path of the medium divided by the particle radius.</p> <p>The Knudsen number is a measure of continuum effects and deviation thereof. For larger particles, the Knudsen number goes towards 0. For smaller particles, the Knudsen number goes towards infinity.</p>"},{"location":"API/particula/util/knudsen_number/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from particula import u\n&gt;&gt;&gt; from particula.util.knudsen_number import knu\n&gt;&gt;&gt; # with radius 1e-9 m\n&gt;&gt;&gt; knu(radius=1e-9)\n&lt;Quantity(66.4798498, 'dimensionless')&gt;\n&gt;&gt;&gt; # with radius 1e-9 m and mfp 60 nm\n&gt;&gt;&gt; knu(radius=1e-9*u.m, mfp=60*u.nm).m\n60.00000000000001\n&gt;&gt;&gt; calculating via mfp(**kwargs)\n&gt;&gt;&gt; knu(\n... radius=1e-9*u.m,\n... temperature=300,\n... pressure=1e5,\n... molecular_weight=0.03,\n... )\n&lt;Quantity(66.7097062, 'dimensionless')&gt;\n</code></pre>"},{"location":"API/particula/util/knudsen_number/#arguments","title":"Arguments","text":"<p>radius  (float) [m] mfp     (float) [m] (default: util)</p>"},{"location":"API/particula/util/knudsen_number/#returns","title":"Returns","text":"<p>(float) [dimensionless]</p>"},{"location":"API/particula/util/knudsen_number/#notes","title":"Notes","text":"<p>mfp can be calculated using mfp(**kwargs); refer to particula.util.mean_free_path.mfp for more info.</p>"},{"location":"API/particula/util/knudsen_number/#signature","title":"Signature","text":"<pre><code>def knu(radius=None, mfp=None, **kwargs): ...\n</code></pre>"},{"location":"API/particula/util/machine_limit/","title":"Machine Limit","text":"<p>Particula Index / Particula / Util / Machine Limit</p> <p>Auto-generated documentation for particula.util.machine_limit module.</p>"},{"location":"API/particula/util/machine_limit/#safe_exp","title":"safe_exp","text":"<p>Show source in machine_limit.py:12</p> <p>Compute the exponential of each element in the input array, with limits to prevent overflow based on machine precision.</p>"},{"location":"API/particula/util/machine_limit/#arguments","title":"Arguments","text":"<ul> <li><code>value</code> ArrayLike - Input array.</li> </ul>"},{"location":"API/particula/util/machine_limit/#returns","title":"Returns","text":"<ul> <li><code>np.ndarray</code> - Exponential of the input array with overflow protection.</li> </ul>"},{"location":"API/particula/util/machine_limit/#signature","title":"Signature","text":"<pre><code>def safe_exp(value: ArrayLike) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/util/machine_limit/#safe_log","title":"safe_log","text":"<p>Show source in machine_limit.py:28</p> <p>Compute the natural logarithm of each element in the input array, with limits to prevent underflow based on machine precision.</p>"},{"location":"API/particula/util/machine_limit/#arguments_1","title":"Arguments","text":"<ul> <li><code>value</code> ArrayLike - Input array.</li> </ul>"},{"location":"API/particula/util/machine_limit/#returns_1","title":"Returns","text":"<ul> <li><code>np.ndarray</code> - Natural logarithm of the input array with underflow protection.</li> </ul>"},{"location":"API/particula/util/machine_limit/#signature_1","title":"Signature","text":"<pre><code>def safe_log(value: ArrayLike) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/util/machine_limit/#safe_log10","title":"safe_log10","text":"<p>Show source in machine_limit.py:45</p> <p>Compute the base 10 logarithm of each element in the input array, with limits to prevent underflow based on machine precision.</p>"},{"location":"API/particula/util/machine_limit/#arguments_2","title":"Arguments","text":"<ul> <li><code>value</code> ArrayLike - Input array.</li> </ul>"},{"location":"API/particula/util/machine_limit/#returns_2","title":"Returns","text":"<ul> <li><code>np.ndarray</code> - Base 10 logarithm of the input array with underflow protection.</li> </ul>"},{"location":"API/particula/util/machine_limit/#signature_2","title":"Signature","text":"<pre><code>def safe_log10(value: ArrayLike) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/util/mean_free_path/","title":"Mean Free Path","text":"<p>Particula Index / Particula / Util / Mean Free Path</p> <p>Auto-generated documentation for particula.util.mean_free_path module.</p>"},{"location":"API/particula/util/mean_free_path/#mfp","title":"mfp","text":"<p>Show source in mean_free_path.py:22</p> <p>Returns the mean free path of in air.</p> <p>The mean free path is the average distance traveled by a molecule between collisions with other molecules present in a medium (air).</p> <p>The expeected mean free path of air is approx. 65 nm at 298 K and 101325 Pa.</p>"},{"location":"API/particula/util/mean_free_path/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from particula import u\n&gt;&gt;&gt; from particula.util.mean_free_path import mfp\n&gt;&gt;&gt; # with no inputs, it defaults to 298 K and 101325 Pa\n&gt;&gt;&gt; mfp()\n&lt;Quantity(6.64373669e-08, 'meter')&gt;\n&gt;&gt;&gt; # specifying a temperature of 300 K\n&gt;&gt;&gt; mfp(temperature=300*u.K).magnitude\n6.700400687925813e-08\n&gt;&gt;&gt; # specifying 300 K and  pressure of 1e5 Pa\n&gt;&gt;&gt; mfp(temperature=300*u.K, pressure=1e5*u.Pa)\n&lt;Quantity(6.789181e-08, 'meter')&gt;\n&gt;&gt;&gt; mfp(\n... temperature=300,\n... pressure=1e5,\n... molecular_weight=0.03\n... )\n&lt;Quantity(6.67097062e-08, 'meter')&gt;\n&gt;&gt;&gt; # specifying explicit value for dynamic viscosity\n&gt;&gt;&gt; mfp(dynamic_viscosity=1e-5)\n&lt;Quantity(3.61864151e-08, 'meter')&gt;\n&gt;&gt;&gt; # specifying implicit value for dynamic viscosity\n&gt;&gt;&gt; mfp(\n... temperature=300,\n... reference_viscosity=1e-5,\n... reference_temperature=273.15\n... )\n&lt;Quantity(3.90466241e-08, 'meter')&gt;\n&gt;&gt;&gt; # specifying a list of temperatures\n&gt;&gt;&gt; mfp(temperature=[200, 250, 300, 400]).m\narray([3.93734886e-08, 5.29859655e-08, 6.70040069e-08, 9.57800224e-08])\n&gt;&gt;&gt; # specifying a list of pressures\n&gt;&gt;&gt; mfp(pressure=[1.0e5, 1.1e5, 1.2e5, 1.3e5]).m\narray([6.73607078e-08, 6.12370071e-08, 5.61339232e-08, 5.18159291e-08])\n&gt;&gt;&gt; # specifying a list of pressures and temperatures\n&gt;&gt;&gt; mfp(temperature=[300,310], pressure=[1e5, 1.1e5])\n&lt;Quantity([6.78918100e-08 6.43354325e-08], 'meter')&gt;\n</code></pre> <ul> <li><code>Args</code> - (either # or $)     temperature           (float) [K]      (default: 298)     pressure              (float) [Pa]     (default: 101325)     molecular_weight      (float) [kg/mol] (default: constants)</li> </ul>"},{"location":"API/particula/util/mean_free_path/#dynamic_viscosity-float-pas-default-util","title":"dynamic_viscosity     (float) [Pa*s]   (default: util)","text":"<p>$   reference_viscosity   (float) [Pa*s]   (default: constants) $   reference_temperature (float) [K]      (default: constants)</p>"},{"location":"API/particula/util/mean_free_path/#returns","title":"Returns","text":"<p>(float) [m]</p> <p>Using particula.constants:     GAS_CONSTANT            (float) [J/mol/K]     MOLECULAR_WEIGHT_AIR    (float) [kg/mol]</p> <p>REF_VISCOSITY_AIR_STP   (float) [Pa*s] REF_TEMPERATURE_STP     (float) [K] SUTHERLAND_CONSTANT     (float) [K]</p>"},{"location":"API/particula/util/mean_free_path/#notes","title":"Notes","text":"<p>dynamic_viscosity can be calculated independently via particula.util.dynamic_viscosity.dyn_vis(**kwargs), but if the value of dynamic_viscosity is provided directly, it overrides the calculated value.</p>"},{"location":"API/particula/util/mean_free_path/#signature","title":"Signature","text":"<pre><code>def mfp(\n    temperature=298.15 * u.K,\n    pressure=101325 * u.Pa,\n    molecular_weight=MOLECULAR_WEIGHT_AIR,\n    dynamic_viscosity=None,\n    gas_constant=GAS_CONSTANT,\n    **kwargs\n): ...\n</code></pre>"},{"location":"API/particula/util/mean_free_path/#see-also","title":"See also","text":"<ul> <li>GAS_CONSTANT</li> <li>MOLECULAR_WEIGHT_AIR</li> </ul>"},{"location":"API/particula/util/molecular_enhancement/","title":"Molecular Enhancement","text":"<p>Particula Index / Particula / Util / Molecular Enhancement</p> <p>Auto-generated documentation for particula.util.molecular_enhancement module.</p>"},{"location":"API/particula/util/molecular_enhancement/#mol_enh","title":"mol_enh","text":"<p>Show source in molecular_enhancement.py:12</p> <p>Returns the molecular enhancement.</p>"},{"location":"API/particula/util/molecular_enhancement/#arguments","title":"Arguments","text":"<p>vapor_size      (float)  [m] particle_size   (float)  [m]</p>"},{"location":"API/particula/util/molecular_enhancement/#returns","title":"Returns","text":"<p>(float)  [ ]</p> <p>TODO:     - Add explanation of molecular enhancement.</p>"},{"location":"API/particula/util/molecular_enhancement/#signature","title":"Signature","text":"<pre><code>def mol_enh(vapor_size, particle_size): ...\n</code></pre>"},{"location":"API/particula/util/particle_mass/","title":"Particle Mass","text":"<p>Particula Index / Particula / Util / Particle Mass</p> <p>Auto-generated documentation for particula.util.particle_mass module.</p>"},{"location":"API/particula/util/particle_mass/#mass","title":"mass","text":"<p>Show source in particle_mass.py:8</p> <p>Returns particle's mass: 4/3 pi r^3 * density.</p>"},{"location":"API/particula/util/particle_mass/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; particle_mass(1*u.m)\n&lt;Quantity(4188.7902, 'kilogram')&gt;\n&gt;&gt;&gt; particle_mass(1*u.nm, 1000*u.kg/u.m**3).m\n4.188790204786392e-24\n&gt;&gt;&gt; particle_mass(1*u.nm, 1000*u.kg/u.m**3).m_as(u.g)\n4.188790204786392e-21\n&gt;&gt;&gt; particle_mass([1, 2, 3]*u.nm, 1000*u.kg/u.m**3).m\narray([4.18879020e-24, 3.35103216e-23, 1.13097336e-22])\n&gt;&gt;&gt; particle_mass([1, 2]*u.nm, [1, 2]*u.g/u.cm**3).m\narray([4.18879020e-24, 6.70206433e-23])\n&gt;&gt;&gt; particle_mass(2*u.nm, 2*u.g/u.cm**3).m\n6.702064327658225e-23\n</code></pre>"},{"location":"API/particula/util/particle_mass/#arguments","title":"Arguments","text":"<p>radius       (float) [m] density      (float) [kg/m^3] (default: 1000) shape_factor (float) [ ]      (default: 1) volume_void  (float) [ ]      (default: 0)</p>"},{"location":"API/particula/util/particle_mass/#returns","title":"Returns","text":"<p>(float) [kg]</p>"},{"location":"API/particula/util/particle_mass/#signature","title":"Signature","text":"<pre><code>def mass(radius=None, density=1000, shape_factor=1, volume_void=0, **kwargs): ...\n</code></pre>"},{"location":"API/particula/util/particle_surface/","title":"Particle Surface","text":"<p>Particula Index / Particula / Util / Particle Surface</p> <p>Auto-generated documentation for particula.util.particle_surface module.</p>"},{"location":"API/particula/util/particle_surface/#area","title":"area","text":"<p>Show source in particle_surface.py:8</p> <p>Returns particle's surface area: 4 pi r^2 .</p>"},{"location":"API/particula/util/particle_surface/#arguments","title":"Arguments","text":"<p>radius       (float) [m] area_factor  (float) [ ]      (default: 1)</p>"},{"location":"API/particula/util/particle_surface/#returns","title":"Returns","text":"<p>(float) [m^2]</p>"},{"location":"API/particula/util/particle_surface/#signature","title":"Signature","text":"<pre><code>def area(radius=None, area_factor=1): ...\n</code></pre>"},{"location":"API/particula/util/radius_cutoff/","title":"Radius Cutoff","text":"<p>Particula Index / Particula / Util / Radius Cutoff</p> <p>Auto-generated documentation for particula.util.radius_cutoff module.</p>"},{"location":"API/particula/util/radius_cutoff/#cut_rad","title":"cut_rad","text":"<p>Show source in radius_cutoff.py:11</p> <p>This routine determins the radius cutoff for the particle distribution</p> <p>Inputs:     cutoff  (float) coverage cutoff (default: .9999)     gsigma  (float) geometric standard deviation (default: 1.25)     mode    (float) mean radius of the particles (default: 1e-7)</p>"},{"location":"API/particula/util/radius_cutoff/#returns","title":"Returns","text":"<p>(starting radius, ending radius) float tuple</p>"},{"location":"API/particula/util/radius_cutoff/#signature","title":"Signature","text":"<pre><code>def cut_rad(\n    cutoff=in_scalar(0.9999).m,\n    gsigma=in_scalar(1.25).m,\n    mode=in_radius(1e-07),\n    force_radius_start=None,\n    force_radius_end=None,\n    **kwargs\n): ...\n</code></pre>"},{"location":"API/particula/util/reduced_quantity/","title":"Reduced Quantity","text":"<p>Particula Index / Particula / Util / Reduced Quantity</p> <p>Auto-generated documentation for particula.util.reduced_quantity module.</p>"},{"location":"API/particula/util/reduced_quantity/#reduced_quantity","title":"reduced_quantity","text":"<p>Show source in reduced_quantity.py:17</p> <p>Returns the reduced mass of two particles.</p>"},{"location":"API/particula/util/reduced_quantity/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; reduced_quantity(1*u.kg, 1*u.kg)\n&lt;Quantity(0.5, 'kilogram')&gt;\n&gt;&gt;&gt; reduced_quantity(1*u.kg, 20*u.kg).m\n0.9523809523809523\n&gt;&gt;&gt; reduced_quantity(1, 200)\n0.9950248756218906\n&gt;&gt;&gt; reduced_quantity([1, 2, 3], 200)\narray([0.99502488, 1.98019802, 2.95566502])\n&gt;&gt;&gt; reduced_quantity([1, 2], [200, 300])\narray([0.99502488, 1.98675497])\n</code></pre>"},{"location":"API/particula/util/reduced_quantity/#arguments","title":"Arguments","text":"<p>a_quantity  (float)  [arbitrary units] b_quantity  (float)  [arbitrary units]</p>"},{"location":"API/particula/util/reduced_quantity/#returns","title":"Returns","text":"<p>(float)  [arbitrary units]</p> <p>A reduced quantity is an \"effective inertial\" quantity, allowing two-body problems to be solved as one-body problems.</p>"},{"location":"API/particula/util/reduced_quantity/#signature","title":"Signature","text":"<pre><code>def reduced_quantity(a_quantity, b_quantity): ...\n</code></pre>"},{"location":"API/particula/util/reduced_quantity/#reduced_self_broadcast","title":"reduced_self_broadcast","text":"<p>Show source in reduced_quantity.py:128</p> <p>Returns the reduced value of an array with itself, broadcasting the array into a matrix and calculating the reduced value of each element pair. reduced_value = alpha_matrix * alpha_matrix_Transpose                 / (alpha_matrix + alpha_matrix_Transpose)</p>"},{"location":"API/particula/util/reduced_quantity/#arguments_1","title":"Arguments","text":"<ul> <li><code>-</code> alpha_array - The array to be broadcast and reduced.</li> </ul>"},{"location":"API/particula/util/reduced_quantity/#returns_1","title":"Returns","text":"<ul> <li>A square matrix of the reduced values.</li> </ul>"},{"location":"API/particula/util/reduced_quantity/#signature_1","title":"Signature","text":"<pre><code>def reduced_self_broadcast(alpha_array: NDArray[np.float64]) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/util/reduced_quantity/#reduced_value","title":"reduced_value","text":"<p>Show source in reduced_quantity.py:89</p> <p>Returns the reduced value of two parameters, calculated as: reduced_value = alpha * beta / (alpha + beta)</p> <p>This formula calculates an \"effective inertial\" quantity, allowing two-body problems to be solved as if they were one-body problems.</p>"},{"location":"API/particula/util/reduced_quantity/#arguments_2","title":"Arguments","text":"<ul> <li><code>-</code> alpha - The first parameter (scalar or array).</li> <li><code>-</code> beta - The second parameter (scalar or array).</li> </ul>"},{"location":"API/particula/util/reduced_quantity/#returns_2","title":"Returns","text":"<ul> <li>A value or array of the same dimension as the input parameters. Returns   zero where alpha + beta equals zero to handle division by zero   gracefully.</li> </ul>"},{"location":"API/particula/util/reduced_quantity/#raises","title":"Raises","text":"<ul> <li><code>-</code> ValueError - If alpha and beta are arrays and their shapes do not match.</li> </ul>"},{"location":"API/particula/util/reduced_quantity/#signature_2","title":"Signature","text":"<pre><code>def reduced_value(\n    alpha: Union[float, NDArray[np.float64]], beta: Union[float, NDArray[np.float64]]\n) -&gt; Union[float, NDArray[np.float64]]: ...\n</code></pre>"},{"location":"API/particula/util/rms_speed/","title":"Rms Speed","text":"<p>Particula Index / Particula / Util / Rms Speed</p> <p>Auto-generated documentation for particula.util.rms_speed module.</p>"},{"location":"API/particula/util/rms_speed/#cbar","title":"cbar","text":"<p>Show source in rms_speed.py:10</p> <p>Returns the mean speed of molecules in an ideal gas.</p>"},{"location":"API/particula/util/rms_speed/#arguments","title":"Arguments","text":"<p>temperature           (float) [K]      (default: 298.15) molecular_weight      (float) [kg/mol] (default: constants)</p>"},{"location":"API/particula/util/rms_speed/#returns","title":"Returns","text":"<p>(float) [m/s]</p> <p>Using particula.constants:     GAS_CONSTANT            (float) [J/mol/K]     MOLECULAR_WEIGHT_AIR    (float) [kg/mol]</p>"},{"location":"API/particula/util/rms_speed/#signature","title":"Signature","text":"<pre><code>def cbar(\n    temperature=298.15, molecular_weight=MOLECULAR_WEIGHT_AIR, gas_constant=GAS_CONSTANT\n): ...\n</code></pre>"},{"location":"API/particula/util/rms_speed/#see-also","title":"See also","text":"<ul> <li>GAS_CONSTANT</li> <li>MOLECULAR_WEIGHT_AIR</li> </ul>"},{"location":"API/particula/util/settling_velocity/","title":"Settling Velocity","text":"<p>Particula Index / Particula / Util / Settling Velocity</p> <p>Auto-generated documentation for particula.util.settling_velocity module.</p>"},{"location":"API/particula/util/settling_velocity/#psv","title":"psv","text":"<p>Show source in settling_velocity.py:8</p> <p>calculate the settling velocity</p>"},{"location":"API/particula/util/settling_velocity/#signature","title":"Signature","text":"<pre><code>def psv(\n    rad=None, den=None, scf_val=None, sgc=STANDARD_GRAVITY, vis_val=None, **kwargs\n): ...\n</code></pre>"},{"location":"API/particula/util/settling_velocity/#see-also","title":"See also","text":"<ul> <li>STANDARD_GRAVITY</li> </ul>"},{"location":"API/particula/util/simple_solver/","title":"SimpleSolver","text":"<p>Particula Index / Particula / Util / SimpleSolver</p> <p>Auto-generated documentation for particula.util.simple_solver module.</p>"},{"location":"API/particula/util/simple_solver/#simplesolver_1","title":"SimpleSolver","text":"<p>Show source in simple_solver.py:33</p> <p>a class to solve the ODE:</p> <p>Need: 1. initial distribution 2. associated radius 3. associated coagulation kernel</p> <p>Also: 1. desired time span in seconds (given unitless)</p>"},{"location":"API/particula/util/simple_solver/#signature","title":"Signature","text":"<pre><code>class SimpleSolver:\n    def __init__(self, **kwargs): ...\n</code></pre>"},{"location":"API/particula/util/simple_solver/#simplesolverprep_inputs","title":"SimpleSolver().prep_inputs","text":"<p>Show source in simple_solver.py:66</p> <p>strip units, etc.</p>"},{"location":"API/particula/util/simple_solver/#signature_1","title":"Signature","text":"<pre><code>def prep_inputs(self): ...\n</code></pre>"},{"location":"API/particula/util/simple_solver/#simplesolversolution","title":"SimpleSolver().solution","text":"<p>Show source in simple_solver.py:77</p> <p>utilize scipy.integrate.odeint</p>"},{"location":"API/particula/util/simple_solver/#signature_2","title":"Signature","text":"<pre><code>def solution(self): ...\n</code></pre>"},{"location":"API/particula/util/simple_solver/#ode_func","title":"ode_func","text":"<p>Show source in simple_solver.py:21</p> <p>function to integrate</p>"},{"location":"API/particula/util/simple_solver/#signature_3","title":"Signature","text":"<pre><code>def ode_func(_nums, _, _rads, _coag): ...\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/","title":"Size Distribution Convert","text":"<p>Particula Index / Particula / Util / Size Distribution Convert</p> <p>Auto-generated documentation for particula.util.size_distribution_convert module.</p>"},{"location":"API/particula/util/size_distribution_convert/#conversionstrategy","title":"ConversionStrategy","text":"<p>Show source in size_distribution_convert.py:23</p> <p>Defines an interface for conversion strategies between particle size distribution formats.</p> <p>Subclasses must implement the convert method to perform specific conversion logic.</p>"},{"location":"API/particula/util/size_distribution_convert/#signature","title":"Signature","text":"<pre><code>class ConversionStrategy: ...\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/#conversionstrategyconvert","title":"ConversionStrategy().convert","text":"<p>Show source in size_distribution_convert.py:31</p> <p>Converter method common interface, for subclasses.</p>"},{"location":"API/particula/util/size_distribution_convert/#arguments","title":"Arguments","text":"<ul> <li><code>diameters</code> np.ndarray - The particle diameters.</li> <li><code>concentration</code> np.ndarray - The concentration values.</li> <li><code>inverse</code> bool - Flag to perform the inverse conversion.</li> </ul>"},{"location":"API/particula/util/size_distribution_convert/#returns","title":"Returns","text":"<ul> <li><code>np.ndarray</code> - The concentration values converted.</li> </ul>"},{"location":"API/particula/util/size_distribution_convert/#raises","title":"Raises","text":"<ul> <li><code>NotImplementedError</code> - If the subclass does not implement this.</li> </ul>"},{"location":"API/particula/util/size_distribution_convert/#signature_1","title":"Signature","text":"<pre><code>def convert(\n    self, diameters: np.ndarray, concentration: np.ndarray, inverse: bool = False\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/#dndlogdptopdfconversionstrategy","title":"DNdlogDPtoPDFConversionStrategy","text":"<p>Show source in size_distribution_convert.py:83</p> <p>Implements conversion between dn/dlogdp and PDF formats through an intermediate PMS format.</p>"},{"location":"API/particula/util/size_distribution_convert/#signature_2","title":"Signature","text":"<pre><code>class DNdlogDPtoPDFConversionStrategy(ConversionStrategy): ...\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/#see-also","title":"See also","text":"<ul> <li>ConversionStrategy</li> </ul>"},{"location":"API/particula/util/size_distribution_convert/#dndlogdptopdfconversionstrategyconvert","title":"DNdlogDPtoPDFConversionStrategy().convert","text":"<p>Show source in size_distribution_convert.py:87</p>"},{"location":"API/particula/util/size_distribution_convert/#signature_3","title":"Signature","text":"<pre><code>def convert(\n    self, diameters: np.ndarray, concentration: np.ndarray, inverse: bool = False\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/#dndlogdptopmsconversionstrategy","title":"DNdlogDPtoPMSConversionStrategy","text":"<p>Show source in size_distribution_convert.py:61</p> <p>Implements conversion between dn/dlogdp and PMS formats using the convert_sizer_dn method.</p>"},{"location":"API/particula/util/size_distribution_convert/#signature_4","title":"Signature","text":"<pre><code>class DNdlogDPtoPMSConversionStrategy(ConversionStrategy): ...\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/#see-also_1","title":"See also","text":"<ul> <li>ConversionStrategy</li> </ul>"},{"location":"API/particula/util/size_distribution_convert/#dndlogdptopmsconversionstrategyconvert","title":"DNdlogDPtoPMSConversionStrategy().convert","text":"<p>Show source in size_distribution_convert.py:65</p>"},{"location":"API/particula/util/size_distribution_convert/#signature_5","title":"Signature","text":"<pre><code>def convert(\n    self, diameters: np.ndarray, concentration: np.ndarray, inverse: bool = False\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/#pmstopdfconversionstrategy","title":"PMStoPDFConversionStrategy","text":"<p>Show source in size_distribution_convert.py:73</p> <p>Implements conversion between PMS and PDF formats.</p>"},{"location":"API/particula/util/size_distribution_convert/#signature_6","title":"Signature","text":"<pre><code>class PMStoPDFConversionStrategy(ConversionStrategy): ...\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/#see-also_2","title":"See also","text":"<ul> <li>ConversionStrategy</li> </ul>"},{"location":"API/particula/util/size_distribution_convert/#pmstopdfconversionstrategyconvert","title":"PMStoPDFConversionStrategy().convert","text":"<p>Show source in size_distribution_convert.py:76</p>"},{"location":"API/particula/util/size_distribution_convert/#signature_7","title":"Signature","text":"<pre><code>def convert(\n    self, diameters: np.ndarray, concentration: np.ndarray, inverse: bool = False\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/#samescaleconversionstrategy","title":"SameScaleConversionStrategy","text":"<p>Show source in size_distribution_convert.py:52</p> <p>Implements conversion between the same scales, which is a no-op.</p>"},{"location":"API/particula/util/size_distribution_convert/#signature_8","title":"Signature","text":"<pre><code>class SameScaleConversionStrategy(ConversionStrategy): ...\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/#see-also_3","title":"See also","text":"<ul> <li>ConversionStrategy</li> </ul>"},{"location":"API/particula/util/size_distribution_convert/#samescaleconversionstrategyconvert","title":"SameScaleConversionStrategy().convert","text":"<p>Show source in size_distribution_convert.py:55</p>"},{"location":"API/particula/util/size_distribution_convert/#signature_9","title":"Signature","text":"<pre><code>def convert(\n    self, diameters: np.ndarray, concentration: np.ndarray, inverse: bool = False\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/#sizerconverter","title":"SizerConverter","text":"<p>Show source in size_distribution_convert.py:102</p> <p>A converter that uses a specified ConversionStrategy to convert particle size distribution data between different formats.</p>"},{"location":"API/particula/util/size_distribution_convert/#signature_10","title":"Signature","text":"<pre><code>class SizerConverter:\n    def __init__(self, strategy: ConversionStrategy): ...\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/#see-also_4","title":"See also","text":"<ul> <li>ConversionStrategy</li> </ul>"},{"location":"API/particula/util/size_distribution_convert/#sizerconverterconvert","title":"SizerConverter().convert","text":"<p>Show source in size_distribution_convert.py:114</p> <p>Converts particle size distribution data using the specified strategy.</p>"},{"location":"API/particula/util/size_distribution_convert/#arguments_1","title":"Arguments","text":"<ul> <li><code>diameters</code> np.ndarray - The particle diameters.</li> <li><code>concentration</code> np.ndarray - The concentration values.</li> <li><code>inverse</code> bool - Flag to perform the inverse conversion.</li> </ul>"},{"location":"API/particula/util/size_distribution_convert/#returns_1","title":"Returns","text":"<ul> <li><code>np.ndarray</code> - The converted concentration values.</li> </ul>"},{"location":"API/particula/util/size_distribution_convert/#signature_11","title":"Signature","text":"<pre><code>def convert(\n    self, diameters: np.ndarray, concentration: np.ndarray, inverse: bool = False\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/#get_conversion_strategy","title":"get_conversion_strategy","text":"<p>Show source in size_distribution_convert.py:130</p> <p>Factory function to create and return an appropriate conversion strategy based on input and output scales. Use the inverse flag in the converter to invert the directions of the input and output scales.</p>"},{"location":"API/particula/util/size_distribution_convert/#arguments_2","title":"Arguments","text":"<ul> <li><code>input_scale</code> - The scale of the input concentration values.     Either 'dn/dlogdp' or 'pms'.</li> <li><code>output_scale</code> - The desired scale of the output concentration     values. Either 'pms' or 'pdf'. Use inverse flag to invert the input     and output scales.</li> </ul>"},{"location":"API/particula/util/size_distribution_convert/#returns_2","title":"Returns","text":"<ul> <li>ConversionStrategy - A strategy object capable of converting between     the specified scales.</li> </ul>"},{"location":"API/particula/util/size_distribution_convert/#raises_1","title":"Raises","text":"<ul> <li><code>ValueError</code> - If the input_scale or output_scale is not supported, or     if the specified conversion is unsupported.</li> </ul>"},{"location":"API/particula/util/size_distribution_convert/#examples","title":"Examples","text":"Convert dn/dlogdp to PMS<pre><code>strategy = get_conversion_strategy('dn/dlogdp', 'pms')\nconverter = Converter(strategy)\nconverted_concentration = converter.convert(\n    diameters, concentration, inverse=False)\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/#signature_12","title":"Signature","text":"<pre><code>def get_conversion_strategy(\n    input_scale: str, output_scale: str\n) -&gt; ConversionStrategy: ...\n</code></pre>"},{"location":"API/particula/util/size_distribution_convert/#see-also_5","title":"See also","text":"<ul> <li>ConversionStrategy</li> </ul>"},{"location":"API/particula/util/slip_correction/","title":"Slip Correction","text":"<p>Particula Index / Particula / Util / Slip Correction</p> <p>Auto-generated documentation for particula.util.slip_correction module.</p>"},{"location":"API/particula/util/slip_correction/#scf","title":"scf","text":"<p>Show source in slip_correction.py:9</p> <p>Returns particle's Cunningham slip correction factor.</p> <p>Dimensionless quantity accounting for non-continuum effects on small particles. It is a deviation from Stokes' Law. Stokes assumes a no-slip condition that is not correct at high Knudsen numbers. The slip correction factor is used to calculate the friction factor.</p> <p>Thus, the slip correction factor is about unity (1) for larger particles (Kn -&gt; 0). Its behavior on the other end of the spectrum (smaller particles; Kn -&gt; inf) is more nuanced, though it tends to scale linearly on a log-log scale, log Cc vs log Kn.</p>"},{"location":"API/particula/util/slip_correction/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from particula import u\n&gt;&gt;&gt; from particula.util.slip_correction import scf\n&gt;&gt;&gt; # with radius 1e-9 m\n&gt;&gt;&gt; scf(radius=1e-9)\n&lt;Quantity(110.720731, 'dimensionless')&gt;\n&gt;&gt;&gt; # with radius 1e-9 m and knu=1\n&gt;&gt;&gt; scf(radius=1e-9*u.m, knu=1)\n&lt;Quantity(2.39014843, 'dimensionless')&gt;\n&gt;&gt;&gt; # using knu(**kwargs)\n&gt;&gt;&gt; scf(radius=1e-9*u.m, mfp=60*u.nm)\n&lt;Quantity(99.9840088, 'dimensionless')&gt;\n&gt;&gt;&gt; # using mfp(**kwargs)\n&gt;&gt;&gt; scf(\n... radius=1e-9*u.m,\n... temperature=300,\n... pressure=1e5,\n... molecular_weight=0.03\n... )\n&lt;Quantity(111.101591, 'dimensionless')&gt;\n</code></pre>"},{"location":"API/particula/util/slip_correction/#arguments","title":"Arguments","text":"<p>radius  (float) [m] knu     (float) [ ] (default: util)</p>"},{"location":"API/particula/util/slip_correction/#returns","title":"Returns","text":"<p>(float) [dimensionless]</p>"},{"location":"API/particula/util/slip_correction/#notes","title":"Notes","text":"<p>knu can be calculated using knu(**kwargs); refer to particula.util.knudsen_number.knu for more info.</p>"},{"location":"API/particula/util/slip_correction/#signature","title":"Signature","text":"<pre><code>def scf(radius=None, knu=None, **kwargs): ...\n</code></pre>"},{"location":"API/particula/util/species_properties/","title":"Species Properties","text":"<p>Particula Index / Particula / Util / Species Properties</p> <p>Auto-generated documentation for particula.util.species_properties module.</p>"},{"location":"API/particula/util/species_properties/#attributes","title":"Attributes","text":"<ul> <li><code>species_properties</code> - maybe this should be loaded from a file, or for an option of the user to   add their own species or load files with species properties: {'generic': {'molecular_weight': 200.0 * u.g / u.mol, 'surface_tension': 0.072 * u.N / u.m, 'density': 1000.0 * u.kg / u.m ** 3, 'vapor_radius': 1e-14 * u.Pa, 'vapor_attachment': 1.0 * u.dimensionless, 'saturation_pressure': 1.0 * u.Pa, 'latent_heat': 1.0 * u.J / u.g, 'heat_vaporization': 1.0 * u.J / u.kg, 'kappa': 0.2 * u.dimensionless}, 'water': {'molecular_weight': 18.01528 * u.g / u.mol, 'surface_tension': 0.072 * u.N / u.m, 'density': 1000.0 * u.kg / u.m ** 3, 'vapor_radius': 1.6e-09 * u.m, 'vapor_attachment': 1.0 * u.dimensionless, 'saturation_pressure': water_buck_psat, 'latent_heat': lambda T,: 2500.8 - 2.36 * T.m_as('degC') + 0.0016 * T.m_as('degC') ** 2 - 6e-05 * T.m_as('degC') ** 3 * u.J / u.g, 'heat_vaporization': 2257000.0 * u.J / u.kg, 'kappa': 0.2 * u.dimensionless}, 'ammonium sulfate': {'molecular_weight': 132.14 * u.g / u.mol, 'surface_tension': 0.072 * u.N / u.m, 'density': 1770.0 * u.kg / u.m ** 3, 'vapor_radius': 1.6e-09 * u.m, 'vapor_attachment': 1.0 * u.dimensionless, 'saturation_pressure': 1e-14 * u.Pa, 'latent_heat': 0.0 * u.J / u.g, 'heat_vaporization': 0.0 * u.J / u.kg, 'kappa': 0.53 * u.dimensionless}}</li> </ul>"},{"location":"API/particula/util/species_properties/#materialproperties","title":"MaterialProperties","text":"<p>Show source in species_properties.py:17</p>"},{"location":"API/particula/util/species_properties/#signature","title":"Signature","text":"<pre><code>class MaterialProperties:\n    def __init__(self, species_properties): ...\n</code></pre>"},{"location":"API/particula/util/species_properties/#materialpropertieslatent_heat","title":"MaterialProperties().latent_heat","text":"<p>Show source in species_properties.py:34</p>"},{"location":"API/particula/util/species_properties/#signature_1","title":"Signature","text":"<pre><code>def latent_heat(self, temperature, species): ...\n</code></pre>"},{"location":"API/particula/util/species_properties/#materialpropertiessaturation_pressure","title":"MaterialProperties().saturation_pressure","text":"<p>Show source in species_properties.py:24</p>"},{"location":"API/particula/util/species_properties/#signature_2","title":"Signature","text":"<pre><code>def saturation_pressure(self, temperature, species): ...\n</code></pre>"},{"location":"API/particula/util/species_properties/#clausius_clapeyron","title":"clausius_clapeyron","text":"<p>Show source in species_properties.py:63</p> <p>Calculates the vapor pressure of a substance at a given temperature using the Clausius-Clapeyron equation.</p>"},{"location":"API/particula/util/species_properties/#args","title":"Args","text":"<pre><code>temperature (float): Temperature reference in Kelvin\nvapor_pressure (float): Vapor pressure reference in Pa\ntemperature_new (float): Temperature new in Kelvin\nheat_vaporization (float): Heat of vaporization in J/kg\n</code></pre>"},{"location":"API/particula/util/species_properties/#returns","title":"Returns","text":"<pre><code>vapor_pressure_new: Vapor pressure in Pa\n</code></pre>"},{"location":"API/particula/util/species_properties/#signature_3","title":"Signature","text":"<pre><code>def clausius_clapeyron(\n    temperature, vapor_pressure, temperature_new, heat_vaporization\n): ...\n</code></pre>"},{"location":"API/particula/util/species_properties/#material_properties","title":"material_properties","text":"<p>Show source in species_properties.py:140</p> <p>Return the material properties for a given species.</p>"},{"location":"API/particula/util/species_properties/#args_1","title":"Args","text":"<p>property : str     Property to return. Options are: 'all', 'molecular_weight',     'surface_tension', 'density', 'vapor_radius', 'vapor_attachment',     'kappa'. species : str     Species for which to return the material properties. temperature : K     Temperature of the material.</p>"},{"location":"API/particula/util/species_properties/#returns_1","title":"Returns","text":"<p>material_properties : value     The material property for the given species.</p>"},{"location":"API/particula/util/species_properties/#signature_4","title":"Signature","text":"<pre><code>def material_properties(property, species=\"water\", temperature=298.15 * u.K): ...\n</code></pre>"},{"location":"API/particula/util/species_properties/#vapor_concentration","title":"vapor_concentration","text":"<p>Show source in species_properties.py:177</p> <p>Convert saturation ratio to mass concentration at a given temperature.</p>"},{"location":"API/particula/util/species_properties/#args_2","title":"Args","text":"<p>sat_ratio : float     saturation ratio. temperature : K     Air temperature. species : str, optional     Species for which to calculate the saturation vapor pressure.     Default is \"water\".</p>"},{"location":"API/particula/util/species_properties/#returns_2","title":"Returns","text":"<p>concentration : concentration units     Concentration vapor.</p> <p>TODO: check values for different species</p>"},{"location":"API/particula/util/species_properties/#signature_5","title":"Signature","text":"<pre><code>def vapor_concentration(saturation_ratio, temperature=298.15 * u.K, species=\"water\"): ...\n</code></pre>"},{"location":"API/particula/util/species_properties/#water_buck_psat","title":"water_buck_psat","text":"<p>Show source in species_properties.py:47</p> <p>Buck equation for water vapor pressure https://en.wikipedia.org/wiki/Arden_Buck_equation</p>"},{"location":"API/particula/util/species_properties/#signature_6","title":"Signature","text":"<pre><code>def water_buck_psat(temperature): ...\n</code></pre>"},{"location":"API/particula/util/stats/","title":"Stats","text":"<p>Particula Index / Particula / Util / Stats</p> <p>Auto-generated documentation for particula.util.stats module.</p>"},{"location":"API/particula/util/stats/#average_to_interval","title":"average_to_interval","text":"<p>Show source in stats.py:101</p> <p>Calculate the average of the data stream over the specified time intervals.</p> <p>This function calculates the average of the data stream over a series of time intervals specified by <code>average_interval_array</code>. The average and standard deviation of the data are calculated for each interval, and the results are returned as two arrays.</p>"},{"location":"API/particula/util/stats/#arguments","title":"Arguments","text":"<pre><code>- `time_raw` *np.ndarray* - An array of timestamps, sorted in ascending\n    order.\n- `average_interval` *float* - The length of each time interval in seconds.\n- `average_interval_array` *np.ndarray* - An array of timestamps\n    representing\n    the start times of each time interval.\n- `data_raw` *np.ndarray* - An array of data points corresponding to the\n    timestamps in `time_raw`.\n- `average_data` *np.ndarray* - An empty array of shape\n    (num_channels, num_intervals)that will be filled with the\n    average data for each time interval.\n- `average_data_std` *np.ndarray* - An empty array of shape\n    (num_channels, num_intervals) that will be filled with the standard\n    deviation of the data for each time interval.\n</code></pre>"},{"location":"API/particula/util/stats/#returns","title":"Returns","text":"<pre><code>- `Tuple[np.ndarray,` *np.ndarray]* - A tuple containing the average data\n    and the standard deviation of the data, both as arrays of shape\n    (num_channels, num_intervals).\n</code></pre>"},{"location":"API/particula/util/stats/#signature","title":"Signature","text":"<pre><code>def average_to_interval(\n    time_raw: np.ndarray,\n    data_raw: np.ndarray,\n    average_interval: float,\n    average_interval_array: np.ndarray,\n    average_data: np.ndarray,\n    average_data_std: np.ndarray,\n) -&gt; Tuple[np.ndarray, np.ndarray]: ...\n</code></pre>"},{"location":"API/particula/util/stats/#distribution_integration","title":"distribution_integration","text":"<p>Show source in stats.py:272</p> <p>Performs either PDF integration or PMS integration based on the input. This function supports broadcasting where x_array has shape (m,) and distribution has shape (n, m).</p>"},{"location":"API/particula/util/stats/#arguments_1","title":"Arguments","text":"<pre><code>- `distribution` - The distribution array to integrate.\n    It should have a shape of (n, m).\n- `x_array` - The x-values array for PDF\n    integration. It should have a shape of (m,).\n    If None, PMS integration is performed. Defaults to None.\n- `axis` - The axis along which to perform the integration\n    for PDF or the sum for PMS.\n    Defaults to 0.\n</code></pre>"},{"location":"API/particula/util/stats/#returns_1","title":"Returns","text":"<pre><code>- `np.ndarray` - The result of the integration. If PDF integration is\nperformed, the result will have a shape of (n,) if axis=0 or (m,)\nif axis=1. If PMS integration is performed, the result will be a\nsingle value if axis=None, or an array with reduced dimensionality\notherwise.\n</code></pre>"},{"location":"API/particula/util/stats/#signature_1","title":"Signature","text":"<pre><code>def distribution_integration(\n    distribution: np.ndarray, x_array: Optional[np.ndarray] = None, axis: int = 0\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/util/stats/#mask_outliers","title":"mask_outliers","text":"<p>Show source in stats.py:219</p> <p>Create a boolean mask for outliers in a data array. Outliers are defined as values that are either above or below a specified threshold, or that are equal to a specified value. Not all parameters need to be specified. If <code>invert</code> is True, the mask will be inverted. The mask will be True for False for outliers and True for non-outliers.</p>"},{"location":"API/particula/util/stats/#arguments_2","title":"Arguments","text":"<pre><code>- `data` *np.ndarray* - The data array to be masked.\n- `bottom` *float* - The lower threshold for outliers.\n- `top` *float* - The upper threshold for outliers.\n- `value` *float* - The value to be masked.\n- `invert` *bool* - If True, the mask will be inverted.\n</code></pre>"},{"location":"API/particula/util/stats/#returns_2","title":"Returns","text":"<pre><code>- `np.ndarray` - A boolean mask for the outliers in the data array. Mask is\n    True for non-outliers and False for outliers, and the same shape as\n    the data array.\n</code></pre>"},{"location":"API/particula/util/stats/#signature_2","title":"Signature","text":"<pre><code>def mask_outliers(\n    data: np.ndarray,\n    bottom: Optional[float] = None,\n    top: Optional[float] = None,\n    value: Optional[float] = None,\n    invert: Optional[bool] = False,\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/util/stats/#merge_formatting","title":"merge_formatting","text":"<p>Show source in stats.py:10</p> <p>Formats two data arrays and their headers so that the data new can be subsiqently added to data current.</p>"},{"location":"API/particula/util/stats/#arguments_3","title":"Arguments","text":"<ul> <li><code>data_current</code> np.ndarray - First data array to merge.</li> <li><code>header_current</code> list - Header for the first data array.</li> <li><code>data_new</code> np.ndarray - Second data array to merge.</li> <li><code>header_new</code> list - Header for the second data array.</li> </ul>"},{"location":"API/particula/util/stats/#returns_3","title":"Returns","text":"<p>(np.ndarray, list, np.array, list): A tuple formatted data and headers.</p>"},{"location":"API/particula/util/stats/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code> - If the data arrays are not the same shape.</li> <li><code>ValueError</code> - If the headers are not the same length.</li> </ul>"},{"location":"API/particula/util/stats/#signature_3","title":"Signature","text":"<pre><code>def merge_formatting(\n    data_current: np.ndarray,\n    header_current: list,\n    data_new: np.ndarray,\n    header_new: list,\n) -&gt; Tuple[np.ndarray, list, np.ndarray, list]: ...\n</code></pre>"},{"location":"API/particula/util/surface_tension/","title":"Surface Tension","text":"<p>Particula Index / Particula / Util / Surface Tension</p> <p>Auto-generated documentation for particula.util.surface_tension module.</p>"},{"location":"API/particula/util/surface_tension/#dry_mixing","title":"dry_mixing","text":"<p>Show source in surface_tension.py:42</p> <p>Function to calculate the effective surface tension of a dry mixture.</p>"},{"location":"API/particula/util/surface_tension/#arguments","title":"Arguments","text":"<ul> <li>volume_fractions : array, volume fractions of solutes</li> <li>surface_tensions : array, surface tensions of solutes</li> </ul>"},{"location":"API/particula/util/surface_tension/#returns","title":"Returns","text":"<ul> <li>sigma : array, surface tension of droplet</li> </ul>"},{"location":"API/particula/util/surface_tension/#signature","title":"Signature","text":"<pre><code>def dry_mixing(volume_fractions, surface_tensions): ...\n</code></pre>"},{"location":"API/particula/util/surface_tension/#water","title":"water","text":"<p>Show source in surface_tension.py:15</p> <p>Calculate the surface tension of water using the equation from Kalova and Mares (2018).</p>"},{"location":"API/particula/util/surface_tension/#arguments_1","title":"Arguments","text":"<ul> <li>Temperature : float, Ambient temperature of air</li> <li>CritTemp : float, optional: Critical temperature of water</li> </ul>"},{"location":"API/particula/util/surface_tension/#returns_1","title":"Returns","text":"<ul> <li>sigma : float, Surface tension of water at the given temperature</li> </ul>"},{"location":"API/particula/util/surface_tension/#signature_1","title":"Signature","text":"<pre><code>def water(temperature, critical_temperature=647.15): ...\n</code></pre>"},{"location":"API/particula/util/surface_tension/#wet_mixing","title":"wet_mixing","text":"<p>Show source in surface_tension.py:64</p> <p>Function to calculate the effective surface tension of a wet mixture.</p>"},{"location":"API/particula/util/surface_tension/#arguments_2","title":"Arguments","text":"<ul> <li>volume_solute : array, volume of solute mixture</li> <li>volume_water : array, volume of water</li> <li>surface_tension_solute : array, surface tension of solute mixture</li> <li>temperature : float, temperature of droplet</li> <li>method : str, optional: [film, volume] method to calculate effective     surface tension</li> </ul>"},{"location":"API/particula/util/surface_tension/#returns_2","title":"Returns","text":"<ul> <li>EffSigma : array, effective surface tension of droplet</li> </ul>"},{"location":"API/particula/util/surface_tension/#signature_2","title":"Signature","text":"<pre><code>def wet_mixing(\n    volume_solute,\n    volume_water,\n    wet_radius,\n    surface_tension_solute,\n    temperature,\n    method=\"film\",\n): ...\n</code></pre>"},{"location":"API/particula/util/time_manage/","title":"Time Manage","text":"<p>Particula Index / Particula / Util / Time Manage</p> <p>Auto-generated documentation for particula.util.time_manage module.</p>"},{"location":"API/particula/util/time_manage/#datetime64_from_epoch_array","title":"datetime64_from_epoch_array","text":"<p>Show source in time_manage.py:57</p> <p>Converts an array of epoch times to a numpy array of datetime64 objects.</p>"},{"location":"API/particula/util/time_manage/#arguments","title":"Arguments","text":"<pre><code>- `epoch_array` *np.ndarray* - Array of epoch times (in seconds since\n    the Unix epoch).\n- `delta` *int* - An optional offset (in seconds) to add to the epoch times\n    before converting to datetime64 objects.\n</code></pre>"},{"location":"API/particula/util/time_manage/#returns","title":"Returns","text":"<pre><code>- `np.ndarray` - Array of datetime64 objects corresponding to the input\n    epoch times.\n</code></pre>"},{"location":"API/particula/util/time_manage/#signature","title":"Signature","text":"<pre><code>def datetime64_from_epoch_array(\n    epoch_array: np.ndarray, delta: int = 0\n) -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/util/time_manage/#relative_time","title":"relative_time","text":"<p>Show source in time_manage.py:85</p> <p>Cacluates the relative time from the start of the epoch array in the specified units.</p>"},{"location":"API/particula/util/time_manage/#arguments_1","title":"Arguments","text":"<ul> <li><code>-epoch_array</code> np.ndarray - Array of epoch times (in seconds since     the Unix epoch).</li> <li><code>-units</code> str - The units of the relative time. Default is hours.</li> </ul>"},{"location":"API/particula/util/time_manage/#returns_1","title":"Returns","text":"<ul> <li><code>-np.ndarray</code> - Array of relative times in the specified units.</li> </ul>"},{"location":"API/particula/util/time_manage/#signature_1","title":"Signature","text":"<pre><code>def relative_time(epoch_array: np.ndarray, units: str = \"hours\") -&gt; np.ndarray: ...\n</code></pre>"},{"location":"API/particula/util/time_manage/#time_str_to_epoch","title":"time_str_to_epoch","text":"<p>Show source in time_manage.py:10</p> <p>Convert to UTC (epoch) timezone from all inputs. Using pytz library, which implements the Olson time zone database. tz identifiers are strings from the database. See https://en.wikipedia.org/wiki/List_of_tz_database_time_zones for a list of time zones.</p>"},{"location":"API/particula/util/time_manage/#arguments_2","title":"Arguments","text":"<p>time : float (single value no arrays)     Epoch time in seconds. time_format : str     The format of the time string. See     https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes     for a list of format codes. timezone_identifier : str     The time zone identifier for the current time zone.</p>"},{"location":"API/particula/util/time_manage/#returns_2","title":"Returns","text":"<p>new_time : float     The float time in the new time zone.</p> <ul> <li><code>Example</code> - Date Time Format Codes</li> <li>'2019-01-01 00:00:00' is '%Y-%m-%d %H:%M:%S'</li> <li>'10/01/2019 00:00:00' is '%d/%m/%Y %H:%M:%S'</li> <li>'2019-01-01 00:00:00.000000' is '%Y-%m-%d %H:%M:%S.%f'</li> <li>'5/1/2019 1:00:00 PM' is '%m/%d/%Y %I:%M:%S %p'</li> <li><code>-</code> %Y - Year with century as a decimal number.</li> <li><code>-</code> %m - Month as a zero-padded decimal number.</li> <li><code>-</code> %d - Day of the month as a zero-padded decimal number.</li> <li><code>-</code> %H - Hour (24-hour clock) as a zero-padded decimal number.</li> <li><code>-</code> %M - Minute as a zero-padded decimal number.</li> <li><code>-</code> %S - Second as a zero-padded decimal number.</li> <li><code>-</code> %f - Microsecond as a decimal number, zero-padded on the left.</li> <li><code>-</code> %p - Locales equivalent of either AM or PM.</li> </ul>"},{"location":"API/particula/util/time_manage/#_1","title":"Time Manage","text":""},{"location":"API/particula/util/time_manage/#signature_2","title":"Signature","text":"<pre><code>def time_str_to_epoch(\n    time: str, time_format: str, timezone_identifier: str = \"UTC\"\n) -&gt; float: ...\n</code></pre>"},{"location":"API/particula/util/vapor_flux/","title":"Vapor Flux","text":"<p>Particula Index / Particula / Util / Vapor Flux</p> <p>Auto-generated documentation for particula.util.vapor_flux module.</p>"},{"location":"API/particula/util/vapor_flux/#phi","title":"phi","text":"<p>Show source in vapor_flux.py:18</p> <p>vapor flux</p>"},{"location":"API/particula/util/vapor_flux/#signature","title":"Signature","text":"<pre><code>def phi(\n    particle_area=None,\n    molecular_enhancement=None,\n    vapor_attachment=1,\n    vapor_speed=None,\n    driving_force=1,\n    fsc=None,\n    **kwargs\n): ...\n</code></pre>"},{"location":"API/particula/util/wall_loss/","title":"Wall Loss","text":"<p>Particula Index / Particula / Util / Wall Loss</p> <p>Auto-generated documentation for particula.util.wall_loss module.</p>"},{"location":"API/particula/util/wall_loss/#rectangle_wall_loss","title":"rectangle_wall_loss","text":"<p>Show source in wall_loss.py:39</p> <p>Calculate the wall loss coefficient, \u03b2\u2080, for a rectangular chamber.</p> <p>Given the rate of wall diffusivity parameter (ktp_value), the particle diffusion coefficient (diffusion_coefficient_value), and the terminal settling velocity (settling_velocity_value), this function computes the wall loss coefficient for a rectangular-prism chamber with specified dimensions.</p> <p>The wall loss coefficient is calculated based on the diffusion and gravitational sedimentation in a rectangular chamber. It accounts for the effect of chamber geometry on particle loss by considering the length (L), width (W), and height (H) of the chamber.</p>"},{"location":"API/particula/util/wall_loss/#arguments","title":"Arguments","text":"<ul> <li><code>ktp_value</code> float - Rate of wall diffusivity parameter in units of     inverse seconds (s^-1).</li> <li><code>diffusion_coefficient_value</code> float - The particle diffusion     coefficient in units of square meters per second (m^2/s).</li> <li><code>settling_velocity_value</code> float - The terminal settling velocity of the     particles, in units of meters per second (m/s).</li> <li><code>dimension</code> tuple - A tuple of three floats representing the length (L)     width (W), and height (H) of the rectangular chamber,     in units of meters (m).</li> </ul>"},{"location":"API/particula/util/wall_loss/#returns","title":"Returns","text":"<ul> <li><code>float</code> - The calculated wall loss coefficient (B0) for the rectangular chamber.</li> </ul> <p>Reference:     The wall loss coefficient, \u03b2\u2080, is calculated using the following     formula:     $$     \beta_0 = (LWH)^{-1} (4H(L+W) \\sqrt{k_t D}/\\pi +     v_g LW \\coth{[(\\pi v_g)/(4\\sqrt{k_t D}})])     $$</p>"},{"location":"API/particula/util/wall_loss/#signature","title":"Signature","text":"<pre><code>def rectangle_wall_loss(\n    ktp_value, diffusion_coefficient_value, settling_velocity_value, dimension\n): ...\n</code></pre>"},{"location":"API/particula/util/wall_loss/#spherical_wall_loss_coefficient","title":"spherical_wall_loss_coefficient","text":"<p>Show source in wall_loss.py:12</p> <p>Calculate the wall loss coefficient for a spherical chamber approximation.</p>"},{"location":"API/particula/util/wall_loss/#arguments_1","title":"Arguments","text":"<ul> <li><code>ktp_value</code> - rate of the wall eddy diffusivity</li> <li><code>diffusion_coefficient_value</code> - Particle diffusion coefficient.</li> <li><code>settling_velocity_value</code> - Settling velocity of the particle.</li> <li><code>chamber_radius</code> - Radius of the chamber.</li> </ul>"},{"location":"API/particula/util/wall_loss/#returns_1","title":"Returns","text":"<p>The calculated wall loss coefficient for simple case.</p>"},{"location":"API/particula/util/wall_loss/#signature_1","title":"Signature","text":"<pre><code>def spherical_wall_loss_coefficient(\n    ktp_value, diffusion_coefficient_value, settling_velocity_value, chamber_radius\n): ...\n</code></pre>"},{"location":"API/particula/util/wall_loss/#wlc","title":"wlc","text":"<p>Show source in wall_loss.py:94</p> <p>Calculate the wall loss coefficient.</p>"},{"location":"API/particula/util/wall_loss/#arguments_2","title":"Arguments","text":"<ul> <li><code>approximation</code> - The approximation method to use, e.g., \"none\", \"spherical\", \"rectangle\"</li> <li><code>ktp_value</code> - rate of the wall eddy diffusivity</li> <li><code>diffusion_coefficient_value</code> - Particle diffusion coefficient.</li> <li><code>settling_velocity_value</code> - Settling velocity of the particle.</li> <li><code>dimension</code> - Radius of the chamber or tuple of rectangular dimensions.</li> </ul>"},{"location":"API/particula/util/wall_loss/#returns_2","title":"Returns","text":"<p>The calculated wall loss coefficient.</p>"},{"location":"API/particula/util/wall_loss/#signature_2","title":"Signature","text":"<pre><code>def wlc(\n    approx=\"none\",\n    ktp_value=0.1 * u.s**-1,\n    diffusion_coefficient_value=None,\n    dimension=1 * u.m,\n    settling_velocity_value=None,\n    **kwargs\n): ...\n</code></pre>"},{"location":"API/particula/util/converting/","title":"Converting","text":"<p>Particula Index / Particula / Util / Converting</p> <p>Auto-generated documentation for particula.util.converting module.</p>"},{"location":"API/particula/util/converting/#modules","title":"Modules","text":"<ul> <li>Convert Mass Concentration</li> </ul>"},{"location":"API/particula/util/converting/convert_mass_concentration/","title":"Convert Mass Concentration","text":"<p>Particula Index / Particula / Util / Converting / Convert Mass Concentration</p> <p>Auto-generated documentation for particula.util.converting.convert_mass_concentration module.</p>"},{"location":"API/particula/util/converting/convert_mass_concentration/#to_mass_fraction","title":"to_mass_fraction","text":"<p>Show source in convert_mass_concentration.py:97</p> <p>Convert mass concentrations to mass fractions for N components.</p> <p>If inputs are one-dimensional or float, the summation is done over the entire array. If mass_concentration is a 2D array, the summation is done row-wise.</p>"},{"location":"API/particula/util/converting/convert_mass_concentration/#arguments","title":"Arguments","text":"<ul> <li><code>mass_concentrations</code> - A list or ndarray of mass concentrations     (SI, kg/m^3).</li> </ul>"},{"location":"API/particula/util/converting/convert_mass_concentration/#returns","title":"Returns","text":"<p>An ndarray of mass fractions.</p> <p>Reference:     The mass fraction of a component is calculated by dividing the mass     concentration of that component by the total mass concentration of     all components.     - https://en.wikipedia.org/wiki/Mass_fraction_(chemistry)</p>"},{"location":"API/particula/util/converting/convert_mass_concentration/#signature","title":"Signature","text":"<pre><code>def to_mass_fraction(\n    mass_concentrations: NDArray[np.float64],\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/util/converting/convert_mass_concentration/#to_mole_fraction","title":"to_mole_fraction","text":"<p>Show source in convert_mass_concentration.py:7</p> <p>Convert mass concentrations to mole fractions for N components.</p> <p>If the input mass_concentrations is 1D, the summation is performed over the entire array. If mass_concentrations is 2D, the summation is done row-wise.</p>"},{"location":"API/particula/util/converting/convert_mass_concentration/#arguments_1","title":"Arguments","text":"<ul> <li><code>mass_concentrations</code> - A list or ndarray of mass concentrations     (SI, kg/m^3).</li> <li><code>molar_masses</code> - A list or ndarray of molecular weights (SI, kg/mol).</li> </ul>"},{"location":"API/particula/util/converting/convert_mass_concentration/#returns_1","title":"Returns","text":"<p>An ndarray of mole fractions.</p> <p>Reference:     The mole fraction of a component is given by the ratio of its molar     concentration to the total molar concentration of all components.     - https://en.wikipedia.org/wiki/Mole_fraction</p>"},{"location":"API/particula/util/converting/convert_mass_concentration/#signature_1","title":"Signature","text":"<pre><code>def to_mole_fraction(\n    mass_concentrations: NDArray[np.float64], molar_masses: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/util/converting/convert_mass_concentration/#to_volume_fraction","title":"to_volume_fraction","text":"<p>Show source in convert_mass_concentration.py:51</p> <p>Convert mass concentrations to volume fractions for N components.</p> <p>If inputs are the one dimensional or float, the summation is done over the the whole array. It mass_concentration is a 2D array, the summation is done row-wise.</p>"},{"location":"API/particula/util/converting/convert_mass_concentration/#arguments_2","title":"Arguments","text":"<ul> <li><code>mass_concentrations</code> - A list or ndarray of mass concentrations     (SI, kg/m^3).</li> <li><code>densities</code> - A list or ndarray of densities of each component     (SI, kg/m^3).</li> </ul>"},{"location":"API/particula/util/converting/convert_mass_concentration/#returns_2","title":"Returns","text":"<p>An ndarray of volume fractions.</p> <p>Reference:     The volume fraction of a component is calculated by dividing the volume     of that component (derived from mass concentration and density) by the     total volume of all components.     - https://en.wikipedia.org/wiki/Volume_fraction</p>"},{"location":"API/particula/util/converting/convert_mass_concentration/#signature_2","title":"Signature","text":"<pre><code>def to_volume_fraction(\n    mass_concentrations: NDArray[np.float64], densities: NDArray[np.float64]\n) -&gt; NDArray[np.float64]: ...\n</code></pre>"},{"location":"API/particula/util/lf2013_coagulation/","title":"Lf2013 Coagulation","text":"<p>Particula Index / Particula / Util / Lf2013 Coagulation</p> <p>Auto-generated documentation for particula.util.lf2013_coagulation module.</p>"},{"location":"API/particula/util/lf2013_coagulation/#modules","title":"Modules","text":"<ul> <li>Src Lf2013 Coagulation</li> </ul>"},{"location":"API/particula/util/lf2013_coagulation/src_lf2013_coagulation/","title":"Src Lf2013 Coagulation","text":"<p>Particula Index / Particula / Util / Lf2013 Coagulation / Src Lf2013 Coagulation</p> <p>Auto-generated documentation for particula.util.lf2013_coagulation.src_lf2013_coagulation module.</p>"},{"location":"API/particula/util/lf2013_coagulation/src_lf2013_coagulation/#lf2013_coag_full","title":"lf2013_coag_full","text":"<p>Show source in src_lf2013_coagulation.py:14</p> <p>calculate ion--particle coagulation according to lf2013</p>"},{"location":"API/particula/util/lf2013_coagulation/src_lf2013_coagulation/#signature","title":"Signature","text":"<pre><code>def lf2013_coag_full(\n    ion_type=\"air\",\n    particle_type=\"conductive\",\n    temperature_val=298.15,\n    pressure_val=101325,\n    charge_vals=None,\n    radius_vals=None,\n): ...\n</code></pre>"},{"location":"Discussions/","title":"Discussions","text":""},{"location":"Discussions/#technical-topics","title":"Technical Topics","text":"<ul> <li>Condensation Equations</li> <li>Dynamic Viscosity</li> <li>Mean Free Path</li> <li>Ion-Particle Coagulation</li> </ul>"},{"location":"Discussions/#particula-concepts","title":"Particula Concepts","text":"<ul> <li>Maps</li> </ul>"},{"location":"Discussions/Particula_Concepts/Particle_maps/","title":"Relational Maps","text":""},{"location":"Discussions/Particula_Concepts/Particle_maps/#particles","title":"Particles","text":"<pre><code>mindmap\n  root((*particula.next.particles*))\n    distribution\n      strategies\n        MassBasedMovingBin\n        RadiiBasedMovingBin\n        SpeciatedMassMovingBin\n        ParticleResolvedSpeciatedMass\n      builders\n      DistributionFactory\n    activity\n      strategies\n        ActivityIdealMass\n        ActivityIdealMolar\n        ActivityKappaParameter\n      builders\n      ActivityFactory\n    representation\n      ParticleRepresentation\n      builders\n      ParticleRepresentationFactory\n    surface\n      strategies\n        SurfaceStrategyVolume\n        SurfaceStrategyMass\n        SurfaceStrategyMolar\n      builders\n      SurfaceFactory\n    properties</code></pre>"},{"location":"Discussions/Technical/Condensation_Equations/","title":"Condensation Discussion","text":"<p>Iso thermal and non-isothermal condensation processes are important in aerosol dynamics. The condensation process is the addition of a gas phase species to the particle phase. This can be a reversible process, where the species can evaporate back into the gas phase. The condensation process is important in the formation of cloud droplets, and the growth of particles in the atmosphere.</p>"},{"location":"Discussions/Technical/Condensation_Equations/#condensation-equations-isothermal","title":"Condensation Equations (Isothermal)","text":"<p>With the gas phase and particle phase defined, we can start the condensation process. Excluding the latent heat of vaporization for the gas-particle phase transition, which is important in cloud droplet formation.</p> <p>This follows Chapter 2 (EQ 2.41) by Topping, D., &amp; Bane, M. (2022). Introduction to Aerosol Modelling (D. Topping &amp; M. Bane, Eds.). Wiley. https://doi.org/10.1002/9781119625728. Also Chapter 12 and 13 (EQ 13.3) of Seinfeld, J. H., &amp; Pandis, S. N. (2016). Atmospheric Chemistry and Physics: From Air Pollution to Climate Change (3<sup>rd</sup> ed.). Wiley.</p> <p>The isothermal condensation or evaporation process is defined by the following equation:</p> \\[ \\frac{dm_{i}}{dt} = N \\frac{k_{cond} (p_{i, gas} - p_{i, particle~surface})}{RT/ molar~mass_{i}} \\] <p>Where:</p> <ul> <li>\\(m_{i}\\) is the mass of species \\(i\\) in the particle phase, of a specific bin</li> <li>\\(N\\) is the number of particles</li> <li>\\(k_{cond}\\) is the per-particle for order condensation coefficient</li> <li>\\(p_{i, gas}\\) is the partial pressure of species \\(i\\) in the gas phase</li> <li>\\(p_{i, particle~surface}\\) is the partial pressure of species \\(i\\) at the surface of the particle, acounting for Kelvin effect and activity coefficients.</li> <li>\\(R\\) is the ideal gas constant</li> <li>\\(T\\) is the temperature</li> <li>\\(molar mass_{i}\\) is the molar mass of species \\(i\\)</li> <li>\\(dm_{i}/dt\\) is the rate of change of mass of species \\(i\\) in the particle phase</li> </ul> <p>The first order condensation coefficient is defined as:</p> \\[ k_{cond} = 4 \\pi~radius_{particle}~D_{i}~f(Kn, \\alpha) \\] <p>Where:</p> <ul> <li>\\(radius_{particle}\\) is the radius of the particle</li> <li>\\(D_{i}\\) is the vapor diffusion coefficient of species \\(i\\)</li> <li>\\(f(Kn, \\alpha)\\) is the correction factor for the molecular regime to continuum regime transition. This is a function of the Knudsen number and the accommodation coefficient.</li> </ul> <p>The correction factor is defined as:</p> \\[ f(Kn, \\alpha_{i, accom.}) = \\frac{0.75 \\alpha_{i, accom.} (1 + Kn)}{     (Kn^2 + Kn) + 0.283 \\alpha_{i, accom.} Kn + 0.75 \\alpha_{i, accom.}} \\] <p>Where:</p> <ul> <li>\\(\\alpha_{i, accom.}\\) is the accommodation coefficient of species \\(i\\)</li> <li>\\(Kn\\) is the Knudsen number</li> <li>\\(Kn = \\frac{\\lambda_{i}}{radius_{particle}}\\)</li> <li>\\(\\lambda\\) is the mean free path of the gas molecules of species \\(i\\)</li> <li>\\(radius\\) is the radius of the particle</li> </ul>"},{"location":"Discussions/Technical/Condensation_Equations/#partial-pressures","title":"Partial Pressures","text":"<p>The partial pressures of species \\(i\\) in the gas phase and at the surface of the particle are defined as:</p> \\[ p_{i, gas} = conc_{i, gas} RT/molar~mass_{i} \\] <p>Where: - \\(conc_{i, gas}\\) is the concentration of species \\(i\\) in the gas phase</p> <p>At the surface of the particle, the partial pressure is defined as:</p> \\[ p_{i, particle~surface} = p^{pure}_{i} \\gamma_{i} x_{i} k_{i,Kelvin} \\] <p>Where:</p> <ul> <li>\\(p^{pure}_{i}\\) is the saturation vapor pressure of species \\(i\\), sometimes called \\(p^{sat}_{i}\\), \\(p^{vap}_{i}\\), or \\(p^{0}_{i}\\)</li> <li>\\(\\gamma_{i}\\) is the activity coefficient of species \\(i\\)</li> <li>\\(x_{i}\\) is the mole fraction of species \\(i\\) in the particle phase</li> <li>\\(k_{i,Kelvin}\\) is the Kelvin effect correction factor</li> <li>\\(k_{i,Kelvin} = exp(k_{i, Kelvin~radius}/radius_{particle})\\)</li> <li>\\(k_{i, Kelvin~radius} = 2 \\sigma_{surface}~molar~mass_{i} / (R  T ~ density)\\)<ul> <li>\\(\\sigma_{surface}\\) is the effective surface tension of the particle.</li> <li>\\(density\\) is the effective density of the particle.</li> </ul> </li> </ul>"},{"location":"Discussions/Technical/dynamic_viscosity/","title":"Dynamic Viscosity","text":"In\u00a0[1]: Copied! <pre>from particula.next.gas.properties import get_dynamic_viscosity\n\nair_dynamic_viscosity = get_dynamic_viscosity(\n    temperature=298.15\n)  # will produce approx 1.84e-5 kg/m/s\n\nprint(f\"Air dynamic viscosity at 298.15 K is {air_dynamic_viscosity:.2e} kg/m/s\")\n</pre> from particula.next.gas.properties import get_dynamic_viscosity  air_dynamic_viscosity = get_dynamic_viscosity(     temperature=298.15 )  # will produce approx 1.84e-5 kg/m/s  print(f\"Air dynamic viscosity at 298.15 K is {air_dynamic_viscosity:.2e} kg/m/s\") <pre>Air dynamic viscosity at 298.15 K is 1.84e-05 kg/m/s\n</pre>"},{"location":"Discussions/Technical/dynamic_viscosity/#dynamic-viscosity","title":"Dynamic Viscosity\u00b6","text":"<p>The dynamic viscosity is a property of the fluid, defining the resistance of the fluid to its own movement. The dynamic viscosity is calculated using the Sutherland formula (reference). The function can be found and is documented in <code>util.dynamic_viscosity.py</code>. It takes inputs of <code>temperature</code>, <code>reference_viscosity</code>, <code>reference_temperature</code>, and <code>sutherland_constant</code>. It returns a value for the dynamic viscosity at those variables. At default conditions (298.15 K and 101325 Pa), the dynamic viscosity is approximately 1.84e-5 kg/m/s. The Sutherland formula is</p> <p>$$ \\mu = \\frac{\\mu_{0}\\, (T/T_{0})^{3/2}\\, (T_{0} + C)}{C + T} $$</p> <p>where $\\mu$ is the dynamic viscosity, $\\mu_{0}$ is the reference dynamic viscosity, $T$ is temperature, $T_{0}$ is the reference temperature, and $C$ is the Sutherland constant.</p>"},{"location":"Discussions/Technical/ionparticle_coagulation/","title":"Ion\u2013particle coagulation","text":"In\u00a0[1]: Copied! <pre>try:\n    import particula, matplotlib\nexcept ImportError:\n    print(\"Setting up computational environment...\")\n    %pip install -U particula -qqq\n    %pip install matplotlib -qqq\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom particula import particle, u\nfrom particula.util.lf2013_coagulation import lf2013_coag_full\n</pre> try:     import particula, matplotlib except ImportError:     print(\"Setting up computational environment...\")     %pip install -U particula -qqq     %pip install matplotlib -qqq  import numpy as np from matplotlib import pyplot as plt from particula import particle, u from particula.util.lf2013_coagulation import lf2013_coag_full In\u00a0[2]: Copied! <pre>approx = [\"hardsphere\", \"gk2008\", \"gh2012\", \"dy2007\", \"cg2019\"]\nfor i in range(len(approx)):\n    shared_dict = {\n        \"temperature\": 278,\n        \"coagulation_approximation\": approx[i]\n    }\n    positive_particles = [\n        particle.Particle(\n            **shared_dict,\n            particle_radius=3e-9,\n            particle_charge=i,\n            particle_density=1700,\n        ) for i in range(1, 10)\n    ]\n    negative_ion = particle.Particle(\n        **shared_dict,\n        particle_radius=0.45e-9,\n        particle_charge=-1,\n        particle_density=1860,\n    )\n    coags = [\n        negative_ion.coagulation(particle)\n        for particle in positive_particles\n    ]\n    coags_ccps_mags = [\n        coags[index].to(\"cc/s\").m\n        for index in range(0, 9)\n    ]\n    plt.semilogy(range(1,10), np.array(coags_ccps_mags).squeeze(), label=approx[i]);\n   \n\n\nret = np.nan_to_num(lf2013_coag_full(\n        ion_type=\"air\",\n        particle_type=\"conductive\",\n        temperature_val=298.15,\n        pressure_val=101325,\n        charge_vals=np.arange(1, 10),\n        radius_vals=3e-9,)[0], 0)  # [0] returns negative, [1] returns positive ions\nplt.semilogy(range(1,10),  np.array(ret*1e6).squeeze(), label=\"lf2013\");\nplt.ylim([1e-7, 1e-4]); plt.ylabel(\"Attachment coefficient, cc/s\"); plt.legend(); plt.xlabel(\"# charges\");\n</pre> approx = [\"hardsphere\", \"gk2008\", \"gh2012\", \"dy2007\", \"cg2019\"] for i in range(len(approx)):     shared_dict = {         \"temperature\": 278,         \"coagulation_approximation\": approx[i]     }     positive_particles = [         particle.Particle(             **shared_dict,             particle_radius=3e-9,             particle_charge=i,             particle_density=1700,         ) for i in range(1, 10)     ]     negative_ion = particle.Particle(         **shared_dict,         particle_radius=0.45e-9,         particle_charge=-1,         particle_density=1860,     )     coags = [         negative_ion.coagulation(particle)         for particle in positive_particles     ]     coags_ccps_mags = [         coags[index].to(\"cc/s\").m         for index in range(0, 9)     ]     plt.semilogy(range(1,10), np.array(coags_ccps_mags).squeeze(), label=approx[i]);       ret = np.nan_to_num(lf2013_coag_full(         ion_type=\"air\",         particle_type=\"conductive\",         temperature_val=298.15,         pressure_val=101325,         charge_vals=np.arange(1, 10),         radius_vals=3e-9,)[0], 0)  # [0] returns negative, [1] returns positive ions plt.semilogy(range(1,10),  np.array(ret*1e6).squeeze(), label=\"lf2013\"); plt.ylim([1e-7, 1e-4]); plt.ylabel(\"Attachment coefficient, cc/s\"); plt.legend(); plt.xlabel(\"# charges\");"},{"location":"Discussions/Technical/ionparticle_coagulation/#ionparticle-coagulation","title":"Ion\u2013particle coagulation\u00b6","text":"<p>The problem here: positive particles (1 to 9 charges) of radius 3 nm colliding with a negative ion of radius 0.45 nm.</p> <p>Several coagulation approximations:</p> <ul> <li>hard shpere</li> <li>gh2012: https://journals.aps.org/pre/abstract/10.1103/PhysRevE.85.026410</li> <li>gk2008: https://journals.aps.org/pre/abstract/10.1103/PhysRevE.78.046402</li> <li>dy2007: https://aip.scitation.org/doi/10.1063/1.2713719</li> <li>cg2019: https://www.tandfonline.com/doi/suppl/10.1080/02786826.2019.1614522</li> <li>lf2013: https://www.tandfonline.com/doi/full/10.1080/02786826.2013.783684</li> </ul>"},{"location":"Discussions/Technical/mean_free_path/","title":"Mean Free Path","text":"In\u00a0[4]: Copied! <pre>from particula.next.gas.properties import molecule_mean_free_path, get_dynamic_viscosity\n\nair_dynamic_viscosity = get_dynamic_viscosity(temperature=298.15)\n\nmean_free_path = molecule_mean_free_path(\n    molar_mass=28.97e-3,\n    temperature=298.15,\n    pressure=101325,\n    dynamic_viscosity=air_dynamic_viscosity,\n)\n\nprint(f\"mean free path is {mean_free_path} m\") # will produce approx 66.5 nm\n</pre> from particula.next.gas.properties import molecule_mean_free_path, get_dynamic_viscosity  air_dynamic_viscosity = get_dynamic_viscosity(temperature=298.15)  mean_free_path = molecule_mean_free_path(     molar_mass=28.97e-3,     temperature=298.15,     pressure=101325,     dynamic_viscosity=air_dynamic_viscosity, )  print(f\"mean free path is {mean_free_path} m\") # will produce approx 66.5 nm <pre>mean free path is 6.647342358988276e-08 m\n</pre>"},{"location":"Discussions/Technical/mean_free_path/#mean-free-path","title":"Mean Free Path\u00b6","text":"<p>The mean free path is the average distance of a molecule between collisions with other molecules present in the medium. We use the kinetic theory of gases to calculate the mean free path in an ideal gas as</p> <p>$$ \\lambda = \\frac{2 \\mu / p}{(8 \\, \\mathrm{MW} / (\\pi R T))^{1/2}}  $$</p> <p>where $\\lambda$ is the mean free path, $\\mu$ is the dynamic viscosity, $p$ is the pressure, $\\mathrm{MW}$ is the molecular weight, $R$ is the gas constant, $T$ is the temperature. As noted above, the user can provide an explicit value for $\\mu$ or it can be calculated using the above formula (that is, the user can provide the inputs to the above formula for $\\mu$). At default conditions, $\\lambda$ is about 66.5 nm.</p>"},{"location":"How-To-Guides/","title":"How-To Guides","text":"<ul> <li> <p>Setup Particula</p> <p>How to setup python and install <code>Particula</code> via pip.</p> <p> Tutorial</p> </li> <li> <p>Chamber Wall Loss</p> <p>How to simulate and analyze experiments for the loss of particles to the chamber walls.</p> <p> Tutorial</p> </li> <li> <p>Equilibria</p> <p>How to simulate aerosol thermodynamic equilibria using the Binary Activity Thermodynamic <code>BAT</code> Model. Useful for water uptake and cloud droplet activation.</p> <p> Tutorial</p> </li> <li> <p>Light Scattering</p> <p>How to simulate light scattering from aerosol particles and refractive index mixing for humidified aerosol. Useful for understanding how particles scatter light.</p> <p> Tutorial</p> </li> <li> <p>Nucleation</p> <p>How to simulate aerosol nucleation using a custom process. Showing how to add a custom process for a nucleation event.</p> <p> Tutorial</p> </li> <li> <p>Data Streams and Lakes </p> <p>in BETA How to organize and analyze data from multiple instruments using <code>Streams</code> and <code>Lakes</code> organization. Useful for bulk and repeatable data analysis.</p> <p> Tutorial</p> </li> <li> <p>Lagrangian </p> <p>in BETA How to simulate aerosol coagulation dynamics using the Lagrangian method. Useful for tracking individual particles.</p> <p> Tutorial</p> </li> </ul>"},{"location":"How-To-Guides/Chamber_Wall_Loss/","title":"Index: Chamber Wall Loss BETA","text":"<p>In this example we'll go through the steps of combining the data analysis, and modeling capabilities of particula to analyze the wall loss in a chamber.</p>"},{"location":"How-To-Guides/Chamber_Wall_Loss/#notebooks","title":"Notebooks","text":"<ul> <li>Wall Loss Forward Simulation</li> <li>Chamber Data Observations</li> <li>Chamber Rates Fit</li> </ul>"},{"location":"How-To-Guides/Chamber_Wall_Loss/Notebooks/Chamber_Forward_Simulation/","title":"Chamber Forward Simulation","text":"In\u00a0[50]: Copied! <pre>import numpy as np\nfrom matplotlib import pyplot as plt\n\nfrom particula.next.dynamics import dilution, wall_loss_rate, coagulation\nfrom particula.next.particles.properties import lognormal_pmf_distribution\n</pre> import numpy as np from matplotlib import pyplot as plt  from particula.next.dynamics import dilution, wall_loss_rate, coagulation from particula.next.particles.properties import lognormal_pmf_distribution In\u00a0[51]: Copied! <pre># Define initial simulation parameters\nmode = np.array([100e-9, 500e-9])  # Median diameter of the particles in meters\ngeometric_standard_deviation = np.array([1.3, 1.5])  # Geometric standard deviation of particle size distribution\nnumber_in_mode = np.array([5e4, 5e3]) * 1e6  # Number of particles in each mode  1/m^3\n\n\n# define the radius bins for the simulation\nradius_bins = np.logspace(-8, -5, 250)\n\n\n# Create particle distribution using the defined parameters\n\nconcentraiton_pmf = lognormal_pmf_distribution(\n    x_values=radius_bins,\n    mode=mode,\n    geometric_standard_deviation=geometric_standard_deviation,\n    number_of_particles=number_in_mode,\n)\n\n\n# plot the initial particle distribution\nfig, ax = plt.subplots()\nax.plot(radius_bins, concentraiton_pmf, label=\"Initial distribution\",\n        marker='.')\nax.set_xscale(\"log\")\nax.set_xlabel(\"Particle radius (m)\")\nax.set_ylabel(r\"Particle Concentration (dN), $\\dfrac{1}{m^{3}}$\")\nplt.show()\n</pre> # Define initial simulation parameters mode = np.array([100e-9, 500e-9])  # Median diameter of the particles in meters geometric_standard_deviation = np.array([1.3, 1.5])  # Geometric standard deviation of particle size distribution number_in_mode = np.array([5e4, 5e3]) * 1e6  # Number of particles in each mode  1/m^3   # define the radius bins for the simulation radius_bins = np.logspace(-8, -5, 250)   # Create particle distribution using the defined parameters  concentraiton_pmf = lognormal_pmf_distribution(     x_values=radius_bins,     mode=mode,     geometric_standard_deviation=geometric_standard_deviation,     number_of_particles=number_in_mode, )   # plot the initial particle distribution fig, ax = plt.subplots() ax.plot(radius_bins, concentraiton_pmf, label=\"Initial distribution\",         marker='.') ax.set_xscale(\"log\") ax.set_xlabel(\"Particle radius (m)\") ax.set_ylabel(r\"Particle Concentration (dN), $\\dfrac{1}{m^{3}}$\") plt.show() In\u00a0[52]: Copied! <pre># coagulation rate\n\nmass_particle = 4/3 * np.pi * radius_bins**3 * 1000 # mass of the particles in kg\n\nkernel = coagulation.brownian_coagulation_kernel_via_system_state(\n    radius_particle=radius_bins,\n    mass_particle= mass_particle,\n    temperature=293.15,\n    pressure=101325,\n    alpha_collision_efficiency=1,\n)\ncoagulation_loss = coagulation.discrete_loss(\n    concentration=concentraiton_pmf,\n    kernel=kernel,\n)\ncoagulation_gain = coagulation.discrete_gain(\n    radius=radius_bins,\n    concentration=concentraiton_pmf,\n    kernel=kernel,\n)\ncoagulation_net = coagulation_gain - coagulation_loss\n\n# dilution rate\ndilution_coefficent = dilution.volume_dilution_coefficient(\n    volume=1, # m^3\n    input_flow_rate=2*1e-6, # m^3/s\n)\ndilution_loss = dilution.dilution_rate(\n    coefficient=dilution_coefficent,\n    concentration=concentraiton_pmf,\n)\n\n# wall loss rate\nchamber_wall_loss_rate = wall_loss_rate.rectangle_wall_loss_rate(\n    wall_eddy_diffusivity=0.1,\n    particle_radius=radius_bins,\n    particle_density=1000,\n    particle_concentration=concentraiton_pmf,\n    temperature=293.15,\n    pressure=101325,\n    chamber_dimensions=(1, 1, 1),  # m\n)\n\n# plot rates\nfig, ax = plt.subplots()\nax.plot(radius_bins, coagulation_net, label=\"Coagulation Net\",)\nax.plot(radius_bins, dilution_loss, label=\"Dilution Loss\",)\nax.plot(radius_bins, chamber_wall_loss_rate, label=\"Chamber Wall Loss\",)\nax.plot(radius_bins, coagulation_net + dilution_loss + chamber_wall_loss_rate, label=\"Net Rate\", linestyle=\"--\")\nax.set_xscale(\"log\")\n# ax.set_yscale(\"log\")\nax.set_xlabel(\"Particle radius (m)\")\nax.set_ylabel(r\"Rate $\\dfrac{1}{m^{3} s^{1}}$\")\nax.grid()\nplt.legend()\nplt.show()\n</pre> # coagulation rate  mass_particle = 4/3 * np.pi * radius_bins**3 * 1000 # mass of the particles in kg  kernel = coagulation.brownian_coagulation_kernel_via_system_state(     radius_particle=radius_bins,     mass_particle= mass_particle,     temperature=293.15,     pressure=101325,     alpha_collision_efficiency=1, ) coagulation_loss = coagulation.discrete_loss(     concentration=concentraiton_pmf,     kernel=kernel, ) coagulation_gain = coagulation.discrete_gain(     radius=radius_bins,     concentration=concentraiton_pmf,     kernel=kernel, ) coagulation_net = coagulation_gain - coagulation_loss  # dilution rate dilution_coefficent = dilution.volume_dilution_coefficient(     volume=1, # m^3     input_flow_rate=2*1e-6, # m^3/s ) dilution_loss = dilution.dilution_rate(     coefficient=dilution_coefficent,     concentration=concentraiton_pmf, )  # wall loss rate chamber_wall_loss_rate = wall_loss_rate.rectangle_wall_loss_rate(     wall_eddy_diffusivity=0.1,     particle_radius=radius_bins,     particle_density=1000,     particle_concentration=concentraiton_pmf,     temperature=293.15,     pressure=101325,     chamber_dimensions=(1, 1, 1),  # m )  # plot rates fig, ax = plt.subplots() ax.plot(radius_bins, coagulation_net, label=\"Coagulation Net\",) ax.plot(radius_bins, dilution_loss, label=\"Dilution Loss\",) ax.plot(radius_bins, chamber_wall_loss_rate, label=\"Chamber Wall Loss\",) ax.plot(radius_bins, coagulation_net + dilution_loss + chamber_wall_loss_rate, label=\"Net Rate\", linestyle=\"--\") ax.set_xscale(\"log\") # ax.set_yscale(\"log\") ax.set_xlabel(\"Particle radius (m)\") ax.set_ylabel(r\"Rate $\\dfrac{1}{m^{3} s^{1}}$\") ax.grid() plt.legend() plt.show() In\u00a0[53]: Copied! <pre># time steps\ntime_array = np.linspace(start=0, stop=3600, num=1000)\ndt = time_array[1] - time_array[0]\n\n# create a matrix to store the particle distribution at each time step\nconcentration_matrix = np.zeros((len(time_array), len(radius_bins)))\ncoagulation_net_matrix = np.zeros((len(time_array), len(radius_bins)))\ndilution_loss_matrix = np.zeros((len(time_array), len(radius_bins)))\nchamber_wall_loss_rate_matrix = np.zeros((len(time_array), len(radius_bins)))\n\n# set the initial concentration\nconcentration_matrix[0, :] = concentraiton_pmf\n\nkernel = coagulation.brownian_coagulation_kernel_via_system_state(\n    radius_particle=radius_bins,\n    mass_particle= mass_particle,\n    temperature=293.15,\n    pressure=101325,\n    alpha_collision_efficiency=1,\n)\n# iterate over the time steps\nfor i, time in enumerate(time_array[1:], start=1):\n\n    # calculate the coagulation rate\n    coagulation_loss = coagulation.discrete_loss(\n        concentration=concentration_matrix[i-1, :],\n        kernel=kernel,\n    )\n    coagulation_gain = coagulation.discrete_gain(\n        radius=radius_bins,\n        concentration=concentration_matrix[i-1, :],\n        kernel=kernel,\n    )\n    coagulation_net = coagulation_gain - coagulation_loss\n\n    # calculate the dilution rate\n    dilution_coefficent = dilution.volume_dilution_coefficient(\n        volume=1, # m^3\n        input_flow_rate=2*1e-6, # m^3/s\n    )\n    dilution_loss = dilution.dilution_rate(\n        coefficient=dilution_coefficent,\n        concentration=concentration_matrix[i-1, :],\n    )\n\n    # calculate the wall loss rate\n    chamber_wall_loss_rate = wall_loss_rate.rectangle_wall_loss_rate(\n        wall_eddy_diffusivity=0.1,\n        particle_radius=radius_bins,\n        particle_density=1000,\n        particle_concentration=concentration_matrix[i-1, :],\n        temperature=293.15,\n        pressure=101325,\n        chamber_dimensions=(1, 1, 1),  # m\n    )\n\n    # update the concentration matrix\n    concentration_matrix[i, :] = concentration_matrix[i-1, :] + (coagulation_net + dilution_loss + chamber_wall_loss_rate) * dt\n\n    # update the rate matrices\n    coagulation_net_matrix[i, :] = coagulation_net\n    dilution_loss_matrix[i, :] = dilution_loss\n    chamber_wall_loss_rate_matrix[i, :] = chamber_wall_loss_rate\n\nprint(\"Done\")\n</pre> # time steps time_array = np.linspace(start=0, stop=3600, num=1000) dt = time_array[1] - time_array[0]  # create a matrix to store the particle distribution at each time step concentration_matrix = np.zeros((len(time_array), len(radius_bins))) coagulation_net_matrix = np.zeros((len(time_array), len(radius_bins))) dilution_loss_matrix = np.zeros((len(time_array), len(radius_bins))) chamber_wall_loss_rate_matrix = np.zeros((len(time_array), len(radius_bins)))  # set the initial concentration concentration_matrix[0, :] = concentraiton_pmf  kernel = coagulation.brownian_coagulation_kernel_via_system_state(     radius_particle=radius_bins,     mass_particle= mass_particle,     temperature=293.15,     pressure=101325,     alpha_collision_efficiency=1, ) # iterate over the time steps for i, time in enumerate(time_array[1:], start=1):      # calculate the coagulation rate     coagulation_loss = coagulation.discrete_loss(         concentration=concentration_matrix[i-1, :],         kernel=kernel,     )     coagulation_gain = coagulation.discrete_gain(         radius=radius_bins,         concentration=concentration_matrix[i-1, :],         kernel=kernel,     )     coagulation_net = coagulation_gain - coagulation_loss      # calculate the dilution rate     dilution_coefficent = dilution.volume_dilution_coefficient(         volume=1, # m^3         input_flow_rate=2*1e-6, # m^3/s     )     dilution_loss = dilution.dilution_rate(         coefficient=dilution_coefficent,         concentration=concentration_matrix[i-1, :],     )      # calculate the wall loss rate     chamber_wall_loss_rate = wall_loss_rate.rectangle_wall_loss_rate(         wall_eddy_diffusivity=0.1,         particle_radius=radius_bins,         particle_density=1000,         particle_concentration=concentration_matrix[i-1, :],         temperature=293.15,         pressure=101325,         chamber_dimensions=(1, 1, 1),  # m     )      # update the concentration matrix     concentration_matrix[i, :] = concentration_matrix[i-1, :] + (coagulation_net + dilution_loss + chamber_wall_loss_rate) * dt      # update the rate matrices     coagulation_net_matrix[i, :] = coagulation_net     dilution_loss_matrix[i, :] = dilution_loss     chamber_wall_loss_rate_matrix[i, :] = chamber_wall_loss_rate  print(\"Done\") <pre>Done\n</pre> In\u00a0[54]: Copied! <pre># Plotting the simulation results\n# Adjusting the figure size for better clarity\nfig, ax = plt.subplots(1, 1, figsize=[8, 6])\n\n# plot the initial particle distribution\nax.plot(\n    radius_bins,\n    concentration_matrix[0, :],\n    label=\"Initial distribution\",\n)\n# plot the final particle distribution\nax.plot(radius_bins, concentration_matrix[-1, :], label=\"Final distribution\",)\nax.set_xscale(\"log\")\nax.set_xlabel(\"Particle radius (m)\")\nax.set_ylabel(r\"Particle Concentration (dN), $\\dfrac{1}{m^{3}}$\")\nplt.legend()\nplt.show()\n</pre> # Plotting the simulation results # Adjusting the figure size for better clarity fig, ax = plt.subplots(1, 1, figsize=[8, 6])  # plot the initial particle distribution ax.plot(     radius_bins,     concentration_matrix[0, :],     label=\"Initial distribution\", ) # plot the final particle distribution ax.plot(radius_bins, concentration_matrix[-1, :], label=\"Final distribution\",) ax.set_xscale(\"log\") ax.set_xlabel(\"Particle radius (m)\") ax.set_ylabel(r\"Particle Concentration (dN), $\\dfrac{1}{m^{3}}$\") plt.legend() plt.show()  In\u00a0[55]: Copied! <pre># plot the Initial and Final rates\nfig, ax = plt.subplots()\nax.plot(radius_bins, coagulation_net_matrix[0, :], label=\"Initial Coagulation Net\",)\nax.plot(radius_bins, dilution_loss_matrix[0, :], label=\"Initial Dilution Loss\",)\nax.plot(radius_bins, chamber_wall_loss_rate_matrix[0, :], label=\"Initial Chamber Wall Loss\",)\nax.plot(radius_bins, coagulation_net_matrix[-1, :], label=\"Final Coagulation Net\", linestyle=\"--\")\nax.plot(radius_bins, dilution_loss_matrix[-1, :], label=\"Final Dilution Loss\", linestyle=\"--\")\nax.plot(radius_bins, chamber_wall_loss_rate_matrix[-1, :], label=\"Final Chamber Wall Loss\", linestyle=\"--\")\nax.set_xscale(\"log\")\nax.set_xlabel(\"Particle radius (m)\")\nax.set_ylabel(r\"Rate $\\dfrac{1}{m^{3} s^{1}}$\")\nax.grid()\nplt.legend()\nplt.show()\n</pre> # plot the Initial and Final rates fig, ax = plt.subplots() ax.plot(radius_bins, coagulation_net_matrix[0, :], label=\"Initial Coagulation Net\",) ax.plot(radius_bins, dilution_loss_matrix[0, :], label=\"Initial Dilution Loss\",) ax.plot(radius_bins, chamber_wall_loss_rate_matrix[0, :], label=\"Initial Chamber Wall Loss\",) ax.plot(radius_bins, coagulation_net_matrix[-1, :], label=\"Final Coagulation Net\", linestyle=\"--\") ax.plot(radius_bins, dilution_loss_matrix[-1, :], label=\"Final Dilution Loss\", linestyle=\"--\") ax.plot(radius_bins, chamber_wall_loss_rate_matrix[-1, :], label=\"Final Chamber Wall Loss\", linestyle=\"--\") ax.set_xscale(\"log\") ax.set_xlabel(\"Particle radius (m)\") ax.set_ylabel(r\"Rate $\\dfrac{1}{m^{3} s^{1}}$\") ax.grid() plt.legend() plt.show()"},{"location":"How-To-Guides/Chamber_Wall_Loss/Notebooks/Chamber_Forward_Simulation/#chamber-forward-simulation","title":"Chamber Forward Simulation\u00b6","text":"<p>Comprehending particle dynamics within controlled environments is fundamental for the precise interpretation of experimental measurements. An aerosol chamber forward simulation is an approach employed to analyze and predict the behavior of particles under laboratory conditions. This method enables us to construct a virtual representation of the chamber dynamics, providing a platform to systematically examine the influence of different physical and chemical processes on aerosol populations. Specifically, we focus on three key processes: chamber aerosol dilution, particle coagulation, and wall loss (deposition). Each of these plays a pivotal role in shaping the size distribution of particles:</p> <ul> <li>Chamber Aerosol Dilution: Dilution refers to the reduction in particle concentration due to the introduction of clean air into the chamber. This process can lead to a decrease in the overall number of particles without altering the size distribution significantly. However, it can indirectly influence the dynamics of coagulation and deposition by changing the particle concentration.</li> <li>Particle Coagulation: Coagulation is the process where particles collide and stick together, forming larger particles. This leads to a shift in the size distribution towards larger sizes, reducing the number of smaller particles and increasing the average size of particles in the chamber. Coagulation is particularly significant for smaller particles due to their higher Brownian motion and likelihood of interaction.</li> <li>Wall Loss (Deposition): Wall loss occurs when particles deposit onto the walls of the chamber, removing them from the airborne population. This process preferentially affects larger particles due to their greater settling velocity and can lead to a decrease in the overall number of particles and a subtle shift in the size distribution towards smaller sizes.</li> </ul> <p>We'll be running a simulation of a chamber experiment, and turn on/off each of these processes to see how they affect the size distribution of particles. We'll also be able to see how the size distribution changes over time as the experiment progresses.</p> <p>The initial <code>particula</code> imports are next.</p>"},{"location":"How-To-Guides/Chamber_Wall_Loss/Notebooks/Chamber_Forward_Simulation/#initial-distribution","title":"Initial Distribution\u00b6","text":"<p>In this section, we define the initial conditions and parameters for our chamber simulation. The <code>simple_dic_kwargs</code> dictionary contains all the necessary parameters to initialize our particle distribution within the chamber. Here's a breakdown of each parameter:</p> <ul> <li>mode: The median diameter of the particles.</li> <li>geometric_standard_deviation: The geometric standard deviation of the particle size distribution.</li> <li>number_in_mode: The number of particles in the mode.</li> </ul> <p>We define the radius bins, logarithmically, the we can get the particle concentration in a Probability Mass Function (PMF) representation. Or more commonly called <code>dN</code>.</p>"},{"location":"How-To-Guides/Chamber_Wall_Loss/Notebooks/Chamber_Forward_Simulation/#rates","title":"Rates\u00b6","text":"<p>With the initial concentration setup we can now get the rates of change for the distribution of particles. These come from the <code>dynamics</code> module, which contains the functions to calculate the rates of change for each process. The <code>dynamics</code> module contains the following functions:</p> <ul> <li><code>dilution_rate</code>: Calculates the rate of change due to dilution.</li> <li><code>coagulation_rate</code>: Calculates the rate of change due to coagulation.</li> <li><code>wall_loss_rate</code>: Calculates the rate of change due to wall loss.</li> </ul>"},{"location":"How-To-Guides/Chamber_Wall_Loss/Notebooks/Chamber_Forward_Simulation/#for-loop-simulation","title":"For-loop Simulation\u00b6","text":"<p>With the an example of how to calculate the rates of change for each process, we can now simulate the chamber experiment. We'll iterate over a series of time steps and calculate the change in particle concentration due to each process. This is an iterative process where we update the particle distribution at each time step based on the rates of change calculated for dilution, coagulation, and wall loss. The rates are also updated at each time step to account for the changing particle concentration within the chamber.</p>"},{"location":"How-To-Guides/Chamber_Wall_Loss/Notebooks/Chamber_Forward_Simulation/#visualization-of-particle-size-distribution-over-time","title":"Visualization of Particle Size Distribution Over Time\u00b6","text":"<p>In our chamber simulation, the output solution is a matrix representing the evolution of particle size distribution over time. Specifically, the solution is a 500x100 matrix where each row corresponds to a specific particle size (500 size bins in total), and each column represents the particle distribution at a given time point (100 time steps in total).</p> <p>The semi-logarithmic plot visualizes how the particle size distribution changes over the course of the simulation. We are focusing on three specific time points to illustrate these dynamics:</p> <ul> <li>Initial Distribution: This is the distribution at the beginning of the simulation (t=0). It sets the baseline for how particles are initially distributed across different sizes.</li> <li>Mid-Time Distribution: Represents the distribution at a midpoint in time (here, at the 50th time step out of 100). This snapshot provides insight into the evolution of the distribution as particles undergo processes like coagulation, dilution, and wall loss.</li> <li>Final Distribution: Shows the distribution at the end of the simulation (at the 100th time step). It indicates the final state of the particle sizes after all the simulated processes have taken place over the full time course.</li> </ul> <p>By comparing these three distributions, we can observe and analyze how the particle sizes have coalesced, dispersed, or shifted due to the underlying aerosol dynamics within the chamber.</p>"},{"location":"How-To-Guides/Chamber_Wall_Loss/Notebooks/Chamber_Forward_Simulation/#takeaways","title":"Takeaways\u00b6","text":"<p>In this notebook, we conducted a series of simulations to study the behavior of aerosol particles within a controlled chamber environment. Our objective was to understand how different processes \u2014 namely coagulation, dilution, and wall loss \u2014 individually and collectively influence the size distribution of particles over time.</p> <p>Our simulations revealed several key findings:</p> <ul> <li>Coagulation Alone: When only coagulation was considered, the particle size distribution shifted towards larger particles as expected, since smaller particles tend to combine. However, this view was incomplete as it did not account for other loss mechanisms.</li> <li>Importance of Wall Loss: The inclusion of wall loss in the simulations proved to be significant. Wall loss, or deposition, especially affected the larger particles due to their higher probability of contact with the chamber walls. This process led to a noticeable reduction in the number concentration of particles, altering the peak and width of the size distribution.</li> <li>Combined Processes: By simulating a combination of processes, we observed a more complex and realistic representation of particle dynamics. The coagulation plus dilution scenario showed a lower overall concentration across all sizes, while adding wall loss further decreased the number concentration and altered the distribution shape, underscoring the importance of including wall loss in chamber simulations.</li> </ul> <p>The comparison between the different scenarios highlighted that coagulation alone could not fully explain the experimental observations. The absence of wall loss from the simulation would lead to discrepancies when comparing with empirical data, as wall loss is a critical process in chamber dynamics.</p>"},{"location":"How-To-Guides/Chamber_Wall_Loss/Notebooks/Chamber_Observations/","title":"Chamber Observations","text":"In\u00a0[1]: Copied! <pre># all the imports\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom particula.data import loader_interface, settings_generator\nfrom particula.data.tests.example_data.get_example_data import get_data_folder\n\nfrom particula.data import stream_stats\nfrom particula.util import convert, time_manage\n# set the parent directory of the data folders\npath = get_data_folder()\nprint('Path to data folder:')\nprint(path.rsplit('particula')[-1])\n</pre> # all the imports import numpy as np import matplotlib.pyplot as plt from particula.data import loader_interface, settings_generator from particula.data.tests.example_data.get_example_data import get_data_folder  from particula.data import stream_stats from particula.util import convert, time_manage # set the parent directory of the data folders path = get_data_folder() print('Path to data folder:') print(path.rsplit('particula')[-1]) <pre>Path to data folder:\n\\data\\tests\\example_data\n</pre> In\u00a0[2]: Copied! <pre># load the 1d data\nsmps_1d_stream_settings = settings_generator.load_settings_for_stream(\n    path=path,\n    subfolder='chamber_data',\n    settings_suffix='_smps_1d',\n)\nstream_smps_1d = loader_interface.load_files_interface(\n    path=path,\n    settings=smps_1d_stream_settings\n)\n\n# load the 2d data\nsmps_2d_stream_settings = settings_generator.load_settings_for_stream(\n    path=path,\n    subfolder='chamber_data',\n    settings_suffix='_smps_2d',\n)\nstream_smps_2d = loader_interface.load_files_interface(\n    path=path,\n    settings=smps_2d_stream_settings\n)\n\nprint(stream_smps_1d.header)\n</pre> # load the 1d data smps_1d_stream_settings = settings_generator.load_settings_for_stream(     path=path,     subfolder='chamber_data',     settings_suffix='_smps_1d', ) stream_smps_1d = loader_interface.load_files_interface(     path=path,     settings=smps_1d_stream_settings )  # load the 2d data smps_2d_stream_settings = settings_generator.load_settings_for_stream(     path=path,     subfolder='chamber_data',     settings_suffix='_smps_2d', ) stream_smps_2d = loader_interface.load_files_interface(     path=path,     settings=smps_2d_stream_settings )  print(stream_smps_1d.header) <pre>  Loading file: 2023-09-25_160155_SMPS.csv\n  Loading file: 2023-09-25_160155_SMPS.csv\n['Lower_Size_(nm)', 'Upper_Size_(nm)', 'Sample_Temp_(C)', 'Sample_Pressure_(kPa)', 'Relative_Humidity_(%)', 'Median_(nm)', 'Mean_(nm)', 'Geo_Mean_(nm)', 'Mode_(nm)', 'Geo_Std_Dev.', 'Total_Conc_(#/cc)']\n</pre> In\u00a0[3]: Copied! <pre># plot the 1d data\nfig, ax = plt.subplots()\nax.plot(\n    stream_smps_1d.datetime64,\n    stream_smps_1d['Total_Conc_(#/cc)'],\n    label='Concentration'\n)\nplt.xticks(rotation=45)\nax.set_xlabel(\"Time (UTC)\")\nax.set_ylabel('Particle concentration (#/cc)')\nplt.show()\nfig.tight_layout()\n</pre> # plot the 1d data fig, ax = plt.subplots() ax.plot(     stream_smps_1d.datetime64,     stream_smps_1d['Total_Conc_(#/cc)'],     label='Concentration' ) plt.xticks(rotation=45) ax.set_xlabel(\"Time (UTC)\") ax.set_ylabel('Particle concentration (#/cc)') plt.show() fig.tight_layout() In\u00a0[4]: Copied! <pre># 1 convert to dn/dDp\nstream_smps_2d.data = convert.convert_sizer_dn(\n    diameter=np.array(stream_smps_2d.header, dtype=float),\n    dn_dlogdp=stream_smps_2d.data,\n)\n\n# Dilution correction\ndilution_correction = 2\n\n# scale the concentrations\nstream_smps_2d.data *= dilution_correction\nstream_smps_1d['Total_Conc_(#/cc)'] *= dilution_correction\n</pre> # 1 convert to dn/dDp stream_smps_2d.data = convert.convert_sizer_dn(     diameter=np.array(stream_smps_2d.header, dtype=float),     dn_dlogdp=stream_smps_2d.data, )  # Dilution correction dilution_correction = 2  # scale the concentrations stream_smps_2d.data *= dilution_correction stream_smps_1d['Total_Conc_(#/cc)'] *= dilution_correction <p>Plot the distributions</p> In\u00a0[5]: Copied! <pre># plot the 2d data\nfig, ax = plt.subplots()\nax.plot(\n    stream_smps_2d.header_float,\n    stream_smps_2d.data[10, :],\n    label='Concentration earlier'\n)\nax.plot(\n    stream_smps_2d.header_float,\n    stream_smps_2d.data[20, :],\n    label='Concentration later'\n)\nax.set_xscale('log')\nplt.xticks(rotation=45)\nax.set_xlabel(\"Bin diameter (nm)\")\nax.set_ylabel('Particle concentration (#/cc per bin)')\nplt.legend()\nplt.show()\nfig.tight_layout()\n</pre> # plot the 2d data fig, ax = plt.subplots() ax.plot(     stream_smps_2d.header_float,     stream_smps_2d.data[10, :],     label='Concentration earlier' ) ax.plot(     stream_smps_2d.header_float,     stream_smps_2d.data[20, :],     label='Concentration later' ) ax.set_xscale('log') plt.xticks(rotation=45) ax.set_xlabel(\"Bin diameter (nm)\") ax.set_ylabel('Particle concentration (#/cc per bin)') plt.legend() plt.show() fig.tight_layout() <p>Remove the Bad Scans</p> <p>To we'll send the select start and end times to <code>particula.data.stream_stats.remove_time_window</code> to remove the data in that time window.</p> In\u00a0[6]: Copied! <pre># select the time window\nbad_window_start_epoch = time_manage.time_str_to_epoch(\n    time='09-25-2023 19:00:00',\n    time_format='%m-%d-%Y %H:%M:%S',\n    timezone_identifier='UTC'\n)\nbad_window_end_epoch = time_manage.time_str_to_epoch(\n    time='09-25-2023 19:45:00',\n    time_format='%m-%d-%Y %H:%M:%S',\n    timezone_identifier='UTC'\n)\n\nprint(f\"Length of stream before crop: {len(stream_smps_1d)}\")\n# remove the bad data\nstream_smps_1d = stream_stats.remove_time_window(\n    stream=stream_smps_1d,\n    epoch_start=bad_window_start_epoch,\n    epoch_end=bad_window_end_epoch,\n)\nprint(f\"Length of stream after crop: {len(stream_smps_1d)}\")\n# plot the 1d data\nfig, ax = plt.subplots()\nax.plot(\n    stream_smps_1d.datetime64,\n    stream_smps_1d['Total_Conc_(#/cc)'],\n    label='Concentration',\n    marker='.',\n)\nplt.xticks(rotation=45)\nax.set_xlabel(\"Time (UTC)\")\nax.set_ylabel('Particle concentration (#/cc)')\nplt.show()\n</pre>  # select the time window bad_window_start_epoch = time_manage.time_str_to_epoch(     time='09-25-2023 19:00:00',     time_format='%m-%d-%Y %H:%M:%S',     timezone_identifier='UTC' ) bad_window_end_epoch = time_manage.time_str_to_epoch(     time='09-25-2023 19:45:00',     time_format='%m-%d-%Y %H:%M:%S',     timezone_identifier='UTC' )  print(f\"Length of stream before crop: {len(stream_smps_1d)}\") # remove the bad data stream_smps_1d = stream_stats.remove_time_window(     stream=stream_smps_1d,     epoch_start=bad_window_start_epoch,     epoch_end=bad_window_end_epoch, ) print(f\"Length of stream after crop: {len(stream_smps_1d)}\") # plot the 1d data fig, ax = plt.subplots() ax.plot(     stream_smps_1d.datetime64,     stream_smps_1d['Total_Conc_(#/cc)'],     label='Concentration',     marker='.', ) plt.xticks(rotation=45) ax.set_xlabel(\"Time (UTC)\") ax.set_ylabel('Particle concentration (#/cc)') plt.show() <pre>Length of stream before crop: 336\nLength of stream after crop: 321\n</pre> In\u00a0[7]: Copied! <pre>### Repeat the removal for the 2d data\n\nstream_smps_2d = stream_stats.remove_time_window(\n    stream=stream_smps_2d,\n    epoch_start=bad_window_start_epoch,\n    epoch_end=bad_window_end_epoch,\n)\n</pre> ### Repeat the removal for the 2d data  stream_smps_2d = stream_stats.remove_time_window(     stream=stream_smps_2d,     epoch_start=bad_window_start_epoch,     epoch_end=bad_window_end_epoch, ) <p>Crop the Start and End</p> <p>To crop the start and end we can use the same functions as in the previous example. This time the start/end will just be the first and last time in the data.</p> In\u00a0[8]: Copied! <pre># crop start\nexperiment_start_epoch = time_manage.time_str_to_epoch(\n    time='09-25-2023 15:25:00',\n    time_format='%m-%d-%Y %H:%M:%S',\n    timezone_identifier='UTC'\n)\n# crop the end\nexperiment_end_epoch = time_manage.time_str_to_epoch(\n    time='09-26-2023 07:00:00',\n    time_format='%m-%d-%Y %H:%M:%S',\n    timezone_identifier='UTC'\n)\n\n# apply the time window\nstream_smps_1d = stream_stats.select_time_window(\n    stream=stream_smps_1d,\n    epoch_start=experiment_start_epoch,\n    epoch_end=experiment_end_epoch,\n)\nstream_smps_2d = stream_stats.select_time_window(\n    stream=stream_smps_2d,\n    epoch_start=experiment_start_epoch,\n    epoch_end=experiment_end_epoch,\n)\n</pre> # crop start experiment_start_epoch = time_manage.time_str_to_epoch(     time='09-25-2023 15:25:00',     time_format='%m-%d-%Y %H:%M:%S',     timezone_identifier='UTC' ) # crop the end experiment_end_epoch = time_manage.time_str_to_epoch(     time='09-26-2023 07:00:00',     time_format='%m-%d-%Y %H:%M:%S',     timezone_identifier='UTC' )  # apply the time window stream_smps_1d = stream_stats.select_time_window(     stream=stream_smps_1d,     epoch_start=experiment_start_epoch,     epoch_end=experiment_end_epoch, ) stream_smps_2d = stream_stats.select_time_window(     stream=stream_smps_2d,     epoch_start=experiment_start_epoch,     epoch_end=experiment_end_epoch, ) In\u00a0[9]: Copied! <pre># plot the 1d data\nexperiment_time = time_manage.relative_time(\n    epoch_array=stream_smps_1d.time,\n    units='hours',\n)\n\nfig, ax = plt.subplots()\nax.plot(\n    experiment_time,\n    stream_smps_1d['Total_Conc_(#/cc)'],\n    label='Concentration',\n    marker='.',\n)\nplt.xticks(rotation=45)\nax.set_xlabel(\"Experiment time (hours)\")\nax.set_ylabel('Particle concentration (#/cc)')\nplt.show()\n</pre> # plot the 1d data experiment_time = time_manage.relative_time(     epoch_array=stream_smps_1d.time,     units='hours', )  fig, ax = plt.subplots() ax.plot(     experiment_time,     stream_smps_1d['Total_Conc_(#/cc)'],     label='Concentration',     marker='.', ) plt.xticks(rotation=45) ax.set_xlabel(\"Experiment time (hours)\") ax.set_ylabel('Particle concentration (#/cc)') plt.show() In\u00a0[10]: Copied! <pre># Plot the 2d data\n\nfig, ax = plt.subplots(1, 1)\nplt.contourf(\n    experiment_time,\n    stream_smps_2d.header_float,\n    stream_smps_2d.data.T,\n    cmap=plt.cm.PuBu_r, levels=50)\nplt.yscale('log')\nax.set_xlabel('Experiment time (hours)')\nax.set_ylabel('Diameter (nm)')\nplt.colorbar(label='Concentration dN [#/cm3]', ax=ax)\nplt.show()\n</pre> # Plot the 2d data  fig, ax = plt.subplots(1, 1) plt.contourf(     experiment_time,     stream_smps_2d.header_float,     stream_smps_2d.data.T,     cmap=plt.cm.PuBu_r, levels=50) plt.yscale('log') ax.set_xlabel('Experiment time (hours)') ax.set_ylabel('Diameter (nm)') plt.colorbar(label='Concentration dN [#/cm3]', ax=ax) plt.show()"},{"location":"How-To-Guides/Chamber_Wall_Loss/Notebooks/Chamber_Observations/#chamber-observations","title":"Chamber Observations\u00b6","text":"<p>In this example we'll start to look at the aerosols in a smog chamber with a focus on how the size distributions evolves with time. The example data is from a NaCl aerosol experiment in a smog chamber (900 L).</p> <p>The Experiment:</p> <p>After injection of NaCl particles, the chamber was only slowly purged with clean air, so the aerosols would be pushed out to the instruments. The clean air flow was 1.25 LPM. No chemistry was happening in the chamber, so the aerosol size distribution should be stable from a condensation point of view. The aerosol distribution should change due to coagulation, wall losses and dilution.</p> <p>Let's start by loading the data and plotting the size distribution.</p>"},{"location":"How-To-Guides/Chamber_Wall_Loss/Notebooks/Chamber_Observations/#load-the-data","title":"Load the data\u00b6","text":"<p>We'll uses the settings from the Data loading examples, to load the Scanning Mobility Particle Sizer (SMPS) data.</p>"},{"location":"How-To-Guides/Chamber_Wall_Loss/Notebooks/Chamber_Observations/#visualize","title":"Visualize\u00b6","text":"<p>Let's pause to plot the data. We'll plot the size distribution at the start and end of the experiment.</p>"},{"location":"How-To-Guides/Chamber_Wall_Loss/Notebooks/Chamber_Observations/#clean-up-the-data","title":"Clean up the data\u00b6","text":"<p>Now their are a couple things we need to account for from the raw data.</p> <ol> <li>The SMPS data is in dN/dlogDp, but we want dN/dDp. So we need to convert the data.</li> <li>The SMPS sample line was diluted 1:2 with clean air, so we need to account for that.</li> <li>Then we need to remove those couple scans where data jumps crazy high (due to a cpc malfunction), around 1900.</li> <li>We need to select from after the injection starts and before the chamber is purged (that small bump at the end of the data).</li> </ol>"},{"location":"How-To-Guides/Chamber_Wall_Loss/Notebooks/Chamber_Observations/#plot-the-cleaned-data","title":"Plot the Cleaned Data\u00b6","text":"<p>Here, we'll also conver to relative time, so hours since the start of the experiment.</p>"},{"location":"How-To-Guides/Chamber_Wall_Loss/Notebooks/Chamber_Observations/#summary","title":"Summary\u00b6","text":"<p>We've now loaded the data, cleaned it up, and plotted the size distribution. We can see that the size distribution is changing with time. We'll look at accounting for chamber processes, like coagulation, dilution, and wall losses, in the next part.</p>"},{"location":"How-To-Guides/Chamber_Wall_Loss/Notebooks/Chamber_Rates_Fitting/","title":"Chamber Rates Fitting","text":"In\u00a0[1]: Copied! <pre>import numpy as np\n\nimport matplotlib.pyplot as plt\n\nfrom particula.data.process import chamber_rate_fitting, lognormal_2mode\nfrom particula.data import (\n    stream_stats,\n    loader,\n    loader_interface,\n    settings_generator,\n)\n\n# all the imports\nfrom particula.data.tests.example_data.get_example_data import get_data_folder\nfrom particula.util.convert import distribution_convert_pdf_pms\nfrom particula.util import convert, time_manage\nfrom particula.util.input_handling import convert_units\n\n# set the parent directory of the data folders\npath = get_data_folder()\nprint(\"Path to data folder:\")\nprint(path.rsplit(\"particula\")[-1])\n</pre> import numpy as np  import matplotlib.pyplot as plt  from particula.data.process import chamber_rate_fitting, lognormal_2mode from particula.data import (     stream_stats,     loader,     loader_interface,     settings_generator, )  # all the imports from particula.data.tests.example_data.get_example_data import get_data_folder from particula.util.convert import distribution_convert_pdf_pms from particula.util import convert, time_manage from particula.util.input_handling import convert_units  # set the parent directory of the data folders path = get_data_folder() print(\"Path to data folder:\") print(path.rsplit(\"particula\")[-1]) <pre>Path to data folder:\n\\data\\tests\\example_data\n</pre> In\u00a0[2]: Copied! <pre># load the 2d data\nsmps_2d_stream_settings = settings_generator.load_settings_for_stream(\n    path=path,\n    subfolder=\"chamber_data\",\n    settings_suffix=\"_smps_2d\",\n)\nstream_sizer_2d = loader_interface.load_files_interface(\n    path=path, settings=smps_2d_stream_settings\n)\n# 1 convert to dn/dDp\nstream_sizer_2d.data = convert.convert_sizer_dn(\n    diameter=np.array(stream_sizer_2d.header, dtype=float),\n    dn_dlogdp=stream_sizer_2d.data,\n)\n# Dilution correction\ndilution_correction = 2\n# scale the concentrations\nstream_sizer_2d.data *= dilution_correction\n\n# select the time window\nbad_window_start_epoch = time_manage.time_str_to_epoch(\n    time=\"09-25-2023 19:00:00\",\n    time_format=\"%m-%d-%Y %H:%M:%S\",\n    timezone_identifier=\"UTC\",\n)\nbad_window_end_epoch = time_manage.time_str_to_epoch(\n    time=\"09-25-2023 19:45:00\",\n    time_format=\"%m-%d-%Y %H:%M:%S\",\n    timezone_identifier=\"UTC\",\n)\n# remove the bad data\nstream_sizer_2d = stream_stats.remove_time_window(\n    stream=stream_sizer_2d,\n    epoch_start=bad_window_start_epoch,\n    epoch_end=bad_window_end_epoch,\n)\n# remove the first few bins\nstream_sizer_2d.data = stream_sizer_2d.data[:, 20:]\nstream_sizer_2d.header = stream_sizer_2d.header[20:]\n\n# crop start\nexperiment_start_epoch = time_manage.time_str_to_epoch(\n    time=\"09-25-2023 15:25:00\",\n    time_format=\"%m-%d-%Y %H:%M:%S\",\n    timezone_identifier=\"UTC\",\n)\n# crop the end\nexperiment_end_epoch = time_manage.time_str_to_epoch(\n    time=\"09-25-2023 17:00:00\",\n    time_format=\"%m-%d-%Y %H:%M:%S\",\n    timezone_identifier=\"UTC\",\n)  # time=\"09-26-2023 07:00:00\",\n# select the time window\nstream_sizer_2d = stream_stats.select_time_window(\n    stream=stream_sizer_2d,\n    epoch_start=experiment_start_epoch,\n    epoch_end=experiment_end_epoch,\n)\n\n# # save the cleaned data\n# loader.save_stream(\n#     stream=stream_sizer_2d,\n#     path=path,\n#     suffix_name=\"_sizer_2d_cleaned\",\n#     folder=\"chamber_analysis\",\n# )\n\nexperiment_time = time_manage.relative_time(\n    epoch_array=stream_sizer_2d.time,\n    units=\"hours\",\n)\n# Plot the 2d data\nfig, ax = plt.subplots(1, 1)\nplt.contourf(\n    experiment_time,\n    stream_sizer_2d.header_float,\n    stream_sizer_2d.data.T,\n    cmap=plt.cm.PuBu_r,\n    levels=50,\n)\nplt.yscale(\"log\")\nax.set_xlabel(\"Experiment time (hours)\")\nax.set_ylabel(\"Diameter (nm)\")\nax.set_title(\"Concentration vs time\")\nplt.colorbar(label=r\"Concentration $\\dfrac{1}{cm^3}$\", ax=ax)\nplt.show()\n</pre> # load the 2d data smps_2d_stream_settings = settings_generator.load_settings_for_stream(     path=path,     subfolder=\"chamber_data\",     settings_suffix=\"_smps_2d\", ) stream_sizer_2d = loader_interface.load_files_interface(     path=path, settings=smps_2d_stream_settings ) # 1 convert to dn/dDp stream_sizer_2d.data = convert.convert_sizer_dn(     diameter=np.array(stream_sizer_2d.header, dtype=float),     dn_dlogdp=stream_sizer_2d.data, ) # Dilution correction dilution_correction = 2 # scale the concentrations stream_sizer_2d.data *= dilution_correction  # select the time window bad_window_start_epoch = time_manage.time_str_to_epoch(     time=\"09-25-2023 19:00:00\",     time_format=\"%m-%d-%Y %H:%M:%S\",     timezone_identifier=\"UTC\", ) bad_window_end_epoch = time_manage.time_str_to_epoch(     time=\"09-25-2023 19:45:00\",     time_format=\"%m-%d-%Y %H:%M:%S\",     timezone_identifier=\"UTC\", ) # remove the bad data stream_sizer_2d = stream_stats.remove_time_window(     stream=stream_sizer_2d,     epoch_start=bad_window_start_epoch,     epoch_end=bad_window_end_epoch, ) # remove the first few bins stream_sizer_2d.data = stream_sizer_2d.data[:, 20:] stream_sizer_2d.header = stream_sizer_2d.header[20:]  # crop start experiment_start_epoch = time_manage.time_str_to_epoch(     time=\"09-25-2023 15:25:00\",     time_format=\"%m-%d-%Y %H:%M:%S\",     timezone_identifier=\"UTC\", ) # crop the end experiment_end_epoch = time_manage.time_str_to_epoch(     time=\"09-25-2023 17:00:00\",     time_format=\"%m-%d-%Y %H:%M:%S\",     timezone_identifier=\"UTC\", )  # time=\"09-26-2023 07:00:00\", # select the time window stream_sizer_2d = stream_stats.select_time_window(     stream=stream_sizer_2d,     epoch_start=experiment_start_epoch,     epoch_end=experiment_end_epoch, )  # # save the cleaned data # loader.save_stream( #     stream=stream_sizer_2d, #     path=path, #     suffix_name=\"_sizer_2d_cleaned\", #     folder=\"chamber_analysis\", # )  experiment_time = time_manage.relative_time(     epoch_array=stream_sizer_2d.time,     units=\"hours\", ) # Plot the 2d data fig, ax = plt.subplots(1, 1) plt.contourf(     experiment_time,     stream_sizer_2d.header_float,     stream_sizer_2d.data.T,     cmap=plt.cm.PuBu_r,     levels=50, ) plt.yscale(\"log\") ax.set_xlabel(\"Experiment time (hours)\") ax.set_ylabel(\"Diameter (nm)\") ax.set_title(\"Concentration vs time\") plt.colorbar(label=r\"Concentration $\\dfrac{1}{cm^3}$\", ax=ax) plt.show() <pre>  Loading file: 2023-09-25_160155_SMPS.csv\nStream saved: stream_sizer_2d_cleaned.pk\n</pre> In\u00a0[3]: Copied! <pre>radius_m = stream_sizer_2d.header_float / 2 * convert_units(old=\"nm\", new=\"m\")\nconcentration_m3_pmf = stream_sizer_2d.data * convert_units(\n    old=\"1/cm^3\", new=\"1/m^3\"\n)\n\nconcentration_m3_pdf = distribution_convert_pdf_pms(\n    x_array=radius_m,\n    distribution=concentration_m3_pmf,\n    to_pdf=True,\n)\n\n# fit the lognormal pdf distribution with 2 modes\n\nstream_lognormal_prameters = lognormal_2mode.guess_and_optimize_looped(\n    experiment_time=stream_sizer_2d.time,\n    radius_m=radius_m,\n    concentration_m3_pdf=concentration_m3_pdf,\n)\n\n# save the stream to pickle\n# loader.save_stream(\n#     stream=stream_lognormal_prameters,\n#     path=path,\n#     folder=\"chamber_analysis\",\n#     suffix_name=\"_optimized_lognormal_2mode\",\n# )\n# # save to csv\n# loader.save_stream_to_csv(\n#     stream=fitted_stream,\n#     path=path,\n#     folder=\"chamber_analysis\",\n#     suffix_name=\"optimized_lognormal_2mode\",\n# )\n\n# plot the 2 mode lognormal fit\nfig, ax = plt.subplots(1, 1)\nplt.plot(experiment_time, stream_lognormal_prameters[\"R2\"])\nax.set_ylim(0, 1)\nax.set_xlabel(\"Time (hours)\")\nax.set_ylabel(\"R squared\")\nax.set_title(\"R squared of Lognormal 2 mode fit\")\nplt.show()\n</pre> radius_m = stream_sizer_2d.header_float / 2 * convert_units(old=\"nm\", new=\"m\") concentration_m3_pmf = stream_sizer_2d.data * convert_units(     old=\"1/cm^3\", new=\"1/m^3\" )  concentration_m3_pdf = distribution_convert_pdf_pms(     x_array=radius_m,     distribution=concentration_m3_pmf,     to_pdf=True, )  # fit the lognormal pdf distribution with 2 modes  stream_lognormal_prameters = lognormal_2mode.guess_and_optimize_looped(     experiment_time=stream_sizer_2d.time,     radius_m=radius_m,     concentration_m3_pdf=concentration_m3_pdf, )  # save the stream to pickle # loader.save_stream( #     stream=stream_lognormal_prameters, #     path=path, #     folder=\"chamber_analysis\", #     suffix_name=\"_optimized_lognormal_2mode\", # ) # # save to csv # loader.save_stream_to_csv( #     stream=fitted_stream, #     path=path, #     folder=\"chamber_analysis\", #     suffix_name=\"optimized_lognormal_2mode\", # )  # plot the 2 mode lognormal fit fig, ax = plt.subplots(1, 1) plt.plot(experiment_time, stream_lognormal_prameters[\"R2\"]) ax.set_ylim(0, 1) ax.set_xlabel(\"Time (hours)\") ax.set_ylabel(\"R squared\") ax.set_title(\"R squared of Lognormal 2 mode fit\") plt.show() <pre>Lognormal 2-mode: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 32/32 [03:08&lt;00:00,  5.89s/it]\n</pre> <p>Get the new distribution</p> <p>With the new parameters we can now calculate the new distribution. This is also where we can resample. We can change:</p> <ul> <li><code>radius_min</code>: Minimum radius of the distribution</li> <li><code>radius_max</code>: Maximum radius of the distribution</li> <li><code>num_radius_bins</code>: Number of bins in the radius</li> </ul> In\u00a0[5]: Copied! <pre># Create the fitted pmf\n(fitted_pmf_stream, fitted_pmf_concentration) = (\n    lognormal_2mode.create_lognormal_2mode_from_fit(\n        parameters_stream=stream_lognormal_prameters,\n        radius_min=1e-9,\n        radius_max=1e-6,\n        num_radius_bins=250,\n    )\n)\n\n# % Plot the fitted pmf\nfig, ax = plt.subplots(1, 1)\nplt.contourf(\n    experiment_time,\n    fitted_pmf_stream.header_float,\n    fitted_pmf_stream.data.T,\n    cmap=plt.cm.PuBu_r,\n    levels=20,\n)\nplt.yscale(\"log\")\nax.set_xlabel(\"Experiment time (hours)\")\nax.set_ylabel(\"Radius (m)\")\nax.set_title(\"Fitted Concentration PMF\")\nplt.colorbar(label=r\"Concentration $\\dfrac{1}{m^3}$\", ax=ax)\nplt.show()\n</pre> # Create the fitted pmf (fitted_pmf_stream, fitted_pmf_concentration) = (     lognormal_2mode.create_lognormal_2mode_from_fit(         parameters_stream=stream_lognormal_prameters,         radius_min=1e-9,         radius_max=1e-6,         num_radius_bins=250,     ) )  # % Plot the fitted pmf fig, ax = plt.subplots(1, 1) plt.contourf(     experiment_time,     fitted_pmf_stream.header_float,     fitted_pmf_stream.data.T,     cmap=plt.cm.PuBu_r,     levels=20, ) plt.yscale(\"log\") ax.set_xlabel(\"Experiment time (hours)\") ax.set_ylabel(\"Radius (m)\") ax.set_title(\"Fitted Concentration PMF\") plt.colorbar(label=r\"Concentration $\\dfrac{1}{m^3}$\", ax=ax) plt.show()  In\u00a0[12]: Copied! <pre>pmf_derivative_stream = stream_stats.time_derivative_of_stream(\n    stream=fitted_pmf_stream,\n    liner_slope_window_size=10,\n)\n\n# Plot the 2d data\nfig, ax = plt.subplots(1, 1)\nplt.contourf(\n    experiment_time,\n    pmf_derivative_stream.header_float,\n    pmf_derivative_stream.data.T,\n    cmap=plt.cm.PuBu_r,\n    levels=20,\n    vmin=-3e5\n)\nplt.yscale(\"log\")\nax.set_xlabel(\"Experiment time (hours)\")\nax.set_ylabel(\"Radius (m)\")\nax.set_title(\"dN/dt\")\nplt.colorbar(label=r\"Measured Rate $\\dfrac{1}{m^3 s}$\", ax=ax)\nplt.show()\n</pre> pmf_derivative_stream = stream_stats.time_derivative_of_stream(     stream=fitted_pmf_stream,     liner_slope_window_size=10, )  # Plot the 2d data fig, ax = plt.subplots(1, 1) plt.contourf(     experiment_time,     pmf_derivative_stream.header_float,     pmf_derivative_stream.data.T,     cmap=plt.cm.PuBu_r,     levels=20,     vmin=-3e5 ) plt.yscale(\"log\") ax.set_xlabel(\"Experiment time (hours)\") ax.set_ylabel(\"Radius (m)\") ax.set_title(\"dN/dt\") plt.colorbar(label=r\"Measured Rate $\\dfrac{1}{m^3 s}$\", ax=ax) plt.show() In\u00a0[13]: Copied! <pre># %% optimize eddy diffusivity and alpha collision efficiency\n\n# set the chamber properties\nchamber_parameters = chamber_rate_fitting.ChamberParameters()\nchamber_parameters.temperature = 293.15\nchamber_parameters.pressure = 78000\nchamber_parameters.particle_density = 1600\nchamber_parameters.volume = 0.9\nchamber_parameters.input_flow_rate_m3_sec = 1.2 * convert_units(\n    \"L/min\", \"m^3/s\"\n)\nchamber_parameters.chamber_dimensions = (0.739, 0.739, 1.663)\n\nfit_guess, fit_bounds = chamber_rate_fitting.create_guess_and_bounds(\n    guess_eddy_diffusivity=0.1,\n    guess_alpha_collision_efficiency=0.5,\n    bounds_eddy_diffusivity=(1e-2, 50),\n    bounds_alpha_collision_efficiency=(0.1, 1),\n)\n\n# % fit chamber eddy diffusivity and alpha collision efficiency\n(\n    result_stream,\n    coagulation_loss_stream,\n    coagulation_gain_stream,\n    coagulation_net_stream,\n    dilution_loss_stream,\n    wall_loss_rate_stream,\n    total_rate_stream,\n) = chamber_rate_fitting.optimize_and_calculate_rates_looped(\n    pmf_stream=fitted_pmf_stream,\n    pmf_derivative_stream=pmf_derivative_stream,\n    chamber_parameters=chamber_parameters,\n    fit_guess=fit_guess,\n    fit_bounds=fit_bounds,\n)\n</pre> # %% optimize eddy diffusivity and alpha collision efficiency  # set the chamber properties chamber_parameters = chamber_rate_fitting.ChamberParameters() chamber_parameters.temperature = 293.15 chamber_parameters.pressure = 78000 chamber_parameters.particle_density = 1600 chamber_parameters.volume = 0.9 chamber_parameters.input_flow_rate_m3_sec = 1.2 * convert_units(     \"L/min\", \"m^3/s\" ) chamber_parameters.chamber_dimensions = (0.739, 0.739, 1.663)  fit_guess, fit_bounds = chamber_rate_fitting.create_guess_and_bounds(     guess_eddy_diffusivity=0.1,     guess_alpha_collision_efficiency=0.5,     bounds_eddy_diffusivity=(1e-2, 50),     bounds_alpha_collision_efficiency=(0.1, 1), )  # % fit chamber eddy diffusivity and alpha collision efficiency (     result_stream,     coagulation_loss_stream,     coagulation_gain_stream,     coagulation_net_stream,     dilution_loss_stream,     wall_loss_rate_stream,     total_rate_stream, ) = chamber_rate_fitting.optimize_and_calculate_rates_looped(     pmf_stream=fitted_pmf_stream,     pmf_derivative_stream=pmf_derivative_stream,     chamber_parameters=chamber_parameters,     fit_guess=fit_guess,     fit_bounds=fit_bounds, ) <pre>Chamber rates: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 32/32 [02:15&lt;00:00,  4.24s/it]\n</pre> <p>Visualize the results</p> In\u00a0[17]: Copied! <pre># %% plot the optimized rates\n\nfig, ax = plt.subplots(1, 1)\nax.plot(experiment_time, result_stream[\"r2_value\"])\nax.set_ylim(0, 1)\nax.set_xlabel(\"Time (hours)\")\nax.set_ylabel(\"R squared\")\nax.set_title(\"R squared from Rates fit\")\nplt.show()\n\n# plot the optimized values\nfig, ax = plt.subplots(1, 1)\nax.plot(\n    experiment_time,\n    result_stream[\"wall_eddy_diffusivity_[1/s]\"],\n    label=\"Wall eddy diffusivity\",\n)\nax.set_yscale(\"log\")\nax.set_xlabel(\"Time (hours)\")\nax.set_ylabel(\"Wall eddy diffusivity (1/s)\")\nax.set_title(\"Wall eddy diffusivity\")\nplt.legend()\nplt.show()\n\nfig, ax = plt.subplots(1, 1)\nax.plot(\n    experiment_time,\n    result_stream[\"alpha_collision_efficiency_[-]\"],\n    label=\"Alpha collision efficiency\",\n)\nax.set_xlabel(\"Time (hours)\")\nax.set_ylabel(\"Alpha collision efficiency (-)\")\nax.set_title(\"Alpha collision efficiency\")\nplt.legend()\nplt.show()\n\n# plot the rate fractions\nfig, ax = plt.subplots(1, 1)\nax.plot(\n    experiment_time,\n    result_stream[\"coagulation_net_fraction\"],\n    label=\"Coagulation net\",\n)\nax.plot(\n    experiment_time,\n    result_stream[\"dilution_loss_fraction\"],\n    label=\"Dilution loss\",\n)\nax.plot(\n    experiment_time,\n    result_stream[\"wall_loss_rate_fraction\"],\n    label=\"Wall loss\",\n)\nax.set_ylim(0, 1)\nax.set_xlabel(\"Time (hours)\")\nax.set_ylabel(\"Rate fraction\")\nax.set_title(\"Rate fractions\")\nplt.legend()\nplt.show()\n\n# plot the optimized rates\ntime_index = 20\nradius_m_values = fitted_pmf_stream.header_float\nfig, ax = plt.subplots(1, 1)\nplt.plot(\n    radius_m_values,\n    coagulation_net_stream.data[time_index, :],\n    label=\"Coagulation net\",\n)\nplt.plot(\n    radius_m_values, dilution_loss_stream.data[time_index, :], label=\"Dilution\"\n)\nplt.plot(\n    radius_m_values,\n    wall_loss_rate_stream.data[time_index, :],\n    label=\"Wall loss\",\n)\nplt.plot(\n    radius_m_values, total_rate_stream.data[time_index, :], label=\"Total rate\"\n)\nplt.plot(\n    radius_m_values,\n    pmf_derivative_stream.data[time_index, :],\n    label=\"Measured rate\",\n    linestyle=\"--\",\n)\nplt.fill_between(\n    radius_m_values,\n    pmf_derivative_stream.data[time_index, :] * 0.75,\n    pmf_derivative_stream.data[time_index, :] * 1.25,\n    alpha=0.5,\n)\nplt.xscale(\"log\")\nplt.xlabel(\"Diameter (m)\")\nplt.ylabel(r\"Rate $\\dfrac{1}{m^3 s}$\")\nplt.title(\"Rate comparison\")\nplt.legend()\nplt.show()\n</pre> # %% plot the optimized rates  fig, ax = plt.subplots(1, 1) ax.plot(experiment_time, result_stream[\"r2_value\"]) ax.set_ylim(0, 1) ax.set_xlabel(\"Time (hours)\") ax.set_ylabel(\"R squared\") ax.set_title(\"R squared from Rates fit\") plt.show()  # plot the optimized values fig, ax = plt.subplots(1, 1) ax.plot(     experiment_time,     result_stream[\"wall_eddy_diffusivity_[1/s]\"],     label=\"Wall eddy diffusivity\", ) ax.set_yscale(\"log\") ax.set_xlabel(\"Time (hours)\") ax.set_ylabel(\"Wall eddy diffusivity (1/s)\") ax.set_title(\"Wall eddy diffusivity\") plt.legend() plt.show()  fig, ax = plt.subplots(1, 1) ax.plot(     experiment_time,     result_stream[\"alpha_collision_efficiency_[-]\"],     label=\"Alpha collision efficiency\", ) ax.set_xlabel(\"Time (hours)\") ax.set_ylabel(\"Alpha collision efficiency (-)\") ax.set_title(\"Alpha collision efficiency\") plt.legend() plt.show()  # plot the rate fractions fig, ax = plt.subplots(1, 1) ax.plot(     experiment_time,     result_stream[\"coagulation_net_fraction\"],     label=\"Coagulation net\", ) ax.plot(     experiment_time,     result_stream[\"dilution_loss_fraction\"],     label=\"Dilution loss\", ) ax.plot(     experiment_time,     result_stream[\"wall_loss_rate_fraction\"],     label=\"Wall loss\", ) ax.set_ylim(0, 1) ax.set_xlabel(\"Time (hours)\") ax.set_ylabel(\"Rate fraction\") ax.set_title(\"Rate fractions\") plt.legend() plt.show()  # plot the optimized rates time_index = 20 radius_m_values = fitted_pmf_stream.header_float fig, ax = plt.subplots(1, 1) plt.plot(     radius_m_values,     coagulation_net_stream.data[time_index, :],     label=\"Coagulation net\", ) plt.plot(     radius_m_values, dilution_loss_stream.data[time_index, :], label=\"Dilution\" ) plt.plot(     radius_m_values,     wall_loss_rate_stream.data[time_index, :],     label=\"Wall loss\", ) plt.plot(     radius_m_values, total_rate_stream.data[time_index, :], label=\"Total rate\" ) plt.plot(     radius_m_values,     pmf_derivative_stream.data[time_index, :],     label=\"Measured rate\",     linestyle=\"--\", ) plt.fill_between(     radius_m_values,     pmf_derivative_stream.data[time_index, :] * 0.75,     pmf_derivative_stream.data[time_index, :] * 1.25,     alpha=0.5, ) plt.xscale(\"log\") plt.xlabel(\"Diameter (m)\") plt.ylabel(r\"Rate $\\dfrac{1}{m^3 s}$\") plt.title(\"Rate comparison\") plt.legend() plt.show()"},{"location":"How-To-Guides/Chamber_Wall_Loss/Notebooks/Chamber_Rates_Fitting/#chamber-rates-fitting","title":"Chamber Rates Fitting\u00b6","text":"<p>In this notebook we now will use the chamber observations and process simulations to fit the chamber rates. We will use the same approach as in the previous notebook, but now we will fit the rates for each chamber. We will be fitting the free parameters of <code>wall_eddy_diffusivity</code> and <code>alpha_collision_efficiency</code>.</p>"},{"location":"How-To-Guides/Chamber_Wall_Loss/Notebooks/Chamber_Rates_Fitting/#load-and-prepare-data","title":"Load and Prepare Data\u00b6","text":"<p>First we will load the data, clean and prepare it for the fitting of the size distributions.</p>"},{"location":"How-To-Guides/Chamber_Wall_Loss/Notebooks/Chamber_Rates_Fitting/#lognormal-distribution-fitting","title":"Lognormal Distribution Fitting\u00b6","text":"<p>We use a 2-mode lognormal distribution to fit the size distributions. This means we first convert the measured observations to a pdf and then fit the lognormal distribution to it. We will use a machine learning model to guess the initial parameters of the lognormal distribution. Then a scipy optimization routine will be used to optimize the lognormal parameters.</p> <p>The fit parameters are the following:</p> <ul> <li><code>Mode_1</code>: Mode 1 of the lognormal distribution</li> <li><code>Mode_2</code>: Mode 2 of the lognormal distribution</li> <li><code>GSD_1</code>: Geometric standard deviation of mode 1</li> <li><code>GSD_2</code>: Geometric standard deviation of mode 2</li> <li><code>N_1</code>: Number concentration of mode 1</li> <li><code>N_2</code>: Number concentration of mode 2</li> </ul> <p>This is likely the computational part of the notebook, so save the results in a file to avoid running it again. This can be done by uncommenting the <code>save_stream</code> call.</p>"},{"location":"How-To-Guides/Chamber_Wall_Loss/Notebooks/Chamber_Rates_Fitting/#time-derivative","title":"Time Derivative\u00b6","text":"<p>To get the measured rates we need to calculate the time derivative of the size distribution. We will use the linear slope of a moving window to calculate the time derivative. The window size is defined by <code>linear_slope_window_size</code>.</p>"},{"location":"How-To-Guides/Chamber_Wall_Loss/Notebooks/Chamber_Rates_Fitting/#fitting-the-chamber-rates","title":"Fitting the Chamber Rates\u00b6","text":"<p>Now we will fit the chamber rates. We will be fitting the free parameters of <code>wall_eddy_diffusivity</code> and <code>alpha_collision_efficiency</code>. First we define the chamber and its environment. Then we call the optimization routine to fit the missing rates.</p>"},{"location":"How-To-Guides/Chamber_Wall_Loss/Notebooks/Chamber_Rates_Fitting/#conclusion","title":"Conclusion\u00b6","text":"<p>In this notebook we have fitted the chamber rates using the observations and process simulations. We have used a 2-mode lognormal distribution to fit the size distributions and calculated the time derivative of the size distribution to get the rates. We have then fitted the chamber rates using the optimization routine.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/","title":"Index: Data Streams and Lakes BETA","text":"<p>Within Particula, instrument data loading and processing is handled by the <code>particula.data</code> module. This module contains a number of classes and functions that can be used to load and process data from a variety of sources. The <code>particula.data</code> module is designed to be used in conjunction with the <code>particula.model</code> module, which can improve the interpretation of the data.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/#notebooks","title":"Notebooks","text":"<ul> <li>Data Loading Part 1</li> <li>Data Loading Part 2</li> <li>Data Loading Part 3</li> <li>Data Loading Part 4</li> <li>Stream Statistics</li> <li>Stream Statistics Sizer Data</li> </ul>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part1/","title":"Loading Part 1: Into &amp; 1D Data","text":"In\u00a0[2]: Copied! <pre>import os  # For handling file paths and directories\nimport matplotlib.pyplot as plt  # For plotting data\n\n# Importing specific functions from the particula package for data loading\n# and handling\nfrom particula.data import loader, loader_interface\nfrom particula.data.tests.example_data.get_example_data import get_data_folder\nfrom particula.data.loader_setting_builders import (\n    DataChecksBuilder,\n    Loader1DSettingsBuilder,\n)\n</pre>  import os  # For handling file paths and directories import matplotlib.pyplot as plt  # For plotting data  # Importing specific functions from the particula package for data loading # and handling from particula.data import loader, loader_interface from particula.data.tests.example_data.get_example_data import get_data_folder from particula.data.loader_setting_builders import (     DataChecksBuilder,     Loader1DSettingsBuilder, ) In\u00a0[3]: Copied! <pre># Setting up the path for data files\nimport os  # Re-importing os for clarity\nfrom particula.data.tests.example_data.get_example_data import get_data_folder\n\ncurrent_path = os.getcwd()  # Getting the current working directory\nprint('Current path for this script:')\nprint(current_path.rsplit('particula')[-1])  # Displaying the current path\n\npath = get_data_folder()  # Getting the example data folder path\nprint('Path to data folder:')\nprint(path.rsplit('particula')[-1])  # Displaying the data folder path\n</pre> # Setting up the path for data files import os  # Re-importing os for clarity from particula.data.tests.example_data.get_example_data import get_data_folder  current_path = os.getcwd()  # Getting the current working directory print('Current path for this script:') print(current_path.rsplit('particula')[-1])  # Displaying the current path  path = get_data_folder()  # Getting the example data folder path print('Path to data folder:') print(path.rsplit('particula')[-1])  # Displaying the data folder path <pre>Current path for this script:\n\\docs\\examples\\streamlake\\notebooks\nPath to data folder:\n\\data\\tests\\example_data\n</pre> In\u00a0[4]: Copied! <pre>data_file = os.path.join(\n    path,\n    'CPC_3010_data',\n    'CPC_3010_data_20220709_Jul.csv')\n\n# load the data\nraw_data = loader.data_raw_loader(data_file)\n\n# print the first 2 rows\nprint(raw_data[:2])\n</pre> data_file = os.path.join(     path,     'CPC_3010_data',     'CPC_3010_data_20220709_Jul.csv')  # load the data raw_data = loader.data_raw_loader(data_file)  # print the first 2 rows print(raw_data[:2]) <pre>['1657342801,32660,17.1,', '1,0.017']\n</pre> In\u00a0[5]: Copied! <pre># Printing the length of raw_data before cleaning\nprint(f\"raw_data length: {len(raw_data)}\")\n\n# This function needs Data checks dict for:\n# - characters: Ensures each line has between 10 and 100 characters\n# - char_counts: Checks that each line contains 4 commas (this is customizable)\n# - skip_rows: Number of rows to skip at the start (none in this case)\n# - skip_end: Number of rows to skip at the end (none in this case)\n# This can be built using the DataChecksBuilder class\ndata_checks = (\n    DataChecksBuilder()\n    .set_characters([10, 100])\n    .set_char_counts({\",\": 4})\n    .set_skip_rows(0)\n    .set_skip_end(0)\n    .build()\n)\nprint(f\"data checks: {data_checks}\")\n\n# Cleaning the data using loader.data_format_checks\ndata = loader.data_format_checks(\n    data=raw_data,\n    data_checks=data_checks\n)\n\n# Printing the length of data after cleaning\nprint(f\"data length: {len(data)}\")\n\n# Calculating and printing the number of lines removed during the cleaning\n# process\nprint(f\"There was {len(raw_data) - len(data)} lines removed from the data\")\n\n# Note: The data cleaning is performed by the general_data_formatter function for timeseries data.\n# If dealing with 2D data, a separate function is used for cleaning.\n</pre> # Printing the length of raw_data before cleaning print(f\"raw_data length: {len(raw_data)}\")  # This function needs Data checks dict for: # - characters: Ensures each line has between 10 and 100 characters # - char_counts: Checks that each line contains 4 commas (this is customizable) # - skip_rows: Number of rows to skip at the start (none in this case) # - skip_end: Number of rows to skip at the end (none in this case) # This can be built using the DataChecksBuilder class data_checks = (     DataChecksBuilder()     .set_characters([10, 100])     .set_char_counts({\",\": 4})     .set_skip_rows(0)     .set_skip_end(0)     .build() ) print(f\"data checks: {data_checks}\")  # Cleaning the data using loader.data_format_checks data = loader.data_format_checks(     data=raw_data,     data_checks=data_checks )  # Printing the length of data after cleaning print(f\"data length: {len(data)}\")  # Calculating and printing the number of lines removed during the cleaning # process print(f\"There was {len(raw_data) - len(data)} lines removed from the data\")  # Note: The data cleaning is performed by the general_data_formatter function for timeseries data. # If dealing with 2D data, a separate function is used for cleaning. <pre>raw_data length: 33280\ndata checks: {'characters': [10, 100], 'char_counts': {',': 4}, 'skip_rows': 0, 'skip_end': 0}\ndata length: 33254\nThere was 26 lines removed from the data\n</pre> In\u00a0[6]: Copied! <pre># Sample the data to get the epoch times and the data\nepoch_time, data_array = loader.sample_data(\n    data=data,\n    time_column=[0],  # Indicate the column(s) that contain time data.\n                      # For instance, if time data spans multiple columns,\n                      # list them here, like [0, 2] for columns 0 and 2.\n    time_format=\"epoch\",  # Define the format of the time data.\n                          # Use \"epoch\" for epoch time, or specify another format\n                          # compatible with datetime.strptime(), such as\n                          # \"%m/%d/%Y %I:%M:%S %p\".\n    # Specify columns that contain the actual data for analysis.\n    data_columns=[1, 2],\n    # Indicate the delimiter used in the data (e.g., comma for CSV files).\n    delimiter=\",\",\n)\n\n# Printing the shape and first few entries of the epoch time array\nprint(f\"epoch_time shape: {epoch_time.shape}\")\nprint(\"First 5 epoch times:\", epoch_time[:5])\n\n# Printing the shape and first few entries of the data array\nprint(f\"data_array shape: {data_array.shape}\")\nprint(\"First 5 data entries:\", data_array[:5])\n</pre> # Sample the data to get the epoch times and the data epoch_time, data_array = loader.sample_data(     data=data,     time_column=[0],  # Indicate the column(s) that contain time data.                       # For instance, if time data spans multiple columns,                       # list them here, like [0, 2] for columns 0 and 2.     time_format=\"epoch\",  # Define the format of the time data.                           # Use \"epoch\" for epoch time, or specify another format                           # compatible with datetime.strptime(), such as                           # \"%m/%d/%Y %I:%M:%S %p\".     # Specify columns that contain the actual data for analysis.     data_columns=[1, 2],     # Indicate the delimiter used in the data (e.g., comma for CSV files).     delimiter=\",\", )  # Printing the shape and first few entries of the epoch time array print(f\"epoch_time shape: {epoch_time.shape}\") print(\"First 5 epoch times:\", epoch_time[:5])  # Printing the shape and first few entries of the data array print(f\"data_array shape: {data_array.shape}\") print(\"First 5 data entries:\", data_array[:5]) <pre>epoch_time shape: (33254,)\nFirst 5 epoch times: [1.65734280e+09 1.65734281e+09 1.65734281e+09 1.65734281e+09\n 1.65734282e+09]\ndata_array shape: (33254, 2)\nFirst 5 data entries: [[3.3510e+04 1.7000e+01]\n [3.3465e+04 1.7100e+01]\n [3.2171e+04 1.7000e+01]\n [3.2889e+04 1.6800e+01]\n [3.2706e+04 1.7000e+01]]\n</pre> In\u00a0[7]: Copied! <pre># Creating a figure and axis for the plot\nfig, ax = plt.subplots()\n\n# Plotting the data\n# `epoch_time` on the x-axis and the first column of `data_array` on the y-axis\nax.plot(epoch_time,\n        data_array[:, 0],  # Selecting the first column of data_array\n        label=\"data column 1\",  # Label for this data series\n        linestyle=\"none\",  # No line connecting the data points\n        marker=\".\")  # Style of the data points; here, it's a dot\n\n# Setting the x-axis label to \"Time (epoch)\"\nax.set_xlabel(\"Time (epoch)\")\n\n# Setting the y-axis label to \"Data\"\nax.set_ylabel(\"Data\")\n\n# Adding a legend to the plot, which helps identify the data series\nax.legend()\n\n# Displaying the plot\nplt.show()\n\n# Adjusting the layout to make sure everything fits well within the figure\n# This is particularly useful for ensuring labels and titles are not cut off\nfig.tight_layout()\n</pre> # Creating a figure and axis for the plot fig, ax = plt.subplots()  # Plotting the data # `epoch_time` on the x-axis and the first column of `data_array` on the y-axis ax.plot(epoch_time,         data_array[:, 0],  # Selecting the first column of data_array         label=\"data column 1\",  # Label for this data series         linestyle=\"none\",  # No line connecting the data points         marker=\".\")  # Style of the data points; here, it's a dot  # Setting the x-axis label to \"Time (epoch)\" ax.set_xlabel(\"Time (epoch)\")  # Setting the y-axis label to \"Data\" ax.set_ylabel(\"Data\")  # Adding a legend to the plot, which helps identify the data series ax.legend()  # Displaying the plot plt.show()  # Adjusting the layout to make sure everything fits well within the figure # This is particularly useful for ensuring labels and titles are not cut off fig.tight_layout() In\u00a0[8]: Copied! <pre># Using the LoaderSetting1DBuilder class to generate the settings dictionary\n\nsettings = (\n    Loader1DSettingsBuilder()\n    .set_relative_data_folder(\"CPC_3010_data\")\n    .set_filename_regex(\"*.csv\")\n    .set_header_row(0)\n    .set_data_checks(data_checks)  # from above\n    .set_data_column([1, 2])\n    .set_data_header([\"data 1\", \"data 2\"])\n    .set_time_column([0])\n    .set_time_format(\"epoch\")\n    .set_delimiter(\",\")\n    .set_timezone_identifier(\"UTC\")\n    .build()\n)\n\n# Printing the generated settings dictionary to verify its contents\nprint('Settings dictionary:')\nfor key, value in settings.items():\n    print(f'{key}: {value}')\n</pre> # Using the LoaderSetting1DBuilder class to generate the settings dictionary  settings = (     Loader1DSettingsBuilder()     .set_relative_data_folder(\"CPC_3010_data\")     .set_filename_regex(\"*.csv\")     .set_header_row(0)     .set_data_checks(data_checks)  # from above     .set_data_column([1, 2])     .set_data_header([\"data 1\", \"data 2\"])     .set_time_column([0])     .set_time_format(\"epoch\")     .set_delimiter(\",\")     .set_timezone_identifier(\"UTC\")     .build() )  # Printing the generated settings dictionary to verify its contents print('Settings dictionary:') for key, value in settings.items():     print(f'{key}: {value}') <pre>Settings dictionary:\nrelative_data_folder: CPC_3010_data\nfilename_regex: *.csv\nMIN_SIZE_BYTES: 10000\ndata_loading_function: general_1d_load\nheader_row: 0\ndata_checks: {'characters': [10, 100], 'char_counts': {',': 4}, 'skip_rows': 0, 'skip_end': 0}\ndata_column: [1, 2]\ndata_header: ['data 1', 'data 2']\ntime_column: [0]\ntime_format: epoch\ndelimiter: ,\ntime_shift_seconds: 0\ntimezone_identifier: UTC\n</pre> In\u00a0[9]: Copied! <pre># Importing the loader interface from the particula package\nfrom particula.data import loader_interface\nfrom particula.data.tests.example_data.get_example_data import get_data_folder\n\n# Getting the working path where the data files are located\nworking_path = get_data_folder()\n\n# Defining the settings for loading CPC 3010 data\n# These settings were previously generated or can be created manually\ncpc_settings = {\n    # Folder name containing the data files\n    'relative_data_folder': 'CPC_3010_data',\n    # Pattern to match filenames (e.g., all CSV files)\n    'filename_regex': '*.csv',\n    'header_row': 0,  # Row number of the header in the data file\n    'MIN_SIZE_BYTES': 10,  # Minimum file size in bytes for a file to be considered\n    # Function to be used for loading the data\n    'data_loading_function': 'general_1d_load',\n    'header_row': 0,  # Row number of the header in the data file\n    'data_checks': {\n        # Range of character count per line (min, max)\n        'characters': [10, 100],\n        # Number of times a character (comma) should appear in each line\n        'char_counts': {',': 4},\n        'skip_rows': 0,  # Number of rows to skip at the beginning of the file\n        'skip_end': 0  # Number of rows to skip at the end of the file\n    },\n    'data_column': [1, 2],  # Columns in the file that contain the data\n    'data_header': ['data 1', 'data 2'],  # Headers for the data columns\n    'time_column': [0],  # Column in the file that contains the time data\n    'time_format': 'epoch',  # Format of the time data (epoch, ISO 8601, etc.)\n    'delimiter': ',',  # Delimiter used in the data file (e.g., comma for CSV)\n    'time_shift_seconds': 0,  # Shift in time data if needed, in seconds\n    'timezone_identifier': 'UTC'  # Timezone identifier for the time data\n}\n\n# Now call the loader interface to load the data using the specified settings\ndata_stream = loader_interface.load_files_interface(\n    path=working_path,  # Path to the data folder\n    settings=cpc_settings,  # Settings defined above\n)\n\n# The data_stream object now contains the loaded and formatted data ready\n# for analysis\n</pre> # Importing the loader interface from the particula package from particula.data import loader_interface from particula.data.tests.example_data.get_example_data import get_data_folder  # Getting the working path where the data files are located working_path = get_data_folder()  # Defining the settings for loading CPC 3010 data # These settings were previously generated or can be created manually cpc_settings = {     # Folder name containing the data files     'relative_data_folder': 'CPC_3010_data',     # Pattern to match filenames (e.g., all CSV files)     'filename_regex': '*.csv',     'header_row': 0,  # Row number of the header in the data file     'MIN_SIZE_BYTES': 10,  # Minimum file size in bytes for a file to be considered     # Function to be used for loading the data     'data_loading_function': 'general_1d_load',     'header_row': 0,  # Row number of the header in the data file     'data_checks': {         # Range of character count per line (min, max)         'characters': [10, 100],         # Number of times a character (comma) should appear in each line         'char_counts': {',': 4},         'skip_rows': 0,  # Number of rows to skip at the beginning of the file         'skip_end': 0  # Number of rows to skip at the end of the file     },     'data_column': [1, 2],  # Columns in the file that contain the data     'data_header': ['data 1', 'data 2'],  # Headers for the data columns     'time_column': [0],  # Column in the file that contains the time data     'time_format': 'epoch',  # Format of the time data (epoch, ISO 8601, etc.)     'delimiter': ',',  # Delimiter used in the data file (e.g., comma for CSV)     'time_shift_seconds': 0,  # Shift in time data if needed, in seconds     'timezone_identifier': 'UTC'  # Timezone identifier for the time data }  # Now call the loader interface to load the data using the specified settings data_stream = loader_interface.load_files_interface(     path=working_path,  # Path to the data folder     settings=cpc_settings,  # Settings defined above )  # The data_stream object now contains the loaded and formatted data ready # for analysis <pre>  Loading file: CPC_3010_data_20220709_Jul.csv\n  Loading file: CPC_3010_data_20220710_Jul.csv\n</pre> In\u00a0[10]: Copied! <pre># Example 1: Print the Headers of the Data Stream\nprint(\"Headers of the Data Stream:\")\nprint(data_stream.header)\n\n# Example 2: Display the First Few Rows of Data\nprint(\"\\nFirst 5 Rows of Data:\")\nprint(data_stream.data[:5, :])\n\n# Example 3: Print the Time Stamps Associated with the First Few Data Entries\nprint(\"\\nTime Stamps for the First 5 Data Entries:\")\nprint(data_stream.time[:5])\n\n# Example 4: Retrieve and Print Data from a Specific Column using Header Name\ncolumn_name = 'data 1'  # Replace with an actual column name from your header\nprint(f\"\\n5 Entries from data Column '{column_name}':\")\nprint(data_stream[column_name][:5])\n\n# Example 5: Print the Length of the Time Stream (Number of Data Entries)\nprint(\"\\nNumber of Data Entries in the Time Stream:\")\nprint(len(data_stream))\n\n# Example 6: Convert Time to datetime64 and Print the First Few Entries\nprint(\"\\nFirst 5 Time Entries in datetime64 Format:\")\nprint(data_stream.datetime64[:5])\n\n# Example 7: Print the Names of the Source Files\nprint(\"\\nNames of the Source Files for the Data Stream:\")\nprint(data_stream.files)\n</pre> # Example 1: Print the Headers of the Data Stream print(\"Headers of the Data Stream:\") print(data_stream.header)  # Example 2: Display the First Few Rows of Data print(\"\\nFirst 5 Rows of Data:\") print(data_stream.data[:5, :])  # Example 3: Print the Time Stamps Associated with the First Few Data Entries print(\"\\nTime Stamps for the First 5 Data Entries:\") print(data_stream.time[:5])  # Example 4: Retrieve and Print Data from a Specific Column using Header Name column_name = 'data 1'  # Replace with an actual column name from your header print(f\"\\n5 Entries from data Column '{column_name}':\") print(data_stream[column_name][:5])  # Example 5: Print the Length of the Time Stream (Number of Data Entries) print(\"\\nNumber of Data Entries in the Time Stream:\") print(len(data_stream))  # Example 6: Convert Time to datetime64 and Print the First Few Entries print(\"\\nFirst 5 Time Entries in datetime64 Format:\") print(data_stream.datetime64[:5])  # Example 7: Print the Names of the Source Files print(\"\\nNames of the Source Files for the Data Stream:\") print(data_stream.files) <pre>Headers of the Data Stream:\n['data 1', 'data 2']\n\nFirst 5 Rows of Data:\n[[3.3510e+04 1.7000e+01]\n [3.3465e+04 1.7100e+01]\n [3.2171e+04 1.7000e+01]\n [3.2889e+04 1.6800e+01]\n [3.2706e+04 1.7000e+01]]\n\nTime Stamps for the First 5 Data Entries:\n[1.65734280e+09 1.65734281e+09 1.65734281e+09 1.65734281e+09\n 1.65734282e+09]\n\n5 Entries from data Column 'data 1':\n[33510. 33465. 32171. 32889. 32706.]\n\nNumber of Data Entries in the Time Stream:\n68551\n\nFirst 5 Time Entries in datetime64 Format:\n['2022-07-09T05:00:04' '2022-07-09T05:00:07' '2022-07-09T05:00:10'\n '2022-07-09T05:00:13' '2022-07-09T05:00:16']\n\nNames of the Source Files for the Data Stream:\n[['CPC_3010_data_20220709_Jul.csv', 1044534], ['CPC_3010_data_20220710_Jul.csv', 1113488]]\n</pre> In\u00a0[11]: Copied! <pre># Importing the matplotlib library for plotting\nimport matplotlib.pyplot as plt\n\n# Creating a new figure and axis for the plot\nfig, ax = plt.subplots()\n\n# Plotting data from the data_stream object\n# data_stream.datetime64 is used for the x-axis (time data)\n# data_stream.data[:, 0] selects the first column of data for the y-axis\nax.plot(data_stream.datetime64,\n        data_stream.data[:, 0],  # Selecting the first column of data\n        label=\"data column 1\",  # Label for the plotted data series\n        linestyle=\"none\",  # No line connecting the data points\n        marker=\".\")  # Style of the data points; here, it's a dot\n\n# Adjusting the x-axis labels for better readability\n# Rotating the labels by -35 degrees\nplt.tick_params(rotation=-35, axis='x')\n\n# Setting the labels for the x-axis and y-axis\nax.set_xlabel(\"Time (UTC)\")  # Label for the x-axis\nax.set_ylabel(\"Data\")  # Label for the y-axis\n\n# Adding a legend to the plot\n# This helps in identifying the data series\nax.legend()\n\n# Displaying the plot\nplt.show()\n\n# Adjusting the layout of the plot\n# Ensures that all elements of the plot are nicely fitted within the figure\nfig.tight_layout()\n</pre> # Importing the matplotlib library for plotting import matplotlib.pyplot as plt  # Creating a new figure and axis for the plot fig, ax = plt.subplots()  # Plotting data from the data_stream object # data_stream.datetime64 is used for the x-axis (time data) # data_stream.data[:, 0] selects the first column of data for the y-axis ax.plot(data_stream.datetime64,         data_stream.data[:, 0],  # Selecting the first column of data         label=\"data column 1\",  # Label for the plotted data series         linestyle=\"none\",  # No line connecting the data points         marker=\".\")  # Style of the data points; here, it's a dot  # Adjusting the x-axis labels for better readability # Rotating the labels by -35 degrees plt.tick_params(rotation=-35, axis='x')  # Setting the labels for the x-axis and y-axis ax.set_xlabel(\"Time (UTC)\")  # Label for the x-axis ax.set_ylabel(\"Data\")  # Label for the y-axis  # Adding a legend to the plot # This helps in identifying the data series ax.legend()  # Displaying the plot plt.show()  # Adjusting the layout of the plot # Ensures that all elements of the plot are nicely fitted within the figure fig.tight_layout() In\u00a0[12]: Copied! <pre># call help on data_stream to see the available methods\nhelp(data_stream)\n</pre> # call help on data_stream to see the available methods help(data_stream) <pre>Help on Stream in module particula.data.stream object:\n\nclass Stream(builtins.object)\n |  Stream(header: List[str] = &lt;factory&gt;, data: numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]] = &lt;factory&gt;, time: numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]] = &lt;factory&gt;, files: List[str] = &lt;factory&gt;) -&gt; None\n |  \n |  Consistent format for storing data.\n |  \n |  Represents a consistent format for storing and managing data streams\n |  within a list. Similar to pandas but with tighter control over the\n |  data allowed and expected format.\n |  \n |  Attributes:\n |      header: Headers of the data stream, each a string.\n |      data: 2D numpy array where rows are timepoints and columns\n |          correspond to headers.\n |      time: 1D numpy array representing the time points of the data stream.\n |      files: List of filenames that contain the data stream.\n |  \n |  Methods:\n |      validate_inputs: Validates the types of class inputs.\n |      __getitem__(index): Returns the data at the specified index.\n |      __setitem__(index, value): Sets or updates data at the specified index.\n |      __len__(): Returns the length of the time stream.\n |      datetime64: Converts time stream to numpy datetime64 array for plots.\n |      header_dict: Provides a dictionary mapping of header indices to names.\n |      header_float: Converts header names to a numpy array of floats.\n |  \n |  Methods defined here:\n |  \n |  __eq__(self, other)\n |      Return self==value.\n |  \n |  __getitem__(self, index: Union[int, str]) -&gt; numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]]\n |      Gets data at a specified index or header name.\n |      \n |      Allows indexing of the data stream using an integer index or a string\n |      corresponding to the header. If a string is used, the header index is\n |      retrieved and used to return the data array. Only one str\n |      argument is allowed. A list of int is allowed.\n |      \n |      Args:\n |          index: The index or name of the data column to\n |              retrieve.\n |      \n |      Returns:\n |          np.ndarray: The data array at the specified index.\n |  \n |  __init__(self, header: List[str] = &lt;factory&gt;, data: numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]] = &lt;factory&gt;, time: numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]] = &lt;factory&gt;, files: List[str] = &lt;factory&gt;) -&gt; None\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  __len__(self) -&gt; int\n |      Returns the number of time points in the data stream.\n |      \n |      Returns:\n |          int: Length of the time stream.\n |  \n |  __pop__(self, index: Union[int, str]) -&gt; None\n |      Removes data at a specified index or header name.\n |      \n |      Allows indexing of the data stream using an integer index or a string\n |      corresponding to the header. If a string is used, the header index is\n |      retrieved and used to return the data array. Only one str\n |      argument is allowed. A list of int is allowed.\n |      \n |      Args:\n |          index: The index or name of the data column to\n |              retrieve.\n |  \n |  __post_init__(self)\n |  \n |  __repr__(self)\n |      Return repr(self).\n |  \n |  __setitem__(self, index: Union[int, str], value: numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]])\n |      Sets or adds data at a specified index.\n |      \n |      If index is a string and not in headers, it is added. This is used\n |      to add new data columns to the stream.\n |      \n |      Args:\n |          index: The index or name of the data column to set.\n |          value: The data to set at the specified index.\n |      \n |      Notes:\n |          Support setting multiple rows by accepting a list of values.\n |  \n |  validate_inputs(self)\n |      Validates that header is a list.\n |      \n |      Raises:\n |          TypeError: If `header` is not a list.\n |  \n |  ----------------------------------------------------------------------\n |  Readonly properties defined here:\n |  \n |  datetime64\n |      Converts the epoch time array to a datetime64 for plotting.\n |      \n |      This method converts the time array to a datetime64 array, which\n |      can be used for plotting time series data. This generally assumes\n |      that the time array is in seconds since the epoch.\n |      \n |      Returns:\n |          np.ndarray: Datetime64 array representing the time stream.\n |  \n |  header_dict\n |      Provides a dictionary mapping from index to header names.\n |      \n |      Returns:\n |          dict: Dictionary with indices as keys and header names as values.\n |  \n |  header_float\n |      Attempts to convert header names to a float array, where possible.\n |      \n |      Returns:\n |          np.ndarray: Array of header names converted to floats.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |  \n |  __dict__\n |      dictionary for instance variables\n |  \n |  __weakref__\n |      list of weak references to the object\n |  \n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |  \n |  __annotations__ = {'data': numpy.ndarray[typing.Any, numpy.dtype[numpy...\n |  \n |  __dataclass_fields__ = {'data': Field(name='data',type=numpy.ndarray[t...\n |  \n |  __dataclass_params__ = _DataclassParams(init=True,repr=True,eq=True,or...\n |  \n |  __hash__ = None\n |  \n |  __match_args__ = ('header', 'data', 'time', 'files')\n\n</pre>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part1/#loading-part-1-into-1d-data","title":"Loading Part 1: Into &amp; 1D Data\u00b6","text":"<p>This notebook is designed to guide you through the process of loading, cleaning, formatting, and processing data, a common task in aerosol research. You'll learn how to automate these repetitive tasks using Python scripts, specifically leveraging the functionalities of the <code>particula.data</code> package. This will streamline your data handling process, making your research more efficient.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part1/#setting-the-working-path","title":"Setting the Working Path\u00b6","text":"<p>The first step in data processing is to set the working path where your data files are located. In this example, we'll use example data from the data/examples directory. However, you can easily adapt this to point to any directory on your computer.</p> <p>For instance, if you have a data folder in your home directory, you might set the path like this: <code>path = \"U:\\\\data\\\\processing\\\\Campaign2023_of_awesome\\\\data\"</code></p> <p>This flexibility allows you to work with data stored in different locations on your computer.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part1/#importing-packages","title":"Importing Packages\u00b6","text":"<p>Before we get started, we need to import the packages we'll be using.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part1/#loading-the-data","title":"Loading the Data\u00b6","text":"<p>With the working directory set, we're ready to load the data. For this task, we'll use the <code>loader</code> module from the <code>particula</code> package. The <code>loader.data_raw_loader()</code> function allows us to easily load data files by providing the file path. This simplifies the initial step of any data analysis process, especially for those new to Python.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part1/#clean-up-data","title":"Clean Up Data\u00b6","text":"<p>To facilitate data cleaning, we utilize <code>loader.data_format_checks</code>. This function performs a series of checks on the data, ensuring it meets specified criteria. The checks include:</p> <ul> <li><code>characters</code>: Validates the minimum and maximum number of characters in each data line, ensuring data integrity and uniformity.</li> <li><code>char_counts</code>: Counts the occurrences of specific characters in each line. This is defined in a dictionary, with characters as keys and their expected counts as values.</li> <li><code>skip_rows</code>: Specifies the number of rows to skip at the beginning of the file, useful for bypassing headers or non-data lines.</li> <li><code>skip_end</code>: Determines the number of rows to omit at the end of the file, often used to avoid reading summary or footer information.</li> </ul> <p>After performing these checks, the function returns a list of data that has passed all the criteria. This cleaned data is then ready for further analysis or processing.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part1/#data-and-time","title":"Data and Time\u00b6","text":"<p>Once the data is cleaned, the next crucial step is extracting and standardizing the time and data columns. This process is particularly important because time data can come in many formats, and standardizing it to a single format, like epoch time, facilitates analysis and comparison. Epoch time, also known as Unix time, is a system for describing points in time as the number of seconds elapsed since January 1, 1970. It's a widely used standard in computing and data processing.</p> <p>To handle the conversion and extraction of time and data, we use the <code>loader.sample_data()</code> function. This function is designed to:</p> <ol> <li>Identify and Extract Time Data: It locates the time information within the dataset, which can be in various formats such as ISO 8601, DD/MM/YYYY, MM/DD/YYYY, etc.</li> <li>Convert to Epoch Time: It standardizes the extracted time data to epoch time. This conversion is crucial because epoch time provides a consistent reference for time data, making it easier to perform time-based calculations and comparisons.</li> <li>Separate Data Columns: Along with time data, it also segregates other data columns for further analysis.</li> </ol> <p>By using <code>loader.sample_data()</code> to convert various time formats to epoch time and separate the data columns, we effectively prepare our dataset for robust and error-free analysis. This approach is essential in research and data science, where dealing with multiple time formats is a common challenge.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part1/#pause-to-plot-verifying-data-integrity","title":"Pause to Plot: Verifying Data Integrity\u00b6","text":"<p>After successfully importing the data and converting time information, it's crucial to pause and visually inspect our dataset. Plotting the data serves as an essential checkpoint to verify that the import process has been executed correctly. This step is vital for several reasons:</p> <ol> <li><p>Data Integrity Check: Visualizing the data helps in quickly identifying any anomalies or irregularities that might indicate issues in the data import or cleaning processes.</p> </li> <li><p>Understanding Data Structure: A plot can provide immediate insights into the nature and structure of the dataset, such as trends, patterns, and outliers.</p> </li> <li><p>Ensuring Accuracy: Before proceeding to more complex analyses or modeling, confirming the accuracy of the data through visualization is a fundamental best practice.</p> </li> </ol> <p>In this section, we will create a simple plot to examine our time series data, ensuring that the time conversion and data import have been performed correctly.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part1/#stream-object-streamlining-your-analysis","title":"Stream Object: Streamlining Your Analysis\u00b6","text":"<p>Once you have the cleaned and formatted data, you might find yourself repeatedly using the same code to analyze different datasets. To avoid the tedium of copying and pasting the same code, we can utilize the <code>Stream</code> object provided by the <code>loader</code> module. The <code>Stream</code> object allows for more automated and efficient analysis, significantly simplifying repetitive tasks.</p> <p>The <code>Stream</code> object requires a settings dictionary that encapsulates all necessary parameters for data loading. Below, we'll explore how to create this settings dictionary and use it to initialize a <code>Stream</code> object.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part1/#settings-dictionary-centralizing-data-loading-parameters","title":"Settings Dictionary: Centralizing Data Loading Parameters\u00b6","text":"<p>The settings dictionary is a crucial component in the data loading process. It consolidates all the necessary settings for loading your data into a single, easily manageable structure. This includes parameters for data checks, specification of time and data columns, as well as the time format.</p> <p>There are two primary methods to generate this settings dictionary:</p> <ol> <li><p>Using <code>LoaderSetting1DBuilder</code>: This is a builder class that simplifies the creation of the settings dictionary. It provides a structured approach to defining the settings, ensuring that all required parameters are included. This method is particularly useful for beginners or those looking for a more guided approach.</p> </li> <li><p>Manual Creation: Alternatively, you can manually construct the settings dictionary. This might involve writing the dictionary from scratch or modifying one generated by the <code>settings_generator</code> module. Manual creation offers more flexibility and is particularly useful if your data loading requirements are unique or complex.</p> </li> </ol> <p>In the next steps, we will demonstrate how to use the settings dictionary for loading data into a <code>Stream</code> object.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part1/#load-the-data-with-the-interface","title":"Load the Data with the Interface\u00b6","text":"<p>With our settings dictionary in hand, we can now streamline the data loading process using a specialized interface. This interface acts as a bridge between our predefined settings and the actual data loading steps. It essentially automates the sequence of actions we performed manually earlier, like data cleaning and formatting, based on the parameters specified in the settings dictionary.</p> <p>By utilizing this interface, we can efficiently load our data with a few lines of code, ensuring consistency and accuracy. This approach is particularly beneficial when dealing with multiple datasets or when needing to replicate the same data processing steps in different projects.</p> <p>The interface function we'll use is designed to accept the settings dictionary and the location of the data. It then internally calls the necessary functions to execute the data loading process. This includes:</p> <ul> <li>Reading the data files based on the specified filename patterns and folder locations.</li> <li>Performing data checks and cleaning as defined in the settings.</li> <li>Extracting and formatting time and data columns according to our requirements.</li> </ul> <p>This method significantly simplifies the data loading process, reducing the potential for errors and increasing efficiency.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part1/#exploring-the-stream-class-in-particula","title":"Exploring the Stream Class in Particula\u00b6","text":"<p>The <code>Stream</code> class in the Particula package is a sophisticated tool for data management, akin to a well-organized filing cabinet for your data. Let's dive into its features and functionalities to understand how it can streamline your data analysis tasks.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part1/#key-features-of-the-stream-class","title":"Key Features of the Stream Class\u00b6","text":"<ul> <li><p>Header: Just as labels on filing cabinet drawers help you identify contents, the <code>header</code> in <code>Stream</code> serves a similar purpose. It's a list of strings that represent the column names of your data, guiding you to understand what each column in your dataset signifies.</p> </li> <li><p>Data: Imagine each drawer in a filing cabinet filled with files; <code>data</code> in <code>Stream</code> is akin to this. It's a numpy array containing your dataset, neatly organized where each row represents a point in time and each column corresponds to one of the headers.</p> </li> <li><p>Time: Like time tags on files that show when they were recorded, the <code>time</code> attribute in <code>Stream</code> keeps a chronological record of each data entry. It\u2019s a numpy array that represents the time dimension of your data, correlating each row in the <code>data</code> array with a specific moment.</p> </li> <li><p>Files: Similar to having a list that tells you about all the folders inside a filing cabinet, <code>files</code> in <code>Stream</code> reveals the names of all the data files that comprise your data stream. This list of strings provides a clear trace back to the original data sources.</p> </li> </ul>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part1/#functionalities-and-tools","title":"Functionalities and Tools\u00b6","text":"<ul> <li><p>validate_inputs: This function acts like a checklist ensuring all your files are correctly formatted before being placed in the cabinet. In <code>Stream</code>, it checks the validity of header, data, and time inputs, ensuring everything is in order for smooth data handling.</p> </li> <li><p>datetime64: Think of it as a tool that standardizes the dates and times on your documents into a uniform format (datetime64), making them easier to understand and use, particularly for plotting and time-based operations.</p> </li> <li><p>return_header_dict: It\u2019s like having a quick reference guide in your filing cabinet, telling you exactly where to find data corresponding to each label (header). In <code>Stream</code>, it offers a dictionary mapping header elements to their indices in the data array, simplifying data access.</p> </li> </ul>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part1/#practical-application","title":"Practical Application\u00b6","text":"<p>For beginners and experienced users alike, the Stream class in Particula package is your organized, efficient data manager. It takes the complexity out of data handling, allowing you to focus more on insightful analysis and less on the intricacies of data organization.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part1/#plotting-data-using-the-stream-object","title":"Plotting Data Using the Stream Object\u00b6","text":"<p>Visualizing your data is a crucial step in understanding its patterns and behavior. With the <code>data_stream</code> object from the Particula package, plotting time-series data becomes straightforward and efficient. Here's how you can use <code>data_stream</code> for plotting:</p> <ol> <li><p>Preparing the Plot: Start by creating a figure and an axis using <code>matplotlib</code>'s <code>plt.subplots()</code>. This sets up the canvas on which you'll draw your plot.</p> </li> <li><p>Plotting Time-Series Data:</p> <ul> <li>The <code>data_stream.datetime64</code> provides time data in a format that is ideal for plotting on the x-axis.</li> <li>Since <code>data_stream.data</code> is a 2D array (where rows correspond to time and columns to different data types), you need to specify which column you want to plot. For example, <code>data_stream.data[:, 0]</code> plots the first column of data.</li> </ul> </li> <li><p>Customizing the Plot:</p> <ul> <li>Add labels to your plot for clarity. The <code>label</code> parameter in the <code>ax.plot</code> function can be used to name the data series being plotted.</li> <li>Customize the appearance of your plot. In this example, we use <code>linestyle=\"none\"</code> and <code>marker=\".\"</code> to plot individual data points without connecting lines.</li> </ul> </li> <li><p>Adjusting Axes and Display:</p> <ul> <li>The <code>plt.tick_params</code> function allows you to rotate the x-axis labels, making them easier to read, especially for densely plotted data.</li> <li>Set the x-axis and y-axis labels using <code>ax.set_xlabel</code> and <code>ax.set_ylabel</code> to provide context to your plot.</li> </ul> </li> <li><p>Final Touches:</p> <ul> <li>Include a legend by calling <code>ax.legend()</code>. This is particularly useful when plotting multiple data series.</li> <li>Use <code>plt.show()</code> to display the plot.</li> <li>The <code>fig.tight_layout()</code> ensures that the layout of the plot is adjusted so that all elements (like labels and titles) are clearly visible.</li> </ul> </li> </ol>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part1/#summary","title":"Summary\u00b6","text":"<p>In this section, we explored a comprehensive approach to handling data using the functionalities provided by the Particula package. Key takeaways include:</p> <ol> <li><p>Data Loading and Cleaning: We began by loading data from files, emphasizing the importance of automating the cleaning process. This step involved removing errors, handling missing values, and ensuring the data is in a consistent format, which is crucial for accurate analysis.</p> </li> <li><p>Using the Settings Dictionary: A significant part of the process was the creation of a settings dictionary. This dictionary serves as a blueprint for the data loading process, specifying parameters like data checks, column information, and time formatting. This approach is particularly effective when working with large datasets or needing to replicate data processing steps across various projects.</p> </li> <li><p>Streamlining with the Stream Object: We introduced the <code>Stream</code> object, a powerful tool for organizing and processing data streams. The <code>Stream</code> object allows for efficient data manipulation, storage, and retrieval, making it an invaluable resource for handling complex or voluminous datasets.</p> </li> <li><p>Simplifying Repetitive Tasks: By automating data loading and cleaning through the <code>Stream</code> object and settings dictionary, we significantly reduced the redundancy of repetitive tasks. This method proves beneficial in projects where data from multiple files needs to be loaded and combined into a single, manageable unit.</p> </li> <li><p>Visualization and Analysis: Finally, we demonstrated how to plot the data using <code>matplotlib</code>, a crucial step for visually inspecting the data and ensuring its integrity post-import. This visual check is vital for confirming that the import process has been executed correctly and the data is ready for further analysis.</p> </li> </ol> <p>In conclusion, this section provided a solid foundation for efficiently managing and processing data in Python, setting the stage for more advanced analysis and applications in future sections.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part1/#bonus-utilizing-pythons-help-function","title":"Bonus: Utilizing Python's Help Function\u00b6","text":"<p>One of Python's most useful built-in functions for learners and developers alike is the <code>help</code> function. It provides detailed information about objects, functions, modules, and more, directly within your Python environment. This can be particularly helpful when exploring new libraries or understanding the functionalities of different components in your code.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part1/#how-to-use-the-help-function","title":"How to Use the Help Function\u00b6","text":"<p>The <code>help</code> function can be invoked directly in your Python code or interactive session. Simply pass the object or function you're curious about as an argument to <code>help()</code>, and it will display documentation including descriptions, available methods, attributes, and other relevant details.</p> <p>For example, to learn more about the <code>data_stream</code> object we've been working with, you can use:</p> <pre>help(data_stream)\n</pre> <p>This command will display information about the Stream class, including its methods, attributes, and how to use them.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part1/#applying-help-to-explore-functionality","title":"Applying Help to Explore Functionality\u00b6","text":"<p>You can use help with any object or function in Python. For instance, if you want to understand more about a function from the Particula package or even a built-in Python function, simply pass it to help(). Here's how you can use it:</p> <p>To explore a module: help(particula) To learn about a specific function: help(particula.some_function) To understand an object you created: help(my_object) Enhancing Learning and Troubleshooting Using the help function is an excellent habit to develop. It enhances your learning process by providing immediate access to documentation. It's also a valuable tool for troubleshooting and understanding the functionalities of different components in your code.</p> <p>Remember, the help function is always there to assist you, making it a bit easier to navigate the extensive world of Python programming.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part2/","title":"Formatting the Data","text":"In\u00a0[1]: Copied! <pre>import os  # For handling file and directory paths\nimport numpy as np  # For numerical operations\nimport matplotlib.pyplot as plt  # For plotting and visualizing data\n# Particula package components\nfrom particula.data import loader, loader_interface\nfrom particula.data.loader_setting_builders import (\n    SizerDataReaderBuilder,\n    LoaderSizerSettingsBuilder,\n    DataChecksBuilder,\n)\n# For accessing example data\nfrom particula.data.tests.example_data.get_example_data import get_data_folder\n</pre> import os  # For handling file and directory paths import numpy as np  # For numerical operations import matplotlib.pyplot as plt  # For plotting and visualizing data # Particula package components from particula.data import loader, loader_interface from particula.data.loader_setting_builders import (     SizerDataReaderBuilder,     LoaderSizerSettingsBuilder,     DataChecksBuilder, ) # For accessing example data from particula.data.tests.example_data.get_example_data import get_data_folder <p>Now, we'll determine the current working directory and set the path for the data folder. This step is essential for ensuring that our scripts know where to look for the data files.</p> In\u00a0[2]: Copied! <pre># Retrieving and printing the current working directory of this script\ncurrent_path = os.getcwd()\nprint('Current path for this script:')\nprint(current_path.rsplit('particula')[-1])\n\n# Setting and printing the path to the data folder\npath = get_data_folder()\nprint('Path to data folder:')\nprint(path.rsplit('particula')[-1])\n</pre> # Retrieving and printing the current working directory of this script current_path = os.getcwd() print('Current path for this script:') print(current_path.rsplit('particula')[-1])  # Setting and printing the path to the data folder path = get_data_folder() print('Path to data folder:') print(path.rsplit('particula')[-1]) <pre>Current path for this script:\n\\docs\\examples\\streamlake\\notebooks\nPath to data folder:\n\\data\\tests\\example_data\n</pre> In\u00a0[3]: Copied! <pre># Constructing the full file path for the data file\n# We're joining the path set earlier with the specific file we want to load\ndata_file = os.path.join(\n    path,  # The base path we set earlier\n    'SMPS_data',  # The subdirectory where the data file is located\n    '2022-07-07_095151_SMPS.csv')  # The name of the data file\n\n# Optional: Print the file path to confirm it's correct\n# print(\"Data file path:\", data_file)\n\n# Using the loader module to load the data from the file\n# The data_raw_loader function takes the file path as its argument and\n# reads the data\nraw_data = loader.data_raw_loader(data_file)\n\n# Printing a snippet of the loaded data for a quick preview\n# This helps us to confirm that the data is loaded and to get an idea of\n# its structure\nprint(\"Preview of loaded data:\")\nfor row in raw_data[22:30]:  # Displaying rows 22 to 30 as a sample\n    print(row)\n</pre> # Constructing the full file path for the data file # We're joining the path set earlier with the specific file we want to load data_file = os.path.join(     path,  # The base path we set earlier     'SMPS_data',  # The subdirectory where the data file is located     '2022-07-07_095151_SMPS.csv')  # The name of the data file  # Optional: Print the file path to confirm it's correct # print(\"Data file path:\", data_file)  # Using the loader module to load the data from the file # The data_raw_loader function takes the file path as its argument and # reads the data raw_data = loader.data_raw_loader(data_file)  # Printing a snippet of the loaded data for a quick preview # This helps us to confirm that the data is loaded and to get an idea of # its structure print(\"Preview of loaded data:\") for row in raw_data[22:30]:  # Displaying rows 22 to 30 as a sample     print(row) <pre>Preview of loaded data:\nUnits,dW/dlogDp\nWeight,Number\nSample #,Date,Start Time,Sample Temp (C),Sample Pressure (kPa),Relative Humidity (%),Mean Free Path (m),Gas Viscosity (Pa*s),Diameter Midpoint (nm),20.72,21.10,21.48,21.87,22.27,22.67,23.08,23.50,23.93,24.36,24.80,25.25,25.71,26.18,26.66,27.14,27.63,28.13,28.64,29.16,29.69,30.23,30.78,31.34,31.91,32.49,33.08,33.68,34.29,34.91,35.55,36.19,36.85,37.52,38.20,38.89,39.60,40.32,41.05,41.79,42.55,43.32,44.11,44.91,45.73,46.56,47.40,48.26,49.14,50.03,50.94,51.86,52.80,53.76,54.74,55.73,56.74,57.77,58.82,59.89,60.98,62.08,63.21,64.36,65.52,66.71,67.93,69.16,70.41,71.69,72.99,74.32,75.67,77.04,78.44,79.86,81.31,82.79,84.29,85.82,87.38,88.96,90.58,92.22,93.90,95.60,97.34,99.10,100.90,102.74,104.60,106.50,108.43,110.40,112.40,114.44,116.52,118.64,120.79,122.98,125.21,127.49,129.80,132.16,134.56,137.00,139.49,142.02,144.60,147.22,149.89,152.61,155.38,158.20,161.08,164.00,166.98,170.01,173.09,176.24,179.43,182.69,186.01,189.38,192.82,196.32,199.89,203.51,207.21,210.97,214.80,218.70,222.67,226.71,230.82,235.01,239.28,243.62,248.05,252.55,257.13,261.80,266.55,271.39,276.32,281.33,286.44,291.64,296.93,302.32,307.81,313.40,319.08,324.88,330.77,336.78,342.89,349.12,355.45,361.90,368.47,375.16,381.97,388.91,395.96,403.15,410.47,417.92,425.51,433.23,441.09,449.10,457.25,465.55,474.00,482.61,491.37,500.29,509.37,518.61,528.03,537.61,547.37,557.31,567.42,577.72,588.21,598.89,609.76,620.82,632.09,643.57,655.25,667.14,679.25,691.58,704.14,716.92,729.93,743.18,756.67,770.40,784.39,Scan Time (s),Retrace Time (s),Scan Resolution (Hz),Scans Per Sample,HV Polarity,Sheath Flow (L/min),Aerosol Flow (L/min),Bypass Flow (L/min),Low Voltage (V),High Voltage (V),Lower Size (nm),Upper Size (nm),Density (g/cm\u00b3),td + 0.5 (s),tf (s),D50 (nm),Median (nm),Mean (nm),Geo. Mean (nm),Mode (nm),Geo. Std. Dev.,Total Conc. (#/cm\u00b3),Neutralizer Status,Dilution Factor,Test Name,Test Description,Dataset Name,Dataset Description,Instrument Errors\n1,07/07/2022,08:49:17,23.7,101.2,61.9,6.75690e-8,1.83579e-5,,6103.186,2832.655,4733.553,4765.944,5960.964,4475.806,4412.044,5853.069,4832.167,3781.343,3675.830,3271.549,3084.392,3668.269,4116.143,3310.157,3978.368,4151.566,2515.995,3755.837,2776.663,5032.745,3775.426,2818.553,2641.302,2636.806,3079.759,2606.094,2317.234,3192.346,2226.703,2484.878,3394.395,1762.834,3172.359,2919.533,2452.013,3403.780,2360.277,2543.386,2563.290,2649.769,1375.374,1364.046,1446.529,2068.167,1336.070,1542.077,1707.249,1482.481,2272.182,1754.409,2472.438,1191.563,2221.825,1635.293,2548.571,1991.926,2546.956,1790.114,2115.075,1138.769,1934.746,2163.955,1613.179,2132.750,1654.348,1698.154,2403.529,1222.983,1829.254,1197.162,1638.797,1248.565,2417.521,1130.421,1429.423,1694.923,1658.378,1443.393,1731.346,1277.799,1089.149,1072.630,1205.387,1693.146,1109.648,915.428,491.529,881.028,1218.297,755.658,714.301,686.247,790.943,398.805,1043.226,1298.495,1548.704,1070.899,846.596,938.241,232.947,926.941,837.452,794.492,254.455,392.637,353.144,872.576,693.986,1544.164,657.340,546.445,311.890,365.934,616.794,610.810,938.786,815.964,593.441,939.634,188.115,1077.429,1213.142,737.913,1876.626,735.779,996.521,1098.601,1166.494,962.551,1392.535,947.504,655.459,993.819,682.087,852.503,601.057,733.860,529.122,960.578,687.512,839.973,652.820,289.921,623.835,453.604,588.057,856.253,283.994,282.839,365.801,200.382,365.756,146.548,306.730,373.162,114.272,0.000,182.692,260.788,164.857,19.851,89.612,0.000,181.974,0.000,53.276,20.016,0.000,0.000,95.433,96.222,0.000,0.000,197.307,0.000,100.336,0.000,102.072,0.000,0.000,209.529,0.000,213.227,107.561,0.000,218.965,220.930,111.453,0.000,113.460,0.000,115.513,0.000,0.000,0.000,0.000,28.221,93.413,122.992,0.000,75,4,50,1,Negative,2.000,0.300,0.00,10.07,9863.01,20.5,791.5,1.0,1.81,10.79,1000.0,41.562,74.959,52.078,20.721,2.179,2.16900e+3,ON,1,TRACER-CAT,,2022 07 07 09_51,,Detector aerosol flow rate error;Incomplete Scan\n2,07/07/2022,08:50:48,23.6,101.2,61.7,6.75401e-8,1.83531e-5,,5621.118,5867.747,6233.403,3453.156,4484.307,5468.148,4725.052,4689.983,3661.759,4356.725,4292.911,7728.414,5112.679,4746.084,3957.005,3472.977,3496.697,4674.202,4188.868,2868.559,3375.113,4306.112,5191.077,4732.512,4566.029,3514.167,5172.877,3825.270,5323.756,2327.737,3846.602,2347.097,3182.011,1876.273,2952.863,2831.255,2497.869,4158.061,3828.510,3199.720,2309.195,2462.550,3060.240,1086.744,1476.289,2069.774,1727.787,2710.631,2067.327,2619.082,2345.026,2362.235,1429.749,2557.408,2660.327,1209.933,1590.320,1696.569,2236.773,1499.046,1922.632,1650.213,3147.351,2201.919,1622.954,2198.739,1800.998,1429.621,1426.761,1923.931,1262.939,1745.284,1458.571,1523.548,1920.108,1382.558,2211.525,2571.277,1979.297,1562.697,1741.573,1307.680,967.481,838.919,1502.136,1301.401,1011.619,829.770,973.269,1100.004,1152.808,749.250,1187.900,806.256,111.008,297.062,809.059,1361.412,779.536,535.087,881.522,1307.518,800.804,1053.953,182.381,1042.830,673.021,646.171,825.612,963.187,748.743,540.954,769.157,788.222,825.566,236.537,865.009,289.185,803.098,398.510,446.847,439.645,1118.961,1003.003,924.180,745.149,430.134,415.522,805.970,790.348,998.975,1043.136,604.082,1004.545,1082.455,1312.781,1447.390,872.420,398.380,695.719,857.412,645.872,691.129,623.007,471.728,641.049,1023.693,394.611,475.599,446.076,657.686,313.003,136.395,248.550,579.894,336.126,485.938,298.810,0.000,227.571,104.550,157.583,289.697,0.229,0.000,0.000,217.592,67.816,24.067,0.000,0.000,0.000,0.000,0.000,97.009,0.000,0.000,0.000,0.000,0.000,0.000,205.900,0.000,104.761,0.000,0.000,0.000,108.509,0.000,110.461,0.000,0.000,0.000,114.471,115.506,116.540,0.000,118.660,0.000,0.000,0.000,0.000,75.377,75,4,50,1,Negative,2.000,0.300,0.00,10.07,9863.01,20.5,791.5,1.0,1.81,10.79,1000.0,39.458,69.080,49.198,25.255,2.101,2.39408e+3,ON,1,TRACER-CAT,,2022 07 07 09_51,,Detector aerosol flow rate error;Incomplete Scan\n3,07/07/2022,08:52:19,23.7,101.2,61.5,6.75690e-8,1.83579e-5,,5165.139,4969.987,4312.386,6939.394,4680.764,3224.473,4999.149,3653.002,4241.532,3928.137,2718.607,3363.947,4863.410,5338.452,4659.515,3430.329,3997.386,4644.421,4943.511,3883.970,3212.310,4445.981,2349.435,3605.419,4366.557,4969.924,4880.573,3186.281,3089.412,2724.537,3195.740,4277.947,4864.436,4263.532,2100.807,1967.634,3283.337,3268.660,3001.917,2781.549,1879.354,1376.083,2051.524,2165.874,2012.210,2923.129,1575.515,1544.252,1610.635,1572.609,1299.370,1549.832,1145.100,2897.864,1839.992,2351.579,2102.027,1543.106,953.811,2073.610,2317.378,2087.617,1586.363,1897.860,2456.722,1647.781,1013.534,1734.023,1633.021,1841.697,2193.442,2714.856,1396.336,2264.046,1671.363,1538.012,1257.148,1423.316,1217.281,1745.437,1787.473,1284.774,1534.815,1274.852,1438.025,1199.602,964.066,862.098,685.995,679.146,879.775,806.703,979.672,894.103,1379.499,1112.031,744.999,580.777,1241.262,960.784,750.484,908.236,957.901,652.265,1200.515,429.487,347.453,552.393,617.871,652.163,709.227,788.963,1499.238,627.895,1315.208,976.800,555.360,440.680,1182.819,863.800,362.530,942.047,460.380,1222.507,678.820,1006.555,319.371,91.941,761.841,205.384,449.120,751.217,572.530,350.734,295.089,413.379,612.088,474.457,678.504,490.408,751.536,400.656,585.567,676.707,364.052,124.385,631.790,788.487,566.062,390.904,141.751,256.369,366.589,528.781,512.078,257.120,393.412,350.601,361.659,65.138,348.203,326.629,329.714,175.810,111.365,74.091,103.212,0.000,0.000,47.532,0.000,166.826,0.000,96.217,388.070,97.832,98.649,99.490,200.678,202.399,0.000,102.953,0.000,0.000,105.683,106.611,33.630,183.108,2.602,218.305,222.901,0.000,226.925,0.000,0.000,116.553,0.000,118.661,119.732,120.801,0.000,122.992,124.085,75,4,50,1,Negative,2.000,0.300,0.00,10.07,9863.01,20.5,791.5,1.0,1.81,10.79,1000.0,39.324,72.102,50.019,21.870,2.136,2.27861e+3,ON,1,TRACER-CAT,,2022 07 07 09_51,,Detector aerosol flow rate error;Incomplete Scan\n4,07/07/2022,08:53:50,23.8,101.2,61.4,6.75979e-8,1.83627e-5,,5814.745,5937.421,5542.118,7127.484,5341.069,4793.690,4938.844,5721.541,4877.746,5900.250,5104.984,4914.366,4891.892,6655.579,4431.173,3389.961,4947.809,3115.245,4138.126,5421.474,4589.063,4007.156,2524.137,5009.064,4780.963,4959.096,3648.285,4148.676,4270.099,2229.465,3043.487,5618.376,3689.188,4700.549,2535.915,1754.223,2560.335,2853.385,2454.711,2515.907,3015.370,1502.864,2344.161,2761.448,2047.076,1542.531,2151.757,2365.884,2330.816,2585.566,1431.955,2391.335,2097.717,1891.014,2211.815,2071.479,2188.302,2475.058,1906.364,1781.793,2356.998,1527.723,2609.446,1644.771,1917.624,1843.984,2418.197,1385.516,1263.621,2155.939,2083.223,1765.167,957.777,2077.747,1667.811,1122.065,1579.113,1709.471,1604.406,686.151,390.075,1194.313,1657.144,1462.232,1870.846,1012.132,847.165,1248.528,1039.604,779.076,1375.101,1058.272,1013.378,1211.420,1641.490,979.146,835.539,763.524,951.720,1270.393,1308.492,1056.486,1715.924,657.112,1475.767,235.866,827.129,1266.089,1080.958,1246.249,1147.116,840.719,1560.246,1201.554,1743.366,1233.526,1166.422,1068.551,1047.492,787.018,759.836,491.419,714.111,460.361,681.068,767.815,654.715,501.038,357.016,575.937,613.281,851.029,583.739,475.691,431.584,616.144,744.932,409.334,984.682,371.750,613.130,757.474,637.077,441.004,609.132,380.961,595.419,565.033,566.955,332.402,450.524,139.761,430.419,443.058,558.628,158.467,271.708,346.807,57.637,148.050,226.825,353.827,77.661,0.000,0.000,74.100,0.000,250.296,117.433,93.156,187.816,0.000,95.443,0.000,0.000,293.505,0.000,99.496,100.342,0.000,102.078,102.959,0.000,0.000,0.000,106.622,322.709,0.000,328.474,0.000,67.473,44.378,0.000,0.000,115.519,0.000,0.000,118.668,0.000,0.000,0.000,0.000,0.000,75,4,50,1,Negative,2.000,0.300,0.00,10.07,9863.01,20.5,791.5,1.0,1.81,10.79,1000.0,37.995,68.796,48.896,21.870,2.107,2.51144e+3,ON,1,TRACER-CAT,,2022 07 07 09_51,,Detector aerosol flow rate error;Incomplete Scan\n5,07/07/2022,08:55:21,24.0,101.1,61.4,6.77227e-8,1.83722e-5,,8034.425,6317.981,6972.600,4577.324,6488.519,4985.397,5484.518,7295.312,3449.590,4261.716,4259.456,6124.670,4418.824,5418.742,3311.293,3548.897,4940.747,6738.536,3377.823,3309.433,5322.339,4148.187,3387.285,3967.636,5064.382,4573.259,3896.245,4006.531,3769.030,4129.946,4678.454,3121.839,3888.625,2443.782,1947.617,2321.130,1845.465,2833.269,2745.881,3262.145,4055.876,2319.187,3397.282,2596.623,2935.256,1508.733,1555.232,3184.200,2683.631,2158.530,2303.663,2739.336,2714.276,2536.377,2051.076,2063.667,2074.972,2852.267,2366.702,2135.668,1500.801,2228.817,2220.527,1501.131,2354.567,2072.434,2547.917,2111.890,1474.809,1561.614,1334.889,1100.318,1077.335,1470.618,1377.825,1684.933,1093.441,1596.409,1456.255,1543.298,1116.499,984.258,1294.805,1586.816,723.664,1709.369,1060.965,1415.310,1611.158,1791.258,1098.238,1513.790,1335.019,1178.572,1538.772,477.803,1130.380,1596.999,652.664,1098.951,1384.104,772.285,788.185,1432.363,773.331,729.470,819.882,979.684,925.309,753.771,706.255,659.741,1026.707,818.647,1205.428,940.460,906.655,758.763,811.344,1123.245,520.356,1009.392,651.265,735.336,209.657,549.624,537.181,841.849,483.705,713.011,497.248,743.196,556.459,953.140,847.692,614.097,423.810,816.193,627.059,453.998,976.898,592.170,548.197,535.480,667.837,312.390,476.781,369.028,451.687,432.520,1001.512,312.053,498.408,198.771,399.968,363.778,403.848,381.782,223.839,227.667,212.819,101.097,164.909,359.326,285.450,0.000,44.177,0.000,158.441,220.559,81.404,49.687,95.468,0.000,194.095,391.452,98.679,0.000,0.000,0.000,0.000,102.990,103.881,104.800,0.000,106.644,0.000,108.554,0.000,110.496,0.000,112.492,113.494,0.000,115.548,0.000,0.000,0.000,239.531,241.683,0.000,0.000,248.252,75,4,50,1,Negative,2.000,0.300,0.00,10.07,9863.01,20.5,791.5,1.0,1.81,10.79,1000.0,39.214,69.960,48.959,20.721,2.123,2.56068e+3,ON,1,TRACER-CAT,,2022 07 07 09_51,,Detector aerosol flow rate error;Incomplete Scan\n</pre> In\u00a0[4]: Copied! <pre># Formatting the data for time series analysis\n# The sizer_data_formatter function from the loader module is used for\n# this purpose\n\ndata_checks = (\n    DataChecksBuilder()\n    .set_characters([250])\n    .set_skip_rows(25)\n    .set_char_counts({\"/\": 2, \":\": 2})\n    .build()\n)\ndata_sizer_reader = (\n    SizerDataReaderBuilder()\n    .set_sizer_start_keyword(\"20.72\")\n    .set_sizer_end_keyword(\"784.39\")\n    .set_sizer_concentration_convert_from(\"dw/dlogdp\")\n    .build()\n)\n\nepoch_time, data, header = loader.sizer_data_formatter(\n    data=raw_data,  # The raw data that was loaded earlier\n    data_checks=data_checks,\n    data_sizer_reader=data_sizer_reader,\n    time_column=[1, 2],  # Columns that contain the time data\n    time_format=\"%m/%d/%Y %H:%M:%S\",  # Format of the time data\n    delimiter=\",\",  # Delimiter used in the data file\n    header_row=24)  # Row number that contains the header\n\n# Printing a preview of the formatted data to confirm successful formatting\nprint('Epoch time (First 5 Entries):')\nprint(epoch_time[:5])  # Displaying the first 5 time entries\nprint('Data shape:')\nprint(data.shape)  # Showing the shape of the data array\nprint('Header (First 10 Entries):')\nprint(header[:10])  # Displaying the first 10 headers\n</pre> # Formatting the data for time series analysis # The sizer_data_formatter function from the loader module is used for # this purpose  data_checks = (     DataChecksBuilder()     .set_characters([250])     .set_skip_rows(25)     .set_char_counts({\"/\": 2, \":\": 2})     .build() ) data_sizer_reader = (     SizerDataReaderBuilder()     .set_sizer_start_keyword(\"20.72\")     .set_sizer_end_keyword(\"784.39\")     .set_sizer_concentration_convert_from(\"dw/dlogdp\")     .build() )  epoch_time, data, header = loader.sizer_data_formatter(     data=raw_data,  # The raw data that was loaded earlier     data_checks=data_checks,     data_sizer_reader=data_sizer_reader,     time_column=[1, 2],  # Columns that contain the time data     time_format=\"%m/%d/%Y %H:%M:%S\",  # Format of the time data     delimiter=\",\",  # Delimiter used in the data file     header_row=24)  # Row number that contains the header  # Printing a preview of the formatted data to confirm successful formatting print('Epoch time (First 5 Entries):') print(epoch_time[:5])  # Displaying the first 5 time entries print('Data shape:') print(data.shape)  # Showing the shape of the data array print('Header (First 10 Entries):') print(header[:10])  # Displaying the first 10 headers <pre>Epoch time (First 5 Entries):\n[1.65718376e+09 1.65718385e+09 1.65718394e+09 1.65718403e+09\n 1.65718412e+09]\nData shape:\n(2854, 203)\nHeader (First 10 Entries):\n['20.72', '21.10', '21.48', '21.87', '22.27', '22.67', '23.08', '23.50', '23.93', '24.36']\n</pre> In\u00a0[5]: Copied! <pre># Creating a plot using matplotlib\nfig, ax = plt.subplots()  # Creating a figure and axis for the plot\n\n# Plotting data from a specific size bin against time\n# 'epoch_time' is used on the x-axis (time data)\n# 'data[:, 50]' selects the data from the 50th bin (as an example) for the y-axis\nax.plot(epoch_time,\n        data[:, 50],  # Selecting the 50th bin of data to plot\n        label=f'Bin {header[50]} nm',  # Adding a label with the bin size\n        )\n\n# Setting labels for the x-axis and y-axis\nax.set_xlabel(\"Time (epoch)\")  # Label for the x-axis\nax.set_ylabel(\"Bin Concentration (#/cm\u00b3)\")  # Label for the y-axis\n\n# Adding a legend to the plot for clarity\nax.legend()\n\n# Displaying the plot\nplt.show()\n\n# Adjusting the layout to ensure all plot elements are visible and\n# well-arranged\nfig.tight_layout()\n</pre> # Creating a plot using matplotlib fig, ax = plt.subplots()  # Creating a figure and axis for the plot  # Plotting data from a specific size bin against time # 'epoch_time' is used on the x-axis (time data) # 'data[:, 50]' selects the data from the 50th bin (as an example) for the y-axis ax.plot(epoch_time,         data[:, 50],  # Selecting the 50th bin of data to plot         label=f'Bin {header[50]} nm',  # Adding a label with the bin size         )  # Setting labels for the x-axis and y-axis ax.set_xlabel(\"Time (epoch)\")  # Label for the x-axis ax.set_ylabel(\"Bin Concentration (#/cm\u00b3)\")  # Label for the y-axis  # Adding a legend to the plot for clarity ax.legend()  # Displaying the plot plt.show()  # Adjusting the layout to ensure all plot elements are visible and # well-arranged fig.tight_layout() In\u00a0[6]: Copied! <pre># Importing the necessary function for converting epoch time to datetime64\nfrom particula.util.time_manage import datetime64_from_epoch_array\n\n# Converting the epoch time to datetime64 format\ntime_in_datetime64 = datetime64_from_epoch_array(epoch_time)\n\n# Creating a plot\nfig, ax = plt.subplots()\n\n# Plotting the data with time in datetime64 format on the x-axis\nax.plot(time_in_datetime64,\n        data[:, 50],  # Selecting the 50th bin of data\n        label=f'Bin {header[50]} nm',  # Label for the data series\n        )\n\n# Rotating the x-axis labels to 45 degrees for better readability\nplt.xticks(rotation=45)\n\n# Setting the x-axis and y-axis labels\nax.set_xlabel(\"Time (UTC)\")  # Updated label to indicate the time format\nax.set_ylabel(\"Bin Concentration (#/cm\u00b3)\")\n\n# Adding a legend to the plot\nax.legend()\n\n# Displaying the plot\nplt.show()\n\n# Adjusting the layout for a neat presentation\nfig.tight_layout()\n</pre> # Importing the necessary function for converting epoch time to datetime64 from particula.util.time_manage import datetime64_from_epoch_array  # Converting the epoch time to datetime64 format time_in_datetime64 = datetime64_from_epoch_array(epoch_time)  # Creating a plot fig, ax = plt.subplots()  # Plotting the data with time in datetime64 format on the x-axis ax.plot(time_in_datetime64,         data[:, 50],  # Selecting the 50th bin of data         label=f'Bin {header[50]} nm',  # Label for the data series         )  # Rotating the x-axis labels to 45 degrees for better readability plt.xticks(rotation=45)  # Setting the x-axis and y-axis labels ax.set_xlabel(\"Time (UTC)\")  # Updated label to indicate the time format ax.set_ylabel(\"Bin Concentration (#/cm\u00b3)\")  # Adding a legend to the plot ax.legend()  # Displaying the plot plt.show()  # Adjusting the layout for a neat presentation fig.tight_layout() In\u00a0[7]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# Setting limits on the concentration data to improve plot readability\nconcentration = data\nconcentration = np.where(\n    concentration &lt; 1e-5,\n    1e-5,\n    concentration)  # Setting a lower limit\nconcentration = np.where(\n    concentration &gt; 10**5,\n    10**5,\n    concentration)  # Setting an upper limit\n# Uncomment the next line to plot concentration in logarithmic scale\n# concentration = np.log10(concentration)\n\n# Creating a figure and axis for the contour plot\nfig, ax = plt.subplots(1, 1)\n\n# Creating the contour plot\nplt.contourf(\n    epoch_time,  # X-axis: Time data in epoch format\n    # Y-axis: Particle sizes converted to float\n    np.array(header).astype(float),\n    concentration.T,  # Transposed concentration data for correct orientation\n    cmap=plt.cm.PuBu_r,  # Color map for the plot\n    levels=50  # Number of levels in the contour plot\n)\n\n# Setting the y-axis to logarithmic scale for better visualization of size\n# distribution\nplt.yscale('log')\n\n# Setting labels for the x-axis and y-axis\nax.set_xlabel('Epoch Time')  # Label for the x-axis\nax.set_ylabel('Diameter (nm)')  # Label for the y-axis\n\n# Adding a color bar to the plot, indicating concentration levels\nplt.colorbar(label='Concentration dN/dlogDp [#/cm\u00b3]', ax=ax)\n\n# Displaying the plot\nplt.show()\n\n# Adjusting the layout for a better presentation of the plot elements\nfig.tight_layout()\n</pre> import numpy as np import matplotlib.pyplot as plt  # Setting limits on the concentration data to improve plot readability concentration = data concentration = np.where(     concentration &lt; 1e-5,     1e-5,     concentration)  # Setting a lower limit concentration = np.where(     concentration &gt; 10**5,     10**5,     concentration)  # Setting an upper limit # Uncomment the next line to plot concentration in logarithmic scale # concentration = np.log10(concentration)  # Creating a figure and axis for the contour plot fig, ax = plt.subplots(1, 1)  # Creating the contour plot plt.contourf(     epoch_time,  # X-axis: Time data in epoch format     # Y-axis: Particle sizes converted to float     np.array(header).astype(float),     concentration.T,  # Transposed concentration data for correct orientation     cmap=plt.cm.PuBu_r,  # Color map for the plot     levels=50  # Number of levels in the contour plot )  # Setting the y-axis to logarithmic scale for better visualization of size # distribution plt.yscale('log')  # Setting labels for the x-axis and y-axis ax.set_xlabel('Epoch Time')  # Label for the x-axis ax.set_ylabel('Diameter (nm)')  # Label for the y-axis  # Adding a color bar to the plot, indicating concentration levels plt.colorbar(label='Concentration dN/dlogDp [#/cm\u00b3]', ax=ax)  # Displaying the plot plt.show()  # Adjusting the layout for a better presentation of the plot elements fig.tight_layout() In\u00a0[8]: Copied! <pre># Importing the necessary module for settings generation\nfrom particula.data import settings_generator\n\n# Generating settings for loading 1d and 2d data from files\n# This is useful for instruments that output both types of data in the\n# same file\n\nsettings_1d, settings_2d = (\n    LoaderSizerSettingsBuilder()\n    .set_relative_data_folder('SMPS_data')\n    .set_filename_regex('*.csv')\n    .set_header_row(24)\n    .set_data_checks(data_checks)\n    .set_data_column([\n        \"Lower Size (nm)\", \"Upper Size (nm)\", \"Sample Temp (C)\",\n        \"Sample Pressure (kPa)\", \"Relative Humidity (%)\", \"Median (nm)\",\n        \"Mean (nm)\", \"Geo. Mean (nm)\", \"Mode (nm)\", \"Geo. Std. Dev.\",\n        \"Total Conc. (#/cm\u00b3)\"\n    ])\n    .set_data_header([\n        \"Lower_Size_(nm)\", \"Upper_Size_(nm)\", \"Sample_Temp_(C)\",\n        \"Sample_Pressure_(kPa)\", \"Relative_Humidity_(%)\", \"Median_(nm)\",\n        \"Mean_(nm)\", \"Geo_Mean_(nm)\", \"Mode_(nm)\", \"Geo_Std_Dev.\",\n        \"Total_Conc_(#/cc)\"\n    ])\n    .set_data_sizer_reader(data_sizer_reader)\n    .set_time_column([1, 2])\n    .set_time_format(\"%m/%d/%Y %H:%M:%S\")\n    .set_delimiter(\",\")\n    .set_timezone_identifier(\"UTC\")\n    .build()\n)\n\n# Printing the generated settings dictionaries for both 1d and 2d data\nprint('Settings for 1d data:')\nfor key, value in settings_1d.items():\n    print(f'{key}: {value}')\n\nprint('\\nSettings for 2d data:')\nfor key, value in settings_2d.items():\n    print(f'{key}: {value}')\n</pre> # Importing the necessary module for settings generation from particula.data import settings_generator  # Generating settings for loading 1d and 2d data from files # This is useful for instruments that output both types of data in the # same file  settings_1d, settings_2d = (     LoaderSizerSettingsBuilder()     .set_relative_data_folder('SMPS_data')     .set_filename_regex('*.csv')     .set_header_row(24)     .set_data_checks(data_checks)     .set_data_column([         \"Lower Size (nm)\", \"Upper Size (nm)\", \"Sample Temp (C)\",         \"Sample Pressure (kPa)\", \"Relative Humidity (%)\", \"Median (nm)\",         \"Mean (nm)\", \"Geo. Mean (nm)\", \"Mode (nm)\", \"Geo. Std. Dev.\",         \"Total Conc. (#/cm\u00b3)\"     ])     .set_data_header([         \"Lower_Size_(nm)\", \"Upper_Size_(nm)\", \"Sample_Temp_(C)\",         \"Sample_Pressure_(kPa)\", \"Relative_Humidity_(%)\", \"Median_(nm)\",         \"Mean_(nm)\", \"Geo_Mean_(nm)\", \"Mode_(nm)\", \"Geo_Std_Dev.\",         \"Total_Conc_(#/cc)\"     ])     .set_data_sizer_reader(data_sizer_reader)     .set_time_column([1, 2])     .set_time_format(\"%m/%d/%Y %H:%M:%S\")     .set_delimiter(\",\")     .set_timezone_identifier(\"UTC\")     .build() )  # Printing the generated settings dictionaries for both 1d and 2d data print('Settings for 1d data:') for key, value in settings_1d.items():     print(f'{key}: {value}')  print('\\nSettings for 2d data:') for key, value in settings_2d.items():     print(f'{key}: {value}')  <pre>Settings for 1d data:\nrelative_data_folder: SMPS_data\nfilename_regex: *.csv\nMIN_SIZE_BYTES: 10000\ndata_loading_function: general_1d_load\nheader_row: 24\ndata_checks: {'characters': [250], 'char_counts': {'/': 2, ':': 2}, 'skip_rows': 25, 'skip_end': 0}\ndata_column: ['Lower Size (nm)', 'Upper Size (nm)', 'Sample Temp (C)', 'Sample Pressure (kPa)', 'Relative Humidity (%)', 'Median (nm)', 'Mean (nm)', 'Geo. Mean (nm)', 'Mode (nm)', 'Geo. Std. Dev.', 'Total Conc. (#/cm\u00b3)']\ndata_header: ['Lower_Size_(nm)', 'Upper_Size_(nm)', 'Sample_Temp_(C)', 'Sample_Pressure_(kPa)', 'Relative_Humidity_(%)', 'Median_(nm)', 'Mean_(nm)', 'Geo_Mean_(nm)', 'Mode_(nm)', 'Geo_Std_Dev.', 'Total_Conc_(#/cc)']\ntime_column: [1, 2]\ntime_format: %m/%d/%Y %H:%M:%S\ndelimiter: ,\ntime_shift_seconds: 0\ntimezone_identifier: UTC\n\nSettings for 2d data:\nrelative_data_folder: SMPS_data\nfilename_regex: *.csv\nMIN_SIZE_BYTES: 10000\ndata_loading_function: general_2d_load\nheader_row: 24\ndata_checks: {'characters': [250], 'char_counts': {'/': 2, ':': 2}, 'skip_rows': 25, 'skip_end': 0}\ndata_sizer_reader: {'convert_scale_from': 'dw/dlogdp', 'Dp_start_keyword': '20.72', 'Dp_end_keyword': '784.39'}\ndata_header: ['Lower_Size_(nm)', 'Upper_Size_(nm)', 'Sample_Temp_(C)', 'Sample_Pressure_(kPa)', 'Relative_Humidity_(%)', 'Median_(nm)', 'Mean_(nm)', 'Geo_Mean_(nm)', 'Mode_(nm)', 'Geo_Std_Dev.', 'Total_Conc_(#/cc)']\ntime_column: [1, 2]\ntime_format: %m/%d/%Y %H:%M:%S\ndelimiter: ,\ntime_shift_seconds: 0\ntimezone_identifier: UTC\n</pre> In\u00a0[9]: Copied! <pre># Setting the working path to the directory where the data files are located\nworking_path = get_data_folder()\n\n# Using the settings dictionaries created earlier for 1d and 2d data\n\n# Loading 1-dimensional data using the loader interface\n# The interface takes the path and settings for 1d data and loads the data\n# accordingly\ndata_stream_1d = loader_interface.load_files_interface(\n    path=working_path,  # The path where data files are stored\n    settings=settings_1d,  # Settings dictionary for 1d data\n)\n\n# Loading 2-dimensional data using the loader interface\n# Similar to the 1d data, but using the settings for 2d data\ndata_stream_2d = loader_interface.load_files_interface(\n    path=working_path,  # The path where data files are stored\n    settings=settings_2d,  # Settings dictionary for 2d data\n)\n\n# The data_stream_1d and data_stream_2d objects now contain the loaded data\n# ready for further analysis and visualization\n</pre> # Setting the working path to the directory where the data files are located working_path = get_data_folder()  # Using the settings dictionaries created earlier for 1d and 2d data  # Loading 1-dimensional data using the loader interface # The interface takes the path and settings for 1d data and loads the data # accordingly data_stream_1d = loader_interface.load_files_interface(     path=working_path,  # The path where data files are stored     settings=settings_1d,  # Settings dictionary for 1d data )  # Loading 2-dimensional data using the loader interface # Similar to the 1d data, but using the settings for 2d data data_stream_2d = loader_interface.load_files_interface(     path=working_path,  # The path where data files are stored     settings=settings_2d,  # Settings dictionary for 2d data )  # The data_stream_1d and data_stream_2d objects now contain the loaded data # ready for further analysis and visualization <pre>  Loading file: 2022-07-07_095151_SMPS.csv\n  Loading file: 2022-07-10_094659_SMPS.csv\n  Loading file: 2022-07-07_095151_SMPS.csv\n  Loading file: 2022-07-10_094659_SMPS.csv\n</pre> In\u00a0[10]: Copied! <pre># Print a blank line for better readability\nprint('')\n\n# Print the summary of the 1-dimensional data stream\nprint('Data stream 1d summary:')\nprint(data_stream_1d)  # This will display a summary of the 1d data\n\n# Print another blank line for separation\nprint('')\n\n# Print the summary of the 2-dimensional data stream\nprint('Data stream 2d summary:')\nprint(data_stream_2d)  # This will display a summary of the 2d data\n</pre> # Print a blank line for better readability print('')  # Print the summary of the 1-dimensional data stream print('Data stream 1d summary:') print(data_stream_1d)  # This will display a summary of the 1d data  # Print another blank line for separation print('')  # Print the summary of the 2-dimensional data stream print('Data stream 2d summary:') print(data_stream_2d)  # This will display a summary of the 2d data <pre>\nData stream 1d summary:\nStream(header=['Lower_Size_(nm)', 'Upper_Size_(nm)', 'Sample_Temp_(C)', 'Sample_Pressure_(kPa)', 'Relative_Humidity_(%)', 'Median_(nm)', 'Mean_(nm)', 'Geo_Mean_(nm)', 'Mode_(nm)', 'Geo_Std_Dev.', 'Total_Conc_(#/cc)'], data=array([[2.05000e+01, 7.91500e+02, 2.37000e+01, ..., 2.07210e+01,\n        2.17900e+00, 2.16900e+03],\n       [2.05000e+01, 7.91500e+02, 2.36000e+01, ..., 2.52550e+01,\n        2.10100e+00, 2.39408e+03],\n       [2.05000e+01, 7.91500e+02, 2.37000e+01, ..., 2.18700e+01,\n        2.13600e+00, 2.27861e+03],\n       ...,\n       [2.05000e+01, 7.91500e+02, 2.35000e+01, ..., 2.07210e+01,\n        2.31800e+00, 2.08056e+03],\n       [2.05000e+01, 7.91500e+02, 2.33000e+01, ..., 2.10970e+01,\n        2.31800e+00, 2.10616e+03],\n       [2.05000e+01, 7.91500e+02, 2.35000e+01, ..., 2.07210e+01,\n        2.24800e+00, 2.45781e+03]]), time=array([1.65718376e+09, 1.65718385e+09, 1.65718394e+09, ...,\n       1.65753440e+09, 1.65753450e+09, 1.65753459e+09]), files=[['2022-07-07_095151_SMPS.csv', 5620804], ['2022-07-10_094659_SMPS.csv', 2004838]])\n\nData stream 2d summary:\nStream(header=['20.72', '21.10', '21.48', '21.87', '22.27', '22.67', '23.08', '23.50', '23.93', '24.36', '24.80', '25.25', '25.71', '26.18', '26.66', '27.14', '27.63', '28.13', '28.64', '29.16', '29.69', '30.23', '30.78', '31.34', '31.91', '32.49', '33.08', '33.68', '34.29', '34.91', '35.55', '36.19', '36.85', '37.52', '38.20', '38.89', '39.60', '40.32', '41.05', '41.79', '42.55', '43.32', '44.11', '44.91', '45.73', '46.56', '47.40', '48.26', '49.14', '50.03', '50.94', '51.86', '52.80', '53.76', '54.74', '55.73', '56.74', '57.77', '58.82', '59.89', '60.98', '62.08', '63.21', '64.36', '65.52', '66.71', '67.93', '69.16', '70.41', '71.69', '72.99', '74.32', '75.67', '77.04', '78.44', '79.86', '81.31', '82.79', '84.29', '85.82', '87.38', '88.96', '90.58', '92.22', '93.90', '95.60', '97.34', '99.10', '100.90', '102.74', '104.60', '106.50', '108.43', '110.40', '112.40', '114.44', '116.52', '118.64', '120.79', '122.98', '125.21', '127.49', '129.80', '132.16', '134.56', '137.00', '139.49', '142.02', '144.60', '147.22', '149.89', '152.61', '155.38', '158.20', '161.08', '164.00', '166.98', '170.01', '173.09', '176.24', '179.43', '182.69', '186.01', '189.38', '192.82', '196.32', '199.89', '203.51', '207.21', '210.97', '214.80', '218.70', '222.67', '226.71', '230.82', '235.01', '239.28', '243.62', '248.05', '252.55', '257.13', '261.80', '266.55', '271.39', '276.32', '281.33', '286.44', '291.64', '296.93', '302.32', '307.81', '313.40', '319.08', '324.88', '330.77', '336.78', '342.89', '349.12', '355.45', '361.90', '368.47', '375.16', '381.97', '388.91', '395.96', '403.15', '410.47', '417.92', '425.51', '433.23', '441.09', '449.10', '457.25', '465.55', '474.00', '482.61', '491.37', '500.29', '509.37', '518.61', '528.03', '537.61', '547.37', '557.31', '567.42', '577.72', '588.21', '598.89', '609.76', '620.82', '632.09', '643.57', '655.25', '667.14', '679.25', '691.58', '704.14', '716.92', '729.93', '743.18', '756.67', '770.40', '784.39'], data=array([[ 6103.186,  2832.655,  4733.553, ...,    93.413,   122.992,\n            0.   ],\n       [ 5621.118,  5867.747,  6233.403, ...,     0.   ,     0.   ,\n           75.377],\n       [ 5165.139,  4969.987,  4312.386, ...,     0.   ,   122.992,\n          124.085],\n       ...,\n       [ 9962.036,  7986.823,  8682.258, ...,     0.   ,     0.   ,\n          124.153],\n       [ 8765.782, 11175.603,  8148.945, ...,     0.   ,     0.   ,\n          372.433],\n       [14380.528, 11524.35 , 13632.727, ...,     0.   ,     0.   ,\n            0.   ]]), time=array([1.65718376e+09, 1.65718385e+09, 1.65718394e+09, ...,\n       1.65753440e+09, 1.65753450e+09, 1.65753459e+09]), files=[['2022-07-07_095151_SMPS.csv', 5620804], ['2022-07-10_094659_SMPS.csv', 2004838]])\n</pre> In\u00a0[11]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# Adjusting the concentration data for better visualization in the plot\nconcentration = data_stream_2d.data\nconcentration = np.where(\n    concentration &lt; 1e-5,\n    1e-5,\n    concentration)  # Setting a lower limit\nconcentration = np.where(\n    concentration &gt; 10**5,\n    10**5,\n    concentration)  # Setting an upper limit\n# Uncomment the following line to plot the concentration on a logarithmic scale\n# concentration = np.log10(concentration)\n\n# Creating a figure and axis for the contour plot\nfig, ax = plt.subplots(1, 1)\n\n# Creating the contour plot\n# X-axis: Time data in datetime64 format from data_stream_2d\n# Y-axis: Particle sizes (diameter in nm) converted from the header strings to floats\n# Z-axis: Concentration data\nplt.contourf(\n    data_stream_2d.datetime64,  # Time data\n    data_stream_2d.header_float,  # Particle sizes\n    concentration.T,  # Concentration data, transposed for correct orientation\n    cmap=plt.cm.PuBu_r,  # Color map for the plot\n    levels=50  # Number of contour levels\n)\n\n# Setting the y-axis to logarithmic scale for better visualization of size\n# distribution\nplt.yscale('log')\n\n# Rotating the x-axis labels for better readability\nplt.tick_params(rotation=35)\n\n# Setting labels for the x-axis and y-axis\nax.set_xlabel(\"Time (UTC)\")\nax.set_ylabel('Diameter (nm)')\n\n# Adding a color bar to indicate concentration levels\nplt.colorbar(label='Concentration dN/dlog(Dp) [#/cm\u00b3]', ax=ax)\n\n# Displaying the plot\nplt.show()\n\n# Adjusting the layout to ensure all elements of the plot are clearly visible\nfig.tight_layout()\n</pre> import numpy as np import matplotlib.pyplot as plt  # Adjusting the concentration data for better visualization in the plot concentration = data_stream_2d.data concentration = np.where(     concentration &lt; 1e-5,     1e-5,     concentration)  # Setting a lower limit concentration = np.where(     concentration &gt; 10**5,     10**5,     concentration)  # Setting an upper limit # Uncomment the following line to plot the concentration on a logarithmic scale # concentration = np.log10(concentration)  # Creating a figure and axis for the contour plot fig, ax = plt.subplots(1, 1)  # Creating the contour plot # X-axis: Time data in datetime64 format from data_stream_2d # Y-axis: Particle sizes (diameter in nm) converted from the header strings to floats # Z-axis: Concentration data plt.contourf(     data_stream_2d.datetime64,  # Time data     data_stream_2d.header_float,  # Particle sizes     concentration.T,  # Concentration data, transposed for correct orientation     cmap=plt.cm.PuBu_r,  # Color map for the plot     levels=50  # Number of contour levels )  # Setting the y-axis to logarithmic scale for better visualization of size # distribution plt.yscale('log')  # Rotating the x-axis labels for better readability plt.tick_params(rotation=35)  # Setting labels for the x-axis and y-axis ax.set_xlabel(\"Time (UTC)\") ax.set_ylabel('Diameter (nm)')  # Adding a color bar to indicate concentration levels plt.colorbar(label='Concentration dN/dlog(Dp) [#/cm\u00b3]', ax=ax)  # Displaying the plot plt.show()  # Adjusting the layout to ensure all elements of the plot are clearly visible fig.tight_layout()"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part2/#loading-part-2-sizer-data","title":"Loading Part 2: Sizer Data\u00b6","text":"<p>Welcome to Part 2 of our data loading series! This section builds upon the concepts and techniques introduced in Part 1. If you haven't gone through the first part, we highly recommend you do so to get a firm foundation. Here, we'll dive into handling 2-dimensional data, such as size distributions, which are common in fields like environmental science and engineering.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part2/#setting-up-your-working-path","title":"Setting Up Your Working Path\u00b6","text":"<p>Before we begin, let's set up the working path, which is the location on your computer where your data files are stored. In this example, we'll use data provided in the current directory of this notebook. However, you can easily change this to any directory where your data files are located. For instance, if you have a folder named \"data\" in your home directory for a project called \"Campaign2023_of_awesome\", you would set the path like this:</p> <p><code>path = \"U:\\\\data\\\\processing\\\\Campaign2023_of_awesome\\\\data\"</code></p> <p>Let's start by importing the necessary Python libraries and modules. We'll explain each one as we use them throughout this notebook.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part2/#load-the-data","title":"Load the Data\u00b6","text":"<p>Now that we've set our working directory, the next step is to load the data. We'll be using the <code>loader</code> module from the Particula package for this task. The function <code>loader.data_raw_loader()</code> is specifically designed to read data from a file, which we'll specify using its file path. This approach is straightforward and efficient for loading data into Python for analysis.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part2/#formatting-the-data","title":"Formatting the Data\u00b6","text":"<p>When dealing with 2-dimensional data, such as size distributions, the formatting process can be a bit more complex compared to 1-dimensional data. For our data, we need to extract size bins and use them as headers for our dataset. This involves specifying the start and end points within the data that define our size bins. In our specific example, the start point is indicated by the keyword \"Date Time\" and the end point by \"Total Conc\". Understanding where your data starts and ends is crucial for accurate formatting and analysis.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part2/#pause-to-plot","title":"Pause to Plot\u00b6","text":"<p>Visualizing your data is a crucial step in the data analysis process. It allows you to see patterns, trends, and potential anomalies that might not be evident from the raw data alone. Now that we have formatted the data and extracted the time information, let's create a plot. This will help us get a visual sense of the data's characteristics, such as the concentration of particles in different size bins over time.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part2/#dates-in-plots","title":"Dates in Plots\u00b6","text":"<p>When working with time-series data, it's often helpful to have dates on the x-axis of your plots for better readability and understanding. However, to display dates effectively in plots using <code>matplotlib</code>, we need to convert our time data into a format that <code>matplotlib</code> can recognize and work with.</p> <p>One common format for this purpose is <code>np.datetime64</code>. This format represents dates and times in a way that is compatible with numpy arrays, making it ideal for plotting time-related data. In our case, we can convert our epoch time (time since a fixed point in the past, typically January 1, 1970) to <code>np.datetime64</code> using the <code>convert.datetime64_from_epoch_array</code> function from the Particula package.</p> <p>Additionally, to make the plot more readable, especially when there are many data points, it's a good practice to rotate the x-axis labels. This prevents overlapping and makes each date and time label clear. We can achieve this rotation using <code>plt.xticks(rotation=45)</code>.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part2/#contour-plot-of-data","title":"Contour Plot of Data\u00b6","text":"<p>Contour plots are a powerful tool for visualizing how data changes over time and space. In the context of size distribution data, a contour plot can effectively show the variation in particle concentration across different sizes over time. It's like looking at a topographic map where different colors or shades represent varying concentrations of particles at different sizes and times.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part2/#preparing-the-data-for-contour-plotting","title":"Preparing the Data for Contour Plotting\u00b6","text":"<p>Before we plot, it's a good practice to set limits on our data to ensure that extreme values don't skew the visualization. This helps in highlighting the relevant ranges of our data. Here's how we do it:</p> <ol> <li><p>Setting Lower and Upper Limits: We impose a lower limit to avoid plotting extremely low concentrations (which might be less relevant or below detection limits) and an upper limit to avoid letting very high concentrations dominate the plot.</p> </li> <li><p>Option for Logarithmic Scale: For data with a wide range of values, using a logarithmic scale (e.g., <code>np.log10(concentration)</code>) can make the plot more informative by compressing the scale and emphasizing the variations across orders of magnitude.</p> </li> </ol>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part2/#creating-the-contour-plot","title":"Creating the Contour Plot\u00b6","text":"<p>With our data prepared, we can now create the contour plot. This type of plot will use different colors or shades to represent the concentration of particles at various sizes and times.</p> <ul> <li>X-Axis (Epoch Time): Represents the time dimension of our data.</li> <li>Y-Axis (Diameter in nm): Represents the different size bins of particles.</li> <li>Color Intensity: Indicates the concentration of particles at each size and time.</li> </ul> <p>Using <code>plt.contourf</code>, we create a filled contour plot with a logarithmic y-scale, which is particularly useful for size distribution data that typically spans several orders of magnitude in particle sizes.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part2/#simplifying-data-import-with-the-settings-generator","title":"Simplifying Data Import with the Settings Generator\u00b6","text":"<p>In the same way we handled 1-dimensional (1d) data, we can also streamline the import process for 2-dimensional (2d) data using the settings generator. This tool is particularly useful for creating a structured approach to loading complex datasets. By using the <code>settings_generator.for_general_sizer_1d_2d_load()</code> function, we can generate a comprehensive settings dictionary that directs how data should be imported and formatted.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part2/#understanding-the-settings-generator-function","title":"Understanding the Settings Generator Function\u00b6","text":"<p>This function is designed to be flexible and accommodate a wide range of data types and formats. It comes with numerous arguments that allow you to specify details like data checks, column information, time format, etc., tailored to your specific dataset. However, it's important to note that you don't have to be overwhelmed by these options.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part2/#using-default-settings","title":"Using Default Settings\u00b6","text":"<p>For many users, especially those just starting out or working with standard data formats, the default settings of the <code>settings_generator</code> function may work. These defaults are configured to align with the example data provided in the Particula package. This means that if your data structure is similar to the example data, you can call this function without passing any arguments, and it will automatically set up the settings for you.</p> <p>This approach not only saves time but also reduces the potential for errors in the data import process, making it a quick and reliable way to get your data ready for analysis.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part2/#efficient-data-loading-with-the-interface","title":"Efficient Data Loading with the Interface\u00b6","text":"<p>After configuring our settings dictionaries for 1-dimensional and 2-dimensional data, we're set to leverage the interface for data loading. This interface, a key component of the Particula package, streamlines the process, making it more efficient and straightforward, especially after you have a good grasp of how the settings work.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part2/#understanding-the-interfaces-role","title":"Understanding the Interface's Role\u00b6","text":"<p>The interface acts as a facilitator that intelligently uses the settings we've established to manage the data loading process. It eliminates the need for manual execution of multiple steps, thereby integrating and automating the data import based on our predefined preferences.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part2/#the-advantages-of-mastery","title":"The Advantages of Mastery\u00b6","text":"<p>Once you're comfortable with setting up your data parameters, using the interface offers several key benefits:</p> <ul> <li>Enhanced Efficiency: It consolidates several operations into a single action, significantly speeding up the data loading process.</li> <li>Consistent Results: By automating the data import process with predefined settings, it ensures uniformity and accuracy across different datasets.</li> <li>Optimized Workflow: For users who understand the settings, the interface offers a simplified and more effective way to handle data loading. It removes the repetitive task of manually calling functions, allowing you to focus more on data analysis.</li> </ul> <p>In the following section, we'll demonstrate how to utilize the interface with our prepared settings to efficiently load and process our data.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part2/#printing-data-stream-summaries","title":"Printing Data Stream Summaries\u00b6","text":"<p>After loading our data using the loader interface, it's a good practice to take a moment and review what we have loaded. This helps us confirm that the data is imported correctly and gives us an initial overview of its structure. We'll do this by printing summaries of the <code>data_stream_1d</code> and <code>data_stream_2d</code> objects.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part2/#understanding-the-data-stream-summary","title":"Understanding the Data Stream Summary\u00b6","text":"<p>When we print a <code>data_stream</code> object, it provides us with a summary of its contents. This includes information like the size of the data, the headers (which represent different data types or measurements), and a glimpse into the actual data values. These summaries are especially useful for:</p> <ul> <li>Verifying Data Integrity: Ensuring that the data has been loaded as expected and is ready for analysis.</li> <li>Quick Overview: Getting a high-level understanding of the data's structure, such as the number of data points and the range of measurements.</li> </ul>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part2/#code-for-printing-summaries","title":"Code for Printing Summaries\u00b6","text":"<p>Here's how we print the summaries for our 1-dimensional and 2-dimensional data streams:</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part2/#plotting-again","title":"Plotting Again\u00b6","text":"<p>Plotting is an integral part of the data analysis process. It transforms raw data into visual representations that can reveal insights, patterns, and anomalies that might not be immediately apparent in numerical form. Let's delve into why plotting is so crucial in understanding your data.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part2/#summary-of-loading-data-part-2","title":"Summary of Loading Data Part 2\u00b6","text":"<p>In this section, we delved into the process of loading and handling 2-dimensional data, focusing on a size distribution dataset. We walked through several crucial steps, providing a comprehensive guide to managing and visualizing complex data structures. Here's a recap of what we covered:</p> <ul> <li>Setting the Working Path: We began by establishing the working directory for our data, a foundational step in ensuring our scripts access the correct files.</li> <li>Loading the Data: Using the loader module, we demonstrated how to import raw data from a file, setting the stage for further processing.</li> <li>Formatting the Data: We then tackled the challenge of formatting 2-dimensional data, extracting size bins as headers, and preparing the dataset for analysis.</li> <li>Initial Plotting: To get a preliminary understanding of our data, we created initial plots. This step is crucial for visually inspecting the data and confirming its integrity.</li> <li>Generating the Settings Dictionary: We utilized the settings_generator to create settings dictionaries for both 1-dimensional and 2-dimensional data. This streamlines the data loading process, especially for complex datasets.</li> <li>Loading Data with the Interface: We showcased how to use the loader interface to efficiently load data using the predefined settings, emphasizing the ease and efficiency it brings to the data loading process.</li> <li>Advanced Plotting of the Data Stream: Lastly, we explored more advanced data visualization techniques, including creating contour plots. This allowed us to visualize how particle concentration varied across different sizes and times, offering valuable insights into our dataset.</li> </ul> <p>Throughout this section, we focused on making each step clear and accessible, particularly for those new to working with 2-dimensional datasets in Python. By following these steps, you can effectively manage and analyze complex data, gaining deeper insights into your research or projects.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part3/","title":"Loading Part 3: Lake","text":"In\u00a0[12]: Copied! <pre># Import necessary modules\nimport os  # Provides functions for interacting with the operating system.\n# Matplotlib is a library for creating visualizations and plots.\nimport matplotlib.pyplot as plt\nfrom particula.data import (\n    loader_interface,  # This module allows you to load data from files.\n    # This module provides statistics for a collection of data streams.\n    lake_stats\n)\nfrom particula.data.loader_setting_builders import (\n    # These functions create settings for loading data from files.\n    DataChecksBuilder,\n    SizerDataReaderBuilder,\n    Loader1DSettingsBuilder,\n    LoaderSizerSettingsBuilder\n)\nfrom particula.data.tests.example_data.get_example_data import get_data_folder\n# Lake is a container for multiple data streams.\nfrom particula.data.lake import Lake\n\n# Set the parent directory of the data folder\npath = get_data_folder()\n</pre> # Import necessary modules import os  # Provides functions for interacting with the operating system. # Matplotlib is a library for creating visualizations and plots. import matplotlib.pyplot as plt from particula.data import (     loader_interface,  # This module allows you to load data from files.     # This module provides statistics for a collection of data streams.     lake_stats ) from particula.data.loader_setting_builders import (     # These functions create settings for loading data from files.     DataChecksBuilder,     SizerDataReaderBuilder,     Loader1DSettingsBuilder,     LoaderSizerSettingsBuilder ) from particula.data.tests.example_data.get_example_data import get_data_folder # Lake is a container for multiple data streams. from particula.data.lake import Lake  # Set the parent directory of the data folder path = get_data_folder() In\u00a0[13]: Copied! <pre># settings for the CPC data\ndata_checks_cpc = (\n    DataChecksBuilder()\n    .set_characters([10, 100])\n    .set_char_counts({\",\": 4})\n    .set_skip_rows(0)\n    .set_skip_end(0)\n    .build()\n)\n\ncpc_settings = (\n    Loader1DSettingsBuilder()\n    .set_relative_data_folder(\"CPC_3010_data\")\n    .set_filename_regex(\"*.csv\")\n    .set_header_row(0)\n    .set_data_checks(data_checks_cpc)  # from above\n    .set_data_column([1, 2])\n    .set_data_header([\"CPC_count[#/sec]\", \"Temperature[degC]\"])\n    .set_time_column([0])\n    .set_time_format(\"epoch\")\n    .set_delimiter(\",\")\n    .set_timezone_identifier(\"UTC\")\n    .build()\n)\n\n# settings for the SMPS data\ndata_checks_sizer = (\n    DataChecksBuilder()\n    .set_characters([250])\n    .set_skip_rows(25)\n    .set_char_counts({\"/\": 2, \":\": 2})\n    .build()\n)\ndata_sizer_reader = (\n    SizerDataReaderBuilder()\n    .set_sizer_start_keyword(\"20.72\")\n    .set_sizer_end_keyword(\"784.39\")\n    .set_sizer_concentration_convert_from(\"dw/dlogdp\")\n    .build()\n)\nsmps_1d_settings, smps_2d_settings = (\n    LoaderSizerSettingsBuilder()\n    .set_relative_data_folder(\"SMPS_data\")\n    .set_filename_regex(\"*.csv\")\n    .set_header_row(24)\n    .set_data_checks(data_checks_sizer)\n    .set_data_column(\n        [\n            \"Lower Size (nm)\",\n            \"Upper Size (nm)\",\n            \"Sample Temp (C)\",\n            \"Sample Pressure (kPa)\",\n            \"Relative Humidity (%)\",\n            \"Median (nm)\",\n            \"Mean (nm)\",\n            \"Geo. Mean (nm)\",\n            \"Mode (nm)\",\n            \"Geo. Std. Dev.\",\n            \"Total Conc. (#/cm\u00b3)\",\n        ]\n    )\n    .set_data_header(\n        [\n            \"Lower_Size_(nm)\",\n            \"Upper_Size_(nm)\",\n            \"Sample_Temp_(C)\",\n            \"Sample_Pressure_(kPa)\",\n            \"Relative_Humidity_(%)\",\n            \"Median_(nm)\",\n            \"Mean_(nm)\",\n            \"Geo_Mean_(nm)\",\n            \"Mode_(nm)\",\n            \"Geo_Std_Dev.\",\n            \"Total_Conc_(#/cc)\",\n        ]\n    )\n    .set_data_sizer_reader(data_sizer_reader)\n    .set_time_column([1, 2])\n    .set_time_format(\"%m/%d/%Y %H:%M:%S\")\n    .set_delimiter(\",\")\n    .set_timezone_identifier(\"UTC\")\n    .build()\n)\n\n# collect settings into a dictionary\ncombined_settings = {\n    'cpc': cpc_settings,\n    'smps_1d': smps_1d_settings,\n    'smps_2d': smps_2d_settings,\n}\n\n# now call the loader interface for files\nlake = loader_interface.load_folders_interface(\n    path=path,\n    folder_settings=combined_settings,\n)\n\nprint(' ')\nprint(lake)\n</pre> # settings for the CPC data data_checks_cpc = (     DataChecksBuilder()     .set_characters([10, 100])     .set_char_counts({\",\": 4})     .set_skip_rows(0)     .set_skip_end(0)     .build() )  cpc_settings = (     Loader1DSettingsBuilder()     .set_relative_data_folder(\"CPC_3010_data\")     .set_filename_regex(\"*.csv\")     .set_header_row(0)     .set_data_checks(data_checks_cpc)  # from above     .set_data_column([1, 2])     .set_data_header([\"CPC_count[#/sec]\", \"Temperature[degC]\"])     .set_time_column([0])     .set_time_format(\"epoch\")     .set_delimiter(\",\")     .set_timezone_identifier(\"UTC\")     .build() )  # settings for the SMPS data data_checks_sizer = (     DataChecksBuilder()     .set_characters([250])     .set_skip_rows(25)     .set_char_counts({\"/\": 2, \":\": 2})     .build() ) data_sizer_reader = (     SizerDataReaderBuilder()     .set_sizer_start_keyword(\"20.72\")     .set_sizer_end_keyword(\"784.39\")     .set_sizer_concentration_convert_from(\"dw/dlogdp\")     .build() ) smps_1d_settings, smps_2d_settings = (     LoaderSizerSettingsBuilder()     .set_relative_data_folder(\"SMPS_data\")     .set_filename_regex(\"*.csv\")     .set_header_row(24)     .set_data_checks(data_checks_sizer)     .set_data_column(         [             \"Lower Size (nm)\",             \"Upper Size (nm)\",             \"Sample Temp (C)\",             \"Sample Pressure (kPa)\",             \"Relative Humidity (%)\",             \"Median (nm)\",             \"Mean (nm)\",             \"Geo. Mean (nm)\",             \"Mode (nm)\",             \"Geo. Std. Dev.\",             \"Total Conc. (#/cm\u00b3)\",         ]     )     .set_data_header(         [             \"Lower_Size_(nm)\",             \"Upper_Size_(nm)\",             \"Sample_Temp_(C)\",             \"Sample_Pressure_(kPa)\",             \"Relative_Humidity_(%)\",             \"Median_(nm)\",             \"Mean_(nm)\",             \"Geo_Mean_(nm)\",             \"Mode_(nm)\",             \"Geo_Std_Dev.\",             \"Total_Conc_(#/cc)\",         ]     )     .set_data_sizer_reader(data_sizer_reader)     .set_time_column([1, 2])     .set_time_format(\"%m/%d/%Y %H:%M:%S\")     .set_delimiter(\",\")     .set_timezone_identifier(\"UTC\")     .build() )  # collect settings into a dictionary combined_settings = {     'cpc': cpc_settings,     'smps_1d': smps_1d_settings,     'smps_2d': smps_2d_settings, }  # now call the loader interface for files lake = loader_interface.load_folders_interface(     path=path,     folder_settings=combined_settings, )  print(' ') print(lake) <pre>Folder Settings: cpc\n  Loading file: CPC_3010_data_20220709_Jul.csv\n  Loading file: CPC_3010_data_20220710_Jul.csv\nFolder Settings: smps_1d\n  Loading file: 2022-07-07_095151_SMPS.csv\n  Loading file: 2022-07-10_094659_SMPS.csv\nFolder Settings: smps_2d\n  Loading file: 2022-07-07_095151_SMPS.csv\n  Loading file: 2022-07-10_094659_SMPS.csv\n \nLake with streams: ['cpc', 'smps_1d', 'smps_2d']\n</pre> In\u00a0[14]: Copied! <pre># get the names of the streams\nprint(' ')\nprint('Names of the streams:')\nprint(dir(lake))\n</pre> # get the names of the streams print(' ') print('Names of the streams:') print(dir(lake)) <pre> \nNames of the streams:\n['cpc', 'smps_1d', 'smps_2d']\n</pre> In\u00a0[15]: Copied! <pre># get the streams\nprint(' ')\nprint('The streams:')\nfor stream in lake:\n    print(stream)\n</pre> # get the streams print(' ') print('The streams:') for stream in lake:     print(stream) <pre> \nThe streams:\n('cpc', Stream(header=['CPC_count[#/sec]', 'Temperature[degC]'], data=array([[3.3510e+04, 1.7000e+01],\n       [3.3465e+04, 1.7100e+01],\n       [3.2171e+04, 1.7000e+01],\n       ...,\n       [1.9403e+04, 1.6900e+01],\n       [2.0230e+04, 1.7000e+01],\n       [1.9521e+04, 1.6800e+01]]), time=array([1.65734280e+09, 1.65734281e+09, 1.65734281e+09, ...,\n       1.65751559e+09, 1.65751560e+09, 1.65751560e+09]), files=[['CPC_3010_data_20220709_Jul.csv', 1044534], ['CPC_3010_data_20220710_Jul.csv', 1113488]]))\n('smps_1d', Stream(header=['Lower_Size_(nm)', 'Upper_Size_(nm)', 'Sample_Temp_(C)', 'Sample_Pressure_(kPa)', 'Relative_Humidity_(%)', 'Median_(nm)', 'Mean_(nm)', 'Geo_Mean_(nm)', 'Mode_(nm)', 'Geo_Std_Dev.', 'Total_Conc_(#/cc)'], data=array([[2.05000e+01, 7.91500e+02, 2.37000e+01, ..., 2.07210e+01,\n        2.17900e+00, 2.16900e+03],\n       [2.05000e+01, 7.91500e+02, 2.36000e+01, ..., 2.52550e+01,\n        2.10100e+00, 2.39408e+03],\n       [2.05000e+01, 7.91500e+02, 2.37000e+01, ..., 2.18700e+01,\n        2.13600e+00, 2.27861e+03],\n       ...,\n       [2.05000e+01, 7.91500e+02, 2.35000e+01, ..., 2.07210e+01,\n        2.31800e+00, 2.08056e+03],\n       [2.05000e+01, 7.91500e+02, 2.33000e+01, ..., 2.10970e+01,\n        2.31800e+00, 2.10616e+03],\n       [2.05000e+01, 7.91500e+02, 2.35000e+01, ..., 2.07210e+01,\n        2.24800e+00, 2.45781e+03]]), time=array([1.65718376e+09, 1.65718385e+09, 1.65718394e+09, ...,\n       1.65753440e+09, 1.65753450e+09, 1.65753459e+09]), files=[['2022-07-07_095151_SMPS.csv', 5620804], ['2022-07-10_094659_SMPS.csv', 2004838]]))\n('smps_2d', Stream(header=['20.72', '21.10', '21.48', '21.87', '22.27', '22.67', '23.08', '23.50', '23.93', '24.36', '24.80', '25.25', '25.71', '26.18', '26.66', '27.14', '27.63', '28.13', '28.64', '29.16', '29.69', '30.23', '30.78', '31.34', '31.91', '32.49', '33.08', '33.68', '34.29', '34.91', '35.55', '36.19', '36.85', '37.52', '38.20', '38.89', '39.60', '40.32', '41.05', '41.79', '42.55', '43.32', '44.11', '44.91', '45.73', '46.56', '47.40', '48.26', '49.14', '50.03', '50.94', '51.86', '52.80', '53.76', '54.74', '55.73', '56.74', '57.77', '58.82', '59.89', '60.98', '62.08', '63.21', '64.36', '65.52', '66.71', '67.93', '69.16', '70.41', '71.69', '72.99', '74.32', '75.67', '77.04', '78.44', '79.86', '81.31', '82.79', '84.29', '85.82', '87.38', '88.96', '90.58', '92.22', '93.90', '95.60', '97.34', '99.10', '100.90', '102.74', '104.60', '106.50', '108.43', '110.40', '112.40', '114.44', '116.52', '118.64', '120.79', '122.98', '125.21', '127.49', '129.80', '132.16', '134.56', '137.00', '139.49', '142.02', '144.60', '147.22', '149.89', '152.61', '155.38', '158.20', '161.08', '164.00', '166.98', '170.01', '173.09', '176.24', '179.43', '182.69', '186.01', '189.38', '192.82', '196.32', '199.89', '203.51', '207.21', '210.97', '214.80', '218.70', '222.67', '226.71', '230.82', '235.01', '239.28', '243.62', '248.05', '252.55', '257.13', '261.80', '266.55', '271.39', '276.32', '281.33', '286.44', '291.64', '296.93', '302.32', '307.81', '313.40', '319.08', '324.88', '330.77', '336.78', '342.89', '349.12', '355.45', '361.90', '368.47', '375.16', '381.97', '388.91', '395.96', '403.15', '410.47', '417.92', '425.51', '433.23', '441.09', '449.10', '457.25', '465.55', '474.00', '482.61', '491.37', '500.29', '509.37', '518.61', '528.03', '537.61', '547.37', '557.31', '567.42', '577.72', '588.21', '598.89', '609.76', '620.82', '632.09', '643.57', '655.25', '667.14', '679.25', '691.58', '704.14', '716.92', '729.93', '743.18', '756.67', '770.40', '784.39'], data=array([[ 6103.186,  2832.655,  4733.553, ...,    93.413,   122.992,\n            0.   ],\n       [ 5621.118,  5867.747,  6233.403, ...,     0.   ,     0.   ,\n           75.377],\n       [ 5165.139,  4969.987,  4312.386, ...,     0.   ,   122.992,\n          124.085],\n       ...,\n       [ 9962.036,  7986.823,  8682.258, ...,     0.   ,     0.   ,\n          124.153],\n       [ 8765.782, 11175.603,  8148.945, ...,     0.   ,     0.   ,\n          372.433],\n       [14380.528, 11524.35 , 13632.727, ...,     0.   ,     0.   ,\n            0.   ]]), time=array([1.65718376e+09, 1.65718385e+09, 1.65718394e+09, ...,\n       1.65753440e+09, 1.65753450e+09, 1.65753459e+09]), files=[['2022-07-07_095151_SMPS.csv', 5620804], ['2022-07-10_094659_SMPS.csv', 2004838]]))\n</pre> In\u00a0[16]: Copied! <pre># get just the keys\nprint(' ')\nprint('The keys:')\nfor key in lake.keys():\n    print(key)\n</pre> # get just the keys print(' ') print('The keys:') for key in lake.keys():     print(key) <pre> \nThe keys:\ncpc\nsmps_1d\nsmps_2d\n</pre> In\u00a0[17]: Copied! <pre># get just the values\nprint(' ')\nprint('The values:')\nfor value in lake.values():\n    print(value)\n</pre> # get just the values print(' ') print('The values:') for value in lake.values():     print(value) <pre> \nThe values:\nStream(header=['CPC_count[#/sec]', 'Temperature[degC]'], data=array([[3.3510e+04, 1.7000e+01],\n       [3.3465e+04, 1.7100e+01],\n       [3.2171e+04, 1.7000e+01],\n       ...,\n       [1.9403e+04, 1.6900e+01],\n       [2.0230e+04, 1.7000e+01],\n       [1.9521e+04, 1.6800e+01]]), time=array([1.65734280e+09, 1.65734281e+09, 1.65734281e+09, ...,\n       1.65751559e+09, 1.65751560e+09, 1.65751560e+09]), files=[['CPC_3010_data_20220709_Jul.csv', 1044534], ['CPC_3010_data_20220710_Jul.csv', 1113488]])\nStream(header=['Lower_Size_(nm)', 'Upper_Size_(nm)', 'Sample_Temp_(C)', 'Sample_Pressure_(kPa)', 'Relative_Humidity_(%)', 'Median_(nm)', 'Mean_(nm)', 'Geo_Mean_(nm)', 'Mode_(nm)', 'Geo_Std_Dev.', 'Total_Conc_(#/cc)'], data=array([[2.05000e+01, 7.91500e+02, 2.37000e+01, ..., 2.07210e+01,\n        2.17900e+00, 2.16900e+03],\n       [2.05000e+01, 7.91500e+02, 2.36000e+01, ..., 2.52550e+01,\n        2.10100e+00, 2.39408e+03],\n       [2.05000e+01, 7.91500e+02, 2.37000e+01, ..., 2.18700e+01,\n        2.13600e+00, 2.27861e+03],\n       ...,\n       [2.05000e+01, 7.91500e+02, 2.35000e+01, ..., 2.07210e+01,\n        2.31800e+00, 2.08056e+03],\n       [2.05000e+01, 7.91500e+02, 2.33000e+01, ..., 2.10970e+01,\n        2.31800e+00, 2.10616e+03],\n       [2.05000e+01, 7.91500e+02, 2.35000e+01, ..., 2.07210e+01,\n        2.24800e+00, 2.45781e+03]]), time=array([1.65718376e+09, 1.65718385e+09, 1.65718394e+09, ...,\n       1.65753440e+09, 1.65753450e+09, 1.65753459e+09]), files=[['2022-07-07_095151_SMPS.csv', 5620804], ['2022-07-10_094659_SMPS.csv', 2004838]])\nStream(header=['20.72', '21.10', '21.48', '21.87', '22.27', '22.67', '23.08', '23.50', '23.93', '24.36', '24.80', '25.25', '25.71', '26.18', '26.66', '27.14', '27.63', '28.13', '28.64', '29.16', '29.69', '30.23', '30.78', '31.34', '31.91', '32.49', '33.08', '33.68', '34.29', '34.91', '35.55', '36.19', '36.85', '37.52', '38.20', '38.89', '39.60', '40.32', '41.05', '41.79', '42.55', '43.32', '44.11', '44.91', '45.73', '46.56', '47.40', '48.26', '49.14', '50.03', '50.94', '51.86', '52.80', '53.76', '54.74', '55.73', '56.74', '57.77', '58.82', '59.89', '60.98', '62.08', '63.21', '64.36', '65.52', '66.71', '67.93', '69.16', '70.41', '71.69', '72.99', '74.32', '75.67', '77.04', '78.44', '79.86', '81.31', '82.79', '84.29', '85.82', '87.38', '88.96', '90.58', '92.22', '93.90', '95.60', '97.34', '99.10', '100.90', '102.74', '104.60', '106.50', '108.43', '110.40', '112.40', '114.44', '116.52', '118.64', '120.79', '122.98', '125.21', '127.49', '129.80', '132.16', '134.56', '137.00', '139.49', '142.02', '144.60', '147.22', '149.89', '152.61', '155.38', '158.20', '161.08', '164.00', '166.98', '170.01', '173.09', '176.24', '179.43', '182.69', '186.01', '189.38', '192.82', '196.32', '199.89', '203.51', '207.21', '210.97', '214.80', '218.70', '222.67', '226.71', '230.82', '235.01', '239.28', '243.62', '248.05', '252.55', '257.13', '261.80', '266.55', '271.39', '276.32', '281.33', '286.44', '291.64', '296.93', '302.32', '307.81', '313.40', '319.08', '324.88', '330.77', '336.78', '342.89', '349.12', '355.45', '361.90', '368.47', '375.16', '381.97', '388.91', '395.96', '403.15', '410.47', '417.92', '425.51', '433.23', '441.09', '449.10', '457.25', '465.55', '474.00', '482.61', '491.37', '500.29', '509.37', '518.61', '528.03', '537.61', '547.37', '557.31', '567.42', '577.72', '588.21', '598.89', '609.76', '620.82', '632.09', '643.57', '655.25', '667.14', '679.25', '691.58', '704.14', '716.92', '729.93', '743.18', '756.67', '770.40', '784.39'], data=array([[ 6103.186,  2832.655,  4733.553, ...,    93.413,   122.992,\n            0.   ],\n       [ 5621.118,  5867.747,  6233.403, ...,     0.   ,     0.   ,\n           75.377],\n       [ 5165.139,  4969.987,  4312.386, ...,     0.   ,   122.992,\n          124.085],\n       ...,\n       [ 9962.036,  7986.823,  8682.258, ...,     0.   ,     0.   ,\n          124.153],\n       [ 8765.782, 11175.603,  8148.945, ...,     0.   ,     0.   ,\n          372.433],\n       [14380.528, 11524.35 , 13632.727, ...,     0.   ,     0.   ,\n            0.   ]]), time=array([1.65718376e+09, 1.65718385e+09, 1.65718394e+09, ...,\n       1.65753440e+09, 1.65753450e+09, 1.65753459e+09]), files=[['2022-07-07_095151_SMPS.csv', 5620804], ['2022-07-10_094659_SMPS.csv', 2004838]])\n</pre> In\u00a0[18]: Copied! <pre># Load and Plot Data from Lake\n\n# Access CPC data from the Lake\ncpc_time = lake['cpc'].datetime64\ncpc_data = lake['cpc']['CPC_count[#/sec]']\n\n# Access SMPS data from the Lake\nsmps_time = lake['smps_1d'].datetime64\nsmps_data = lake['smps_1d']['Mode_(nm)']\n\n# Plot the Data on Twinx Axis\nfig, ax = plt.subplots()\n\n# Plot CPC data\nax.plot(cpc_time,\n        cpc_data,\n        label='CPC',\n        color='blue')\n\n# Rotate x-axis labels for better readability\nplt.xticks(rotation=45)\n\n# Create a twin y-axis for SMPS data\naxb = ax.twinx()\n\n# Plot SMPS data\naxb.plot(smps_time,\n         smps_data,\n         label='SMPS',\n         color='orange')\n\n# Set y-axis limits for SMPS data\naxb.set_ylim(0, 200)\n\n# Set axis labels\nax.set_xlabel(\"Time (UTC)\")\nax.set_ylabel('CPC Counts [#/sec]')\naxb.set_ylabel('SMPS Mode [nm]')\n\n# Display the legend and show the plot\nplt.show()\n\n# Adjust layout for better visualization\nfig.tight_layout()\n</pre> # Load and Plot Data from Lake  # Access CPC data from the Lake cpc_time = lake['cpc'].datetime64 cpc_data = lake['cpc']['CPC_count[#/sec]']  # Access SMPS data from the Lake smps_time = lake['smps_1d'].datetime64 smps_data = lake['smps_1d']['Mode_(nm)']  # Plot the Data on Twinx Axis fig, ax = plt.subplots()  # Plot CPC data ax.plot(cpc_time,         cpc_data,         label='CPC',         color='blue')  # Rotate x-axis labels for better readability plt.xticks(rotation=45)  # Create a twin y-axis for SMPS data axb = ax.twinx()  # Plot SMPS data axb.plot(smps_time,          smps_data,          label='SMPS',          color='orange')  # Set y-axis limits for SMPS data axb.set_ylim(0, 200)  # Set axis labels ax.set_xlabel(\"Time (UTC)\") ax.set_ylabel('CPC Counts [#/sec]') axb.set_ylabel('SMPS Mode [nm]')  # Display the legend and show the plot plt.show()  # Adjust layout for better visualization fig.tight_layout() In\u00a0[19]: Copied! <pre># Compute the average and standard deviation of data within a time interval\n# of 600 seconds for each stream in the lake, and create a new lake\n# containing the averaged data.\nlake_averaged = lake_stats.average_std(\n    lake=lake,\n    average_interval=600,\n    clone=True  # Create a new lake instead of modifying the original\n)\n\n# Print the resulting lake with averaged data and standard deviation.\nprint(lake_averaged)\n</pre> # Compute the average and standard deviation of data within a time interval # of 600 seconds for each stream in the lake, and create a new lake # containing the averaged data. lake_averaged = lake_stats.average_std(     lake=lake,     average_interval=600,     clone=True  # Create a new lake instead of modifying the original )  # Print the resulting lake with averaged data and standard deviation. print(lake_averaged) <pre>Lake with streams: ['cpc', 'smps_1d', 'smps_2d']\n</pre> In\u00a0[20]: Copied! <pre># Extract datetime and CPC data from the averaged lake\ncpc_time = lake_averaged['cpc'].datetime64\ncpc_data = lake_averaged['cpc']['CPC_count[#/sec]']\n\n# Extract datetime and SMPS data from the averaged lake\nsmps_time = lake_averaged['smps_1d'].datetime64\nsmps_data = lake_averaged['smps_1d']['Mode_(nm)']\n\n# Create a plot with two y-axes (twinx) for CPC and SMPS data\nfig, ax = plt.subplots()\nax.plot(cpc_time,\n        cpc_data,\n        label='CPC',\n        color='blue')\nplt.xticks(rotation=45)\n\n# Create a twinx axis for SMPS data\naxb = ax.twinx()\naxb.plot(smps_time,\n         smps_data,\n         label='SMPS',\n         color='orange',)\naxb.set_ylim(0, 200)\n\n# Set labels for both y-axes and the x-axis\nax.set_xlabel(\"Time (UTC)\")\nax.set_ylabel('CPC_counts[#/sec]')\naxb.set_ylabel('SMPS_Mode[nm]')\n\n# Show the plot and adjust layout for better presentation\nplt.show()\nfig.tight_layout()\n</pre> # Extract datetime and CPC data from the averaged lake cpc_time = lake_averaged['cpc'].datetime64 cpc_data = lake_averaged['cpc']['CPC_count[#/sec]']  # Extract datetime and SMPS data from the averaged lake smps_time = lake_averaged['smps_1d'].datetime64 smps_data = lake_averaged['smps_1d']['Mode_(nm)']  # Create a plot with two y-axes (twinx) for CPC and SMPS data fig, ax = plt.subplots() ax.plot(cpc_time,         cpc_data,         label='CPC',         color='blue') plt.xticks(rotation=45)  # Create a twinx axis for SMPS data axb = ax.twinx() axb.plot(smps_time,          smps_data,          label='SMPS',          color='orange',) axb.set_ylim(0, 200)  # Set labels for both y-axes and the x-axis ax.set_xlabel(\"Time (UTC)\") ax.set_ylabel('CPC_counts[#/sec]') axb.set_ylabel('SMPS_Mode[nm]')  # Show the plot and adjust layout for better presentation plt.show() fig.tight_layout() In\u00a0[21]: Copied! <pre>help(Lake)\n</pre> help(Lake) <pre>Help on class Lake in module particula.data.lake:\n\nclass Lake(builtins.object)\n |  Lake(streams: Dict[str, particula.data.stream.Stream] = &lt;factory&gt;) -&gt; None\n |  \n |  A class representing a lake which is a collection of streams.\n |  \n |  Attributes:\n |      streams (Dict[str, Stream]): A dictionary to hold streams with their\n |      names as keys.\n |  \n |  Methods defined here:\n |  \n |  __delitem__(self, key: str) -&gt; None\n |      Remove a stream by name.\n |      Example: del lake['stream_name']\n |  \n |  __dir__(self) -&gt; list\n |      List available streams.\n |      Example: dir(lake)\n |  \n |  __eq__(self, other)\n |      Return self==value.\n |  \n |  __getattr__(self, name: str) -&gt; Any\n |      Allow accessing streams as an attributes.\n |      Raises:\n |          AttributeError: If the stream name is not in the lake.\n |      Example: lake.stream_name\n |  \n |  __getitem__(self, key: str) -&gt; Any\n |      Get a stream by name.\n |      Example: lake['stream_name']\n |  \n |  __init__(self, streams: Dict[str, particula.data.stream.Stream] = &lt;factory&gt;) -&gt; None\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  __iter__(self) -&gt; Iterator[Any]\n |      Iterate over the streams in the lake.\n |      Example: [stream.header for stream in lake]\"\"\n |  \n |  __len__(self) -&gt; int\n |      Return the number of streams in the lake.\n |      Example: len(lake)\n |  \n |  __repr__(self) -&gt; str\n |      Return a string representation of the lake.\n |      Example: print(lake)\n |  \n |  __setitem__(self, key: str, value: particula.data.stream.Stream) -&gt; None\n |      Set a stream by name.\n |      Example: lake['stream_name'] = new_stream\n |  \n |  add_stream(self, stream: particula.data.stream.Stream, name: str) -&gt; None\n |      Add a stream to the lake.\n |      \n |      Args:\n |          stream (Stream): The stream object to be added.\n |          name (str): The name of the stream.\n |      \n |      Raises:\n |      -------\n |          ValueError: If the stream name is already in use or not a valid\n |          identifier.\n |  \n |  items(self) -&gt; Iterator[Tuple[Any, Any]]\n |      Return an iterator over the key-value pairs.\n |  \n |  keys(self) -&gt; Iterator[Any]\n |      Return an iterator over the keys.\n |  \n |  values(self) -&gt; Iterator[Any]\n |      Return an iterator over the values.\n |  \n |  ----------------------------------------------------------------------\n |  Readonly properties defined here:\n |  \n |  summary\n |      Return a string summary iterating over each stream\n |          and print Stream.header.\n |      Example: lake.summary\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |  \n |  __dict__\n |      dictionary for instance variables\n |  \n |  __weakref__\n |      list of weak references to the object\n |  \n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |  \n |  __annotations__ = {'streams': typing.Dict[str, particula.data.stream.S...\n |  \n |  __dataclass_fields__ = {'streams': Field(name='streams',type=typing.Di...\n |  \n |  __dataclass_params__ = _DataclassParams(init=True,repr=True,eq=True,or...\n |  \n |  __hash__ = None\n |  \n |  __match_args__ = ('streams',)\n\n</pre>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part3/#loading-part-3-lake","title":"Loading Part 3: Lake\u00b6","text":"<p>In this example, we explore the process of working with data from multiple instruments and consolidating them into a single <code>Lake</code> object. A <code>Lake</code> object serves as a convenient container for aggregating multiple <code>Stream</code>s, each representing data from individual instruments.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part3/#setting-the-working-path","title":"Setting the Working Path\u00b6","text":"<p>To begin, you need to establish the working path where your data is stored. For this demonstration, we will use provided example data located in the current directory. However, keep in mind that the path can be anywhere on your computer. For instance, if you have a folder named \"data\" in your home directory, you can set the path as follows:</p> <pre>path = \"U:\\\\data\\\\processing\\\\Campaign2023_of_awesome\\\\data\"\n</pre> <p>Your folder structure should resemble the following:</p> <pre><code>data\n\u251c\u2500\u2500 CPC_3010_data\n\u2502   \u251c\u2500\u2500 CPC_3010_data_20220709_Jul.csv\n\u2502   \u251c\u2500\u2500 CPC_3010_data_20220709_Jul.csv\n\u251c\u2500\u2500 SMPS_data\n\u2502   \u251c\u2500\u2500 2022-07-07_095151_SMPS.csv\n\u2502   \u251c\u2500\u2500 2022-07-10_094659_SMPS.csv\n</code></pre> <p>Here, the path points to the \"data\" folder. Within this folder, you'll find two subfolders: one for CPC data and another for SMPS data. These subfolders correspond to the relative_data_folder keywords used in the settings dictionary. The data within these subfolders will be loaded as Stream objects.</p> <p>Inside each of these subfolders, you'll find data files that match the specified filename_regex. A regular expression is used to select files based on specific criteria. In this case, we are matching all files ending with \".csv\" and loading them into the respective Stream objects. This approach allows you to efficiently manage and consolidate data from various instruments for further analysis and visualization.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part3/#load-the-data","title":"Load the Data\u00b6","text":"<p>In this example, we'll work with provided example data. However, you have the flexibility to change the path to any folder on your computer. We will use the settings generator to efficiently load the data.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part3/#lake-class-overview","title":"Lake Class Overview\u00b6","text":"<p>The <code>Lake</code> is a collection of <code>Stream</code> objects stored as a dictionary. The keys represent the names of the streams, and the values are the stream objects themselves. It provides a convenient way to organize and manage multiple datasets. Let's explore its key attributes and methods:</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part3/#attributes","title":"Attributes:\u00b6","text":"<ul> <li><code>streams</code> (Dict[str, Stream]): A dictionary where keys are stream names, and values are the corresponding <code>Stream</code> objects.</li> </ul>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part3/#methods","title":"Methods:\u00b6","text":"<ul> <li><p><code>__getitem__(self, key: str) -&gt; Any</code>: Retrieve a specific <code>Stream</code> by its name.</p> <ul> <li>Example: To access the CPC stream, you can use <code>lake['cpc']</code>.</li> </ul> </li> <li><p><code>__delitem__(self, key: str) -&gt; None</code>: Remove a <code>Stream</code> from the <code>Lake</code> using its name.</p> <ul> <li>Example: To remove a stream named 'cpc', you can use <code>del lake['cpc']</code>.</li> </ul> </li> <li><p><code>__getattr__(self, name: str) -&gt; Any</code>: Access streams as attributes for easier navigation.</p> <ul> <li>Example: You can directly access the 'cpc' stream with <code>lake.cpc</code>.</li> </ul> </li> <li><p><code>add_stream(self, stream: particula.data.stream.Stream, name: str) -&gt; None</code>: Add a new <code>Stream</code> to the <code>Lake</code>.</p> <ul> <li>Example: To add a new stream, you can use <code>lake.add_stream(new_stream, 'stream_name')</code>.</li> </ul> </li> <li><p><code>__len__(self) -&gt; int</code>: Determine the number of streams in the <code>Lake</code>.</p> <ul> <li>Example: To find out how many streams are in the <code>Lake</code>, use <code>len(lake)</code>.</li> </ul> </li> <li><p><code>__iter__(self) -&gt; Iterator[Any]</code>: Iterate over the streams in the <code>Lake</code>.</p> <ul> <li>Example: To loop through all streams, you can use <code>[stream.header for stream in lake]</code>.</li> </ul> </li> <li><p><code>summary</code> (Readonly property): Generate a summary by iterating through each stream and printing their headers.</p> <ul> <li>Example: To get a summary of all streams, use <code>lake.summary</code>.</li> </ul> </li> </ul>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part3/#usage","title":"Usage:\u00b6","text":"<p>The <code>Lake</code> class simplifies the management of multiple datasets. You can access individual streams by name, add new streams, and iterate through them efficiently. This class is particularly helpful when dealing with various data sources within your analysis.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part3/#pause-to-plot-the-data","title":"Pause to Plot the data\u00b6","text":"<p>In this code snippet, we retrieve data from the Lake object and create a dual-axis plot to visualize both CPC and SMPS data over time.</p> <ul> <li>We access the CPC data from the Lake using lake['cpc']. We retrieve the datetime and CPC count data.</li> <li>Similarly, we access the SMPS data from the Lake using lake['smps_1d'] and retrieve the datetime and Mode data.</li> <li>We create a plot with a blue line for CPC data using ax.plot(), and an orange line for SMPS data on a twin y-axis axb.</li> <li>To improve readability, we rotate the x-axis labels using plt.xticks(rotation=45).</li> <li>We set y-axis limits for the SMPS data to be in the range [0, 200] using axb.set_ylim(0, 200).</li> <li>Axis labels and legends are added for both datasets.</li> <li>Finally, we display the plot and adjust the layout for better visualization using plt.show() and fig.tight_layout().</li> </ul>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part3/#data-averaging","title":"Data Averaging\u00b6","text":"<p>Now that we have loaded the data, we can perform data averaging over time. To achieve this, we will utilize the 'particula.data.lake_stats' module, which provides a convenient function called 'averaged_std.' This function takes a stream object as input and returns a new stream object containing both the averaged data and the standard deviation of the data.</p> <p>It's worth noting that this function follows a similar naming convention to 'stream_stats.average_std,' which operates on individual stream objects.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part3/#plot-the-averaged-data","title":"Plot the Averaged Data\u00b6","text":"<p>Let's plot the averaged data to see how it compares to the raw data. We will use the same approach as before, but this time we will use the averaged data from the Lake object.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part3/#summary","title":"Summary\u00b6","text":"<p>In this part of the tutorial, we learned how to work with multiple streams of data and load them into a <code>Lake</code> object, which is a collection of streams. We explored operations on the data, including averaging it over time using the <code>particula.data.lake_stats</code> module. This allowed us to create more meaningful visualizations by comparing the averaged and non-averaged data. The example demonstrated the power of the <code>particula.data</code> package in handling and analyzing scientific data efficiently.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part4/","title":"Loading Part 4: Settings Files","text":"In\u00a0[15]: Copied! <pre># Import the necessary libraries and modules\nimport matplotlib.pyplot as plt\nfrom particula.data import loader_interface, settings_generator\nfrom particula.data.tests.example_data.get_example_data import get_data_folder\nfrom particula.data.lake import Lake\nfrom particula.data.loader_setting_builders import (\n    # These functions create settings for loading data from files.\n    DataChecksBuilder,\n    SizerDataReaderBuilder,\n    Loader1DSettingsBuilder,\n    LoaderSizerSettingsBuilder,\n)\n\n# Set the parent directory where the data folders are located\npath = get_data_folder()\nprint('Path to data folder:')\nprint(path.rsplit('particula')[-1])\n</pre> # Import the necessary libraries and modules import matplotlib.pyplot as plt from particula.data import loader_interface, settings_generator from particula.data.tests.example_data.get_example_data import get_data_folder from particula.data.lake import Lake from particula.data.loader_setting_builders import (     # These functions create settings for loading data from files.     DataChecksBuilder,     SizerDataReaderBuilder,     Loader1DSettingsBuilder,     LoaderSizerSettingsBuilder, )  # Set the parent directory where the data folders are located path = get_data_folder() print('Path to data folder:') print(path.rsplit('particula')[-1]) <pre>Path to data folder:\n\\data\\tests\\example_data\n</pre> In\u00a0[16]: Copied! <pre># settings for the CPC data\ndata_checks_cpc = (\n    DataChecksBuilder()\n    .set_characters([10, 100])\n    .set_char_counts({\",\": 4})\n    .build()\n)\n\ncpc_settings = (\n    Loader1DSettingsBuilder()\n    .set_relative_data_folder(\"CPC_3010_data\")\n    .set_filename_regex(\"*.csv\")\n    .set_header_row(0)\n    .set_data_checks(data_checks_cpc)  # from above\n    .set_data_column([1, 2])\n    .set_data_header([\"CPC_count[#/sec]\", \"Temperature[degC]\"])\n    .set_time_column([0])\n    .set_time_format(\"epoch\")\n    .set_delimiter(\",\")\n    .set_timezone_identifier(\"UTC\")\n    .build()\n)\n\n# save the settings to a file\nsettings_generator.save_settings_for_stream(\n    settings=cpc_settings,\n    path=path,\n    subfolder='CPC_3010_data',\n    settings_suffix='_cpc',\n)\n</pre> # settings for the CPC data data_checks_cpc = (     DataChecksBuilder()     .set_characters([10, 100])     .set_char_counts({\",\": 4})     .build() )  cpc_settings = (     Loader1DSettingsBuilder()     .set_relative_data_folder(\"CPC_3010_data\")     .set_filename_regex(\"*.csv\")     .set_header_row(0)     .set_data_checks(data_checks_cpc)  # from above     .set_data_column([1, 2])     .set_data_header([\"CPC_count[#/sec]\", \"Temperature[degC]\"])     .set_time_column([0])     .set_time_format(\"epoch\")     .set_delimiter(\",\")     .set_timezone_identifier(\"UTC\")     .build() )  # save the settings to a file settings_generator.save_settings_for_stream(     settings=cpc_settings,     path=path,     subfolder='CPC_3010_data',     settings_suffix='_cpc', ) In\u00a0[17]: Copied! <pre># settings for the SMPS data\ndata_checks_sizer = (\n    DataChecksBuilder()\n    .set_characters([250])\n    .set_skip_rows(25)\n    .set_char_counts({\"/\": 2, \":\": 2})\n    .build()\n)\ndata_sizer_reader = (\n    SizerDataReaderBuilder()\n    .set_sizer_start_keyword(\"20.72\")\n    .set_sizer_end_keyword(\"784.39\")\n    .set_sizer_concentration_convert_from(\"dw/dlogdp\")\n    .build()\n)\nsmps_1d_settings, smps_2d_settings = (\n    LoaderSizerSettingsBuilder()\n    .set_relative_data_folder(\"SMPS_data\")\n    .set_filename_regex(\"*.csv\")\n    .set_header_row(24)\n    .set_data_checks(data_checks_sizer)\n    .set_data_column(\n        [\n            \"Lower Size (nm)\",\n            \"Upper Size (nm)\",\n            \"Sample Temp (C)\",\n            \"Sample Pressure (kPa)\",\n            \"Relative Humidity (%)\",\n            \"Median (nm)\",\n            \"Mean (nm)\",\n            \"Geo. Mean (nm)\",\n            \"Mode (nm)\",\n            \"Geo. Std. Dev.\",\n            \"Total Conc. (#/cm\u00b3)\",\n        ]\n    )\n    .set_data_header(\n        [\n            \"Lower_Size_(nm)\",\n            \"Upper_Size_(nm)\",\n            \"Sample_Temp_(C)\",\n            \"Sample_Pressure_(kPa)\",\n            \"Relative_Humidity_(%)\",\n            \"Median_(nm)\",\n            \"Mean_(nm)\",\n            \"Geo_Mean_(nm)\",\n            \"Mode_(nm)\",\n            \"Geo_Std_Dev.\",\n            \"Total_Conc_(#/cc)\",\n        ]\n    )\n    .set_data_sizer_reader(data_sizer_reader)\n    .set_time_column([1, 2])\n    .set_time_format(\"%m/%d/%Y %H:%M:%S\")\n    .set_delimiter(\",\")\n    .set_timezone_identifier(\"UTC\")\n    .build()\n)\n\n# save the settings to a file\nsettings_generator.save_settings_for_stream(\n    settings=smps_1d_settings,\n    path=path,\n    subfolder='SMPS_data',\n    settings_suffix='_smps_1d',\n)\nsettings_generator.save_settings_for_stream(\n    settings=smps_2d_settings,\n    path=path,\n    subfolder='SMPS_data',\n    settings_suffix='_smps_2d',\n)\n</pre> # settings for the SMPS data data_checks_sizer = (     DataChecksBuilder()     .set_characters([250])     .set_skip_rows(25)     .set_char_counts({\"/\": 2, \":\": 2})     .build() ) data_sizer_reader = (     SizerDataReaderBuilder()     .set_sizer_start_keyword(\"20.72\")     .set_sizer_end_keyword(\"784.39\")     .set_sizer_concentration_convert_from(\"dw/dlogdp\")     .build() ) smps_1d_settings, smps_2d_settings = (     LoaderSizerSettingsBuilder()     .set_relative_data_folder(\"SMPS_data\")     .set_filename_regex(\"*.csv\")     .set_header_row(24)     .set_data_checks(data_checks_sizer)     .set_data_column(         [             \"Lower Size (nm)\",             \"Upper Size (nm)\",             \"Sample Temp (C)\",             \"Sample Pressure (kPa)\",             \"Relative Humidity (%)\",             \"Median (nm)\",             \"Mean (nm)\",             \"Geo. Mean (nm)\",             \"Mode (nm)\",             \"Geo. Std. Dev.\",             \"Total Conc. (#/cm\u00b3)\",         ]     )     .set_data_header(         [             \"Lower_Size_(nm)\",             \"Upper_Size_(nm)\",             \"Sample_Temp_(C)\",             \"Sample_Pressure_(kPa)\",             \"Relative_Humidity_(%)\",             \"Median_(nm)\",             \"Mean_(nm)\",             \"Geo_Mean_(nm)\",             \"Mode_(nm)\",             \"Geo_Std_Dev.\",             \"Total_Conc_(#/cc)\",         ]     )     .set_data_sizer_reader(data_sizer_reader)     .set_time_column([1, 2])     .set_time_format(\"%m/%d/%Y %H:%M:%S\")     .set_delimiter(\",\")     .set_timezone_identifier(\"UTC\")     .build() )  # save the settings to a file settings_generator.save_settings_for_stream(     settings=smps_1d_settings,     path=path,     subfolder='SMPS_data',     settings_suffix='_smps_1d', ) settings_generator.save_settings_for_stream(     settings=smps_2d_settings,     path=path,     subfolder='SMPS_data',     settings_suffix='_smps_2d', ) In\u00a0[18]: Copied! <pre>smps_1d_stream_settings = settings_generator.load_settings_for_stream(\n    path=path,\n    subfolder='SMPS_data',\n    settings_suffix='_smps_1d',\n)\n\nstream_smps_1d = loader_interface.load_files_interface(\n    path=path,\n    settings=smps_1d_stream_settings\n)\n\nprint(stream_smps_1d.header)\n</pre> smps_1d_stream_settings = settings_generator.load_settings_for_stream(     path=path,     subfolder='SMPS_data',     settings_suffix='_smps_1d', )  stream_smps_1d = loader_interface.load_files_interface(     path=path,     settings=smps_1d_stream_settings )  print(stream_smps_1d.header) <pre>  Loading file: 2022-07-07_095151_SMPS.csv\n  Loading file: 2022-07-10_094659_SMPS.csv\n['Lower_Size_(nm)', 'Upper_Size_(nm)', 'Sample_Temp_(C)', 'Sample_Pressure_(kPa)', 'Relative_Humidity_(%)', 'Median_(nm)', 'Mean_(nm)', 'Geo_Mean_(nm)', 'Mode_(nm)', 'Geo_Std_Dev.', 'Total_Conc_(#/cc)']\n</pre> In\u00a0[19]: Copied! <pre># collect settings into a dictionary\ncombined_settings = {\n    'cpc': cpc_settings,\n    'smps_1d': smps_1d_settings,\n    'smps_2d': smps_2d_settings,\n}\n\n# save the lake settings to a file\nsettings_generator.save_settings_for_lake(\n    settings=combined_settings,\n    path=path,\n    subfolder='',\n    settings_suffix='_cpc_smps',\n)\n</pre> # collect settings into a dictionary combined_settings = {     'cpc': cpc_settings,     'smps_1d': smps_1d_settings,     'smps_2d': smps_2d_settings, }  # save the lake settings to a file settings_generator.save_settings_for_lake(     settings=combined_settings,     path=path,     subfolder='',     settings_suffix='_cpc_smps', )  In\u00a0[20]: Copied! <pre>lake_settings = settings_generator.load_settings_for_lake(\n    path=path,\n    subfolder='',\n    settings_suffix='_cpc_smps',\n)\n\n# now call the loader interface for files\nlake = loader_interface.load_folders_interface(\n    path=path,\n    folder_settings=combined_settings,\n)\n\nprint(' ')\nprint(lake)\n</pre> lake_settings = settings_generator.load_settings_for_lake(     path=path,     subfolder='',     settings_suffix='_cpc_smps', )  # now call the loader interface for files lake = loader_interface.load_folders_interface(     path=path,     folder_settings=combined_settings, )  print(' ') print(lake) <pre>Folder Settings: cpc\n  Loading file: CPC_3010_data_20220709_Jul.csv\n  Loading file: CPC_3010_data_20220710_Jul.csv\nFolder Settings: smps_1d\n  Loading file: 2022-07-07_095151_SMPS.csv\n  Loading file: 2022-07-10_094659_SMPS.csv\nFolder Settings: smps_2d\n  Loading file: 2022-07-07_095151_SMPS.csv\n  Loading file: 2022-07-10_094659_SMPS.csv\n \nLake with streams: ['cpc', 'smps_1d', 'smps_2d']\n</pre>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part4/#loading-part-4-settings-files","title":"Loading Part 4: Settings Files\u00b6","text":"<p>In this part of the tutorial, we will explore how to save and load stream and lake settings dictionaries. This can be incredibly useful for preserving your settings, sharing them with others, or simply avoiding the need to retype everything.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part4/#working-path","title":"Working Path\u00b6","text":"<p>In your working path, you will find a couple of <code>.json</code> files. These files are the settings files. The <code>lake_settings.json</code> file stores the settings for the lake, while the <code>stream_settings.json</code> file stores the settings for the stream. These settings are the same ones you created in the previous example, but now they are saved to files for easy access and sharing.</p> <pre><code>data\n\u251c\u2500\u2500 CPC_3010_data\n\u2502   \u251c\u2500\u2500 CPC_3010_data_20220709_Jul.csv\n\u2502   \u251c\u2500\u2500 CPC_3010_data_20220709_Jul.csv\n    \u251c\u2500\u2500 stream_settings_cpc.json\n\u251c\u2500\u2500 SMPS_data\n\u2502   \u251c\u2500\u2500 2022-07-07_095151_SMPS.csv\n\u2502   \u251c\u2500\u2500 2022-07-10_094659_SMPS.csv\n\u2502   \u251c\u2500\u2500 stream_settings_smps_1d.json\n\u2502   \u251c\u2500\u2500 stream_settings_smps_2d.json\n\u251c\u2500\u2500 lake_settings.json\n</code></pre>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part4/#generate-and-save-settings","title":"Generate and Save Settings\u00b6","text":"<p>First, we generate the settings for the CPC data using the <code>settings_generator.for_general_1d_load</code> function. These settings include details such as the data file location, file format, column names, and more.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part4/#next-save-the-smps-settings","title":"Next save the SMPS settings\u00b6","text":""},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part4/#loading-stream-settings","title":"Loading Stream Settings\u00b6","text":"<p>If you are still exploring your analysis pipeline, you may want to load settings for individual streams. To do so, you can use the generate_settings.load_settings_for_stream function. This function takes the path to the settings file as an argument and returns a dictionary containing the stream settings.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part4/#lake-settings","title":"Lake settings\u00b6","text":"<p>If you wanted to load everything for a reanalysis, instead of calling each individual stream, you can first save a lake settings file.  This is done with <code>generate_settings.save_settings_for_lake</code>.  This function takes the path to the lake settings file as an argument.  It returns a dictionary with the settings.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part4/#load-the-lake","title":"Load the Lake\u00b6","text":"<p>To load the lake settings use <code>generate_settings.load_settings_for_lake</code>.  This function takes the path to the lake settings file as an argument.  It returns a dictionary with the settings.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/loading_data_part4/#summary","title":"Summary\u00b6","text":"<p>This example showed how to save and load the settings for a stream and a lake.  This is useful if you want to save your settings and then load them later.  This is also useful if you want to share your settings with someone else.  Or just stop from having to retype everything.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/stream_stats_part1/","title":"Load the data","text":"In\u00a0[2]: Copied! <pre># all the imports, but we'll go through them one by one as we use them\nimport os\nimport matplotlib.pyplot as plt\nfrom particula.data import loader_interface, settings_generator, stream_stats\nfrom particula.data.tests.example_data.get_example_data import get_data_folder\nfrom particula.data.loader_setting_builders import (\n    # These functions create settings for loading data from files.\n    DataChecksBuilder,\n    Loader1DSettingsBuilder,\n)\n\n# set the parent directory of the data folder\npath = get_data_folder()\nprint('Path to data folder:')\nprint(path.rsplit('particula')[-1])\n</pre> # all the imports, but we'll go through them one by one as we use them import os import matplotlib.pyplot as plt from particula.data import loader_interface, settings_generator, stream_stats from particula.data.tests.example_data.get_example_data import get_data_folder from particula.data.loader_setting_builders import (     # These functions create settings for loading data from files.     DataChecksBuilder,     Loader1DSettingsBuilder, )  # set the parent directory of the data folder path = get_data_folder() print('Path to data folder:') print(path.rsplit('particula')[-1]) <pre>Path to data folder:\n\\data\\tests\\example_data\n</pre> In\u00a0[3]: Copied! <pre># settings for the CPC data\ndata_checks_cpc = (\n    DataChecksBuilder()\n    .set_characters([10, 100])\n    .set_char_counts({\",\": 4})\n    .build()\n)\n\nsettings = (\n    Loader1DSettingsBuilder()\n    .set_relative_data_folder(\"CPC_3010_data\")\n    .set_filename_regex(\"*.csv\")\n    .set_header_row(0)\n    .set_data_checks(data_checks_cpc)  # from above\n    .set_data_column([1, 2])\n    .set_data_header([\"CPC_count[#/sec]\", \"Temperature[degC]\"])\n    .set_time_column([0])\n    .set_time_format(\"epoch\")\n    .set_delimiter(\",\")\n    .set_timezone_identifier(\"UTC\")\n    .build()\n)\n\n# now call the loader interface\ndata_stream = loader_interface.load_files_interface(\n    path=path,\n    settings=settings,\n)\n</pre> # settings for the CPC data data_checks_cpc = (     DataChecksBuilder()     .set_characters([10, 100])     .set_char_counts({\",\": 4})     .build() )  settings = (     Loader1DSettingsBuilder()     .set_relative_data_folder(\"CPC_3010_data\")     .set_filename_regex(\"*.csv\")     .set_header_row(0)     .set_data_checks(data_checks_cpc)  # from above     .set_data_column([1, 2])     .set_data_header([\"CPC_count[#/sec]\", \"Temperature[degC]\"])     .set_time_column([0])     .set_time_format(\"epoch\")     .set_delimiter(\",\")     .set_timezone_identifier(\"UTC\")     .build() )  # now call the loader interface data_stream = loader_interface.load_files_interface(     path=path,     settings=settings, ) <pre>  Loading file: CPC_3010_data_20220709_Jul.csv\n  Loading file: CPC_3010_data_20220710_Jul.csv\n</pre> In\u00a0[4]: Copied! <pre># print data stream summary\nprint('Stream:')\nprint(data_stream)\n</pre> # print data stream summary print('Stream:') print(data_stream) <pre>Stream:\nStream(header=['CPC_count[#/sec]', 'Temperature[degC]'], data=array([[3.3510e+04, 1.7000e+01],\n       [3.3465e+04, 1.7100e+01],\n       [3.2171e+04, 1.7000e+01],\n       ...,\n       [1.9403e+04, 1.6900e+01],\n       [2.0230e+04, 1.7000e+01],\n       [1.9521e+04, 1.6800e+01]]), time=array([1.65734280e+09, 1.65734281e+09, 1.65734281e+09, ...,\n       1.65751559e+09, 1.65751560e+09, 1.65751560e+09]), files=[['CPC_3010_data_20220709_Jul.csv', 1044534], ['CPC_3010_data_20220710_Jul.csv', 1113488]])\n</pre> In\u00a0[5]: Copied! <pre># plot the data\nfig, ax = plt.subplots()\nax.plot(data_stream.datetime64,\n        data_stream.data[:, 0],  # data_stream.data is a 2d array, so we need\n                                 # to specify which column we want to plot\n        label=data_stream.header[0],\n        linestyle=\"none\",\n        marker=\".\",)\nplt.xticks(rotation=45)\nax.set_xlabel(\"Time (UTC)\")\nax.set_ylabel(data_stream.header[0])\nplt.show()\nfig.tight_layout()\n</pre> # plot the data fig, ax = plt.subplots() ax.plot(data_stream.datetime64,         data_stream.data[:, 0],  # data_stream.data is a 2d array, so we need                                  # to specify which column we want to plot         label=data_stream.header[0],         linestyle=\"none\",         marker=\".\",) plt.xticks(rotation=45) ax.set_xlabel(\"Time (UTC)\") ax.set_ylabel(data_stream.header[0]) plt.show() fig.tight_layout() In\u00a0[6]: Copied! <pre>stream_averaged = stream_stats.average_std(\n    stream=data_stream,\n    average_interval=600,\n)\nstream_averaged.standard_deviation.shape\n</pre> stream_averaged = stream_stats.average_std(     stream=data_stream,     average_interval=600, ) stream_averaged.standard_deviation.shape Out[6]: <pre>(288, 2)</pre> In\u00a0[7]: Copied! <pre>fig, ax = plt.subplots()\nax.plot(stream_averaged.datetime64,\n        stream_averaged.data[:, 0],\n        label=stream_averaged.header[0],\n        marker=\".\",)\nplt.xticks(rotation=45)\nax.set_xlabel(\"Time (UTC)\")\nax.set_ylabel(stream_averaged.header[0])\nplt.show()\nfig.tight_layout()\n</pre> fig, ax = plt.subplots() ax.plot(stream_averaged.datetime64,         stream_averaged.data[:, 0],         label=stream_averaged.header[0],         marker=\".\",) plt.xticks(rotation=45) ax.set_xlabel(\"Time (UTC)\") ax.set_ylabel(stream_averaged.header[0]) plt.show() fig.tight_layout() In\u00a0[8]: Copied! <pre>stream_filtered = stream_stats.filtering(\n    stream=data_stream,\n    top=250000,\n    drop=True,\n)\nfig, ax = plt.subplots()\nax.plot(stream_filtered.datetime64,\n        stream_filtered.data[:, 0],\n        label=stream_filtered.header[0],\n        marker=\".\",)\nplt.xticks(rotation=45)\nax.set_xlabel(\"Time (UTC)\")\nax.set_ylabel(stream_filtered.header[0])\nplt.show()\nfig.tight_layout()\n</pre> stream_filtered = stream_stats.filtering(     stream=data_stream,     top=250000,     drop=True, ) fig, ax = plt.subplots() ax.plot(stream_filtered.datetime64,         stream_filtered.data[:, 0],         label=stream_filtered.header[0],         marker=\".\",) plt.xticks(rotation=45) ax.set_xlabel(\"Time (UTC)\") ax.set_ylabel(stream_filtered.header[0]) plt.show() fig.tight_layout()"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/stream_stats_part1/#stream-averaging-and-outliers","title":"Stream: Averaging and Outliers\u00b6","text":"<p>This example shows how to clean up a stream of data by removing outliers and and averaging the values over time.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/stream_stats_part1/#working-path","title":"Working path\u00b6","text":"<p>Set the working path where the data is stored. For now we'll use the provided example data in this current directory.</p> <p>But the path could be any where on your computer. For example, if you have a folder called \"data\" in your home directory, you could set the path to: <code>path = \"U:\\\\data\\\\processing\\\\Campgain2023_of_aswsome\\\\data\"</code></p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/stream_stats_part1/#load-the-data","title":"Load the data\u00b6","text":"<p>For this example we'll use the provided example data. But you can change the path to any folder on your computer. We then can used the settings generator to load the data.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/stream_stats_part1/#average-the-data","title":"Average the data\u00b6","text":"<p>Now that we have the data loaded, we can average the data over time. We'll use the 'particula.data.stream_stats' module to do this. The module has a function called 'averaged_std' that will take stream object and return a new stream object with the averaged data and the standard deviation of the data.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/stream_stats_part1/#plot-the-averaged-data","title":"Plot the averaged data\u00b6","text":""},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/stream_stats_part1/#clean-up-the-data","title":"Clean up the data\u00b6","text":"<p>Now we may see some outliers in the data. We can use the 'particula.data.stream_stats' module to remove the outliers. The module has a function called 'filtering' that will take stream object and return a new stream object with the outliers removed.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/stream_stats_part1/#summary","title":"Summary\u00b6","text":"<p>This example shows how to clean up a stream of data by removing outliers and and averaging the values over time.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/stream_stats_size_distribution_part2/","title":"Stream stats size distribution part2","text":"In\u00a0[3]: Copied! <pre># all the imports\nimport matplotlib.pyplot as plt\nfrom particula.data import loader_interface, settings_generator\nfrom particula.data.tests.example_data.get_example_data import get_data_folder\nfrom particula.data.loader_setting_builders import (\n    # These functions create settings for loading data from files.\n    DataChecksBuilder,\n    SizerDataReaderBuilder,\n    LoaderSizerSettingsBuilder,\n)\n\n# the new step\nfrom particula.data.process import size_distribution\n\n# set the parent directory of the data folder\npath = get_data_folder()\n</pre> # all the imports import matplotlib.pyplot as plt from particula.data import loader_interface, settings_generator from particula.data.tests.example_data.get_example_data import get_data_folder from particula.data.loader_setting_builders import (     # These functions create settings for loading data from files.     DataChecksBuilder,     SizerDataReaderBuilder,     LoaderSizerSettingsBuilder, )  # the new step from particula.data.process import size_distribution  # set the parent directory of the data folder path = get_data_folder() In\u00a0[4]: Copied! <pre># settings for the SMPS data\ndata_checks_sizer = (\n    DataChecksBuilder()\n    .set_characters([250])\n    .set_skip_rows(25)\n    .set_char_counts({\"/\": 2, \":\": 2})\n    .build()\n)\ndata_sizer_reader = (\n    SizerDataReaderBuilder()\n    .set_sizer_start_keyword(\"20.72\")\n    .set_sizer_end_keyword(\"784.39\")\n    .set_sizer_concentration_convert_from(\"dw/dlogdp\")\n    .build()\n)\nsmps_1d_settings, smps_2d_settings = (\n    LoaderSizerSettingsBuilder()\n    .set_relative_data_folder(\"SMPS_data\")\n    .set_filename_regex(\"*.csv\")\n    .set_header_row(24)\n    .set_data_checks(data_checks_sizer)\n    .set_data_column(\n        [\n            \"Lower Size (nm)\",\n            \"Upper Size (nm)\",\n            \"Sample Temp (C)\",\n            \"Sample Pressure (kPa)\",\n            \"Relative Humidity (%)\",\n            \"Median (nm)\",\n            \"Mean (nm)\",\n            \"Geo. Mean (nm)\",\n            \"Mode (nm)\",\n            \"Geo. Std. Dev.\",\n            \"Total Conc. (#/cm\u00b3)\",\n        ]\n    )\n    .set_data_header(\n        [\n            \"Lower_Size_(nm)\",\n            \"Upper_Size_(nm)\",\n            \"Sample_Temp_(C)\",\n            \"Sample_Pressure_(kPa)\",\n            \"Relative_Humidity_(%)\",\n            \"Median_(nm)\",\n            \"Mean_(nm)\",\n            \"Geo_Mean_(nm)\",\n            \"Mode_(nm)\",\n            \"Geo_Std_Dev.\",\n            \"Total_Conc_(#/cc)\",\n        ]\n    )\n    .set_data_sizer_reader(data_sizer_reader)\n    .set_time_column([1, 2])\n    .set_time_format(\"%m/%d/%Y %H:%M:%S\")\n    .set_delimiter(\",\")\n    .set_timezone_identifier(\"UTC\")\n    .build()\n)\n\n# collect settings into a dictionary\ncombined_settings = {\n    'smps_1d': smps_1d_settings,\n    'smps_2d': smps_2d_settings,\n}\n\n# now call the loader interface for files\nlake = loader_interface.load_folders_interface(\n    path=path,\n    folder_settings=combined_settings,\n)\n\nprint(' ')\nprint(lake)\n</pre> # settings for the SMPS data data_checks_sizer = (     DataChecksBuilder()     .set_characters([250])     .set_skip_rows(25)     .set_char_counts({\"/\": 2, \":\": 2})     .build() ) data_sizer_reader = (     SizerDataReaderBuilder()     .set_sizer_start_keyword(\"20.72\")     .set_sizer_end_keyword(\"784.39\")     .set_sizer_concentration_convert_from(\"dw/dlogdp\")     .build() ) smps_1d_settings, smps_2d_settings = (     LoaderSizerSettingsBuilder()     .set_relative_data_folder(\"SMPS_data\")     .set_filename_regex(\"*.csv\")     .set_header_row(24)     .set_data_checks(data_checks_sizer)     .set_data_column(         [             \"Lower Size (nm)\",             \"Upper Size (nm)\",             \"Sample Temp (C)\",             \"Sample Pressure (kPa)\",             \"Relative Humidity (%)\",             \"Median (nm)\",             \"Mean (nm)\",             \"Geo. Mean (nm)\",             \"Mode (nm)\",             \"Geo. Std. Dev.\",             \"Total Conc. (#/cm\u00b3)\",         ]     )     .set_data_header(         [             \"Lower_Size_(nm)\",             \"Upper_Size_(nm)\",             \"Sample_Temp_(C)\",             \"Sample_Pressure_(kPa)\",             \"Relative_Humidity_(%)\",             \"Median_(nm)\",             \"Mean_(nm)\",             \"Geo_Mean_(nm)\",             \"Mode_(nm)\",             \"Geo_Std_Dev.\",             \"Total_Conc_(#/cc)\",         ]     )     .set_data_sizer_reader(data_sizer_reader)     .set_time_column([1, 2])     .set_time_format(\"%m/%d/%Y %H:%M:%S\")     .set_delimiter(\",\")     .set_timezone_identifier(\"UTC\")     .build() )  # collect settings into a dictionary combined_settings = {     'smps_1d': smps_1d_settings,     'smps_2d': smps_2d_settings, }  # now call the loader interface for files lake = loader_interface.load_folders_interface(     path=path,     folder_settings=combined_settings, )  print(' ') print(lake) <pre>Folder Settings: smps_1d\n  Loading file: 2022-07-07_095151_SMPS.csv\n  Loading file: 2022-07-10_094659_SMPS.csv\nFolder Settings: smps_2d\n  Loading file: 2022-07-07_095151_SMPS.csv\n  Loading file: 2022-07-10_094659_SMPS.csv\n \nLake with streams: ['smps_1d', 'smps_2d']\n</pre> In\u00a0[5]: Copied! <pre>lake['mean_properties'] = size_distribution.sizer_mean_properties(\n    stream=lake['smps_2d'],\n    diameter_units='nm',\n)\n\n# list out the header\nfor header in lake['mean_properties'].header:\n    print(header)\n</pre> lake['mean_properties'] = size_distribution.sizer_mean_properties(     stream=lake['smps_2d'],     diameter_units='nm', )  # list out the header for header in lake['mean_properties'].header:     print(header) <pre>Total_Conc_(#/cc)\nMean_Diameter_(nm)\nGeometric_Mean_Diameter_(nm)\nMode_Diameter_(nm)\nMean_Diameter_Vol_(nm)\nMode_Diameter_Vol_(nm)\nUnit_Mass_(ug/m3)\nMass_(ug/m3)\nTotal_Conc_(#/cc)_N100\nUnit_Mass_(ug/m3)_N100\nMass_(ug/m3)_N100\nTotal_Conc_(#/cc)_PM1\nUnit_Mass_(ug/m3)_PM1\nMass_(ug/m3)_PM1\nTotal_Conc_(#/cc)_PM2.5\nUnit_Mass_(ug/m3)_PM2.5\nMass_(ug/m3)_PM2.5\nTotal_Conc_(#/cc)_PM10\nUnit_Mass_(ug/m3)_PM10\nMass_(ug/m3)_PM10\n</pre> In\u00a0[6]: Copied! <pre>mean_prop_stream = lake['mean_properties']\n\n# plot the data on twinx axis\nfig, ax = plt.subplots()\nax.plot(mean_prop_stream.datetime64,\n        mean_prop_stream['Mass_(ug/m3)_PM2.5'],\n        label='PM 2.5',\n        color='blue')\nax.plot(mean_prop_stream.datetime64,\n        mean_prop_stream['Mass_(ug/m3)_N100'],\n        label='N100 mass',\n        color='red')\nax.set_ylim(0, 50)\nplt.xticks(rotation=45)\nax.set_xlabel(\"Time (UTC)\")\nax.set_ylabel('PM mass (ug/m3)')\nax.legend()\nplt.show()\nfig.tight_layout()\n</pre> mean_prop_stream = lake['mean_properties']  # plot the data on twinx axis fig, ax = plt.subplots() ax.plot(mean_prop_stream.datetime64,         mean_prop_stream['Mass_(ug/m3)_PM2.5'],         label='PM 2.5',         color='blue') ax.plot(mean_prop_stream.datetime64,         mean_prop_stream['Mass_(ug/m3)_N100'],         label='N100 mass',         color='red') ax.set_ylim(0, 50) plt.xticks(rotation=45) ax.set_xlabel(\"Time (UTC)\") ax.set_ylabel('PM mass (ug/m3)') ax.legend() plt.show() fig.tight_layout()"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/stream_stats_size_distribution_part2/#size-distribution-stats","title":"Size Distribution Stats\u00b6","text":"<p>This example shows how to process size distribution data from an SMPS. The processing returns mean properties of the size distribution, such as the mean diameter, median diameter, and total PM2.5 mass.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/stream_stats_size_distribution_part2/#load-the-data","title":"Load the data\u00b6","text":"<p>For this example we'll use the provided example data. But you can change the path to any folder on your computer. We then can used the settings generator to</p> <p>If you think this settings generator is getting tedious, we hear you. We'll show the fix to that soon.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/stream_stats_size_distribution_part2/#processing-the-stream","title":"Processing the Stream\u00b6","text":"<p>The lake is a collection of streams, stored as a dictionary. The next step can be average the data or you may have a processing step that you want to apply to all the data. For example, you may want to calculate the total PM2.5 mass from the SMPS data. You could do this by looping through the streams and applying a cusutom processing function to each stream. Or you could use some standard process already built in to <code>particula.data.process</code>. In this example we'll use <code>process.size_distribution</code> to calculate the PM2.5 mass from the</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/stream_stats_size_distribution_part2/#plot-the-data","title":"Plot the Data\u00b6","text":"<p>With that processing done we can plot some useful summary plots. For example, we can plot the total PM2.5 mass as a function of time. And on the same plot we can add the N100 mass.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/stream_stats_size_distribution_part2/#tip-calling-the-header-directly","title":"Tip: Calling the header directly\u00b6","text":"<p>Note below how we can call the data header directly from the stream. This is because the get items property defined in the stream class accepts, either and index or a header name. So we can call the header name directly from the stream and get back that specific time series.</p> <p>This is incontrast to callint <code>stream.data['header_name']</code> which would return an error. As that line first calls <code>stream.data</code> returning the np.ndarray, then calls the header name, which is not a valid index for a np.ndarray.</p>"},{"location":"How-To-Guides/Data_Streams_and_Lakes/notebooks/stream_stats_size_distribution_part2/#summary","title":"Summary\u00b6","text":"<p>This example showed how to process size distribution data from an SMPS. The processing returns mean properties of the size distribution, such as the mean diameter, median diameter, and total PM2.5 mass.</p>"},{"location":"How-To-Guides/Equilibria/","title":"Index Equilibria","text":""},{"location":"How-To-Guides/Equilibria/#notebooks","title":"Notebooks","text":"<ul> <li>Activity Coefficients</li> <li>Liquid-Liquid Equilibrium</li> </ul>"},{"location":"How-To-Guides/Equilibria/#what-is-equilibria","title":"What is Equilibria?","text":"<p>Equilibria, a fundamental concept in physical chemistry, refers to the state where the concentrations of reactants and products in a chemical reaction remain constant over time. In the context of aerosol science, equilibria are essential in understanding how aerosol particles interact with their environment, particularly with respect to liquid and vapor phases. This balance is crucial in predicting how aerosols behave under different atmospheric conditions.</p>"},{"location":"How-To-Guides/Equilibria/#why-is-equilibria-important","title":"Why is Equilibria Important?","text":"<p>Studying equilibria in aerosol systems is vital for several reasons:</p> <ol> <li> <p>Environmental Impact: Aerosols play a significant role in air quality and climate change. Understanding their equilibrium behavior helps in assessing their environmental impact, such as their role in cloud formation and solar radiation scattering.</p> </li> <li> <p>Health Implications: Aerosols affect human health, especially in terms of respiratory issues. Knowledge of equilibrium states helps in evaluating exposure risks and designing mitigation strategies.</p> </li> <li> <p>Atmospheric Chemistry: Equilibria studies contribute to our understanding of atmospheric chemistry, particularly in the formation and transformation of aerosols.</p> </li> </ol>"},{"location":"How-To-Guides/Equilibria/#how-does-equilibria-relate-to-these-notebooks","title":"How Does Equilibria Relate to These Notebooks?","text":"<p>The notebooks presented here are dedicated to exploring various aspects of equilibria in aerosol science:</p> <ol> <li> <p>Activity Coefficients and Phase Behavior: By calculating activity coefficients, we can predict how different components of aerosols partition between liquid and vapor phases. This is crucial in understanding the composition and concentration of aerosols under varying atmospheric conditions.</p> </li> <li> <p>Liquid-Vapor Equilibrium: The notebook delves into the equilibrium compositions of liquid-vapor mixtures, highlighting the role of relative humidity (RH) in shaping aerosol behavior.</p> </li> <li> <p>Practical Applications: Through examples and simulations, these notebooks provide practical insights into real-world scenarios, enhancing our understanding of aerosols in environmental and health contexts.</p> </li> </ol> <p>Overall, the notebooks serve as an interactive platform to explore and understand the complex yet fascinating world of equilibria in aerosol science. Whether you're a student, researcher, or enthusiast, these materials offer valuable insights into the dynamic equilibrium processes that govern aerosol behavior in our atmosphere.</p>"},{"location":"How-To-Guides/Equilibria/Notebooks/activity_part1/","title":"Activity Example","text":"In\u00a0[1]: Copied! <pre>import numpy as np  # For numerical operations\nimport matplotlib.pyplot as plt  # For plotting graphs\n# Specific functions from the particula package for activity calculations\nfrom particula.activity import binary_activity, phase_separation, species_density\n</pre> import numpy as np  # For numerical operations import matplotlib.pyplot as plt  # For plotting graphs # Specific functions from the particula package for activity calculations from particula.activity import binary_activity, phase_separation, species_density In\u00a0[2]: Copied! <pre># Define a range of organic mole fractions for the calculation\norganic_mole_fraction = np.linspace(0.001, 1, 1000)\n\n# Define other necessary parameters\noxygen2carbon = 0.225  # Oxygen to carbon ratio\nmolar_mass_ratio = 18.016 / 100  # Water to organic molecular weight ratio\ndensity = species_density.organic_density_estimate(\n    18.016 / molar_mass_ratio,\n    oxygen2carbon)  # Estimate of organic compound density\n\n# Calculate activity coefficients using the binary_activity function\nactivity_water, activity_organic, mass_water, mass_organic, gamma_water, gamma_organic = \\\n    binary_activity.activity_coefficients(\n        molar_mass_ratio,\n        organic_mole_fraction,\n        oxygen2carbon,\n        density,\n        functional_group=None)\n</pre> # Define a range of organic mole fractions for the calculation organic_mole_fraction = np.linspace(0.001, 1, 1000)  # Define other necessary parameters oxygen2carbon = 0.225  # Oxygen to carbon ratio molar_mass_ratio = 18.016 / 100  # Water to organic molecular weight ratio density = species_density.organic_density_estimate(     18.016 / molar_mass_ratio,     oxygen2carbon)  # Estimate of organic compound density  # Calculate activity coefficients using the binary_activity function activity_water, activity_organic, mass_water, mass_organic, gamma_water, gamma_organic = \\     binary_activity.activity_coefficients(         molar_mass_ratio,         organic_mole_fraction,         oxygen2carbon,         density,         functional_group=None) In\u00a0[3]: Copied! <pre>fig, ax = plt.subplots()\nax.plot(\n    1 - organic_mole_fraction,\n    activity_water,\n    label=\"water\",\n    linestyle='dashed'\n)\nax.plot(\n    1 - organic_mole_fraction,\n    activity_organic,\n    label=\"organic\",\n)\nax.set_ylim()\nax.set_xlabel(\"water mole fraction\")\nax.set_ylabel(\"activity\")\nax.legend()\nplt.show()\n\nfig, ax = plt.subplots()\nax.plot(\n    1 - organic_mole_fraction,\n    gamma_water,\n    label=\"water\",\n    linestyle='dashed'\n)\nax.plot(\n    1 - organic_mole_fraction,\n    gamma_organic,\n    label=\"organic\",\n)\nax.set_ylim()\nax.set_xlabel(\"water mole fraction\")\nax.set_ylabel(\"activity coefficient\")\nax.legend()\nplt.show()\n</pre> fig, ax = plt.subplots() ax.plot(     1 - organic_mole_fraction,     activity_water,     label=\"water\",     linestyle='dashed' ) ax.plot(     1 - organic_mole_fraction,     activity_organic,     label=\"organic\", ) ax.set_ylim() ax.set_xlabel(\"water mole fraction\") ax.set_ylabel(\"activity\") ax.legend() plt.show()  fig, ax = plt.subplots() ax.plot(     1 - organic_mole_fraction,     gamma_water,     label=\"water\",     linestyle='dashed' ) ax.plot(     1 - organic_mole_fraction,     gamma_organic,     label=\"organic\", ) ax.set_ylim() ax.set_xlabel(\"water mole fraction\") ax.set_ylabel(\"activity coefficient\") ax.legend() plt.show() In\u00a0[4]: Copied! <pre># Finding phase separation points and calculating q_alpha\nphase_sep_aw = phase_separation.find_phase_separation(\n    activity_water, activity_organic)\nq_alpha = phase_separation.q_alpha(\n    seperation_activity=phase_sep_aw['upper_seperation'],\n    activities=activity_water)\n\n# Plotting q_alpha\nfig, ax = plt.subplots()\nplt.plot(activity_water, q_alpha)\nplt.xlabel('Water Activity')\nplt.ylabel('$q^{\\\\alpha}$ [Organic Rich to Water Rich]')\nplt.show()\n</pre> # Finding phase separation points and calculating q_alpha phase_sep_aw = phase_separation.find_phase_separation(     activity_water, activity_organic) q_alpha = phase_separation.q_alpha(     seperation_activity=phase_sep_aw['upper_seperation'],     activities=activity_water)  # Plotting q_alpha fig, ax = plt.subplots() plt.plot(activity_water, q_alpha) plt.xlabel('Water Activity') plt.ylabel('$q^{\\\\alpha}$ [Organic Rich to Water Rich]') plt.show() In\u00a0[5]: Copied! <pre># select the water activity desired\nwater_activity_desired = np.linspace(0.5, 1, 100)\noxygen2carbon = 0.25\n\n# calculate the mass fraction of water in the alpha and beta phases\n# for each water activity\nalpha, beta, q_alpha = binary_activity.fixed_water_activity(\n        water_activity=water_activity_desired,\n        molar_mass_ratio=molar_mass_ratio,\n        oxygen2carbon=oxygen2carbon,\n        density=density\n        )\n\n# plot the results vs water activity\nfig, ax = plt.subplots()\nax.plot(\n    water_activity_desired,\n    alpha[2],\n    label=\"alpha phase mass fraction water\",\n)\nax.plot(\n        water_activity_desired,\n        q_alpha,\n        label=\"q_alpha\",\n        )\nif beta is not None:\n    ax.plot(\n        water_activity_desired,\n        beta[2],\n        label=\"beta phase mass fraction water\",\n    )\nax.set_ylim()\nax.set_xlabel(\"water activity (Relative Humidity/100)\")\nax.set_ylabel(\"mass fraction of water\")\nplt.legend()\nplt.show()\n</pre> # select the water activity desired water_activity_desired = np.linspace(0.5, 1, 100) oxygen2carbon = 0.25  # calculate the mass fraction of water in the alpha and beta phases # for each water activity alpha, beta, q_alpha = binary_activity.fixed_water_activity(         water_activity=water_activity_desired,         molar_mass_ratio=molar_mass_ratio,         oxygen2carbon=oxygen2carbon,         density=density         )  # plot the results vs water activity fig, ax = plt.subplots() ax.plot(     water_activity_desired,     alpha[2],     label=\"alpha phase mass fraction water\", ) ax.plot(         water_activity_desired,         q_alpha,         label=\"q_alpha\",         ) if beta is not None:     ax.plot(         water_activity_desired,         beta[2],         label=\"beta phase mass fraction water\",     ) ax.set_ylim() ax.set_xlabel(\"water activity (Relative Humidity/100)\") ax.set_ylabel(\"mass fraction of water\") plt.legend() plt.show() In\u00a0[6]: Copied! <pre># select the water activity desired\nwater_activity_desired = np.linspace(0.5, 1, 100)\n# select the oxygen to carbon ratio\noxygen2carbon = 0.6\n\n# calculate the mass fraction of water in the alpha and beta phases\n# for each water activity\nalpha, beta, q_alpha = binary_activity.fixed_water_activity(\n    water_activity=water_activity_desired,\n    molar_mass_ratio=molar_mass_ratio,\n    oxygen2carbon=oxygen2carbon,\n    density=density\n)\n\n# plot the results vs water activity\nfig, ax = plt.subplots()\nax.plot(\n    water_activity_desired,\n    alpha[2],\n    label=\"alpha phase mass fraction water\",\n)\nax.plot(\n    water_activity_desired,\n    q_alpha,\n    label=\"q_alpha\",\n)\nif beta is not None:\n    ax.plot(\n        water_activity_desired,\n        beta[2],\n        label=\"beta phase mass fraction water\",\n    )\nax.set_ylim()\nax.set_xlabel(\"water activity (Relative Humidity/100)\")\nax.set_ylabel(\"mass fraction of water\")\nplt.legend()\nplt.show()\n</pre> # select the water activity desired water_activity_desired = np.linspace(0.5, 1, 100) # select the oxygen to carbon ratio oxygen2carbon = 0.6  # calculate the mass fraction of water in the alpha and beta phases # for each water activity alpha, beta, q_alpha = binary_activity.fixed_water_activity(     water_activity=water_activity_desired,     molar_mass_ratio=molar_mass_ratio,     oxygen2carbon=oxygen2carbon,     density=density )  # plot the results vs water activity fig, ax = plt.subplots() ax.plot(     water_activity_desired,     alpha[2],     label=\"alpha phase mass fraction water\", ) ax.plot(     water_activity_desired,     q_alpha,     label=\"q_alpha\", ) if beta is not None:     ax.plot(         water_activity_desired,         beta[2],         label=\"beta phase mass fraction water\",     ) ax.set_ylim() ax.set_xlabel(\"water activity (Relative Humidity/100)\") ax.set_ylabel(\"mass fraction of water\") plt.legend() plt.show() In\u00a0[7]: Copied! <pre>help(binary_activity)\n</pre> help(binary_activity) <pre>Help on module particula.activity.binary_activity in particula.activity:\n\nNAME\n    particula.activity.binary_activity - Binary activity coefficient model for organic-water mixtures.\n\nDESCRIPTION\n    Gorkowski, K., Preston, T. C., &amp;#38; Zuend, A. (2019).\n    Relative-humidity-dependent organic aerosol thermodynamics\n    Via an efficient reduced-complexity model.\n    Atmospheric Chemistry and Physics\n    https://doi.org/10.5194/acp-19-13383-2019\n\nFUNCTIONS\n    activity_coefficients(molar_mass_ratio: Union[numpy.__array_like._SupportsArray[numpy.dtype[Any]], numpy.__nested_sequence._NestedSequence[numpy.__array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy.__nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], organic_mole_fraction: Union[numpy.__array_like._SupportsArray[numpy.dtype[Any]], numpy.__nested_sequence._NestedSequence[numpy.__array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy.__nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], oxygen2carbon: Union[numpy.__array_like._SupportsArray[numpy.dtype[Any]], numpy.__nested_sequence._NestedSequence[numpy.__array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy.__nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], density: Union[numpy.__array_like._SupportsArray[numpy.dtype[Any]], numpy.__nested_sequence._NestedSequence[numpy.__array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy.__nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], functional_group=None) -&gt; Tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray]\n        Calculate the activity coefficients for water and organic matter in\n        organic-water mixtures.\n        \n        Args:\n            - molar_mass_ratio: Ratio of the molecular weight of water to the\n                molecular weight of organic matter.\n            - organic_mole_fraction: Molar fraction of organic matter in the\n                mixture.\n            - oxygen2carbon: Oxygen to carbon ratio in the organic compound.\n            - density: Density of the mixture.\n            - functional_group: Optional functional group(s) of the organic\n                compound, if applicable.\n        \n        Returns:\n            A tuple containing the activity of water, activity\n            of organic matter, mass fraction of water, and mass\n            fraction of organic matter, gamma_water (activity coefficient),\n            and gamma_organic (activity coefficient).\n    \n    bat_blending_weights(molar_mass_ratio: Union[numpy.__array_like._SupportsArray[numpy.dtype[Any]], numpy.__nested_sequence._NestedSequence[numpy.__array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy.__nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], oxygen2carbon: Union[numpy.__array_like._SupportsArray[numpy.dtype[Any]], numpy.__nested_sequence._NestedSequence[numpy.__array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy.__nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]]) -&gt; numpy.ndarray\n        Function to estimate the blending weights for the BAT model.\n        \n        Args:\n            - molar_mass_ratio: The molar mass ratio of water to organic\n                matter.\n            - oxygen2carbon: The oxygen to carbon ratio.\n        \n        Returns:\n            - blending_weights : List of blending weights for the BAT model\n            in the low, mid, and high oxygen2carbon regions.\n    \n    biphasic_water_activity_point(oxygen2carbon: Union[numpy.__array_like._SupportsArray[numpy.dtype[Any]], numpy.__nested_sequence._NestedSequence[numpy.__array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy.__nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], hydrogen2carbon: Union[numpy.__array_like._SupportsArray[numpy.dtype[Any]], numpy.__nested_sequence._NestedSequence[numpy.__array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy.__nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], molar_mass_ratio: Union[numpy.__array_like._SupportsArray[numpy.dtype[Any]], numpy.__nested_sequence._NestedSequence[numpy.__array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy.__nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], functional_group: Union[list[str], str, NoneType] = None) -&gt; numpy.ndarray\n        This function computes the biphasic to single phase\n        water activity (RH*100).\n        \n        Args:\n            - oxygen2carbon: The oxygen to carbon ratio.\n            - hydrogen2carbon: The hydrogen to carbon ratio.\n            - molar_mass_ratio: The molar mass ratio of water to organic\n                matter.\n            - functional_group: Optional functional group(s) of the organic\n                compound, if applicable.\n        \n        Returns:\n            - np.array: The RH cross point array.\n    \n    coefficients_c(molar_mass_ratio: Union[numpy.__array_like._SupportsArray[numpy.dtype[Any]], numpy.__nested_sequence._NestedSequence[numpy.__array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy.__nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], oxygen2carbon: Union[numpy.__array_like._SupportsArray[numpy.dtype[Any]], numpy.__nested_sequence._NestedSequence[numpy.__array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy.__nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], fit_values: Union[numpy.__array_like._SupportsArray[numpy.dtype[Any]], numpy.__nested_sequence._NestedSequence[numpy.__array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy.__nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]]) -&gt; numpy.ndarray\n        Coefficients for activity model, see Gorkowski (2019). equation S1 S2.\n        \n        Args:\n            - molar_mass_ratio: The molar mass ratio of water to organic\n                matter.\n            - oxygen2carbon: The oxygen to carbon ratio.\n            - fit_values: The fit values for the activity model.\n        \n        Returns:\n            - np.ndarray: The coefficients for the activity model.\n    \n    convert_to_oh_equivalent(oxygen2carbon: Union[numpy.__array_like._SupportsArray[numpy.dtype[Any]], numpy.__nested_sequence._NestedSequence[numpy.__array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy.__nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], molar_mass_ratio: Union[numpy.__array_like._SupportsArray[numpy.dtype[Any]], numpy.__nested_sequence._NestedSequence[numpy.__array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy.__nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], functional_group: Union[list[str], str, NoneType] = None) -&gt; Tuple[numpy.ndarray, numpy.ndarray]\n        just a pass through now, but will\n        add the oh equivalent conversion\n    \n    fixed_water_activity(water_activity: Union[numpy.__array_like._SupportsArray[numpy.dtype[Any]], numpy.__nested_sequence._NestedSequence[numpy.__array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy.__nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], molar_mass_ratio: Union[numpy.__array_like._SupportsArray[numpy.dtype[Any]], numpy.__nested_sequence._NestedSequence[numpy.__array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy.__nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], oxygen2carbon: Union[numpy.__array_like._SupportsArray[numpy.dtype[Any]], numpy.__nested_sequence._NestedSequence[numpy.__array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy.__nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], density: Union[numpy.__array_like._SupportsArray[numpy.dtype[Any]], numpy.__nested_sequence._NestedSequence[numpy.__array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy.__nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]]) -&gt; Tuple\n        Calculate the activity coefficients of water and organic matter in\n        organic-water mixtures.\n        \n        This function assumes a fixed water activity value (e.g., RH = 75%\n        corresponds to 0.75 water activity in equilibrium).\n        It calculates the activity coefficients for different phases and\n        determines phase separations if they occur.\n        \n        Parameters:\n        water_activity (ArrayLike): An array of water activity values.\n        molar_mass_ratio (ArrayLike): Array of molar mass ratios of the components.\n        oxygen2carbon (ArrayLike): Array of oxygen-to-carbon ratios.\n        density (ArrayLike): Array of densities of the mixture.\n        \n        Returns:\n        Tuple: A tuple containing the activity coefficients for alpha and beta\n                phases, and the alpha phase mole fraction.\n               If no phase separation occurs, the beta phase values are None.\n    \n    gibbs_mix_weight(molar_mass_ratio: Union[numpy.__array_like._SupportsArray[numpy.dtype[Any]], numpy.__nested_sequence._NestedSequence[numpy.__array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy.__nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], organic_mole_fraction: Union[numpy.__array_like._SupportsArray[numpy.dtype[Any]], numpy.__nested_sequence._NestedSequence[numpy.__array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy.__nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], oxygen2carbon: Union[numpy.__array_like._SupportsArray[numpy.dtype[Any]], numpy.__nested_sequence._NestedSequence[numpy.__array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy.__nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], density: Union[numpy.__array_like._SupportsArray[numpy.dtype[Any]], numpy.__nested_sequence._NestedSequence[numpy.__array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy.__nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], functional_group: Optional[str] = None) -&gt; Tuple[numpy.ndarray, numpy.ndarray]\n        Gibbs free energy of mixing, see Gorkowski (2019), with weighted\n        oxygen2carbon regions. Only can run one compound at a time.\n        \n        Args:\n            - molar_mass_ratio: The molar mass ratio of water to organic\n                matter.\n            - organic_mole_fraction: The fraction of organic matter.\n            - oxygen2carbon: The oxygen to carbon ratio.\n            - density: The density of the mixture.\n            - functional_group: Optional functional group(s) of the organic\n                compound, if applicable.\n        \n        Returns:\n            - gibbs_mix : Gibbs energy of mixing (including 1/RT)\n            - derivative_gibbs : derivative of Gibbs energy with respect to\n            - mole fraction of organics (includes 1/RT)\n    \n    gibbs_of_mixing(molar_mass_ratio: Union[numpy.__array_like._SupportsArray[numpy.dtype[Any]], numpy.__nested_sequence._NestedSequence[numpy.__array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy.__nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], organic_mole_fraction: Union[numpy.__array_like._SupportsArray[numpy.dtype[Any]], numpy.__nested_sequence._NestedSequence[numpy.__array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy.__nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], oxygen2carbon: Union[numpy.__array_like._SupportsArray[numpy.dtype[Any]], numpy.__nested_sequence._NestedSequence[numpy.__array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy.__nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], density: Union[numpy.__array_like._SupportsArray[numpy.dtype[Any]], numpy.__nested_sequence._NestedSequence[numpy.__array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy.__nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]], fit_dict: dict) -&gt; Tuple[numpy.ndarray, numpy.ndarray]\n        Calculate the Gibbs free energy of mixing for a binary mixture.\n        \n        Args:\n            - molar_mass_ratio: The molar mass ratio of water to organic\n                matter.\n            - organic_mole_fraction: The fraction of organic matter.\n            - oxygen2carbon: The oxygen to carbon ratio.\n            - density: The density of the mixture.\n            - fit_dict: A dictionary of fit values for the low oxygen2carbon region\n        \n        Returns:\n            Tuple[np.ndarray, np.ndarray]: A tuple containing the Gibbs free\n            energy of mixing and its derivative.\n\nDATA\n    ArrayLike = typing.Union[numpy._typing._array_like._Supports...ng.Unio...\n    FIT_HIGH = {'a1': [5.92155, -2.528295, -3.883017, -7.898128], 'a2': [-...\n    FIT_LOW = {'a1': [7.089476, -7.71186, -38.85941, -100.0], 'a2': [-0.62...\n    FIT_MID = {'a1': [5.872214, -4.535007, -5.129327, -28.09232], 'a2': [-...\n    INTERPOLATE_WATER_FIT = 500\n    LOWEST_ORGANIC_MOLE_FRACTION = 1e-12\n    Optional = typing.Optional\n        Optional type.\n        \n        Optional[X] is equivalent to Union[X, None].\n    \n    Tuple = typing.Tuple\n        Tuple type; Tuple[X, Y] is the cross-product type of X and Y.\n        \n        Example: Tuple[T1, T2] is a tuple of two elements corresponding\n        to type variables T1 and T2.  Tuple[int, float, str] is a tuple\n        of an int, a float and a string.\n        \n        To specify a variable-length tuple of homogeneous type, use Tuple[T, ...].\n    \n    Union = typing.Union\n        Union type; Union[X, Y] means either X or Y.\n        \n        To define a union, use e.g. Union[int, str].  Details:\n        - The arguments must be types and there must be at least one.\n        - None as an argument is a special case and is replaced by\n          type(None).\n        - Unions of unions are flattened, e.g.::\n        \n            Union[Union[int, str], float] == Union[int, str, float]\n        \n        - Unions of a single argument vanish, e.g.::\n        \n            Union[int] == int  # The constructor actually returns int\n        \n        - Redundant arguments are skipped, e.g.::\n        \n            Union[int, str, int] == Union[int, str]\n        \n        - When comparing unions, the argument order is ignored, e.g.::\n        \n            Union[int, str] == Union[str, int]\n        \n        - You cannot subclass or instantiate a union.\n        - You can use Optional[X] as a shorthand for Union[X, None].\n\nFILE\n    c:\\users\\kkgor\\onedrive\\areas\\github\\particula\\particula\\activity\\binary_activity.py\n\n\n</pre>"},{"location":"How-To-Guides/Equilibria/Notebooks/activity_part1/#activity-example","title":"Activity Example\u00b6","text":"<p>This notebook demonstrates the Binary Activity Theory (BAT) model application, crucial for calculating the activity of water and organic compounds in mixtures and understanding phase separation. This model, as detailed in Gorkowski, K., Preston, T. C., &amp; Zuend, A. (2019), provides critical insights into aerosol particle behavior, essential in environmental and climate change research.</p> <p>Reference: Gorkowski, K., Preston, T. C., &amp; Zuend, A. (2019). Relative-humidity-dependent organic aerosol thermodynamics Via an efficient reduced-complexity model. Atmospheric Chemistry and Physics https://doi.org/10.5194/acp-19-13383-2019</p>"},{"location":"How-To-Guides/Equilibria/Notebooks/activity_part1/#activity-calculation","title":"Activity Calculation\u00b6","text":"<p>Define the parameters required by the activity module to calculate the activity of water and organic compounds in a mixture, as well as phase separation. These parameters include organic mole fraction, density, molecular weight ratio [water/organic], and the density of the organic compound. Using these parameters helps in accurately modeling the behavior of aerosol particles in various environmental conditions.</p>"},{"location":"How-To-Guides/Equilibria/Notebooks/activity_part1/#plotting-the-activity-and-phase-separation","title":"Plotting the Activity and Phase Separation\u00b6","text":"<p>Here we plot the activity of water and the organic compound as a function of the organic mole fraction. Visualizing these activities helps in identifying phase separation or miscibility gaps, crucial for understanding the behavior of aerosols under different environmental conditions. Phase separation is indicated by activities greater than 1.0 or non-monotonic behavior in the activity curve, as shown below.</p>"},{"location":"How-To-Guides/Equilibria/Notebooks/activity_part1/#qalpha","title":"$ q^\\alpha $\u00b6","text":"<p>The $q^\\alpha$ parameter signifies the transition from an organic-rich phase to a water-rich phase. This transition is crucial for understanding the phase behavior of aerosol particles. It can be calculated using the <code>particula.activity.phase_separation</code> function. The plot below illustrates $q^\\alpha$ based on the activity calculations performed earlier.</p>"},{"location":"How-To-Guides/Equilibria/Notebooks/activity_part1/#water-activity-focus","title":"Water Activity Focus\u00b6","text":"<p>In atmospheric aerosol modeling, water activity is often a more critical parameter than mole fraction. This is because water activity is typically a controllable or known variable in atmospheric conditions, unlike the exact mole fractions in a solution. To correlate water activity with the mole fraction required to achieve it, we utilize functions from the <code>particula.activity</code> module.</p>"},{"location":"How-To-Guides/Equilibria/Notebooks/activity_part1/#higher-oxygen-to-carbon-ratios","title":"Higher Oxygen to Carbon Ratios\u00b6","text":"<p>Higher oxygen to carbon ratios in the mixture tend to inhibit phase separation. The following analysis demonstrates this effect. This observation is crucial in predicting the behavior of aerosol particles under varying chemical compositions (more or less 'aged').</p>"},{"location":"How-To-Guides/Equilibria/Notebooks/activity_part1/#summary","title":"Summary\u00b6","text":"<p>This notebook demonstrates how to use the activity module for calculating the activity of water and organic compounds in a mixture and assessing phase separation. The insights gained are vital for applications in aerosol thermodynamics, cloud condensation nuclei, and cloud microphysics.</p> <p>This is an implementation of the Binary Activity Theory (BAT) model developed in Gorkowski, K., Preston, T. C., &amp; Zuend, A. (2019).</p>"},{"location":"How-To-Guides/Equilibria/Notebooks/activity_part1/#further-documentation","title":"Further Documentation\u00b6","text":"<p>For more in-depth understanding and additional functionalities, refer to the documentation, or call the <code>help</code> function on any of the functions in the <code>particula.activity</code> module.</p>"},{"location":"How-To-Guides/Equilibria/Notebooks/equilibria_part1/","title":"Liquid Vapor Equilibrium","text":"In\u00a0[1]: Copied! <pre># Importing necessary libraries\nimport matplotlib.pyplot as plt  # For creating plots and visualizations\nimport numpy as np  # For numerical operations\nfrom particula.activity import species_density  # For calculating species density\n# For partitioning calculations in liquid-vapor equilibrium\nfrom particula.equilibria import partitioning\n</pre> # Importing necessary libraries import matplotlib.pyplot as plt  # For creating plots and visualizations import numpy as np  # For numerical operations from particula.activity import species_density  # For calculating species density # For partitioning calculations in liquid-vapor equilibrium from particula.equilibria import partitioning In\u00a0[2]: Copied! <pre># Defining system parameters\nc_star_j_dry = [1e-6, 1e-4, 1e-1, 1e2, 1e4]  # Volatility distribution in ug/m3\n# Total concentration in ug/m3\nconcentration_organic_matter = [1, 5, 10, 15, 10]\noxygen2carbon = np.array([0.2, 0.3, 0.5, 0.4, 0.4])  # Oxygen to carbon ratios\n\nmolar_mass = np.array([200, 200, 200, 200, 200])  # Molar mass in g/mol\nwater_activity_desired = np.array([0.8])  # Desired water activity\nmolar_mass_ratio = 18.015 / np.array(molar_mass)  # Molar mass ratio\n\n# Calculate the density of organic compounds\ndensity = species_density.organic_array(\n    molar_mass,\n    oxygen2carbon,\n    hydrogen2carbon=None,\n    nitrogen2carbon=None)\n</pre> # Defining system parameters c_star_j_dry = [1e-6, 1e-4, 1e-1, 1e2, 1e4]  # Volatility distribution in ug/m3 # Total concentration in ug/m3 concentration_organic_matter = [1, 5, 10, 15, 10] oxygen2carbon = np.array([0.2, 0.3, 0.5, 0.4, 0.4])  # Oxygen to carbon ratios  molar_mass = np.array([200, 200, 200, 200, 200])  # Molar mass in g/mol water_activity_desired = np.array([0.8])  # Desired water activity molar_mass_ratio = 18.015 / np.array(molar_mass)  # Molar mass ratio  # Calculate the density of organic compounds density = species_density.organic_array(     molar_mass,     oxygen2carbon,     hydrogen2carbon=None,     nitrogen2carbon=None) In\u00a0[3]: Copied! <pre># Calculate the properties needed for liquid-vapor partitioning\ngamma_organic_ab, mass_fraction_water_ab, q_ab = \\\n    partitioning.get_properties_for_liquid_vapor_partitioning(\n        water_activity_desired=water_activity_desired,\n        molar_mass=molar_mass,\n        oxygen2carbon=oxygen2carbon,\n        density=density,\n    )\n\n# The optimization the partition coefficients, i.e. the partitioning calculation\nalpha_opt, beta_opt, system_opt, fit_result = \\\n    partitioning.liquid_vapor_partitioning(\n        c_star_j_dry=c_star_j_dry,\n        concentration_organic_matter=concentration_organic_matter,\n        molar_mass=molar_mass,\n        gamma_organic_ab=gamma_organic_ab,\n        mass_fraction_water_ab=mass_fraction_water_ab,\n        q_ab=q_ab,\n        partition_coefficient_guess=None,\n    )\n\nprint(f\"mass in organic aerosol [ug/m3]: {system_opt[0]}\")\nprint(f\"mass in water [ug/3]: {system_opt[1]}\")\n</pre> # Calculate the properties needed for liquid-vapor partitioning gamma_organic_ab, mass_fraction_water_ab, q_ab = \\     partitioning.get_properties_for_liquid_vapor_partitioning(         water_activity_desired=water_activity_desired,         molar_mass=molar_mass,         oxygen2carbon=oxygen2carbon,         density=density,     )  # The optimization the partition coefficients, i.e. the partitioning calculation alpha_opt, beta_opt, system_opt, fit_result = \\     partitioning.liquid_vapor_partitioning(         c_star_j_dry=c_star_j_dry,         concentration_organic_matter=concentration_organic_matter,         molar_mass=molar_mass,         gamma_organic_ab=gamma_organic_ab,         mass_fraction_water_ab=mass_fraction_water_ab,         q_ab=q_ab,         partition_coefficient_guess=None,     )  print(f\"mass in organic aerosol [ug/m3]: {system_opt[0]}\") print(f\"mass in water [ug/3]: {system_opt[1]}\") <pre>mass in organic aerosol [ug/m3]: 22.37729297689113\nmass in water [ug/3]: 4.826984139901269\n</pre> In\u00a0[9]: Copied! <pre># Calculating activity coefficients across a range of RH values\n# Range of water activity (RH/100)\nwater_activity_curve = np.linspace(0.01, 0.99, 80)\ntotal_oa_concentration = np.empty([len(water_activity_curve), 1], dtype=float)\nwater_concentration = np.empty([len(water_activity_curve), 1], dtype=float)\n\nfor i, water_activity in enumerate(water_activity_curve):\n    # Get properties for liquid-vapor partitioning at each RH value\n    gamma_organic_ab, mass_fraction_water_ab, q_ab = \\\n        partitioning.get_properties_for_liquid_vapor_partitioning(\n            water_activity_desired=water_activity,\n            molar_mass=molar_mass,\n            oxygen2carbon=oxygen2carbon,\n            density=density,\n        )\n\n    # Optimize the partition coefficients for each RH value\n    alpha_opt, beta_opt, system_opt, fit_result = \\\n        partitioning.liquid_vapor_partitioning(\n            c_star_j_dry=c_star_j_dry,\n            concentration_organic_matter=concentration_organic_matter,\n            molar_mass=molar_mass,\n            gamma_organic_ab=gamma_organic_ab,\n            mass_fraction_water_ab=mass_fraction_water_ab,\n            q_ab=q_ab,\n            partition_coefficient_guess=None,\n        )\n\n    # Record the total organic and water concentration\n    total_oa_concentration[i] = system_opt[0]\n    water_concentration[i] = system_opt[1]\n\nprint('Calculation complete')\n</pre> # Calculating activity coefficients across a range of RH values # Range of water activity (RH/100) water_activity_curve = np.linspace(0.01, 0.99, 80) total_oa_concentration = np.empty([len(water_activity_curve), 1], dtype=float) water_concentration = np.empty([len(water_activity_curve), 1], dtype=float)  for i, water_activity in enumerate(water_activity_curve):     # Get properties for liquid-vapor partitioning at each RH value     gamma_organic_ab, mass_fraction_water_ab, q_ab = \\         partitioning.get_properties_for_liquid_vapor_partitioning(             water_activity_desired=water_activity,             molar_mass=molar_mass,             oxygen2carbon=oxygen2carbon,             density=density,         )      # Optimize the partition coefficients for each RH value     alpha_opt, beta_opt, system_opt, fit_result = \\         partitioning.liquid_vapor_partitioning(             c_star_j_dry=c_star_j_dry,             concentration_organic_matter=concentration_organic_matter,             molar_mass=molar_mass,             gamma_organic_ab=gamma_organic_ab,             mass_fraction_water_ab=mass_fraction_water_ab,             q_ab=q_ab,             partition_coefficient_guess=None,         )      # Record the total organic and water concentration     total_oa_concentration[i] = system_opt[0]     water_concentration[i] = system_opt[1]  print('Calculation complete') <pre>Calculation complete\n</pre> In\u00a0[10]: Copied! <pre>fig, ax = plt.subplots()\nax.plot(water_activity_curve, total_oa_concentration,\n        label='total organic concentration', color='green')\naw=ax.twinx()\naw.plot(water_activity_curve, water_concentration,\n        label='water concentration', color='blue')\nplt.legend(loc='upper left')\nax.set_xlabel('water activity (a_w is RH/100)')\n\nhandles, labels = ax.get_legend_handles_labels()\naw_handles, aw_labels = aw.get_legend_handles_labels()\nhandles.extend(aw_handles)\nlabels.extend(aw_labels)\nplt.legend(handles, labels, loc='upper left')\n\nax.set_ylabel('organic aerosol concentration [ug/m3]')\naw.set_ylabel('aerosol water concentration [ug/m3]')\nplt.show()\n</pre> fig, ax = plt.subplots() ax.plot(water_activity_curve, total_oa_concentration,         label='total organic concentration', color='green') aw=ax.twinx() aw.plot(water_activity_curve, water_concentration,         label='water concentration', color='blue') plt.legend(loc='upper left') ax.set_xlabel('water activity (a_w is RH/100)')  handles, labels = ax.get_legend_handles_labels() aw_handles, aw_labels = aw.get_legend_handles_labels() handles.extend(aw_handles) labels.extend(aw_labels) plt.legend(handles, labels, loc='upper left')  ax.set_ylabel('organic aerosol concentration [ug/m3]') aw.set_ylabel('aerosol water concentration [ug/m3]') plt.show()"},{"location":"How-To-Guides/Equilibria/Notebooks/equilibria_part1/#liquid-vapor-equilibrium","title":"Liquid Vapor Equilibrium\u00b6","text":"<p>This notebook explores the calculation of equilibrium composition in liquid-vapor mixtures, a crucial concept in aerosol science and environmental studies. We utilize an activity coefficient model to understand how different volatile organic compounds distribute between the liquid and vapor phases. This analysis is particularly important for predicting aerosol behavior and understanding atmospheric processes.</p>"},{"location":"How-To-Guides/Equilibria/Notebooks/equilibria_part1/#setup-the-system","title":"Setup the System\u00b6","text":"<p>To simulate the liquid-vapor equilibrium, we define several key parameters:</p> <ul> <li><code>c_star_j_dry</code>: Represents the volatility distribution of organic compounds in dry air, calculable from vapor pressure.</li> <li><code>concentration_organic_matter</code>: The combined concentration of vapor and liquid organic matter in the system.</li> <li><code>oxygen2carbon</code>: The ratio of oxygen to carbon in the organic compounds, crucial for characterizing their chemical nature.</li> <li><code>molar_mass</code>: The molar mass of the organic compounds.</li> </ul> <p>These parameters help us determine the density of organics in the system, a vital step in understanding their distribution between phases.</p>"},{"location":"How-To-Guides/Equilibria/Notebooks/equilibria_part1/#calculate-the-activity-coefficients","title":"Calculate the Activity Coefficients\u00b6","text":"<p>The next step involves calculating the activity coefficients, which are pivotal in determining how the organic compounds distribute between the liquid and vapor phases. We use the <code>partitioning.get_properties_for_liquid_vapor_equilibrium</code> function, a specialized tool that simplifies the process by returning only the essential properties: activity coefficients, mass fractions, and the two-phase q values for the alpha-beta equilibrium.</p>"},{"location":"How-To-Guides/Equilibria/Notebooks/equilibria_part1/#activity-coefficients-as-a-function-of-relative-humidity-frh","title":"Activity Coefficients as a Function of Relative Humidity (f(RH))\u00b6","text":"<p>The binary activity model's key feature is its interaction with water, particularly through relative humidity (RH). Here, we will calculate how the activity coefficients vary as a function of RH. This is done by iterating over a range of RH values and computing the corresponding activity coefficients, providing insights into how atmospheric humidity influences the equilibrium behavior of the system.</p>"},{"location":"How-To-Guides/Equilibria/Notebooks/equilibria_part1/#plotting-the-equilibrium-composition-vs-relative-humidity","title":"Plotting the Equilibrium Composition vs. Relative Humidity\u00b6","text":"<p>Now that we have calculated the equilibrium composition for a range of RH values, we will visualize these results. The plot will show how the total organic aerosol concentration and the water concentration in the aerosol vary with changing RH. This visualization is crucial for understanding the dynamic behavior of aerosols in different atmospheric humidity conditions.</p>"},{"location":"How-To-Guides/Equilibria/Notebooks/equilibria_part1/#summary","title":"Summary\u00b6","text":"<p>In this notebook, we have journeyed through the process of defining a liquid-vapor equilibrium system and employing the binary activity model to calculate activity coefficients as a function of relative humidity (RH). We then used these coefficients to determine the equilibrium composition of the liquid and vapor phases. Finally, the results were visualized to demonstrate the impact of RH on aerosol behavior, which is essential for understanding atmospheric aerosol dynamics and their environmental implications.</p>"},{"location":"How-To-Guides/Lagrangian/","title":"Index: Lagrangian Particle BETA","text":"<p>This example will cover the basics of the Lagrangian particle model. Starting with a simple initial condition, and then adding more complexity to the model.</p>"},{"location":"How-To-Guides/Lagrangian/#notebooks","title":"Notebooks","text":"<ul> <li>Basic Lagrangian Particle Model</li> <li>Faster via Sweep and Prune</li> <li>Drag Force</li> <li>Turbulence Approximation</li> </ul>"},{"location":"How-To-Guides/Lagrangian/notebooks/basic_lagrangian_box/","title":"Introduction to the Lagrangian Box Model","text":"In\u00a0[22]: Copied! <pre># Code Section: Importing Necessary Libraries and Initializing Variables\nimport time\nimport torch\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom particula.lagrangian import boundary, integration, collisions, particle_property, particle_pairs\n\n# Initializing the Torch Generator and setting the data type\ntorch.manual_seed(1234)  # Set the seed for reproducibility\nt_type = torch.float32\n</pre> # Code Section: Importing Necessary Libraries and Initializing Variables import time import torch import numpy as np import matplotlib.pyplot as plt from particula.lagrangian import boundary, integration, collisions, particle_property, particle_pairs  # Initializing the Torch Generator and setting the data type torch.manual_seed(1234)  # Set the seed for reproducibility t_type = torch.float32 In\u00a0[23]: Copied! <pre># Setting up the Simulation Parameters and Initial Conditions\n\n# Define fixed parameters\nTOTAL_NUMBER_OF_PARTICLES = 500\nTIME_STEP = 0.01\nSIMULATION_TIME = 100\nMASS = 3\nCUBE_SIDE = 50\nspeed = 5\nsave_points = 50\n\n# Initialize particle positions randomly within the cube\nposition = torch.rand(\n    3,\n    TOTAL_NUMBER_OF_PARTICLES,\n    dtype=t_type) * CUBE_SIDE - CUBE_SIDE / 2\n\n# Initialize particle velocities randomly\nvelocity = torch.rand(3, TOTAL_NUMBER_OF_PARTICLES,\n                      dtype=t_type) * speed - speed / 2\n\n# Initialize force as zero for all particles\nforce = torch.zeros(3, TOTAL_NUMBER_OF_PARTICLES, dtype=t_type)\n\n# Set constant mass and density for all particles\nmass = torch.ones(TOTAL_NUMBER_OF_PARTICLES, dtype=t_type) * MASS\ndensity = torch.ones(TOTAL_NUMBER_OF_PARTICLES, dtype=t_type) * 1\n\n# Generate indices for particles, could be integer type\nindices = torch.arange(TOTAL_NUMBER_OF_PARTICLES, dtype=t_type)  # could be int\n\n# Calculate the total number of iterations for the simulation\ntotal_iterations = int(SIMULATION_TIME / TIME_STEP)\n\n# Initialize a tensor to track the total mass over iterations\ntotal_mass = torch.zeros(total_iterations, dtype=t_type)\n\n# Define gravity acting on all particles\ngravity = torch.tensor(\n    [0, -9.81, 0]).repeat(TOTAL_NUMBER_OF_PARTICLES, 1).transpose(0, 1)\n</pre> # Setting up the Simulation Parameters and Initial Conditions  # Define fixed parameters TOTAL_NUMBER_OF_PARTICLES = 500 TIME_STEP = 0.01 SIMULATION_TIME = 100 MASS = 3 CUBE_SIDE = 50 speed = 5 save_points = 50  # Initialize particle positions randomly within the cube position = torch.rand(     3,     TOTAL_NUMBER_OF_PARTICLES,     dtype=t_type) * CUBE_SIDE - CUBE_SIDE / 2  # Initialize particle velocities randomly velocity = torch.rand(3, TOTAL_NUMBER_OF_PARTICLES,                       dtype=t_type) * speed - speed / 2  # Initialize force as zero for all particles force = torch.zeros(3, TOTAL_NUMBER_OF_PARTICLES, dtype=t_type)  # Set constant mass and density for all particles mass = torch.ones(TOTAL_NUMBER_OF_PARTICLES, dtype=t_type) * MASS density = torch.ones(TOTAL_NUMBER_OF_PARTICLES, dtype=t_type) * 1  # Generate indices for particles, could be integer type indices = torch.arange(TOTAL_NUMBER_OF_PARTICLES, dtype=t_type)  # could be int  # Calculate the total number of iterations for the simulation total_iterations = int(SIMULATION_TIME / TIME_STEP)  # Initialize a tensor to track the total mass over iterations total_mass = torch.zeros(total_iterations, dtype=t_type)  # Define gravity acting on all particles gravity = torch.tensor(     [0, -9.81, 0]).repeat(TOTAL_NUMBER_OF_PARTICLES, 1).transpose(0, 1) In\u00a0[24]: Copied! <pre># Initializing Arrays for Saving Position and Mass Data\n\n# Create arrays to store position and mass data at each save point\nsave_position = np.zeros((3, TOTAL_NUMBER_OF_PARTICLES, save_points))\nsave_mass = np.zeros((TOTAL_NUMBER_OF_PARTICLES, save_points))\n\n# Determine which iterations will correspond to the save points\nsave_iterations = np.linspace(0, total_iterations, save_points, dtype=int)\n</pre> # Initializing Arrays for Saving Position and Mass Data  # Create arrays to store position and mass data at each save point save_position = np.zeros((3, TOTAL_NUMBER_OF_PARTICLES, save_points)) save_mass = np.zeros((TOTAL_NUMBER_OF_PARTICLES, save_points))  # Determine which iterations will correspond to the save points save_iterations = np.linspace(0, total_iterations, save_points, dtype=int) In\u00a0[25]: Copied! <pre># Initialize counter for saving data\nsave_counter = 0\nstart_time = time.time()\n# Start the simulation\nfor i in range(total_iterations):\n\n\n    # Calculate pairwise distances between particles\n    distance_matrix = particle_pairs.calculate_pairwise_distance(\n        position=position)\n\n    # Adjust distances for the radius of each particle (surface-to-surface\n    # distance)\n    radius = particle_property.radius_calculation(mass=mass, density=density)\n    distance_matrix -= radius.unsqueeze(1) + radius.unsqueeze(0)\n\n    # Identify pairs of particles that have collided\n    valid_collision_indices_pairs = collisions.find_collisions(\n        distance_matrix=distance_matrix, indices=indices, mass=mass)\n\n    if valid_collision_indices_pairs.shape[0] &gt; 0:\n        # Coalesce particles that have collided and update their velocity and\n        # mass\n        velocity, mass = collisions.coalescence(\n            position=position,\n            velocity=velocity,\n            mass=mass,\n            radius=radius,\n            collision_indices_pairs=valid_collision_indices_pairs)\n\n    # Calculate the force acting on the particles (e.g., gravity)\n    force = mass * gravity\n\n    # Integrate the equations of motion to update position and velocity\n    position, velocity = integration.leapfrog(\n        position=position, velocity=velocity, force=force, mass=mass, time_step=TIME_STEP)\n\n    # Apply boundary conditions for the cube (wrap-around)\n    position = boundary.wrapped_cube(position=position, cube_side=CUBE_SIDE)\n\n    # Save the position and mass data at designated save points\n    if i == save_iterations[save_counter]:\n        save_position[:, :, save_counter] = position.detach().cpu().numpy()\n        save_mass[:, save_counter] = mass.detach().cpu().numpy()\n        save_counter += 1\n\n# Perform a final save of the position and mass data\nsave_position[:, :, -1] = position.detach().cpu().numpy()\nsave_mass[:, -1] = mass.detach().cpu().numpy()\n\n# Calculate the total simulation time\nend_time = time.time()\nprint(f\"Total wall time: {end_time - start_time} seconds\")\nprint(f\"Ratio of wall time to simulation time: {(end_time - start_time) / SIMULATION_TIME}\")\n</pre> # Initialize counter for saving data save_counter = 0 start_time = time.time() # Start the simulation for i in range(total_iterations):       # Calculate pairwise distances between particles     distance_matrix = particle_pairs.calculate_pairwise_distance(         position=position)      # Adjust distances for the radius of each particle (surface-to-surface     # distance)     radius = particle_property.radius_calculation(mass=mass, density=density)     distance_matrix -= radius.unsqueeze(1) + radius.unsqueeze(0)      # Identify pairs of particles that have collided     valid_collision_indices_pairs = collisions.find_collisions(         distance_matrix=distance_matrix, indices=indices, mass=mass)      if valid_collision_indices_pairs.shape[0] &gt; 0:         # Coalesce particles that have collided and update their velocity and         # mass         velocity, mass = collisions.coalescence(             position=position,             velocity=velocity,             mass=mass,             radius=radius,             collision_indices_pairs=valid_collision_indices_pairs)      # Calculate the force acting on the particles (e.g., gravity)     force = mass * gravity      # Integrate the equations of motion to update position and velocity     position, velocity = integration.leapfrog(         position=position, velocity=velocity, force=force, mass=mass, time_step=TIME_STEP)      # Apply boundary conditions for the cube (wrap-around)     position = boundary.wrapped_cube(position=position, cube_side=CUBE_SIDE)      # Save the position and mass data at designated save points     if i == save_iterations[save_counter]:         save_position[:, :, save_counter] = position.detach().cpu().numpy()         save_mass[:, save_counter] = mass.detach().cpu().numpy()         save_counter += 1  # Perform a final save of the position and mass data save_position[:, :, -1] = position.detach().cpu().numpy() save_mass[:, -1] = mass.detach().cpu().numpy()  # Calculate the total simulation time end_time = time.time() print(f\"Total wall time: {end_time - start_time} seconds\") print(f\"Ratio of wall time to simulation time: {(end_time - start_time) / SIMULATION_TIME}\") <pre>Total wall time: 19.743536710739136 seconds\nRatio of wall time to simulation time: 0.19743536710739135\n</pre> In\u00a0[26]: Copied! <pre># Processing the Final Data for Visualization\n\n# Select the final time index for the data\ntime_index = -1\nposition_final = save_position[:, :, time_index]\nmass_final = save_mass[:, time_index]\n\n# Filter out particles with zero mass\nfilter_zero_mass = mass_final &gt; 0\n\n# Calculate the radius and area of each particle\n\nradius_final = (3 * mass_final / (4 * np.pi * density.cpu().numpy()))** ( 1/3 )\nparticle_area = np.pi * radius_final**2\n\n# Display the number of remaining particles\nprint(f\"Number of particles at the end: {filter_zero_mass.sum()}\")\n\n# Creating a 3D Plot for Visualization\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Choose a color map for the scatter plot\ncmap = plt.cm.viridis\n\n# Plot the final positions of particles with non-zero mass\nscatter_plot = ax.scatter(\n    position_final[0, filter_zero_mass],\n    position_final[1, filter_zero_mass],\n    position_final[2, filter_zero_mass],\n    c=mass_final[filter_zero_mass],\n    cmap=cmap,\n    s=particle_area[filter_zero_mass]  # Particle size based on area\n)\n\n# Set axis limits based on cube dimensions\nax.set_xlim(-CUBE_SIDE / 2, CUBE_SIDE / 2)\nax.set_ylim(-CUBE_SIDE / 2, CUBE_SIDE / 2)\nax.set_zlim(-CUBE_SIDE / 2, CUBE_SIDE / 2)\n\n# Add a color bar indicating particle mass\ncolor_bar = plt.colorbar(scatter_plot, ax=ax)\ncolor_bar.set_label('Mass')\n\n# Show the plot with optimized layout\nplt.show()\nfig.tight_layout()\n</pre> # Processing the Final Data for Visualization  # Select the final time index for the data time_index = -1 position_final = save_position[:, :, time_index] mass_final = save_mass[:, time_index]  # Filter out particles with zero mass filter_zero_mass = mass_final &gt; 0  # Calculate the radius and area of each particle  radius_final = (3 * mass_final / (4 * np.pi * density.cpu().numpy()))** ( 1/3 ) particle_area = np.pi * radius_final**2  # Display the number of remaining particles print(f\"Number of particles at the end: {filter_zero_mass.sum()}\")  # Creating a 3D Plot for Visualization fig = plt.figure() ax = fig.add_subplot(projection='3d')  # Choose a color map for the scatter plot cmap = plt.cm.viridis  # Plot the final positions of particles with non-zero mass scatter_plot = ax.scatter(     position_final[0, filter_zero_mass],     position_final[1, filter_zero_mass],     position_final[2, filter_zero_mass],     c=mass_final[filter_zero_mass],     cmap=cmap,     s=particle_area[filter_zero_mass]  # Particle size based on area )  # Set axis limits based on cube dimensions ax.set_xlim(-CUBE_SIDE / 2, CUBE_SIDE / 2) ax.set_ylim(-CUBE_SIDE / 2, CUBE_SIDE / 2) ax.set_zlim(-CUBE_SIDE / 2, CUBE_SIDE / 2)  # Add a color bar indicating particle mass color_bar = plt.colorbar(scatter_plot, ax=ax) color_bar.set_label('Mass')  # Show the plot with optimized layout plt.show() fig.tight_layout() <pre>Number of particles at the end: 56\n</pre> In\u00a0[27]: Copied! <pre># Visualizing the Mass Distribution at Different Stages\n\n# Create a new figure for the histogram\nfig = plt.figure()\nax = fig.add_subplot()\n\n# Normalizing by initial MASS to observe distribution changes\nnormalized_mass = save_mass[filter_zero_mass, :] / MASS\nmax_mass = normalized_mass.max()\n\n# Plot histograms of mass distribution at different stages\nax.hist(normalized_mass[:, 0], bins=25,\n        alpha=0.8, label='Initial', range=(0, max_mass))\nax.hist(normalized_mass[:, 24], bins=25,\n        alpha=0.6, label='Middle', range=(0, max_mass))\nax.hist(normalized_mass[:, -1], bins=25,\n        alpha=0.5, label='Final', range=(0, max_mass))\n\n# Setting labels and title for the plot\nax.set_xlabel('Mass / Initial MASS')\nax.set_ylabel('Number of Particles')\n\n# Add a legend to the plot\nax.legend()\n\n# Display the plot\nplt.show()\n\n# Adjust layout for optimal visualization\nfig.tight_layout()\n</pre> # Visualizing the Mass Distribution at Different Stages  # Create a new figure for the histogram fig = plt.figure() ax = fig.add_subplot()  # Normalizing by initial MASS to observe distribution changes normalized_mass = save_mass[filter_zero_mass, :] / MASS max_mass = normalized_mass.max()  # Plot histograms of mass distribution at different stages ax.hist(normalized_mass[:, 0], bins=25,         alpha=0.8, label='Initial', range=(0, max_mass)) ax.hist(normalized_mass[:, 24], bins=25,         alpha=0.6, label='Middle', range=(0, max_mass)) ax.hist(normalized_mass[:, -1], bins=25,         alpha=0.5, label='Final', range=(0, max_mass))  # Setting labels and title for the plot ax.set_xlabel('Mass / Initial MASS') ax.set_ylabel('Number of Particles')  # Add a legend to the plot ax.legend()  # Display the plot plt.show()  # Adjust layout for optimal visualization fig.tight_layout()"},{"location":"How-To-Guides/Lagrangian/notebooks/basic_lagrangian_box/#introduction-to-the-lagrangian-box-model","title":"Introduction to the Lagrangian Box Model\u00b6","text":"<p>In this notebook, we will develop a simple box model for a Lagrangian particle. This model serves as a foundational tool to understand how various processes influence the evolution of a particle. We will start with a basic framework and gradually introduce more complex elements.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/basic_lagrangian_box/#understanding-particle-dynamics-in-a-cube","title":"Understanding Particle Dynamics in a Cube\u00b6","text":"<p>Here, we simulate particles moving within a cubic space. When these particles collide, they coagulate. This initial model does not include processes like condensation, evaporation, or forces such as drag. However, these elements will be integrated in subsequent steps to enhance realism.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/basic_lagrangian_box/#enhancing-particle-realism-and-model-complexity","title":"Enhancing Particle Realism and Model Complexity\u00b6","text":"<p>Currently, the particles lack realistic properties, but we plan to incorporate these features progressively. The model's complexity will also be scaled up, which is where the flexibility of the <code>particula.lagrangian</code> module becomes crucial.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/basic_lagrangian_box/#leveraging-pytorch-for-enhanced-computational-performance","title":"Leveraging PyTorch for Enhanced Computational Performance\u00b6","text":"<p>This model is designed with a focus on PyTorch, allowing us to seamlessly switch between CPU and GPU computations. This capability becomes increasingly important as we add more particles and complexity to the model, necessitating the use of GPU for efficient computation.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/basic_lagrangian_box/#defining-the-system-parameters-and-initial-conditions","title":"Defining the System: Parameters and Initial Conditions\u00b6","text":"<p>The first step in our simulation is to define the system. This involves setting up a combination of fixed parameters and initializing the conditions for our particles. These parameters include the total number of particles, time step for the simulation, mass of each particle, dimensions of the cubic space, and other physical properties. The initial positions and velocities of the particles are generated randomly within this defined space, laying the groundwork for the subsequent simulation dynamics.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/basic_lagrangian_box/#setting-up-data-saving-mechanism","title":"Setting Up Data Saving Mechanism\u00b6","text":"<p>To effectively monitor and analyze the simulation, we will record specific variables at predetermined intervals. In this case, we'll focus on saving the position and mass of each particle. These variables will be captured at a set number of 'save points' throughout the simulation, allowing us to track the dynamic changes over time.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/basic_lagrangian_box/#executing-the-box-model-simulation","title":"Executing the Box Model Simulation\u00b6","text":"<p>With our system defined and data saving mechanisms in place, we now proceed to run the simulation. The process involves a series of steps that are iteratively executed to simulate the dynamics of the particles within the box. The steps are as follows:</p> <ul> <li>Boundary Check: Verify if any particles have moved outside the boundaries of the box and handle accordingly.</li> <li>Center Distance Calculation: Compute the pairwise distances between particles to their center.</li> <li>Surface Distance Calculation: Determine the pairwise distances from the surfaces of the particles.</li> <li>Collision Detection: Identify instances where particles collide with each other.</li> <li>Coalescence: Merge particles that have collided, simulating coalescence.</li> <li>Force Calculations: Apply force calculations to the particles, influencing their motion.</li> <li>Motion Integration: Integrate the equations of motion to update the position and velocity of each particle.</li> <li>Data Recording: At designated intervals, save the position and mass data of the particles for later analysis.</li> </ul>"},{"location":"How-To-Guides/Lagrangian/notebooks/basic_lagrangian_box/#visualizing-the-final-3d-positions-of-particles","title":"Visualizing the Final 3D Positions of Particles\u00b6","text":"<p>In the final step of our analysis, we focus on visualizing the 3D positions of the particles at the end of the simulation. To accurately represent the final state, we will exclude particles that have effectively zero mass, as these have merged with other particles during the coalescence process. This visualization will provide us with an insightful view of the particle distribution and the results of the dynamic interactions that have occurred throughout the simulation.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/basic_lagrangian_box/#analyzing-the-mass-distribution-of-particles","title":"Analyzing the Mass Distribution of Particles\u00b6","text":"<p>Next, we turn our attention to understanding how the mass distribution of the particles has evolved over the course of the simulation. To achieve this, we will analyze the mass data normalized by the initial MASS value. This normalization allows us to observe changes in the mass distribution as multiples of the initial mass, providing insights into the extent of coalescence and mass variation among the particles.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/basic_lagrangian_box/#summary-of-the-lagrangian-particle-simulation","title":"Summary of the Lagrangian Particle Simulation\u00b6","text":"<p>In this Jupyter Notebook, we have explored the dynamics of a Lagrangian particle system within a defined cubic space. Our focus has been on simulating and analyzing the interactions and evolution of particles under a set of initial conditions and physical laws. Here is a brief overview of what we covered:</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/basic_lagrangian_box/#system-definition-and-initialization","title":"System Definition and Initialization\u00b6","text":"<ul> <li>We began by defining the simulation space and initial conditions for our particle system. This included setting parameters such as the number of particles, mass, and dimensions of the cubic space, as well as initializing the positions and velocities of the particles.</li> </ul>"},{"location":"How-To-Guides/Lagrangian/notebooks/basic_lagrangian_box/#simulation-process","title":"Simulation Process\u00b6","text":"<ul> <li>The core of our simulation involved a series of iterative steps to simulate particle dynamics. These steps included checking boundary conditions, calculating distances, detecting and handling collisions, coalescing particles, applying forces, and integrating the equations of motion.</li> </ul>"},{"location":"How-To-Guides/Lagrangian/notebooks/basic_lagrangian_box/#data-saving-and-analysis","title":"Data Saving and Analysis\u00b6","text":"<ul> <li>Throughout the simulation, we saved key data points, such as the position and mass of particles at specified intervals. This allowed us to track and analyze the changes in the system over time.</li> </ul>"},{"location":"How-To-Guides/Lagrangian/notebooks/basic_lagrangian_box/#visualization-and-interpretation","title":"Visualization and Interpretation\u00b6","text":"<ul> <li>We utilized various visualization techniques to interpret the simulation results. This included creating 3D plots to visualize the final positions of particles and histograms to analyze the distribution of mass at different stages of the simulation.</li> </ul>"},{"location":"How-To-Guides/Lagrangian/notebooks/basic_lagrangian_box/#insights-gained","title":"Insights Gained\u00b6","text":"<ul> <li>The simulation provided valuable insights into the behavior of particles in a Lagrangian framework. We observed how particles interact, coalesce, and evolve over time under the influence of set physical parameters and forces.</li> </ul>"},{"location":"How-To-Guides/Lagrangian/notebooks/friction_force/","title":"Realistic Drag, Mass, and Velocity","text":"In\u00a0[\u00a0]: Copied! <pre># Code Section: Importing Necessary Libraries and Initializing Variables\nimport time\nimport torch\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom particula.lagrangian import boundary, integration, collisions, particle_property, particle_pairs\nfrom particula.util import machine_limit\n# Initializing the Torch Generator and setting the data type\nseed = 1234\ntorch.manual_seed(seed)  # Set the seed for reproducibility\nt_type = torch.float32\n</pre> # Code Section: Importing Necessary Libraries and Initializing Variables import time import torch import numpy as np import matplotlib.pyplot as plt from particula.lagrangian import boundary, integration, collisions, particle_property, particle_pairs from particula.util import machine_limit # Initializing the Torch Generator and setting the data type seed = 1234 torch.manual_seed(seed)  # Set the seed for reproducibility t_type = torch.float32 In\u00a0[132]: Copied! <pre># Setting up the Simulation Parameters and Initial Conditions\n\n# Define fixed parameters\nTOTAL_NUMBER_OF_PARTICLES = 2000\nTIME_STEP = 0.005\nSIMULATION_TIME = 100\nCUBE_SIDE = 0.010  # Size of the simulation cube in meters\nsave_points = 50  # Number of points to save the simulation data\n\n# Defining new parameters for more realistic simulation\ndensity_uniform = 1.5e3  # Uniform density of particles in kg/m^3\nmean_radius_nm = 50000  # Mean radius of particles in nanometers\nstd_dev_nm = 2  # Standard deviation of particle radius in nanometers\nsystem_temperature_kelvin = 300  # System temperature in Kelvin\nsystem_pressure_pascal = 1e5  # System pressure in Pascal\n\n# Define intervals for updating interaction factors\ninterval_friction_factor = 1000  # Interval for updating friction factor\ninterval_coagulation = 10  # Interval for updating coagulation\n\n# Generating particle masses using a log-normal distribution\nmass = particle_property.generate_particle_masses(\n    mean_radius=mean_radius_nm,\n    std_dev_radius=std_dev_nm,\n    density=density_uniform,\n    num_particles=TOTAL_NUMBER_OF_PARTICLES,\n    radius_input_units=\"nm\",\n)\n\n# Initializing particle velocities using thermal velocity\nvelocity = particle_property.random_thermal_velocity(\n    temperature_kelvin=system_temperature_kelvin,\n    mass_kg=mass,\n    number_of_particles=TOTAL_NUMBER_OF_PARTICLES,\n    t_type=t_type,\n    random_seed=seed\n)\n\n# Setting constant density for all particles\ndensity = torch.ones(TOTAL_NUMBER_OF_PARTICLES, dtype=t_type) * density_uniform\n\n# Initialize particle positions randomly within the cube\nposition = torch.rand(\n    3,\n    TOTAL_NUMBER_OF_PARTICLES,\n    dtype=t_type) * CUBE_SIDE - CUBE_SIDE / 2\n\n# Initialize force as zero for all particles\nforce = torch.zeros(3, TOTAL_NUMBER_OF_PARTICLES, dtype=t_type)\n\n# Generating indices for particles\nindices = torch.arange(TOTAL_NUMBER_OF_PARTICLES, dtype=t_type)  # Integer type\n\n# Calculating the total number of iterations for the simulation\ntotal_iterations = int(SIMULATION_TIME / TIME_STEP)\n\n# Initializing tensor to track total mass over iterations\ntotal_mass = torch.zeros(total_iterations, dtype=t_type)\n\n# Defining gravity acting on all particles\ngravity = torch.tensor(\n    [0, 0, -9.81]).repeat(TOTAL_NUMBER_OF_PARTICLES, 1).transpose(0, 1)\n\n# Initializing Arrays for Saving Position and Mass Data\nsave_position = np.zeros((3, TOTAL_NUMBER_OF_PARTICLES, save_points))\nsave_mass = np.zeros((TOTAL_NUMBER_OF_PARTICLES, save_points))\nsave_iterations = np.linspace(0, total_iterations, save_points, dtype=int)\n\n# Calculating particle radius from mass and density\nradius = particle_property.radius_calculation(mass=mass, density=density)\n</pre> # Setting up the Simulation Parameters and Initial Conditions  # Define fixed parameters TOTAL_NUMBER_OF_PARTICLES = 2000 TIME_STEP = 0.005 SIMULATION_TIME = 100 CUBE_SIDE = 0.010  # Size of the simulation cube in meters save_points = 50  # Number of points to save the simulation data  # Defining new parameters for more realistic simulation density_uniform = 1.5e3  # Uniform density of particles in kg/m^3 mean_radius_nm = 50000  # Mean radius of particles in nanometers std_dev_nm = 2  # Standard deviation of particle radius in nanometers system_temperature_kelvin = 300  # System temperature in Kelvin system_pressure_pascal = 1e5  # System pressure in Pascal  # Define intervals for updating interaction factors interval_friction_factor = 1000  # Interval for updating friction factor interval_coagulation = 10  # Interval for updating coagulation  # Generating particle masses using a log-normal distribution mass = particle_property.generate_particle_masses(     mean_radius=mean_radius_nm,     std_dev_radius=std_dev_nm,     density=density_uniform,     num_particles=TOTAL_NUMBER_OF_PARTICLES,     radius_input_units=\"nm\", )  # Initializing particle velocities using thermal velocity velocity = particle_property.random_thermal_velocity(     temperature_kelvin=system_temperature_kelvin,     mass_kg=mass,     number_of_particles=TOTAL_NUMBER_OF_PARTICLES,     t_type=t_type,     random_seed=seed )  # Setting constant density for all particles density = torch.ones(TOTAL_NUMBER_OF_PARTICLES, dtype=t_type) * density_uniform  # Initialize particle positions randomly within the cube position = torch.rand(     3,     TOTAL_NUMBER_OF_PARTICLES,     dtype=t_type) * CUBE_SIDE - CUBE_SIDE / 2  # Initialize force as zero for all particles force = torch.zeros(3, TOTAL_NUMBER_OF_PARTICLES, dtype=t_type)  # Generating indices for particles indices = torch.arange(TOTAL_NUMBER_OF_PARTICLES, dtype=t_type)  # Integer type  # Calculating the total number of iterations for the simulation total_iterations = int(SIMULATION_TIME / TIME_STEP)  # Initializing tensor to track total mass over iterations total_mass = torch.zeros(total_iterations, dtype=t_type)  # Defining gravity acting on all particles gravity = torch.tensor(     [0, 0, -9.81]).repeat(TOTAL_NUMBER_OF_PARTICLES, 1).transpose(0, 1)  # Initializing Arrays for Saving Position and Mass Data save_position = np.zeros((3, TOTAL_NUMBER_OF_PARTICLES, save_points)) save_mass = np.zeros((TOTAL_NUMBER_OF_PARTICLES, save_points)) save_iterations = np.linspace(0, total_iterations, save_points, dtype=int)  # Calculating particle radius from mass and density radius = particle_property.radius_calculation(mass=mass, density=density) In\u00a0[133]: Copied! <pre># Plotting the Initial Radius Distribution\n\n# Calculate the initial radius of particles\nradius_initial = particle_property.radius_calculation(\n    mass=mass, density=density)\n\n# Plotting the histogram for radius distribution\nfig, ax = plt.subplots()\nax.hist(machine_limit.safe_log10(radius_initial), bins=20, range=(-9, 0))\nax.set_xlabel(\"log10 Radius (m)\")\nax.set_ylabel(\"Number of Particles\")\nax.set_title(\"Initial Particle Radius Distribution\")\nplt.show()\n\n# Plotting the Initial Velocity Distribution\n\n# Calculate the speeds of particles from their velocities\ninitial_speeds = particle_property.speed(velocity)\n\n# Plotting the histogram for velocity distribution\nfig, ax = plt.subplots()\nax.hist(machine_limit.safe_log10(initial_speeds), bins=20)\nax.set_xlabel(\"log10 Velocity (m/s)\")\nax.set_ylabel(\"Number of Particles\")\nax.set_title(\"Initial Particle Velocity Distribution\")\nplt.show()\n</pre> # Plotting the Initial Radius Distribution  # Calculate the initial radius of particles radius_initial = particle_property.radius_calculation(     mass=mass, density=density)  # Plotting the histogram for radius distribution fig, ax = plt.subplots() ax.hist(machine_limit.safe_log10(radius_initial), bins=20, range=(-9, 0)) ax.set_xlabel(\"log10 Radius (m)\") ax.set_ylabel(\"Number of Particles\") ax.set_title(\"Initial Particle Radius Distribution\") plt.show()  # Plotting the Initial Velocity Distribution  # Calculate the speeds of particles from their velocities initial_speeds = particle_property.speed(velocity)  # Plotting the histogram for velocity distribution fig, ax = plt.subplots() ax.hist(machine_limit.safe_log10(initial_speeds), bins=20) ax.set_xlabel(\"log10 Velocity (m/s)\") ax.set_ylabel(\"Number of Particles\") ax.set_title(\"Initial Particle Velocity Distribution\") plt.show() In\u00a0[136]: Copied! <pre># Printing the Maximum and Minimum Radii of the Particles\nprint(\"Max Radius [m]: \", radius.max())\nprint(\"Min Radius [m]: \", radius.min())\n\n# Initializing the Range of Radii for Friction Factor Calculation\n# We use a linspace to cover a range from the smallest to 10 times the\n# largest radius.\nfriction_factor_radius = torch.linspace(\n    start=radius.min(),\n    end=radius.max() * 10,\n    steps=1000,\n)\n\n# Calculating the Friction Factor\n# This calculation considers the radius, temperature, and pressure to\n# determine the friction factor.\nfriction_factor_array = particle_property.friction_factor_wrapper(\n    radius_meter=friction_factor_radius,\n    temperature_kelvin=system_temperature_kelvin,\n    pressure_pascal=system_pressure_pascal,\n)\n\n# Plotting Friction Factor vs Radius\n# The plot helps in visualizing how friction factor varies with particle\n# radius.\nfig, ax = plt.subplots()\nax.plot(friction_factor_radius, friction_factor_array)\nax.set_xscale(\"log\")\nax.set_yscale(\"log\")\nax.set_xlabel(\"Radius (m)\")\nax.set_ylabel(\"Friction Factor\")\nplt.show()\n</pre> # Printing the Maximum and Minimum Radii of the Particles print(\"Max Radius [m]: \", radius.max()) print(\"Min Radius [m]: \", radius.min())  # Initializing the Range of Radii for Friction Factor Calculation # We use a linspace to cover a range from the smallest to 10 times the # largest radius. friction_factor_radius = torch.linspace(     start=radius.min(),     end=radius.max() * 10,     steps=1000, )  # Calculating the Friction Factor # This calculation considers the radius, temperature, and pressure to # determine the friction factor. friction_factor_array = particle_property.friction_factor_wrapper(     radius_meter=friction_factor_radius,     temperature_kelvin=system_temperature_kelvin,     pressure_pascal=system_pressure_pascal, )  # Plotting Friction Factor vs Radius # The plot helps in visualizing how friction factor varies with particle # radius. fig, ax = plt.subplots() ax.plot(friction_factor_radius, friction_factor_array) ax.set_xscale(\"log\") ax.set_yscale(\"log\") ax.set_xlabel(\"Radius (m)\") ax.set_ylabel(\"Friction Factor\") plt.show() <pre>Max Radius [m]:  tensor(0.0006)\nMin Radius [m]:  tensor(6.2121e-06)\n</pre> In\u00a0[137]: Copied! <pre># Initialize Counter for Saving Data and Start Timer\nsave_counter = 0\nstart_time = time.time()\n\n# Initial Calculations Before Starting the Simulation Loop\nradius = particle_property.radius_calculation(mass=mass, density=density)\nfriction_factor_iter = particle_property.nearest_match(\n    x_values=friction_factor_radius,\n    y_values=friction_factor_array,\n    x_new=radius,\n)\n\n# Main Simulation Loop\nfor i in range(total_iterations):\n\n    # Coagulation Step (Optional, based on specified interval)\n    if i % interval_coagulation == 0:\n        # Update radius for collision detection\n        radius = particle_property.radius_calculation(\n            mass=mass, density=density)\n        # Detect potential collision pairs\n        valid_collision_indices_pairs = particle_pairs.full_sweep_and_prune(\n            position=position, radius=radius)\n\n        # Process collisions and update particle properties\n        if valid_collision_indices_pairs.shape[0] &gt; 0:\n            velocity, mass = collisions.coalescence(\n                position=position,\n                velocity=velocity,\n                mass=mass,\n                radius=radius,\n                collision_indices_pairs=valid_collision_indices_pairs)\n\n    # Update Friction Factor (Optional, based on specified interval)\n    if i % interval_friction_factor == 0:\n        radius = particle_property.radius_calculation(\n            mass=mass, density=density)\n        friction_factor_iter = particle_property.nearest_match(\n            x_values=friction_factor_radius,\n            y_values=friction_factor_array,\n            x_new=radius,\n        )\n\n    # Calculate Forces (including updated friction factor)\n    force = mass * gravity - velocity * friction_factor_iter\n\n    # Integrate Equations of Motion (Leapfrog Method)\n    position, velocity = integration.leapfrog(\n        position=position, velocity=velocity, force=force, mass=mass, time_step=TIME_STEP)\n\n    # Apply Boundary Conditions (Cube Wrap-around)\n    position = boundary.wrapped_cube(position=position, cube_side=CUBE_SIDE)\n\n    # Save Data at Predefined Intervals\n    if i == save_iterations[save_counter]:\n        save_position[:, :, save_counter] = position.detach().numpy()\n        save_mass[:, save_counter] = mass.detach().numpy()\n        save_counter += 1\n\n# Final Data Save and Calculation of Total Simulation Time\nsave_position[:, :, -1] = position.detach().numpy()\nsave_mass[:, -1] = mass.detach().numpy()\nend_time = time.time()\nprint(f\"Total wall time: {end_time - start_time} seconds\")\nprint(\n    f\"Ratio of wall time to simulation time: {(end_time - start_time) / SIMULATION_TIME}\")\n</pre> # Initialize Counter for Saving Data and Start Timer save_counter = 0 start_time = time.time()  # Initial Calculations Before Starting the Simulation Loop radius = particle_property.radius_calculation(mass=mass, density=density) friction_factor_iter = particle_property.nearest_match(     x_values=friction_factor_radius,     y_values=friction_factor_array,     x_new=radius, )  # Main Simulation Loop for i in range(total_iterations):      # Coagulation Step (Optional, based on specified interval)     if i % interval_coagulation == 0:         # Update radius for collision detection         radius = particle_property.radius_calculation(             mass=mass, density=density)         # Detect potential collision pairs         valid_collision_indices_pairs = particle_pairs.full_sweep_and_prune(             position=position, radius=radius)          # Process collisions and update particle properties         if valid_collision_indices_pairs.shape[0] &gt; 0:             velocity, mass = collisions.coalescence(                 position=position,                 velocity=velocity,                 mass=mass,                 radius=radius,                 collision_indices_pairs=valid_collision_indices_pairs)      # Update Friction Factor (Optional, based on specified interval)     if i % interval_friction_factor == 0:         radius = particle_property.radius_calculation(             mass=mass, density=density)         friction_factor_iter = particle_property.nearest_match(             x_values=friction_factor_radius,             y_values=friction_factor_array,             x_new=radius,         )      # Calculate Forces (including updated friction factor)     force = mass * gravity - velocity * friction_factor_iter      # Integrate Equations of Motion (Leapfrog Method)     position, velocity = integration.leapfrog(         position=position, velocity=velocity, force=force, mass=mass, time_step=TIME_STEP)      # Apply Boundary Conditions (Cube Wrap-around)     position = boundary.wrapped_cube(position=position, cube_side=CUBE_SIDE)      # Save Data at Predefined Intervals     if i == save_iterations[save_counter]:         save_position[:, :, save_counter] = position.detach().numpy()         save_mass[:, save_counter] = mass.detach().numpy()         save_counter += 1  # Final Data Save and Calculation of Total Simulation Time save_position[:, :, -1] = position.detach().numpy() save_mass[:, -1] = mass.detach().numpy() end_time = time.time() print(f\"Total wall time: {end_time - start_time} seconds\") print(     f\"Ratio of wall time to simulation time: {(end_time - start_time) / SIMULATION_TIME}\") <pre>Total wall time: 22.354511499404907 seconds\nRatio of wall time to simulation time: 0.22354511499404908\n</pre> In\u00a0[130]: Copied! <pre># Processing the Final Data for Visualization\n\n# Select the final time index for the data\ntime_index = -1\nposition_final = save_position[:, :, time_index]\nmass_final = save_mass[:, time_index]\n\n# Filter out particles with zero mass\nfilter_zero_mass = mass_final &gt; 0\n\n# Calculate the radius and area of each particle\nradius_final = particle_property.radius_calculation(mass=mass_final, density=density)\nparticle_area = np.pi * radius_final**2\n# normalize the area\nparticle_area = particle_area / particle_area.max()\n\n\n# Display the number of remaining particles\nprint(f\"Number of particles at the end: {filter_zero_mass.sum()}\")\n\n# Creating a 3D Plot for Visualization\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Choose a color map for the scatter plot\ncmap = plt.cm.viridis\n\n# Plot the final positions of particles with non-zero mass\nscatter_plot = ax.scatter(\n    position_final[0, filter_zero_mass],\n    position_final[1, filter_zero_mass],\n    position_final[2, filter_zero_mass],\n    c=mass_final[filter_zero_mass],\n    cmap=cmap,\n    s=particle_area[filter_zero_mass]*100 # scalled Particle size based on normalized area\n)\n\n# # Set axis limits based on cube dimensions\nax.set_xlim(-CUBE_SIDE / 2, CUBE_SIDE / 2)\nax.set_ylim(-CUBE_SIDE / 2, CUBE_SIDE / 2)\nax.set_zlim(-CUBE_SIDE / 2, CUBE_SIDE / 2)\n\n# Add a color bar indicating particle mass\ncolor_bar = plt.colorbar(scatter_plot, ax=ax)\ncolor_bar.set_label('Mass [kg]')\n\n# Show the plot with optimized layout\nplt.show()\nfig.tight_layout()\n</pre> # Processing the Final Data for Visualization  # Select the final time index for the data time_index = -1 position_final = save_position[:, :, time_index] mass_final = save_mass[:, time_index]  # Filter out particles with zero mass filter_zero_mass = mass_final &gt; 0  # Calculate the radius and area of each particle radius_final = particle_property.radius_calculation(mass=mass_final, density=density) particle_area = np.pi * radius_final**2 # normalize the area particle_area = particle_area / particle_area.max()   # Display the number of remaining particles print(f\"Number of particles at the end: {filter_zero_mass.sum()}\")  # Creating a 3D Plot for Visualization fig = plt.figure() ax = fig.add_subplot(projection='3d')  # Choose a color map for the scatter plot cmap = plt.cm.viridis  # Plot the final positions of particles with non-zero mass scatter_plot = ax.scatter(     position_final[0, filter_zero_mass],     position_final[1, filter_zero_mass],     position_final[2, filter_zero_mass],     c=mass_final[filter_zero_mass],     cmap=cmap,     s=particle_area[filter_zero_mass]*100 # scalled Particle size based on normalized area )  # # Set axis limits based on cube dimensions ax.set_xlim(-CUBE_SIDE / 2, CUBE_SIDE / 2) ax.set_ylim(-CUBE_SIDE / 2, CUBE_SIDE / 2) ax.set_zlim(-CUBE_SIDE / 2, CUBE_SIDE / 2)  # Add a color bar indicating particle mass color_bar = plt.colorbar(scatter_plot, ax=ax) color_bar.set_label('Mass [kg]')  # Show the plot with optimized layout plt.show() fig.tight_layout()  <pre>Number of particles at the end: 1260\n</pre> In\u00a0[138]: Copied! <pre># Visualizing the Mass Distribution at Different Stages\n\n# plot initial radius distribution\nfig, ax = plt.subplots()\nax.hist(machine_limit.safe_log10(radius_initial), bins=20, range=(-6,-2), label=\"Initial\", alpha=0.25)\nax.hist(machine_limit.safe_log10(radius_final[filter_zero_mass]), bins=20, range=(-6,-2), label=\"Final\", alpha=0.5)\nax.set_yscale(\"log\")\nax.set_xlabel(\"log10 Radius (m)\")\nax.set_ylabel(\"Number of Particles\")\nax.set_title(\"Initial Particle Radius Distribution\")\nax.legend()\nplt.show()\n\nprint(\"Initial Max Radius [m]: \", radius_initial.max().item())\nprint(\"Final Max Radius [m]: \", radius_final[filter_zero_mass].max().item())\n</pre> # Visualizing the Mass Distribution at Different Stages  # plot initial radius distribution fig, ax = plt.subplots() ax.hist(machine_limit.safe_log10(radius_initial), bins=20, range=(-6,-2), label=\"Initial\", alpha=0.25) ax.hist(machine_limit.safe_log10(radius_final[filter_zero_mass]), bins=20, range=(-6,-2), label=\"Final\", alpha=0.5) ax.set_yscale(\"log\") ax.set_xlabel(\"log10 Radius (m)\") ax.set_ylabel(\"Number of Particles\") ax.set_title(\"Initial Particle Radius Distribution\") ax.legend() plt.show()  print(\"Initial Max Radius [m]: \", radius_initial.max().item()) print(\"Final Max Radius [m]: \", radius_final[filter_zero_mass].max().item()) <pre>Initial Max Radius [m]:  0.0005869632004760206\nFinal Max Radius [m]:  0.0007475933229391738\n</pre>"},{"location":"How-To-Guides/Lagrangian/notebooks/friction_force/#realistic-drag-mass-and-velocity","title":"Realistic Drag, Mass, and Velocity\u00b6","text":"<p>This notebook section focuses on simulating cloud droplet-sized aerosol particles (around 100 microns) with accurate mass and velocity. Key improvements include:</p> <ol> <li>Refining Initial Conditions: Setting precise starting values for particle mass and velocity.</li> <li>Modeling Forces Accurately: Better representation of forces acting on particles to influence their movement.</li> </ol> <p>These steps are crucial for enhancing the realism of the aerosol particle model.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/friction_force/#initialization-of-particles","title":"Initialization of Particles\u00b6","text":"<p>In this section, we'll enhance particle initialization for realism:</p> <ul> <li>Particle Masses: Implementing a narrow log-normal distribution to better represent real-world mass variation.</li> <li>Particle Velocities: Utilizing thermal velocity, influenced by Brownian motion, for initial velocity settings.</li> <li>Initial Positions: Particles will be randomly placed within a defined box area to simulate natural distribution.</li> </ul>"},{"location":"How-To-Guides/Lagrangian/notebooks/friction_force/#plotting-initial-conditions","title":"Plotting Initial Conditions\u00b6","text":"<p>To verify the realism of our particle model, we'll plot the initial distributions of particle size and velocity. This step ensures that the initial setup aligns with our expectations and the intended simulation parameters.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/friction_force/#particle-size-distribution","title":"Particle Size Distribution\u00b6","text":"<p>First, we examine the distribution of particle radii. The goal is to confirm that the radii follow the specified log-normal distribution.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/friction_force/#particle-velocity-distribution","title":"Particle Velocity Distribution\u00b6","text":"<p>Next, we assess the distribution of particle velocities. This is crucial for ensuring that the initial velocities reflect thermal motion as intended.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/friction_force/#friction-factor-in-particle-dynamics","title":"Friction Factor in Particle Dynamics\u00b6","text":""},{"location":"How-To-Guides/Lagrangian/notebooks/friction_force/#understanding-the-friction-force","title":"Understanding the Friction Force\u00b6","text":"<p>As we simulate particles at a realistic scale, accounting for forces acting on them becomes crucial. The first significant force is friction, which opposes the particle's motion and is proportional to its velocity.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/friction_force/#mathematical-representation","title":"Mathematical Representation\u00b6","text":"<p>The friction factor $(f_p)$ is described by:</p> <p>$$ f_p = \\frac{3 \\pi D_p \\mu}{D_c} $$</p> <p>where $D_p$ is the particle diameter, $\\mu$ is the dynamic viscosity, and $D_c$ is the diffusion coefficient.</p> <p>The drag force, $F_d$, is then:</p> <p>$$ F_d = f_p v_p $$</p> <p>with $v_p$ representing the particle velocity.</p> <p>Considering gravitational settling in a fluid at rest $(u_{fluid} = 0)$, the motion equation becomes:</p> <p>$$ m_p \\frac{dv}{dt} = m_pg + f_p (u_{fluid}-v_p) $$</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/friction_force/#implementing-the-friction-factor-in-the-simulation","title":"Implementing the Friction Factor in the Simulation\u00b6","text":""},{"location":"How-To-Guides/Lagrangian/notebooks/friction_force/#efficiency-considerations","title":"Efficiency Considerations\u00b6","text":"<p>Calculating the friction factor at each simulation step could be computationally intensive. However, it's important to note that $f_p$ is dependent on environmental variables like pressure and temperature, which might change.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/friction_force/#current-approach","title":"Current Approach\u00b6","text":"<p>For the current stage of the simulation, we'll compute $f_p$ initially and use nearest neighbor interpolation for each particle. This approach balances efficiency with accuracy, keeping in mind that future iterations may include dynamic adjustments for varying environmental conditions.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/friction_force/#running-the-particle-simulation","title":"Running the Particle Simulation\u00b6","text":"<p>In this part of the notebook, we execute the core simulation loop. This involves integrating the motion of the particles over time while considering the forces acting on them, including friction and gravity. Several key updates and optimizations are included:</p> <ol> <li><p>Friction Factor Initialization: Before entering the main loop, the friction factor for each particle is calculated. This is an essential step for accurately simulating the drag force on particles.</p> </li> <li><p>Conditional Coagulation Step: The simulation includes an optional coagulation step, executed at a specified interval. This step simulates the merging of particles upon collision, affecting their mass and velocity.</p> </li> <li><p>Friction Factor Update: The friction factor is updated at regular intervals to reflect changes in particle size or other environmental conditions. This step ensures that the drag force remains accurate throughout the simulation.</p> </li> <li><p>Force Calculation and Integration: Within each iteration, we calculate the forces acting on the particles and update their positions and velocities using the leapfrog integration method.</p> </li> <li><p>Boundary Conditions and Data Saving: The simulation includes boundary conditions to mimic a wrapped cube environment. Additionally, particle position and mass data are saved at predefined intervals for analysis.</p> </li> </ol> <p>This simulation loop provides a comprehensive and dynamic model of particle motion, taking into account physical factors and interactions.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/friction_force/#plotting-particle-positions","title":"Plotting Particle Positions\u00b6","text":"<p>After running the simulation, we'll plot the particle positions to visualize their movement.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/friction_force/#size-distribution-of-particles","title":"Size Distribution of Particles\u00b6","text":"<p>Given particle collision and coagulation, we'll plot the distribution of particle sizes at the end of the simulation. This step ensures that the particle size distribution aligns with our expectations and the intended simulation parameters. That being, both a decrease in the number of particles and an increase in the average particle size.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/friction_force/#summary-of-cloud-droplet-simulation","title":"Summary of Cloud Droplet Simulation\u00b6","text":""},{"location":"How-To-Guides/Lagrangian/notebooks/friction_force/#achievements-in-realism","title":"Achievements in Realism\u00b6","text":"<p>In this iteration of the cloud droplet simulation, we've significantly advanced towards realism:</p> <ul> <li>Enhanced Initial Conditions: The simulation now starts with more realistically distributed particle sizes and velocities.</li> <li>Inclusion of Friction Force: We've incorporated the friction force, an essential factor in accurately simulating particle dynamics.</li> <li>Optional Coagulation: The simulation allows for the inclusion of coagulation, further adding to its complexity and realism.</li> </ul>"},{"location":"How-To-Guides/Lagrangian/notebooks/friction_force/#performance-considerations","title":"Performance Considerations\u00b6","text":"<p>While these enhancements bring us closer to real-world scenarios, they also slow down the simulation. However, it still runs at a reasonable pace relative to real time.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/friction_force/#challenges-with-sub-micron-aerosols","title":"Challenges with Sub-Micron Aerosols\u00b6","text":"<p>The next goal is to simulate sub-micron aerosol sizes accurately. The main challenge here lies in particle velocity:</p> <ul> <li>High Speeds and Domain Size: At sub-micron scales, particles can travel multiple domain lengths in a single time step. This necessitates extremely small time steps for accuracy, which is computationally inefficient.</li> <li>Domain Wrapping Issue: As observed in the final position plot, larger droplets end up at the domain's top due to their high speeds and the wrap-around nature of the domain. This indicates the need for a different approach to handle fast-moving particles.</li> </ul>"},{"location":"How-To-Guides/Lagrangian/notebooks/friction_force/#positive-observations","title":"Positive Observations\u00b6","text":"<p>Despite these challenges, there are encouraging signs:</p> <ul> <li>Evolving Size Distribution: The simulation shows a trend towards fewer, larger particles over time. This behavior mirrors what is expected in cloud formation, where larger particles are more likely to collide and grow.</li> </ul>"},{"location":"How-To-Guides/Lagrangian/notebooks/friction_force/#conclusion","title":"Conclusion\u00b6","text":"<p>These observations suggest that we are moving in the right direction towards a realistic and efficient simulation of particle dynamics. Future improvements will focus on addressing the challenges with sub-micron aerosols and further refining the simulation model.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/sweep_and_prune/","title":"Sweep and Prune Algorithm","text":"In\u00a0[41]: Copied! <pre># Code Section: Importing Necessary Libraries and Initializing Variables\nimport time\nimport torch\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom particula.lagrangian import boundary, integration, collisions, particle_property, particle_pairs\n\n# device = torch.device('cuda')  # or 'cuda:0' to specify a particular GPU\n# torch.set_default_device(device)\n\n\n# Initializing the Torch Generator and setting the data type\ntorch.manual_seed(1234)  # Set the seed for reproducibility\nt_type = torch.float32\n</pre> # Code Section: Importing Necessary Libraries and Initializing Variables import time import torch import numpy as np import matplotlib.pyplot as plt from particula.lagrangian import boundary, integration, collisions, particle_property, particle_pairs  # device = torch.device('cuda')  # or 'cuda:0' to specify a particular GPU # torch.set_default_device(device)   # Initializing the Torch Generator and setting the data type torch.manual_seed(1234)  # Set the seed for reproducibility t_type = torch.float32 In\u00a0[42]: Copied! <pre># Setting up the Simulation Parameters and Initial Conditions\n# Define fixed parameters\nTOTAL_NUMBER_OF_PARTICLES = 500\nTIME_STEP = 0.01\nSIMULATION_TIME = 10\nMASS = 3\nCUBE_SIDE = 50\nspeed = 5\nsave_points = 50\n\n# Initialize particle positions randomly within the cube\nposition = torch.rand(\n    3,\n    TOTAL_NUMBER_OF_PARTICLES,\n    dtype=t_type) * CUBE_SIDE - CUBE_SIDE / 2\n\n# Initialize particle velocities randomly\nvelocity = torch.rand(3, TOTAL_NUMBER_OF_PARTICLES,\n                      dtype=t_type) * speed - speed / 2\n\n# Initialize force as zero for all particles\nforce = torch.zeros(3, TOTAL_NUMBER_OF_PARTICLES, dtype=t_type)\n\n# Set constant mass and density for all particles\nmass = torch.ones(TOTAL_NUMBER_OF_PARTICLES, dtype=t_type) * MASS\ndensity = torch.ones(TOTAL_NUMBER_OF_PARTICLES, dtype=t_type) * 1\n\n# Generate indices for particles, could be integer type\nindices = torch.arange(TOTAL_NUMBER_OF_PARTICLES, dtype=t_type)  # could be int\n\n# Calculate the total number of iterations for the simulation\ntotal_iterations = int(SIMULATION_TIME / TIME_STEP)\n\n# Initialize a tensor to track the total mass over iterations\ntotal_mass = torch.zeros(total_iterations, dtype=t_type)\n\n# Define gravity acting on all particles\ngravity = torch.tensor(\n    [0, -9.81, 0]).repeat(TOTAL_NUMBER_OF_PARTICLES, 1).transpose(0, 1)\n\n# Initializing Arrays for Saving Position and Mass Data\n# Create arrays to store position and mass data at each save point\nsave_position = np.zeros((3, TOTAL_NUMBER_OF_PARTICLES, save_points))\nsave_mass = np.zeros((TOTAL_NUMBER_OF_PARTICLES, save_points))\n\n# Determine which iterations will correspond to the save points\nsave_iterations = np.linspace(0, total_iterations, save_points, dtype=int)\nradius = particle_property.radius_calculation(mass=mass, density=density)\n</pre> # Setting up the Simulation Parameters and Initial Conditions # Define fixed parameters TOTAL_NUMBER_OF_PARTICLES = 500 TIME_STEP = 0.01 SIMULATION_TIME = 10 MASS = 3 CUBE_SIDE = 50 speed = 5 save_points = 50  # Initialize particle positions randomly within the cube position = torch.rand(     3,     TOTAL_NUMBER_OF_PARTICLES,     dtype=t_type) * CUBE_SIDE - CUBE_SIDE / 2  # Initialize particle velocities randomly velocity = torch.rand(3, TOTAL_NUMBER_OF_PARTICLES,                       dtype=t_type) * speed - speed / 2  # Initialize force as zero for all particles force = torch.zeros(3, TOTAL_NUMBER_OF_PARTICLES, dtype=t_type)  # Set constant mass and density for all particles mass = torch.ones(TOTAL_NUMBER_OF_PARTICLES, dtype=t_type) * MASS density = torch.ones(TOTAL_NUMBER_OF_PARTICLES, dtype=t_type) * 1  # Generate indices for particles, could be integer type indices = torch.arange(TOTAL_NUMBER_OF_PARTICLES, dtype=t_type)  # could be int  # Calculate the total number of iterations for the simulation total_iterations = int(SIMULATION_TIME / TIME_STEP)  # Initialize a tensor to track the total mass over iterations total_mass = torch.zeros(total_iterations, dtype=t_type)  # Define gravity acting on all particles gravity = torch.tensor(     [0, -9.81, 0]).repeat(TOTAL_NUMBER_OF_PARTICLES, 1).transpose(0, 1)  # Initializing Arrays for Saving Position and Mass Data # Create arrays to store position and mass data at each save point save_position = np.zeros((3, TOTAL_NUMBER_OF_PARTICLES, save_points)) save_mass = np.zeros((TOTAL_NUMBER_OF_PARTICLES, save_points))  # Determine which iterations will correspond to the save points save_iterations = np.linspace(0, total_iterations, save_points, dtype=int) radius = particle_property.radius_calculation(mass=mass, density=density) In\u00a0[43]: Copied! <pre># Initialize counter for saving data\nsave_counter = 0\nstart_time = time.time()\n\nfor i in range(total_iterations):\n\n    # NEW calculate sweep and prune collision pairs\n    radius = particle_property.radius_calculation(mass=mass, density=density)\n    valid_collision_indices_pairs = particle_pairs.full_sweep_and_prune(\n         position=position, radius=radius)\n\n    if valid_collision_indices_pairs.shape[0] &gt; 0:\n        # Coalesce particles that have collided and update their velocity and mass\n        velocity, mass = collisions.coalescence(\n            position=position,\n            velocity=velocity,\n            mass=mass,\n            radius=radius,\n            collision_indices_pairs=valid_collision_indices_pairs)\n\n    # Calculate the force acting on the particles (e.g., gravity)\n    force = mass * gravity\n\n    # Integrate the equations of motion to update position and velocity\n    position, velocity = integration.leapfrog(\n        position=position, velocity=velocity, force=force, mass=mass, time_step=TIME_STEP)\n\n    # Apply boundary conditions for the cube (wrap-around)\n    position = boundary.wrapped_cube(position=position, cube_side=CUBE_SIDE)\n\n    # Save the position and mass data at designated save points\n    if i == save_iterations[save_counter]:\n        save_position[:, :, save_counter] = position.detach().cpu().numpy()\n        save_mass[:, save_counter] = mass.detach().cpu().numpy()\n        save_counter += 1\n\n# Perform a final save of the position and mass data\nsave_position[:, :, -1] = position.detach().cpu().numpy()\nsave_mass[:, -1] = mass.detach().cpu().numpy()\n\n# Calculate the total simulation time\nend_time = time.time()\nprint(f\"Total wall time: {end_time - start_time} seconds\")\nprint(f\"Ratio of wall time to simulation time: {(end_time - start_time) / SIMULATION_TIME}\")\n</pre> # Initialize counter for saving data save_counter = 0 start_time = time.time()  for i in range(total_iterations):      # NEW calculate sweep and prune collision pairs     radius = particle_property.radius_calculation(mass=mass, density=density)     valid_collision_indices_pairs = particle_pairs.full_sweep_and_prune(          position=position, radius=radius)      if valid_collision_indices_pairs.shape[0] &gt; 0:         # Coalesce particles that have collided and update their velocity and mass         velocity, mass = collisions.coalescence(             position=position,             velocity=velocity,             mass=mass,             radius=radius,             collision_indices_pairs=valid_collision_indices_pairs)      # Calculate the force acting on the particles (e.g., gravity)     force = mass * gravity      # Integrate the equations of motion to update position and velocity     position, velocity = integration.leapfrog(         position=position, velocity=velocity, force=force, mass=mass, time_step=TIME_STEP)      # Apply boundary conditions for the cube (wrap-around)     position = boundary.wrapped_cube(position=position, cube_side=CUBE_SIDE)      # Save the position and mass data at designated save points     if i == save_iterations[save_counter]:         save_position[:, :, save_counter] = position.detach().cpu().numpy()         save_mass[:, save_counter] = mass.detach().cpu().numpy()         save_counter += 1  # Perform a final save of the position and mass data save_position[:, :, -1] = position.detach().cpu().numpy() save_mass[:, -1] = mass.detach().cpu().numpy()  # Calculate the total simulation time end_time = time.time() print(f\"Total wall time: {end_time - start_time} seconds\") print(f\"Ratio of wall time to simulation time: {(end_time - start_time) / SIMULATION_TIME}\") <pre>Total wall time: 8.405936002731323 seconds\nRatio of wall time to simulation time: 0.8405936002731323\n</pre> In\u00a0[44]: Copied! <pre># Processing the Final Data for Visualization\n\n# Select the final time index for the data\ntime_index = -2\nposition_final = save_position[:, :, time_index]\nmass_final = save_mass[:, time_index]\n\n# Filter out particles with zero mass\nfilter_zero_mass = mass_final &gt; 0\n\n# Calculate the radius and area of each particle\nradius_final = (3 * mass_final / (4 * np.pi *\n                density.cpu().numpy())) ** (1 / 3)\nparticle_area = np.pi * radius_final**2\n\n# Display the number of remaining particles\nprint(f\"Number of particles at the end: {filter_zero_mass.sum()}\")\n\n# Creating a 3D Plot for Visualization\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Choose a color map for the scatter plot\ncmap = plt.cm.viridis\n\n# Plot the final positions of particles with non-zero mass\nscatter_plot = ax.scatter(\n    position_final[0, filter_zero_mass],\n    position_final[1, filter_zero_mass],\n    position_final[2, filter_zero_mass],\n    c=mass_final[filter_zero_mass],\n    cmap=cmap,\n    s=particle_area[filter_zero_mass]  # Particle size based on area\n)\n\n# Set axis limits based on cube dimensions\nax.set_xlim(-CUBE_SIDE / 2, CUBE_SIDE / 2)\nax.set_ylim(-CUBE_SIDE / 2, CUBE_SIDE / 2)\nax.set_zlim(-CUBE_SIDE / 2, CUBE_SIDE / 2)\n\n# Add a color bar indicating particle mass\ncolor_bar = plt.colorbar(scatter_plot, ax=ax)\ncolor_bar.set_label('Mass')\n\n# Show the plot with optimized layout\nplt.show()\nfig.tight_layout()\n</pre> # Processing the Final Data for Visualization  # Select the final time index for the data time_index = -2 position_final = save_position[:, :, time_index] mass_final = save_mass[:, time_index]  # Filter out particles with zero mass filter_zero_mass = mass_final &gt; 0  # Calculate the radius and area of each particle radius_final = (3 * mass_final / (4 * np.pi *                 density.cpu().numpy())) ** (1 / 3) particle_area = np.pi * radius_final**2  # Display the number of remaining particles print(f\"Number of particles at the end: {filter_zero_mass.sum()}\")  # Creating a 3D Plot for Visualization fig = plt.figure() ax = fig.add_subplot(projection='3d')  # Choose a color map for the scatter plot cmap = plt.cm.viridis  # Plot the final positions of particles with non-zero mass scatter_plot = ax.scatter(     position_final[0, filter_zero_mass],     position_final[1, filter_zero_mass],     position_final[2, filter_zero_mass],     c=mass_final[filter_zero_mass],     cmap=cmap,     s=particle_area[filter_zero_mass]  # Particle size based on area )  # Set axis limits based on cube dimensions ax.set_xlim(-CUBE_SIDE / 2, CUBE_SIDE / 2) ax.set_ylim(-CUBE_SIDE / 2, CUBE_SIDE / 2) ax.set_zlim(-CUBE_SIDE / 2, CUBE_SIDE / 2)  # Add a color bar indicating particle mass color_bar = plt.colorbar(scatter_plot, ax=ax) color_bar.set_label('Mass')  # Show the plot with optimized layout plt.show() fig.tight_layout() <pre>Number of particles at the end: 367\n</pre> In\u00a0[45]: Copied! <pre># Visualizing the Mass Distribution at Different Stages\n\n# Create a new figure for the histogram\nfig = plt.figure()\nax = fig.add_subplot()\n# Normalizing by initial MASS to observe distribution changes\nnormalized_mass = save_mass[filter_zero_mass, :] / MASS\nmax_mass = normalized_mass.max()\n\n# Plot histograms of mass distribution at different stages\nax.hist(normalized_mass[:, 0], bins=25,\n        alpha=0.8, label='Initial', range=(0, max_mass))\nax.hist(normalized_mass[:, 24], bins=25,\n        alpha=0.6, label='Middle', range=(0, max_mass))\nax.hist(normalized_mass[:, -1], bins=25,\n        alpha=0.5, label='Final', range=(0, max_mass))\n\n# Setting labels and title for the plot\nax.set_xlabel('Mass / Initial MASS')\nax.set_ylabel('Number of Particles')\n\n# Add a legend to the plot\nax.legend()\n\n# Display the plot\nplt.show()\n\n# Adjust layout for optimal visualization\nfig.tight_layout()\n</pre> # Visualizing the Mass Distribution at Different Stages  # Create a new figure for the histogram fig = plt.figure() ax = fig.add_subplot() # Normalizing by initial MASS to observe distribution changes normalized_mass = save_mass[filter_zero_mass, :] / MASS max_mass = normalized_mass.max()  # Plot histograms of mass distribution at different stages ax.hist(normalized_mass[:, 0], bins=25,         alpha=0.8, label='Initial', range=(0, max_mass)) ax.hist(normalized_mass[:, 24], bins=25,         alpha=0.6, label='Middle', range=(0, max_mass)) ax.hist(normalized_mass[:, -1], bins=25,         alpha=0.5, label='Final', range=(0, max_mass))  # Setting labels and title for the plot ax.set_xlabel('Mass / Initial MASS') ax.set_ylabel('Number of Particles')  # Add a legend to the plot ax.legend()  # Display the plot plt.show()  # Adjust layout for optimal visualization fig.tight_layout() In\u00a0[46]: Copied! <pre>## sweep and prune along one axis\nhelp(particle_pairs.single_axis_sweep_and_prune)\n</pre> ## sweep and prune along one axis help(particle_pairs.single_axis_sweep_and_prune) <pre>Help on function single_axis_sweep_and_prune in module particula.lagrangian.particle_pairs:\n\nsingle_axis_sweep_and_prune(position_axis: torch.Tensor, radius: torch.Tensor) -&gt; Tuple[torch.Tensor, torch.Tensor]\n    Sweep and prune algorithm for collision detection along a single axis.\n    This function identifies pairs of particles that are close enough to\n    potentially collide.\n    \n    Args:\n        position_axis (torch.Tensor): The position of particles along a single\n            axis.\n        radius (torch.Tensor): The radius of particles.\n    \n    Returns:\n        Tuple[torch.Tensor, torch.Tensor]: Two tensors containing the indices\n        of potentially colliding particles.\n\n</pre>"},{"location":"How-To-Guides/Lagrangian/notebooks/sweep_and_prune/#sweep-and-prune-algorithm","title":"Sweep and Prune Algorithm\u00b6","text":"<p>In our previous approach to collision detection, we compared each particle with every other particle, resulting in a computationally expensive $O(N^2)$ operation, where $N$ is the number of particles. To enhance efficiency, we now implement the sweep and prune algorithm.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/sweep_and_prune/#concept-of-sweep-and-prune","title":"Concept of Sweep and Prune\u00b6","text":"<p>The sweep and prune algorithm is a more efficient method for collision detection. Its efficiency stems from reducing the number of particle pairs we need to check. The key steps of this algorithm are:</p> <p>Sweep: Sort the particles along one axis, typically the $x$-axis. This step orders the particles in a way that adjacent particles in the sorted list are likely to be close in space.</p> <p>Prune: After sorting, we then check for potential collisions only between neighboring particles in this sorted list. This pruning significantly reduces the number of comparisons.</p> <p>Repeat for Other Axes: The process is repeated for the $y$-axis and the $z$-axis. In each iteration, we eliminate pairs of particles that are too far apart to collide based on their coordinates in the respective axis.</p> <p>Euclidean Distance Check: Finally, we validate potential collisions by checking the actual Euclidean distance between particle pairs that remained after the pruning steps. This step ensures accurate detection of collisions.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/sweep_and_prune/#efficiency-gains","title":"Efficiency Gains\u00b6","text":"<p>This method dramatically reduces the number of comparisons from $O(N^2)$ to approximately $O(N \\log N)$, mainly due to sorting. The actual number of particle pairs checked for collision is usually much less than $N$, especially in sparsely populated spaces. This makes the sweep and prune algorithm significantly more efficient for collision detection in systems with a large number of particles.</p> <p>Note: The exact efficiency depends on the distribution and density of particles. In cases where particles are uniformly distributed, the sweep and prune method shows substantial efficiency improvements. However, in highly clustered scenarios, the performance gain might be less pronounced, but it still outperforms the brute-force $N^2$ approach.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/sweep_and_prune/#initialization","title":"Initialization\u00b6","text":"<p>We'll use the same initialization as in the previous notebook.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/sweep_and_prune/#plot-positions","title":"Plot Positions\u00b6","text":"<p>Compared to the previous notebook, the sweep and prune is about 2x faster for this scenario. The exact speedup depends on the number of particles and the distribution of particles in space.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/sweep_and_prune/#analyzing-the-mass-distribution-of-particles","title":"Analyzing the Mass Distribution of Particles\u00b6","text":""},{"location":"How-To-Guides/Lagrangian/notebooks/sweep_and_prune/#summary-of-the-sweep-and-prune-algorithm","title":"Summary of the Sweep and Prune Algorithm\u00b6","text":"<p>In our recent work, we've successfully implemented the sweep and prune algorithm for efficient collision detection. This method has demonstrated a notable efficiency improvement over the traditional brute-force approach. As we progress, the next notebook will introduce realistic aerosol initialization and dynamics, further enhancing our simulation's applicability.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/sweep_and_prune/#understanding-sweep-and-prune-aabb-algorithm","title":"Understanding Sweep and Prune (AABB Algorithm)\u00b6","text":"<p>The sweep and prune algorithm is often referred to as the Axis-Aligned Bounding Box (AABB) algorithm. This designation stems from the technique's reliance on comparing axis-aligned bounding boxes of particles to detect potential collisions. An axis-aligned bounding box is the smallest box that entirely encapsulates a particle and is aligned with the coordinate axes. By working with these boxes, the algorithm efficiently narrows down collision checks to only those particles whose bounding boxes overlap, significantly reducing the number of necessary calculations.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/sweep_and_prune/#additional-context-on-aabb","title":"Additional Context on AABB\u00b6","text":"<ul> <li>Efficient Sorting: The key to its efficiency lies in sorting particles along each axis and then checking for overlap, which is computationally less intensive than checking every pair of particles.</li> <li>Use in Various Domains: While commonly used in computer graphics and game development for spatial partitioning and collision detection, the AABB approach is also highly relevant in scientific simulations like aerosol dynamics.</li> </ul>"},{"location":"How-To-Guides/Lagrangian/notebooks/sweep_and_prune/#exploring-other-collision-detection-methods","title":"Exploring Other Collision Detection Methods\u00b6","text":"<p>Beyond sweep and prune, several other advanced collision detection techniques offer improved efficiency over brute-force methods, albeit with increased complexity in implementation. Some noteworthy methods include:</p> <ul> <li>K-d Tree (Smarter Space Partitioning): This method involves partitioning space into regions using a k-dimensional tree, allowing for efficient searching and nearest-neighbor queries, particularly useful in sparsely populated spaces.</li> <li>Bounding Volume Hierarchy (BVH): BVH involves creating a tree structure of bounding volumes, where each node encompasses a subset of objects in the space. Collision detection then proceeds by traversing this tree, significantly speeding up the process in complex scenes.</li> <li>GJK Algorithm (Gilbert-Johnson-Keerthi): The GJK algorithm is used for collision detection between convex shapes. It efficiently determines whether two convex shapes intersect and can be extended to calculate the minimum distance between them.</li> </ul>"},{"location":"How-To-Guides/Lagrangian/notebooks/sweep_and_prune/#additional-considerations","title":"Additional Considerations\u00b6","text":"<ul> <li>Choosing the Right Method: The choice of collision detection algorithm depends on the specific requirements of the simulation, such as the number of particles, their distribution, and the required accuracy.</li> <li>Hybrid Approaches: In practice, a combination of these methods can be used, depending on the scale and complexity of the simulation environment. By incorporating these advanced collision detection methods, we can further optimize our simulations for more realistic and computationally efficient aerosol behavior modeling.</li> </ul>"},{"location":"How-To-Guides/Lagrangian/notebooks/turbulence_drops/","title":"Realistic Drag, Mass, and Velocity","text":"In\u00a0[1]: Copied! <pre># Code Section: Importing Necessary Libraries and Initializing Variables\nimport time\nimport torch\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom particula.lagrangian import boundary, integration, collisions, particle_property, particle_pairs\nfrom particula.util import machine_limit\n\ndevice = torch.device('cuda') # or 'cuda:0' to specify a particular GPU\ntorch.set_default_device(device)\n\n\n# Initializing the Torch Generator and setting the data type\nseed = 1234\ntorch.manual_seed(seed)  # Set the seed for reproducibility\nt_type = torch.float32\n\n# print particula version\nfrom particula import __version__\nprint(\"particula version: \", __version__)\n</pre> # Code Section: Importing Necessary Libraries and Initializing Variables import time import torch import numpy as np import matplotlib.pyplot as plt from particula.lagrangian import boundary, integration, collisions, particle_property, particle_pairs from particula.util import machine_limit  device = torch.device('cuda') # or 'cuda:0' to specify a particular GPU torch.set_default_device(device)   # Initializing the Torch Generator and setting the data type seed = 1234 torch.manual_seed(seed)  # Set the seed for reproducibility t_type = torch.float32  # print particula version from particula import __version__ print(\"particula version: \", __version__) <pre>particula version:  0.0.17.dev0\n</pre> In\u00a0[\u00a0]: Copied! <pre># Setting up the Simulation Parameters and Initial Conditions\n\n# Define fixed parameters\nTOTAL_NUMBER_OF_PARTICLES = 100\nTIME_STEP = 0.005\nSIMULATION_TIME = 10\nCUBE_SIDE = 0.010  # Size of the simulation cube in meters\nsave_points = 120  # Number of points to save the simulation data\ntke_sigma = 0.5  # Standard deviation of turbulent kinetic energy, m^2/s^2\n\n# Defining new parameters for more realistic simulation\ndensity_uniform = 1.5e3  # Uniform density of particles in kg/m^3\nmean_radius_nm = 25000  # Mean radius of particles in nanometers\nstd_dev_nm = 1.1  # Standard deviation of particle radius in nanometers\nsystem_temperature_kelvin = 300  # System temperature in Kelvin\nsystem_pressure_pascal = 1e5  # System pressure in Pascal\n\n# Define intervals for updating interaction factors\ninterval_friction_factor = 1000  # Interval for updating friction factor\ninterval_coagulation = 100  # Interval for updating coagulation\nregnerate_interval = 10000  # Interval for regenerating particles\ntke_interval = 100  # Interval for updating turbulent kinetic energy\n\n# Generating particle masses using a log-normal distribution\nmass = particle_property.generate_particle_masses(\n    mean_radius=mean_radius_nm,\n    std_dev_radius=std_dev_nm,\n    density=density_uniform,\n    num_particles=TOTAL_NUMBER_OF_PARTICLES,\n    radius_input_units=\"nm\",\n)\n\n# Initializing particle velocities using thermal velocity\nvelocity = particle_property.random_thermal_velocity(\n    temperature_kelvin=system_temperature_kelvin,\n    mass_kg=mass,\n    number_of_particles=TOTAL_NUMBER_OF_PARTICLES,\n    t_type=t_type,\n    random_seed=seed\n)\n\n# Setting constant density for all particles\ndensity = torch.ones(TOTAL_NUMBER_OF_PARTICLES, dtype=t_type) * density_uniform\n\n# Initialize particle positions randomly within the cube\nposition = torch.rand(\n    3,\n    TOTAL_NUMBER_OF_PARTICLES,\n    dtype=t_type) * CUBE_SIDE - CUBE_SIDE / 2\n\n# Initialize force as zero for all particles\nforce = torch.zeros(3, TOTAL_NUMBER_OF_PARTICLES, dtype=t_type)\n\n# Generating indices for particles\nindices = torch.arange(TOTAL_NUMBER_OF_PARTICLES, dtype=t_type)  # Integer type\n\n# Calculating the total number of iterations for the simulation\ntotal_iterations = int(SIMULATION_TIME / TIME_STEP)\n\n# Initializing tensor to track total mass over iterations\ntotal_mass = torch.zeros(total_iterations, dtype=t_type)\n\n# Defining gravity acting on all particles\ngravity = torch.tensor(\n    [0, 0, -9.81]).repeat(TOTAL_NUMBER_OF_PARTICLES, 1).transpose(0, 1)\n\n# Initializing Arrays for Saving Position and Mass Data\nsave_position = np.zeros((3, TOTAL_NUMBER_OF_PARTICLES, save_points))\nsave_mass = np.zeros((TOTAL_NUMBER_OF_PARTICLES, save_points))\nsave_iterations = np.linspace(0, total_iterations, save_points, dtype=int)\n\n# Calculating particle radius from mass and density\nradius = particle_property.radius_calculation(mass=mass, density=density)\n</pre> # Setting up the Simulation Parameters and Initial Conditions  # Define fixed parameters TOTAL_NUMBER_OF_PARTICLES = 100 TIME_STEP = 0.005 SIMULATION_TIME = 10 CUBE_SIDE = 0.010  # Size of the simulation cube in meters save_points = 120  # Number of points to save the simulation data tke_sigma = 0.5  # Standard deviation of turbulent kinetic energy, m^2/s^2  # Defining new parameters for more realistic simulation density_uniform = 1.5e3  # Uniform density of particles in kg/m^3 mean_radius_nm = 25000  # Mean radius of particles in nanometers std_dev_nm = 1.1  # Standard deviation of particle radius in nanometers system_temperature_kelvin = 300  # System temperature in Kelvin system_pressure_pascal = 1e5  # System pressure in Pascal  # Define intervals for updating interaction factors interval_friction_factor = 1000  # Interval for updating friction factor interval_coagulation = 100  # Interval for updating coagulation regnerate_interval = 10000  # Interval for regenerating particles tke_interval = 100  # Interval for updating turbulent kinetic energy  # Generating particle masses using a log-normal distribution mass = particle_property.generate_particle_masses(     mean_radius=mean_radius_nm,     std_dev_radius=std_dev_nm,     density=density_uniform,     num_particles=TOTAL_NUMBER_OF_PARTICLES,     radius_input_units=\"nm\", )  # Initializing particle velocities using thermal velocity velocity = particle_property.random_thermal_velocity(     temperature_kelvin=system_temperature_kelvin,     mass_kg=mass,     number_of_particles=TOTAL_NUMBER_OF_PARTICLES,     t_type=t_type,     random_seed=seed )  # Setting constant density for all particles density = torch.ones(TOTAL_NUMBER_OF_PARTICLES, dtype=t_type) * density_uniform  # Initialize particle positions randomly within the cube position = torch.rand(     3,     TOTAL_NUMBER_OF_PARTICLES,     dtype=t_type) * CUBE_SIDE - CUBE_SIDE / 2  # Initialize force as zero for all particles force = torch.zeros(3, TOTAL_NUMBER_OF_PARTICLES, dtype=t_type)  # Generating indices for particles indices = torch.arange(TOTAL_NUMBER_OF_PARTICLES, dtype=t_type)  # Integer type  # Calculating the total number of iterations for the simulation total_iterations = int(SIMULATION_TIME / TIME_STEP)  # Initializing tensor to track total mass over iterations total_mass = torch.zeros(total_iterations, dtype=t_type)  # Defining gravity acting on all particles gravity = torch.tensor(     [0, 0, -9.81]).repeat(TOTAL_NUMBER_OF_PARTICLES, 1).transpose(0, 1)  # Initializing Arrays for Saving Position and Mass Data save_position = np.zeros((3, TOTAL_NUMBER_OF_PARTICLES, save_points)) save_mass = np.zeros((TOTAL_NUMBER_OF_PARTICLES, save_points)) save_iterations = np.linspace(0, total_iterations, save_points, dtype=int)  # Calculating particle radius from mass and density radius = particle_property.radius_calculation(mass=mass, density=density) In\u00a0[\u00a0]: Copied! <pre># random air velcoity TKE generation\nair_velocity_length = total_iterations//tke_interval\nnormal_dist = torch.distributions.normal.Normal(0, tke_sigma)\nair_velocities = normal_dist.sample((3, air_velocity_length))\n\n# Calculating the initial turbulent kinetic energy\ndef tke_calculation(air_velocities):\n    \"\"\"Calculates the turbulent kinetic energy from air velocity\"\"\"\n    std_velocities = torch.std(air_velocities, dim=1)\n    tke = 0.5 * sum(std_velocities**2)\n    return tke\n\ntke = tke_calculation(air_velocities)\nprint(\"Initial TKE: \", tke)\nprint(\"velocity shape: \", air_velocities.shape)\nprint(\"Air initial velocity: \", air_velocities[:, 0])\n</pre> # random air velcoity TKE generation air_velocity_length = total_iterations//tke_interval normal_dist = torch.distributions.normal.Normal(0, tke_sigma) air_velocities = normal_dist.sample((3, air_velocity_length))  # Calculating the initial turbulent kinetic energy def tke_calculation(air_velocities):     \"\"\"Calculates the turbulent kinetic energy from air velocity\"\"\"     std_velocities = torch.std(air_velocities, dim=1)     tke = 0.5 * sum(std_velocities**2)     return tke  tke = tke_calculation(air_velocities) print(\"Initial TKE: \", tke) print(\"velocity shape: \", air_velocities.shape) print(\"Air initial velocity: \", air_velocities[:, 0])  <pre>Initial TKE:  tensor(0.3742)\nvelocity shape:  torch.Size([3, 86400])\nAir initial velocity:  tensor([ 0.3003, -0.4218, -0.4296])\n</pre> In\u00a0[\u00a0]: Copied! <pre># Plotting the Initial Radius Distribution\n\n# Calculate the initial radius of particles\nradius_initial = particle_property.radius_calculation(\n    mass=mass, density=density)\n\n# Plotting the histogram for radius distribution\nfig, ax = plt.subplots()\nax.hist(machine_limit.safe_log10(radius_initial), bins=20, range=(-7, -2))\nax.set_xlabel(\"log10 Radius (m)\")\nax.set_ylabel(\"Number of Particles\")\nax.set_title(\"Initial Particle Radius Distribution\")\nplt.show()\n\n# Plotting the Initial Velocity Distribution\n\n# Calculate the speeds of particles from their velocities\ninitial_speeds = particle_property.speed(velocity)\n\n# Plotting the histogram for velocity distribution\nfig, ax = plt.subplots()\nax.hist(machine_limit.safe_log10(initial_speeds), bins=20)\nax.set_xlabel(\"log10 Velocity (m/s)\")\nax.set_ylabel(\"Number of Particles\")\nax.set_title(\"Initial Particle Velocity Distribution\")\nplt.show()\n</pre> # Plotting the Initial Radius Distribution  # Calculate the initial radius of particles radius_initial = particle_property.radius_calculation(     mass=mass, density=density)  # Plotting the histogram for radius distribution fig, ax = plt.subplots() ax.hist(machine_limit.safe_log10(radius_initial), bins=20, range=(-7, -2)) ax.set_xlabel(\"log10 Radius (m)\") ax.set_ylabel(\"Number of Particles\") ax.set_title(\"Initial Particle Radius Distribution\") plt.show()  # Plotting the Initial Velocity Distribution  # Calculate the speeds of particles from their velocities initial_speeds = particle_property.speed(velocity)  # Plotting the histogram for velocity distribution fig, ax = plt.subplots() ax.hist(machine_limit.safe_log10(initial_speeds), bins=20) ax.set_xlabel(\"log10 Velocity (m/s)\") ax.set_ylabel(\"Number of Particles\") ax.set_title(\"Initial Particle Velocity Distribution\") plt.show() In\u00a0[\u00a0]: Copied! <pre># Printing the Maximum and Minimum Radii of the Particles\nprint(\"Initial Max Diameter [mm]: \", radius_initial.max().item() * 2 * 1e3)\nprint(\n    \"Initial Min Diameter [mm]: \",\n    radius_initial.min().item() *\n    2 *\n    1e3)\n\n# Initializing the Range of Radii for Friction Factor Calculation\n# We use a linspace to cover a range from the smallest to 10 times the\n# largest radius.\nfriction_factor_radius = torch.linspace(\n    start=radius.min(),\n    end=radius.max() * 10,\n    steps=1000,\n)\n\n# Calculating the Friction Factor\n# This calculation considers the radius, temperature, and pressure to\n# determine the friction factor.\nfriction_factor_array = particle_property.friction_factor_wrapper(\n    radius_meter=friction_factor_radius,\n    temperature_kelvin=system_temperature_kelvin,\n    pressure_pascal=system_pressure_pascal,\n)\n\n# Plotting Friction Factor vs Radius\n# The plot helps in visualizing how friction factor varies with particle\n# radius.\nfig, ax = plt.subplots()\nax.plot(friction_factor_radius, friction_factor_array)\nax.set_xscale(\"log\")\nax.set_yscale(\"log\")\nax.set_xlabel(\"Radius (m)\")\nax.set_ylabel(\"Friction Factor\")\nplt.show()\n</pre> # Printing the Maximum and Minimum Radii of the Particles print(\"Initial Max Diameter [mm]: \", radius_initial.max().item() * 2 * 1e3) print(     \"Initial Min Diameter [mm]: \",     radius_initial.min().item() *     2 *     1e3)  # Initializing the Range of Radii for Friction Factor Calculation # We use a linspace to cover a range from the smallest to 10 times the # largest radius. friction_factor_radius = torch.linspace(     start=radius.min(),     end=radius.max() * 10,     steps=1000, )  # Calculating the Friction Factor # This calculation considers the radius, temperature, and pressure to # determine the friction factor. friction_factor_array = particle_property.friction_factor_wrapper(     radius_meter=friction_factor_radius,     temperature_kelvin=system_temperature_kelvin,     pressure_pascal=system_pressure_pascal, )  # Plotting Friction Factor vs Radius # The plot helps in visualizing how friction factor varies with particle # radius. fig, ax = plt.subplots() ax.plot(friction_factor_radius, friction_factor_array) ax.set_xscale(\"log\") ax.set_yscale(\"log\") ax.set_xlabel(\"Radius (m)\") ax.set_ylabel(\"Friction Factor\") plt.show() <pre>Initial Max Diameter [mm]:  0.06673528696410358\nInitial Min Diameter [mm]:  0.03808399196714163\n</pre> In\u00a0[\u00a0]: Copied! <pre># Initialize Counter for Saving Data and Start Timer\nsave_counter = 0\nstart_time = time.time()\n\n# Initial Calculations Before Starting the Simulation Loop\nradius = particle_property.radius_calculation(mass=mass, density=density)\nfriction_factor_iter = particle_property.nearest_match(\n    x_values=friction_factor_radius,\n    y_values=friction_factor_array,\n    x_new=radius,\n)\n\n# regeneration of radius and velocity\nregen_radius = radius.clone()\nregen_velocity = velocity.clone()\nregen_mass = mass.clone()\nair_ones = torch.ones((3, TOTAL_NUMBER_OF_PARTICLES))\nair_velocity = air_ones*air_velocities[:, 0].unsqueeze(1)\n\n# Main Simulation Loop\nfor i in range(total_iterations):\n\n    # Coagulation Step (Optional, based on specified interval)\n    if i % interval_coagulation == 0:\n        # Update radius for collision detection\n        radius = particle_property.radius_calculation(\n            mass=mass, density=density)\n        # Detect potential collision pairs\n        valid_collision_indices_pairs = particle_pairs.full_sweep_and_prune(\n            position=position, radius=radius)\n\n        # Process collisions and update particle properties\n        if valid_collision_indices_pairs.shape[0] &gt; 0:\n            velocity, mass = collisions.coalescence(\n                position=position,\n                velocity=velocity,\n                mass=mass,\n                radius=radius,\n                collision_indices_pairs=valid_collision_indices_pairs)\n\n    if i % regnerate_interval == 0:\n        # regenerate for constant particle number\n        zero_mass_bool = mass == 0\n        radius[zero_mass_bool] = regen_radius[zero_mass_bool]\n        velocity[:, zero_mass_bool] = regen_velocity[:, zero_mass_bool]\n        mass[zero_mass_bool] = regen_mass[zero_mass_bool]\n\n    if i % tke_interval == 0:\n        # regenerate air velocity\n        air_velocity = air_ones*air_velocities[:, i//tke_interval].unsqueeze(1)\n\n    # Update Friction Factor (Optional, based on specified interval)\n    if i % interval_friction_factor == 0:\n        radius = particle_property.radius_calculation(\n            mass=mass, density=density)\n        friction_factor_iter = particle_property.nearest_match(\n            x_values=friction_factor_radius,\n            y_values=friction_factor_array,\n            x_new=radius,\n        )\n\n    # Calculate Forces (including updated friction factor)\n    force = mass * gravity + (air_velocity - velocity) * friction_factor_iter\n\n    # Integrate Equations of Motion (Leapfrog Method)\n    position, velocity = integration.leapfrog(\n        position=position, velocity=velocity, force=force, mass=mass, time_step=TIME_STEP)\n\n    # Apply Boundary Conditions (Cube Wrap-around)\n    position = boundary.wrapped_cube(position=position, cube_side=CUBE_SIDE)\n\n    # Save Data at Predefined Intervals\n    if i == save_iterations[save_counter]:\n        save_position[:, :, save_counter] = position.detach().numpy()\n        save_mass[:, save_counter] = mass.detach().numpy()\n        save_counter += 1\n        print(f\"Saving data at iteration {i} of {total_iterations}\")\n\n# Final Data Save and Calculation of Total Simulation Time\nsave_position[:, :, -1] = position.detach().numpy()\nsave_mass[:, -1] = mass.detach().numpy()\nend_time = time.time()\nprint(f\"Total wall time: {end_time - start_time} seconds\")\nprint(\n    f\"Ratio of wall time to simulation time: {(end_time - start_time) / SIMULATION_TIME}\")\n</pre> # Initialize Counter for Saving Data and Start Timer save_counter = 0 start_time = time.time()  # Initial Calculations Before Starting the Simulation Loop radius = particle_property.radius_calculation(mass=mass, density=density) friction_factor_iter = particle_property.nearest_match(     x_values=friction_factor_radius,     y_values=friction_factor_array,     x_new=radius, )  # regeneration of radius and velocity regen_radius = radius.clone() regen_velocity = velocity.clone() regen_mass = mass.clone() air_ones = torch.ones((3, TOTAL_NUMBER_OF_PARTICLES)) air_velocity = air_ones*air_velocities[:, 0].unsqueeze(1)  # Main Simulation Loop for i in range(total_iterations):      # Coagulation Step (Optional, based on specified interval)     if i % interval_coagulation == 0:         # Update radius for collision detection         radius = particle_property.radius_calculation(             mass=mass, density=density)         # Detect potential collision pairs         valid_collision_indices_pairs = particle_pairs.full_sweep_and_prune(             position=position, radius=radius)          # Process collisions and update particle properties         if valid_collision_indices_pairs.shape[0] &gt; 0:             velocity, mass = collisions.coalescence(                 position=position,                 velocity=velocity,                 mass=mass,                 radius=radius,                 collision_indices_pairs=valid_collision_indices_pairs)      if i % regnerate_interval == 0:         # regenerate for constant particle number         zero_mass_bool = mass == 0         radius[zero_mass_bool] = regen_radius[zero_mass_bool]         velocity[:, zero_mass_bool] = regen_velocity[:, zero_mass_bool]         mass[zero_mass_bool] = regen_mass[zero_mass_bool]      if i % tke_interval == 0:         # regenerate air velocity         air_velocity = air_ones*air_velocities[:, i//tke_interval].unsqueeze(1)      # Update Friction Factor (Optional, based on specified interval)     if i % interval_friction_factor == 0:         radius = particle_property.radius_calculation(             mass=mass, density=density)         friction_factor_iter = particle_property.nearest_match(             x_values=friction_factor_radius,             y_values=friction_factor_array,             x_new=radius,         )      # Calculate Forces (including updated friction factor)     force = mass * gravity + (air_velocity - velocity) * friction_factor_iter      # Integrate Equations of Motion (Leapfrog Method)     position, velocity = integration.leapfrog(         position=position, velocity=velocity, force=force, mass=mass, time_step=TIME_STEP)      # Apply Boundary Conditions (Cube Wrap-around)     position = boundary.wrapped_cube(position=position, cube_side=CUBE_SIDE)      # Save Data at Predefined Intervals     if i == save_iterations[save_counter]:         save_position[:, :, save_counter] = position.detach().numpy()         save_mass[:, save_counter] = mass.detach().numpy()         save_counter += 1         print(f\"Saving data at iteration {i} of {total_iterations}\")  # Final Data Save and Calculation of Total Simulation Time save_position[:, :, -1] = position.detach().numpy() save_mass[:, -1] = mass.detach().numpy() end_time = time.time() print(f\"Total wall time: {end_time - start_time} seconds\") print(     f\"Ratio of wall time to simulation time: {(end_time - start_time) / SIMULATION_TIME}\")   <pre>Saving data at iteration 0 of 8640000\nSaving data at iteration 72605 of 8640000\nSaving data at iteration 145210 of 8640000\nSaving data at iteration 217815 of 8640000\nSaving data at iteration 290420 of 8640000\nSaving data at iteration 363025 of 8640000\nSaving data at iteration 435630 of 8640000\nSaving data at iteration 508235 of 8640000\nSaving data at iteration 580840 of 8640000\nSaving data at iteration 653445 of 8640000\nSaving data at iteration 726050 of 8640000\nSaving data at iteration 798655 of 8640000\nSaving data at iteration 871260 of 8640000\nSaving data at iteration 943865 of 8640000\nSaving data at iteration 1016470 of 8640000\nSaving data at iteration 1089075 of 8640000\nSaving data at iteration 1161680 of 8640000\nSaving data at iteration 1234285 of 8640000\nSaving data at iteration 1306890 of 8640000\nSaving data at iteration 1379495 of 8640000\nSaving data at iteration 1452100 of 8640000\nSaving data at iteration 1524705 of 8640000\nSaving data at iteration 1597310 of 8640000\nSaving data at iteration 1669915 of 8640000\nSaving data at iteration 1742521 of 8640000\nSaving data at iteration 1815126 of 8640000\nSaving data at iteration 1887731 of 8640000\nSaving data at iteration 1960336 of 8640000\nSaving data at iteration 2032941 of 8640000\nSaving data at iteration 2105546 of 8640000\nSaving data at iteration 2178151 of 8640000\nSaving data at iteration 2250756 of 8640000\nSaving data at iteration 2323361 of 8640000\nSaving data at iteration 2395966 of 8640000\nSaving data at iteration 2468571 of 8640000\nSaving data at iteration 2541176 of 8640000\nSaving data at iteration 2613781 of 8640000\nSaving data at iteration 2686386 of 8640000\nSaving data at iteration 2758991 of 8640000\nSaving data at iteration 2831596 of 8640000\nSaving data at iteration 2904201 of 8640000\nSaving data at iteration 2976806 of 8640000\nSaving data at iteration 3049411 of 8640000\nSaving data at iteration 3122016 of 8640000\nSaving data at iteration 3194621 of 8640000\nSaving data at iteration 3267226 of 8640000\nSaving data at iteration 3339831 of 8640000\nSaving data at iteration 3412436 of 8640000\nSaving data at iteration 3485042 of 8640000\nSaving data at iteration 3557647 of 8640000\nSaving data at iteration 3630252 of 8640000\nSaving data at iteration 3702857 of 8640000\nSaving data at iteration 3775462 of 8640000\nSaving data at iteration 3848067 of 8640000\nSaving data at iteration 3920672 of 8640000\nSaving data at iteration 3993277 of 8640000\nSaving data at iteration 4065882 of 8640000\nSaving data at iteration 4138487 of 8640000\nSaving data at iteration 4211092 of 8640000\nSaving data at iteration 4283697 of 8640000\nSaving data at iteration 4356302 of 8640000\nSaving data at iteration 4428907 of 8640000\nSaving data at iteration 4501512 of 8640000\nSaving data at iteration 4574117 of 8640000\nSaving data at iteration 4646722 of 8640000\nSaving data at iteration 4719327 of 8640000\nSaving data at iteration 4791932 of 8640000\nSaving data at iteration 4864537 of 8640000\nSaving data at iteration 4937142 of 8640000\nSaving data at iteration 5009747 of 8640000\nSaving data at iteration 5082352 of 8640000\nSaving data at iteration 5154957 of 8640000\nSaving data at iteration 5227563 of 8640000\nSaving data at iteration 5300168 of 8640000\nSaving data at iteration 5372773 of 8640000\nSaving data at iteration 5445378 of 8640000\nSaving data at iteration 5517983 of 8640000\nSaving data at iteration 5590588 of 8640000\nSaving data at iteration 5663193 of 8640000\nSaving data at iteration 5735798 of 8640000\nSaving data at iteration 5808403 of 8640000\nSaving data at iteration 5881008 of 8640000\nSaving data at iteration 5953613 of 8640000\nSaving data at iteration 6026218 of 8640000\nSaving data at iteration 6098823 of 8640000\nSaving data at iteration 6171428 of 8640000\nSaving data at iteration 6244033 of 8640000\nSaving data at iteration 6316638 of 8640000\nSaving data at iteration 6389243 of 8640000\nSaving data at iteration 6461848 of 8640000\nSaving data at iteration 6534453 of 8640000\nSaving data at iteration 6607058 of 8640000\nSaving data at iteration 6679663 of 8640000\nSaving data at iteration 6752268 of 8640000\nSaving data at iteration 6824873 of 8640000\nSaving data at iteration 6897478 of 8640000\nSaving data at iteration 6970084 of 8640000\nSaving data at iteration 7042689 of 8640000\nSaving data at iteration 7115294 of 8640000\nSaving data at iteration 7187899 of 8640000\nSaving data at iteration 7260504 of 8640000\nSaving data at iteration 7333109 of 8640000\nSaving data at iteration 7405714 of 8640000\nSaving data at iteration 7478319 of 8640000\nSaving data at iteration 7550924 of 8640000\nSaving data at iteration 7623529 of 8640000\nSaving data at iteration 7696134 of 8640000\nSaving data at iteration 7768739 of 8640000\nSaving data at iteration 7841344 of 8640000\nSaving data at iteration 7913949 of 8640000\nSaving data at iteration 7986554 of 8640000\nSaving data at iteration 8059159 of 8640000\nSaving data at iteration 8131764 of 8640000\nSaving data at iteration 8204369 of 8640000\nSaving data at iteration 8276974 of 8640000\nSaving data at iteration 8349579 of 8640000\nSaving data at iteration 8422184 of 8640000\nSaving data at iteration 8494789 of 8640000\nSaving data at iteration 8567394 of 8640000\nTotal wall time: 3740.235196828842 seconds\nRatio of wall time to simulation time: 0.08657951844511208\n</pre> In\u00a0[\u00a0]: Copied! <pre># save data\nnp.savez_compressed(\n    \"data_tke.npz\",\n    position=save_position,\n    mass=save_mass,\n    iterations=save_iterations,\n    time_step=TIME_STEP,\n    total_iterations=total_iterations,\n    total_number_of_particles=TOTAL_NUMBER_OF_PARTICLES,\n    simulation_time=SIMULATION_TIME,\n    cube_side=CUBE_SIDE,\n    density_uniform=density_uniform,\n    mean_radius_nm=mean_radius_nm,\n    std_dev_nm=std_dev_nm,\n    system_temperature_kelvin=system_temperature_kelvin,\n    system_pressure_pascal=system_pressure_pascal,\n    interval_friction_factor=interval_friction_factor,\n    interval_coagulation=interval_coagulation,\n    seed=seed,\n    friction_factor_radius=friction_factor_radius,\n    friction_factor_array=friction_factor_array,\n)\n</pre> # save data np.savez_compressed(     \"data_tke.npz\",     position=save_position,     mass=save_mass,     iterations=save_iterations,     time_step=TIME_STEP,     total_iterations=total_iterations,     total_number_of_particles=TOTAL_NUMBER_OF_PARTICLES,     simulation_time=SIMULATION_TIME,     cube_side=CUBE_SIDE,     density_uniform=density_uniform,     mean_radius_nm=mean_radius_nm,     std_dev_nm=std_dev_nm,     system_temperature_kelvin=system_temperature_kelvin,     system_pressure_pascal=system_pressure_pascal,     interval_friction_factor=interval_friction_factor,     interval_coagulation=interval_coagulation,     seed=seed,     friction_factor_radius=friction_factor_radius,     friction_factor_array=friction_factor_array, ) In\u00a0[\u00a0]: Copied! <pre># Processing the Final Data for Visualization\n\n# Select the final time index for the data\ntime_index = -1\nposition_final = save_position[:, :, time_index]\nmass_final = save_mass[:, time_index]\n\n# Filter out particles with zero mass\nfilter_zero_mass = mass_final &gt; 0\n\n# Calculate the radius and area of each particle\nradius_final = particle_property.radius_calculation(mass=mass_final, density=density)\nparticle_area = np.pi * radius_final**2\n# normalize the area\nparticle_area = particle_area / particle_area.max()\n\n\n# Display the number of remaining particles\nprint(f\"Number of particles at the end: {filter_zero_mass.sum()}\")\n\n# Creating a 3D Plot for Visualization\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Choose a color map for the scatter plot\ncmap = plt.cm.viridis\n\n# Plot the final positions of particles with non-zero mass\nscatter_plot = ax.scatter(\n    position_final[0, filter_zero_mass],\n    position_final[1, filter_zero_mass],\n    position_final[2, filter_zero_mass],\n    c=mass_final[filter_zero_mass],\n    cmap=cmap,\n    s=particle_area[filter_zero_mass]*10 # scalled Particle size based on normalized area\n)\n\n# # Set axis limits based on cube dimensions\nax.set_xlim(-CUBE_SIDE / 2, CUBE_SIDE / 2)\nax.set_ylim(-CUBE_SIDE / 2, CUBE_SIDE / 2)\nax.set_zlim(-CUBE_SIDE / 2, CUBE_SIDE / 2)\n\n# Add a color bar indicating particle mass\ncolor_bar = plt.colorbar(scatter_plot, ax=ax)\ncolor_bar.set_label('Mass [kg]')\n\n# Show the plot with optimized layout\nplt.show()\nfig.tight_layout()\n</pre> # Processing the Final Data for Visualization  # Select the final time index for the data time_index = -1 position_final = save_position[:, :, time_index] mass_final = save_mass[:, time_index]  # Filter out particles with zero mass filter_zero_mass = mass_final &gt; 0  # Calculate the radius and area of each particle radius_final = particle_property.radius_calculation(mass=mass_final, density=density) particle_area = np.pi * radius_final**2 # normalize the area particle_area = particle_area / particle_area.max()   # Display the number of remaining particles print(f\"Number of particles at the end: {filter_zero_mass.sum()}\")  # Creating a 3D Plot for Visualization fig = plt.figure() ax = fig.add_subplot(projection='3d')  # Choose a color map for the scatter plot cmap = plt.cm.viridis  # Plot the final positions of particles with non-zero mass scatter_plot = ax.scatter(     position_final[0, filter_zero_mass],     position_final[1, filter_zero_mass],     position_final[2, filter_zero_mass],     c=mass_final[filter_zero_mass],     cmap=cmap,     s=particle_area[filter_zero_mass]*10 # scalled Particle size based on normalized area )  # # Set axis limits based on cube dimensions ax.set_xlim(-CUBE_SIDE / 2, CUBE_SIDE / 2) ax.set_ylim(-CUBE_SIDE / 2, CUBE_SIDE / 2) ax.set_zlim(-CUBE_SIDE / 2, CUBE_SIDE / 2)  # Add a color bar indicating particle mass color_bar = plt.colorbar(scatter_plot, ax=ax) color_bar.set_label('Mass [kg]')  # Show the plot with optimized layout plt.show() fig.tight_layout()  <pre>Number of particles at the end: 500\n</pre> In\u00a0[\u00a0]: Copied! <pre># Visualizing the Mass Distribution at Different Stages\n\n# plot initial radius distribution\nfig, ax = plt.subplots()\nax.hist(machine_limit.safe_log10(radius_initial), bins=20, range=(-5,-4), label=\"Initial\", alpha=0.25)\nax.hist(machine_limit.safe_log10(radius_final[filter_zero_mass]), bins=20, range=(-5,-4), label=\"Final\", alpha=0.5)\nax.set_yscale(\"log\")\nax.set_xlabel(\"log10 Radius (m)\")\nax.set_ylabel(\"Number of Particles\")\nax.set_title(\"Initial Particle Radius Distribution\")\nax.legend()\nplt.show()\n\nprint(\"Initial Max Diameter [mm]: \", radius_initial.max().item()*2*1e3)\nprint(\"Final Max Diameter [mm]: \", radius_final[filter_zero_mass].max().item()*2*1e3)\n</pre> # Visualizing the Mass Distribution at Different Stages  # plot initial radius distribution fig, ax = plt.subplots() ax.hist(machine_limit.safe_log10(radius_initial), bins=20, range=(-5,-4), label=\"Initial\", alpha=0.25) ax.hist(machine_limit.safe_log10(radius_final[filter_zero_mass]), bins=20, range=(-5,-4), label=\"Final\", alpha=0.5) ax.set_yscale(\"log\") ax.set_xlabel(\"log10 Radius (m)\") ax.set_ylabel(\"Number of Particles\") ax.set_title(\"Initial Particle Radius Distribution\") ax.legend() plt.show()  print(\"Initial Max Diameter [mm]: \", radius_initial.max().item()*2*1e3) print(\"Final Max Diameter [mm]: \", radius_final[filter_zero_mass].max().item()*2*1e3) <pre>Initial Max Diameter [mm]:  0.06673528696410358\nFinal Max Diameter [mm]:  0.3941673396242591\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"How-To-Guides/Lagrangian/notebooks/turbulence_drops/#realistic-drag-mass-and-velocity","title":"Realistic Drag, Mass, and Velocity\u00b6","text":"<p>Example Broken</p> <p>This notebook section focuses on simulating cloud droplet-sized aerosol particles (around 100 microns) with accurate mass and velocity. Key improvements include:</p> <ol> <li>Refining Initial Conditions: Setting precise starting values for particle mass and velocity.</li> <li>Modeling Forces Accurately: Better representation of forces acting on particles to influence their movement.</li> </ol> <p>These steps are crucial for enhancing the realism of the aerosol particle model.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/turbulence_drops/#initialization-of-particles","title":"Initialization of Particles\u00b6","text":"<p>In this section, we'll enhance particle initialization for realism:</p> <ul> <li>Particle Masses: Implementing a narrow log-normal distribution to better represent real-world mass variation.</li> <li>Particle Velocities: Utilizing thermal velocity, influenced by Brownian motion, for initial velocity settings.</li> <li>Initial Positions: Particles will be randomly placed within a defined box area to simulate natural distribution.</li> </ul>"},{"location":"How-To-Guides/Lagrangian/notebooks/turbulence_drops/#plotting-initial-conditions","title":"Plotting Initial Conditions\u00b6","text":"<p>To verify the realism of our particle model, we'll plot the initial distributions of particle size and velocity. This step ensures that the initial setup aligns with our expectations and the intended simulation parameters.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/turbulence_drops/#particle-size-distribution","title":"Particle Size Distribution\u00b6","text":"<p>First, we examine the distribution of particle radii. The goal is to confirm that the radii follow the specified log-normal distribution.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/turbulence_drops/#particle-velocity-distribution","title":"Particle Velocity Distribution\u00b6","text":"<p>Next, we assess the distribution of particle velocities. This is crucial for ensuring that the initial velocities reflect thermal motion as intended.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/turbulence_drops/#running-the-particle-simulation","title":"Running the Particle Simulation\u00b6","text":"<p>In this part of the notebook, we execute the core simulation loop. This involves integrating the motion of the particles over time while considering the forces acting on them, including friction and gravity. Several key updates and optimizations are included:</p> <ol> <li><p>Friction Factor Initialization: Before entering the main loop, the friction factor for each particle is calculated. This is an essential step for accurately simulating the drag force on particles.</p> </li> <li><p>Conditional Coagulation Step: The simulation includes an optional coagulation step, executed at a specified interval. This step simulates the merging of particles upon collision, affecting their mass and velocity.</p> </li> <li><p>Friction Factor Update: The friction factor is updated at regular intervals to reflect changes in particle size or other environmental conditions. This step ensures that the drag force remains accurate throughout the simulation.</p> </li> <li><p>Force Calculation and Integration: Within each iteration, we calculate the forces acting on the particles and update their positions and velocities using the leapfrog integration method.</p> </li> <li><p>Boundary Conditions and Data Saving: The simulation includes boundary conditions to mimic a wrapped cube environment. Additionally, particle position and mass data are saved at predefined intervals for analysis.</p> </li> </ol> <p>This simulation loop provides a comprehensive and dynamic model of particle motion, taking into account physical factors and interactions.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/turbulence_drops/#plotting-particle-positions","title":"Plotting Particle Positions\u00b6","text":"<p>After running the simulation, we'll plot the particle positions to visualize their movement.</p>"},{"location":"How-To-Guides/Lagrangian/notebooks/turbulence_drops/#size-distribution-of-particles","title":"Size Distribution of Particles\u00b6","text":"<p>Given particle collision and coagulation, we'll plot the distribution of particle sizes at the end of the simulation. This step ensures that the particle size distribution aligns with our expectations and the intended simulation parameters. That being, both a decrease in the number of particles and an increase in the average particle size.</p>"},{"location":"How-To-Guides/Light_Scattering/","title":"Index: Light Scattering BETA","text":"<p>Aerosol optics examines the interaction between light and aerosol particles suspended in the atmosphere. These interactions, encompassing absorption, scattering, and the emission of light, are pivotal in deciphering the physical properties of aerosols and their environmental ramifications.</p>"},{"location":"How-To-Guides/Light_Scattering/#notebooks","title":"Notebooks","text":"<ul> <li>Mie Scattering Basics</li> <li>Humidified Particle Scattering</li> <li>Kappa-HGF Estimation from Light Extinction</li> <li>Correcting for Scattering Truncation</li> </ul>"},{"location":"How-To-Guides/Light_Scattering/#mie-scattering-theory","title":"Mie Scattering Theory","text":"<p>Central to aerosol optics is Mie scattering theory, formulated by Gustav Mie in 1908. This foundational theory enables the precise calculation of light scattering and absorption by spherical particles, taking into account their size, material composition, and the incident light's wavelength. In this context, we leverage the capabilities of pyMieScatt, a comprehensive Python library designed to facilitate Mie scattering computations.</p>"},{"location":"How-To-Guides/Light_Scattering/#fundamental-concepts","title":"Fundamental Concepts","text":"<ul> <li>Scattering Efficiency: Quantifies the efficacy of particles in deflecting light in various directions.</li> <li>Absorption Efficiency: Assesses the extent to which particles absorb incident light.</li> <li>Single Scattering Albedo (SSA): This ratio of scattering to total light extinction (scattering plus absorption) provides insight into whether particles are more likely to scatter light rather than absorb it.</li> </ul>"},{"location":"How-To-Guides/Light_Scattering/#understanding-particle-distributions","title":"Understanding Particle Distributions","text":"<p>Aerosol particles exhibit a vast diversity in terms of size, shape, and chemical composition, making the study of their distributions crucial for accurate optical modeling.</p>"},{"location":"How-To-Guides/Light_Scattering/#types-of-distributions","title":"Types of Distributions","text":"<ul> <li>Monodisperse: A scenario where all particles are of identical size.</li> <li>Polydisperse: Represents a realistic distribution where particles vary in size, often characterized by statistical distribution models, such as the log-normal distribution.</li> </ul>"},{"location":"How-To-Guides/Light_Scattering/#addressing-truncation-errors-in-measurements","title":"Addressing Truncation Errors in Measurements","text":"<p>Measurements of aerosol optical properties can be compromised by truncation errors, stemming from the inability of instruments to capture the complete angular range of scattered light.</p>"},{"location":"How-To-Guides/Light_Scattering/#consequences-and-mitigation-strategies","title":"Consequences and Mitigation Strategies","text":"<ul> <li>Scattering Coefficient Underestimation: The restricted detection of scattered light may lead to inaccuracies in determining aerosol optical depth (AOD) and other key optical properties.</li> <li>Correction Techniques: A variety of correction methods, including analytical adjustments and empirical calibration, are employed to counteract truncation errors and refine the accuracy of aerosol optical measurements.</li> </ul>"},{"location":"How-To-Guides/Light_Scattering/#overview","title":"Overview","text":"<p>This series offers a detailed exploration of aerosol optical phenomena through the lens of Mie scattering theory, analysis of particle size distributions, and methodologies for correcting truncation errors in aerosol instrumentation. By enhancing our understanding of these areas, we aim to further our knowledge of aerosol behavior and its environmental impact.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/humid_scattering/","title":"Scattering for Humidified Particles","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# particula imports\nfrom particula.util import convert, distribution_discretization\nfrom particula.data.process import mie_bulk\n</pre> import numpy as np import matplotlib.pyplot as plt  # particula imports from particula.util import convert, distribution_discretization from particula.data.process import mie_bulk In\u00a0[2]: Copied! <pre># Define the range and resolution of particle diameters (in nanometers)\ndiameters = np.linspace(20, 1000, 500)  # From 20 nm to 1000 nm with 500 points\n\n# Standard deviation of the log-normal distribution (dimensionless)\nsigma = 1.25\n\n# Define the modes (peak diameters) for a bimodal distribution\nmodes = [100, 500]\n\n# Total number of particles in the distribution\nnumber_total = 1e3\n\n# Generate a log-normal probability density function (pdf) with an area equal to 1\npdf_dist = distribution_discretization.discretize(\n    interval=diameters,  # Array of diameters over which to compute the distribution\n    disttype=\"lognormal\",  # Type of distribution\n    gsigma=sigma,  # Geometric standard deviation\n    mode=modes,  # Modes of the distribution\n    nparticles=number_total  # Total number of particles\n).m\n\n# Convert the distribution from pdf to probability mass function (pmf)\nnumber_conc_pms = convert.distribution_convert_pdf_pms(\n    x_array=diameters,  # Array of diameters\n    distribution=pdf_dist,  # The generated pdf\n    to_pdf=False  # Specifies the conversion to pmf\n) * number_total  # Scale to the total number of particles\n\n# Check the total number of particles are equal to the specified number\nprint(f\"Total number of particles: {np.sum(number_conc_pms)}\")\n\n# Visualization\nfig, ax = plt.subplots()\nax.plot(diameters, number_conc_pms, label=\"Base Distribution\")\nax.set_xscale(\"log\")  # Logarithmic scale for diameters\nax.set_xlabel(\"Diameter (nm)\")  # X-axis label\nax.set_ylabel(\"Number concentration (#/cm^3)\")  # Y-axis label\nax.legend()  # Show legend\nplt.show()  # Display the plot\n</pre> # Define the range and resolution of particle diameters (in nanometers) diameters = np.linspace(20, 1000, 500)  # From 20 nm to 1000 nm with 500 points  # Standard deviation of the log-normal distribution (dimensionless) sigma = 1.25  # Define the modes (peak diameters) for a bimodal distribution modes = [100, 500]  # Total number of particles in the distribution number_total = 1e3  # Generate a log-normal probability density function (pdf) with an area equal to 1 pdf_dist = distribution_discretization.discretize(     interval=diameters,  # Array of diameters over which to compute the distribution     disttype=\"lognormal\",  # Type of distribution     gsigma=sigma,  # Geometric standard deviation     mode=modes,  # Modes of the distribution     nparticles=number_total  # Total number of particles ).m  # Convert the distribution from pdf to probability mass function (pmf) number_conc_pms = convert.distribution_convert_pdf_pms(     x_array=diameters,  # Array of diameters     distribution=pdf_dist,  # The generated pdf     to_pdf=False  # Specifies the conversion to pmf ) * number_total  # Scale to the total number of particles  # Check the total number of particles are equal to the specified number print(f\"Total number of particles: {np.sum(number_conc_pms)}\")  # Visualization fig, ax = plt.subplots() ax.plot(diameters, number_conc_pms, label=\"Base Distribution\") ax.set_xscale(\"log\")  # Logarithmic scale for diameters ax.set_xlabel(\"Diameter (nm)\")  # X-axis label ax.set_ylabel(\"Number concentration (#/cm^3)\")  # Y-axis label ax.legend()  # Show legend plt.show()  # Display the plot  <pre>Total number of particles: 999.533377633679\n</pre> In\u00a0[3]: Copied! <pre># Hygroscopic growth parameters\nkappa = 0.61  # Kappa value for ammonium sulfate\nwater_activity_low = 0.3  # Low water activity (30% RH)\nwater_activity_mid = 0.6  # Mid water activity (60% RH)\nwater_activity_high = 0.9  # High water activity (90% RH)\n\n# Convert particle diameters from the base distribution to volumes\nvolume_sizer = convert.length_to_volume(diameters, length_type='diameter')\n\n# Calculate water volume absorbed by particles at different RH\nvolume_water_low = convert.kappa_volume_water(\n    volume_solute=volume_sizer,\n    kappa=kappa,\n    water_activity=water_activity_low)  # showing the input parameters\nvolume_water_mid = convert.kappa_volume_water(\n    volume_sizer, kappa, water_activity_mid)\nvolume_water_high = convert.kappa_volume_water(\n    volume_sizer, kappa, water_activity_high)\n\n# Calculate new particle diameters after hygroscopic growth\ndiameters_low = convert.volume_to_length(\n    volume=volume_sizer + volume_water_low,\n    length_type='diameter')  # showing the input parameters\ndiameters_mid = convert.volume_to_length(\n    volume_sizer + volume_water_mid, 'diameter')\ndiameters_high = convert.volume_to_length(\n    volume_sizer + volume_water_high, 'diameter')\n\n# Plotting the base and grown size distributions\nfig, ax = plt.subplots()\nax.plot(diameters, number_conc_pms, label=\"Base Distribution\")\nax.plot(\n    diameters_low,\n    number_conc_pms,\n    label=f\"Low Water Activity: {water_activity_low*100}% RH\")\nax.plot(\n    diameters_mid,\n    number_conc_pms,\n    label=f\"Mid Water Activity: {water_activity_mid*100}% RH\")\nax.plot(\n    diameters_high,\n    number_conc_pms,\n    label=f\"High Water Activity: {water_activity_high*100}% RH\")\nax.set_xscale(\"log\")\nax.set_xlabel(\"Diameter (nm)\")\nax.set_ylabel(\"Number concentration (#/cm^3)\")\nax.legend(loc=\"upper right\")\nplt.show()\n</pre> # Hygroscopic growth parameters kappa = 0.61  # Kappa value for ammonium sulfate water_activity_low = 0.3  # Low water activity (30% RH) water_activity_mid = 0.6  # Mid water activity (60% RH) water_activity_high = 0.9  # High water activity (90% RH)  # Convert particle diameters from the base distribution to volumes volume_sizer = convert.length_to_volume(diameters, length_type='diameter')  # Calculate water volume absorbed by particles at different RH volume_water_low = convert.kappa_volume_water(     volume_solute=volume_sizer,     kappa=kappa,     water_activity=water_activity_low)  # showing the input parameters volume_water_mid = convert.kappa_volume_water(     volume_sizer, kappa, water_activity_mid) volume_water_high = convert.kappa_volume_water(     volume_sizer, kappa, water_activity_high)  # Calculate new particle diameters after hygroscopic growth diameters_low = convert.volume_to_length(     volume=volume_sizer + volume_water_low,     length_type='diameter')  # showing the input parameters diameters_mid = convert.volume_to_length(     volume_sizer + volume_water_mid, 'diameter') diameters_high = convert.volume_to_length(     volume_sizer + volume_water_high, 'diameter')  # Plotting the base and grown size distributions fig, ax = plt.subplots() ax.plot(diameters, number_conc_pms, label=\"Base Distribution\") ax.plot(     diameters_low,     number_conc_pms,     label=f\"Low Water Activity: {water_activity_low*100}% RH\") ax.plot(     diameters_mid,     number_conc_pms,     label=f\"Mid Water Activity: {water_activity_mid*100}% RH\") ax.plot(     diameters_high,     number_conc_pms,     label=f\"High Water Activity: {water_activity_high*100}% RH\") ax.set_xscale(\"log\") ax.set_xlabel(\"Diameter (nm)\") ax.set_ylabel(\"Number concentration (#/cm^3)\") ax.legend(loc=\"upper right\") plt.show() In\u00a0[4]: Copied! <pre># Define the refractive index of dry particle material and water\nrefractive_index_dry = 1.5 + 0.5j  # Dimensionless\nrefractive_index_water = 1.33  # Dimensionless\n\n# Calculate effective refractive indices for each water activity level,\n# utilizing the volumes of each component\nn_effective_low = convert.effective_refractive_index(\n    m_zero=refractive_index_dry,\n    m_one=refractive_index_water,\n    volume_zero=volume_sizer[-1],\n    volume_one=volume_water_low[-1]\n)\nn_effective_mid = convert.effective_refractive_index(\n    m_zero=refractive_index_dry,\n    m_one=refractive_index_water,\n    volume_zero=volume_sizer[-1],\n    volume_one=volume_water_mid[-1]\n)\nn_effective_high = convert.effective_refractive_index(\n    m_zero=refractive_index_dry,\n    m_one=refractive_index_water,\n    volume_zero=volume_sizer[-1],\n    volume_one=volume_water_high[-1]\n)\n\n# Output the effective refractive indices\nprint(f\"Effective Refractive Index at Low Water Activity: {n_effective_low}\")\nprint(f\"Effective Refractive Index at Mid Water Activity: {n_effective_mid}\")\nprint(f\"Effective Refractive Index at High Water Activity: {n_effective_high}\")\n</pre> # Define the refractive index of dry particle material and water refractive_index_dry = 1.5 + 0.5j  # Dimensionless refractive_index_water = 1.33  # Dimensionless  # Calculate effective refractive indices for each water activity level, # utilizing the volumes of each component n_effective_low = convert.effective_refractive_index(     m_zero=refractive_index_dry,     m_one=refractive_index_water,     volume_zero=volume_sizer[-1],     volume_one=volume_water_low[-1] ) n_effective_mid = convert.effective_refractive_index(     m_zero=refractive_index_dry,     m_one=refractive_index_water,     volume_zero=volume_sizer[-1],     volume_one=volume_water_mid[-1] ) n_effective_high = convert.effective_refractive_index(     m_zero=refractive_index_dry,     m_one=refractive_index_water,     volume_zero=volume_sizer[-1],     volume_one=volume_water_high[-1] )  # Output the effective refractive indices print(f\"Effective Refractive Index at Low Water Activity: {n_effective_low}\") print(f\"Effective Refractive Index at Mid Water Activity: {n_effective_mid}\") print(f\"Effective Refractive Index at High Water Activity: {n_effective_high}\") <pre>Effective Refractive Index at Low Water Activity: (1.475296758061568+0.3877520937699365j)\nEffective Refractive Index at Mid Water Activity: (1.4339992549471252+0.24759591899911076j)\nEffective Refractive Index at High Water Activity: (1.363603614921365+0.06976083730498348j)\n</pre> In\u00a0[5]: Copied! <pre># Define the wavelength of incident light in nanometers\nwavelength = 550\n\n# Calculate optical properties for dry and humidified particles\noptics_dry = mie_bulk.mie_size_distribution(\n    m_sphere=refractive_index_dry,\n    wavelength=wavelength,\n    diameter=diameters,\n    number_per_cm3=number_conc_pms,\n    pms=True,\n    discretize=False\n)\n\noptics_low = mie_bulk.mie_size_distribution(\n    m_sphere=n_effective_low,\n    wavelength=wavelength,\n    diameter=diameters_low,\n    number_per_cm3=number_conc_pms,\n    pms=True,\n    discretize=False\n)\n\noptics_mid = mie_bulk.mie_size_distribution(\n    m_sphere=n_effective_mid,\n    wavelength=wavelength,\n    diameter=diameters_mid,\n    number_per_cm3=number_conc_pms,\n    pms=True,\n    discretize=False\n)\n\noptics_high = mie_bulk.mie_size_distribution(\n    m_sphere=n_effective_high,\n    wavelength=wavelength,\n    diameter=diameters_high,\n    number_per_cm3=number_conc_pms,\n    pms=True,\n    discretize=False\n)\n\n# Combine the results for visualization\ncombined_optics = np.vstack((optics_dry, optics_low, optics_mid, optics_high))\nwater_activity_series = [0, water_activity_low, water_activity_mid, water_activity_high]\n\n# Visualization of optical properties across different humidity levels\nfig, ax = plt.subplots()\nax.plot(water_activity_series, combined_optics[:, 0], label=\"Extinction\")\nax.plot(water_activity_series, combined_optics[:, 1], label=\"Scattering\")\nax.plot(water_activity_series, combined_optics[:, 2], label=\"Absorption\")\nax.set_xlabel(\"Water Activity\")\nax.set_ylabel(\"Coefficient (1/Mm)\")\nax.legend()\nplt.show()\n</pre> # Define the wavelength of incident light in nanometers wavelength = 550  # Calculate optical properties for dry and humidified particles optics_dry = mie_bulk.mie_size_distribution(     m_sphere=refractive_index_dry,     wavelength=wavelength,     diameter=diameters,     number_per_cm3=number_conc_pms,     pms=True,     discretize=False )  optics_low = mie_bulk.mie_size_distribution(     m_sphere=n_effective_low,     wavelength=wavelength,     diameter=diameters_low,     number_per_cm3=number_conc_pms,     pms=True,     discretize=False )  optics_mid = mie_bulk.mie_size_distribution(     m_sphere=n_effective_mid,     wavelength=wavelength,     diameter=diameters_mid,     number_per_cm3=number_conc_pms,     pms=True,     discretize=False )  optics_high = mie_bulk.mie_size_distribution(     m_sphere=n_effective_high,     wavelength=wavelength,     diameter=diameters_high,     number_per_cm3=number_conc_pms,     pms=True,     discretize=False )  # Combine the results for visualization combined_optics = np.vstack((optics_dry, optics_low, optics_mid, optics_high)) water_activity_series = [0, water_activity_low, water_activity_mid, water_activity_high]  # Visualization of optical properties across different humidity levels fig, ax = plt.subplots() ax.plot(water_activity_series, combined_optics[:, 0], label=\"Extinction\") ax.plot(water_activity_series, combined_optics[:, 1], label=\"Scattering\") ax.plot(water_activity_series, combined_optics[:, 2], label=\"Absorption\") ax.set_xlabel(\"Water Activity\") ax.set_ylabel(\"Coefficient (1/Mm)\") ax.legend() plt.show() In\u00a0[6]: Copied! <pre>help(convert.kappa_volume_water)\n</pre> help(convert.kappa_volume_water) <pre>Help on function kappa_volume_water in module particula.util.convert:\n\nkappa_volume_water(volume_solute: Union[float, numpy.ndarray[Any, numpy.dtype[numpy.float64]]], kappa: Union[float, numpy.ndarray[Any, numpy.dtype[numpy.float64]]], water_activity: Union[float, numpy.ndarray[Any, numpy.dtype[numpy.float64]]]) -&gt; Union[float, numpy.ndarray[Any, numpy.dtype[numpy.float64]]]\n    Calculate the volume of water given volume of solute, kappa parameter,\n    and water activity.\n    \n    Args:\n    -----------\n        volume_solute: The volume of solute.\n        kappa: The kappa parameter.\n        water_activity: The water activity.\n    \n    Returns:\n    --------\n        The volume of water as a float.\n\n</pre> In\u00a0[7]: Copied! <pre>help(convert.effective_refractive_index)\n</pre> help(convert.effective_refractive_index) <pre>Help on function effective_refractive_index in module particula.util.convert:\n\neffective_refractive_index(m_zero: Union[float, complex], m_one: Union[float, complex], volume_zero: float, volume_one: float) -&gt; Union[float, complex]\n    Calculate the effective refractive index of a mixture of two solutes, given\n    the refractive index of each solute and the volume of each solute. The\n    mixing is based on volume-weighted molar refraction.\n    \n    Args:\n    -----------\n        m_zero (float or complex): The refractive index of solute 0.\n        m_one (float or complex): The refractive index of solute 1.\n        volume_zero (float): The volume of solute 0.\n        volume_one (float): The volume of solute 1.\n    \n    Returns:\n    -----------\n        The effective refractive index of the mixture.\n    \n    Reference:\n    -----------\n        Liu, Y., &amp;#38; Daum, P. H. (2008).\n        Relationship of refractive index to mass density and self-consistency\n        mixing rules for multicomponent mixtures like ambient aerosols.\n        Journal of Aerosol Science, 39(11), 974-986.\n        https://doi.org/10.1016/j.jaerosci.2008.06.006\n\n</pre>"},{"location":"How-To-Guides/Light_Scattering/notebooks/humid_scattering/#scattering-for-humidified-particles","title":"Scattering for Humidified Particles\u00b6","text":"<p>In atmospheric conditions, aerosol particles frequently undergo hygroscopic growth, absorbing moisture from the air which leads to an increase in their size. This process of water uptake markedly influences the optical properties of aerosols, affecting how they scatter and absorb light. These changes are crucial, as they directly impact climate and visibility, playing a significant role in atmospheric processes such as radiation balance and cloud formation.</p> <p>A thorough understanding of Mie scattering parameters for both dry and humidified (or growing) particles provides essential insights into aerosol behavior under varied humidity conditions. By accurately modeling these changes in light scattering and absorption as particles absorb water, we can enhance our predictions regarding aerosols' effects on the atmosphere.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/humid_scattering/#imports","title":"Imports\u00b6","text":"<p>To proceed with our analysis, we'll start by importing necessary libraries and modules.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/humid_scattering/#base-distribution","title":"Base Distribution\u00b6","text":"<p>This section demonstrates how to create a bimodal log-normal distribution and visualize the number concentration of particles across different diameters.</p> <p>This code snippet generates a bimodal log-normal distribution characterized by specific modes and a standard deviation. The distribution is then scaled to represent the total number of particles, and the resulting number concentration across diameters is visualized using a logarithmic scale. This approach is particularly useful for simulating aerosol size distributions in atmospheric science, enabling researchers to study particle dynamics and interactions based on their size distribution.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/humid_scattering/#hygroscopic-growth-in-aerosol-particles","title":"Hygroscopic Growth in Aerosol Particles\u00b6","text":"<p>Aerosol particles in the atmosphere can absorb water, leading to an increase in their size\u2014a process known as hygroscopic growth. This phenomenon is crucial for studying the optical properties and scattering behavior of aerosols because the particle size directly influences how light interacts with these particles.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/humid_scattering/#key-parameters-for-hygroscopic-growth","title":"Key Parameters for Hygroscopic Growth:\u00b6","text":"<ul> <li>Dry Diameter: The original size of the particles before absorbing water.</li> <li>Water Activity: Defined as the relative humidity divided by 100. It is a measure of the moisture content in the air surrounding the particles.</li> <li>Kappa Parameter: A value that represents the hygroscopicity of the particles, influencing how much water they can absorb under different humidity conditions. The kappa parameter (\u03ba) is used in the kappa-Hygroscopic Growth Factor (HGF) parameterization to model particle growth.</li> </ul> <p>For our analysis, we'll assume a kappa value of 0.61, indicative of ammonium sulfate, a common compound found in atmospheric aerosols. We will explore particle growth at three different water activities (relative humidity levels): 30%, 60%, and 90%.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/humid_scattering/#calculating-and-visualizing-hygroscopic-growth","title":"Calculating and Visualizing Hygroscopic Growth\u00b6","text":"<p>The following Python code calculates the change in particle diameters due to hygroscopic growth at low, mid, and high water activity levels and visualizes the base size distribution alongside the grown distributions.</p> <p>This code section demonstrates how aerosol particles grow in size with increasing humidity, visualized through the changes in their size distribution. Understanding these dynamics is vital for accurately assessing aerosols' environmental and climatic effects.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/humid_scattering/#refractive-index-mixing-rule","title":"Refractive Index Mixing Rule\u00b6","text":"<p>Upon determining the sizes of both wet and dry particles, we proceed to calculate the refractive index for these humidified particles. This calculation employs the Lorentz-Lorenz mixing rule, a straightforward approximation for the refractive index of a mixture comprising two substances. The mixing rule, as detailed by Liu &amp; Daum (2008), underpins the implementation in the <code>convert.effective_refractive_index</code> module, facilitating the computation of the humidified particle's refractive index.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/humid_scattering/#effective-refractive-index-calculation","title":"Effective Refractive Index Calculation\u00b6","text":"<p>The effective refractive index $n_{\\text{effective}}$ for a binary mixture can be derived using molar refraction mixing, as described in the referenced study. The formula is based on the volumes and refractive indices of the individual components:</p> <p>$$ r_{\\text{effective}} = \\frac{V_0}{V_{\\text{total}}} \\cdot \\frac{m_0 - 1}{m_0 + 2} + \\frac{V_1}{V_{\\text{total}}} \\cdot \\frac{m_1 - 1}{m_1 + 2} $$</p> <p>Where:</p> <ul> <li>$V_0$ and $V_1$ are the volumes of components 0 and 1, respectively.</li> <li>$V_{\\text{total}} = V_0 + V_1$ is the total volume.</li> <li>$m_0$ and $m_1$ are the refractive indices of components 0 and 1, respectively.</li> <li>$r_{\\text{effective}}$ is the effective specific refraction.</li> </ul> <p>The effective refractive index is then calculated from $r_{\\text{effective}}$ as follows:</p> <p>$$ n_{\\text{effective}} = \\frac{2R_{\\text{effective}} + 1}{1 - R_{\\text{effective}}} $$</p> <p>This equation allows for the calculation of the effective refractive index of the mixture, accounting for the volumetric contributions and specific refraction of each component.</p> <p>Reference Liu, Y., &amp; Daum, P. H. (2008). Relationship of refractive index to mass density and self-consistency mixing rules for multicomponent mixtures like ambient aerosols. Journal of Aerosol Science, 39(11), 974-986. https://doi.org/10.1016/j.jaerosci.2008.06.006</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/humid_scattering/#calculating-optical-properties-of-humidified-particles","title":"Calculating Optical Properties of Humidified Particles\u00b6","text":"<p>With the sizes and refractive indices of both dry and humidified particles determined, we now turn our attention to calculating their optical properties, including scattering and absorption. These properties are crucial for understanding the particles' behavior in the atmosphere and their potential climate impacts. We leverage the <code>mie_bulk.mie_size_distribution</code> function to compute these properties across different humidity conditions.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/humid_scattering/#implementation-details","title":"Implementation Details\u00b6","text":"<p>The Python code below demonstrates how to calculate the optical properties for particles at varying levels of humidity using Mie scattering theory. These calculations provide insights into how hygroscopic growth affects the particles' ability to scatter and absorb light.</p> <p>This segment calculates and then plots the extinction, scattering, and absorption coefficients for particles at different levels of hygroscopic growth. The <code>water_activity_series</code> corresponds to the range of humidity conditions under consideration, providing a clear visual representation of how water uptake influences the optical properties of aerosol particles.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/humid_scattering/#summary","title":"Summary\u00b6","text":"<p>In this notebook, we delved into the phenomenon of hygroscopic growth of aerosol particles and investigated its consequential effects on their optical characteristics. We started with the construction of a bimodal log-normal distribution, aimed at depicting the number concentration of aerosol particles across a spectrum of diameters. This foundational step allowed us to simulate the real-world complexity of aerosol size distributions.</p> <p>Moving forward, we calculated the hygroscopic growth of these particles under different humidity conditions, employing varying water activities to simulate environmental changes. Through visualization, we effectively illustrated the shifts in particle size distribution resulting from this growth, providing a clear depiction of how particles expand as they absorb moisture.</p> <p>In our subsequent analysis, we determined the refractive index of the humidified particles. This was achieved by applying the Lorentz-Lorenz mixing rule, a theoretical framework that facilitated the computation of the effective refractive index of the particles post-hydration.</p> <p>Our exploration ended in the calculation of the optical properties of aerosol particles across different levels of humidity. By doing so, we unveiled the ways in which hygroscopic growth influences the scattering and absorption behaviors of particles. The insights garnered from this analysis are instrumental in comprehending the broader implications of particle growth on atmospheric optics and climate dynamics.</p> <p>As we proceed, our focus will shift towards finding the kappa parameter based on empirical measurements of particle sizes and extinction coefficients. This reverse engineering process is a common challenge in atmospheric science, offering a deeper understanding of aerosol properties through observational data. Our exploration into this inverse problem marks the next step in bridging theoretical models with practical atmospheric measurements, enhancing our ability to interpret and predict aerosol behavior in the Earth's atmosphere.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/kappa_vs_extinction/","title":"Fitting Kappa-HGF from Light Extinction","text":"In\u00a0[2]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# particula imports\nfrom particula.util import convert, distribution_discretization\nfrom particula.data.process import kappa_via_extinction\n</pre> import numpy as np import matplotlib.pyplot as plt  # particula imports from particula.util import convert, distribution_discretization from particula.data.process import kappa_via_extinction In\u00a0[3]: Copied! <pre># Hygroscopic growth parameters\nkappa = 0.61  # Kappa value for ammonium sulfate\nwater_activity_low = 0.3  # Low water activity (30% RH)\nwater_activity_mid = 0.6  # Mid water activity (60% RH)\nwater_activity_high = 0.9  # High water activity (90% RH)\n\n# Define the range and resolution of particle diameters (in nanometers)\ndiameters = np.linspace(20, 1000, 500)  # From 20 nm to 1000 nm with 500 points\n\n# Standard deviation of the log-normal distribution (dimensionless)\nsigma = 1.25\n\n# Define the modes (peak diameters) for a bimodal distribution\nmodes = [100, 500]\n\n# Total number of particles in the distribution\nnumber_total = 1e3\n\n# Generate a log-normal probability density function (pdf) with an area\n# equal to 1\npdf_dist = distribution_discretization.discretize(\n    interval=diameters,  # Array of diameters over which to compute the distribution\n    disttype=\"lognormal\",  # Type of distribution\n    gsigma=sigma,  # Geometric standard deviation\n    mode=modes,  # Modes of the distribution\n    nparticles=number_total  # Total number of particles\n).m\n\n# Convert the distribution from pdf to probability mass function (pmf)\nnumber_conc_pms = convert.distribution_convert_pdf_pms(\n    x_array=diameters,  # Array of diameters\n    distribution=pdf_dist,  # The generated pdf\n    to_pdf=False  # Specifies the conversion to pmf\n) * number_total  # Scale to the total number of particles\n\n\n# Convert particle diameters from the base distribution to volumes\nvolume_sizer = convert.length_to_volume(diameters, length_type='diameter')\n\n# Calculate water volume absorbed by particles at different RH\nvolume_water_low = convert.kappa_volume_water(\n    volume_solute=volume_sizer,\n    kappa=kappa,\n    water_activity=water_activity_low)  # showing the input parameters\nvolume_water_mid = convert.kappa_volume_water(\n    volume_sizer, kappa, water_activity_mid)\nvolume_water_high = convert.kappa_volume_water(\n    volume_sizer, kappa, water_activity_high)\n\n# Calculate new particle diameters after hygroscopic growth\ndiameters_low = convert.volume_to_length(\n    volume=volume_sizer + volume_water_low,\n    length_type='diameter')  # showing the input parameters\ndiameters_mid = convert.volume_to_length(\n    volume_sizer + volume_water_mid, 'diameter')\ndiameters_high = convert.volume_to_length(\n    volume_sizer + volume_water_high, 'diameter')\n\n# Plotting the base and grown size distributions\nfig, ax = plt.subplots()\nax.plot(diameters, number_conc_pms, label=\"Base Distribution\")\nax.plot(\n    diameters_low,\n    number_conc_pms,\n    label=f\"Low Water Activity: {water_activity_low*100}% RH\")\nax.plot(\n    diameters_mid,\n    number_conc_pms,\n    label=f\"Mid Water Activity: {water_activity_mid*100}% RH\")\nax.plot(\n    diameters_high,\n    number_conc_pms,\n    label=f\"High Water Activity: {water_activity_high*100}% RH\")\nax.set_xscale(\"log\")\nax.set_xlabel(\"Diameter (nm)\")\nax.set_ylabel(\"Number concentration (#/cm^3)\")\nax.legend()\nplt.show()\n</pre> # Hygroscopic growth parameters kappa = 0.61  # Kappa value for ammonium sulfate water_activity_low = 0.3  # Low water activity (30% RH) water_activity_mid = 0.6  # Mid water activity (60% RH) water_activity_high = 0.9  # High water activity (90% RH)  # Define the range and resolution of particle diameters (in nanometers) diameters = np.linspace(20, 1000, 500)  # From 20 nm to 1000 nm with 500 points  # Standard deviation of the log-normal distribution (dimensionless) sigma = 1.25  # Define the modes (peak diameters) for a bimodal distribution modes = [100, 500]  # Total number of particles in the distribution number_total = 1e3  # Generate a log-normal probability density function (pdf) with an area # equal to 1 pdf_dist = distribution_discretization.discretize(     interval=diameters,  # Array of diameters over which to compute the distribution     disttype=\"lognormal\",  # Type of distribution     gsigma=sigma,  # Geometric standard deviation     mode=modes,  # Modes of the distribution     nparticles=number_total  # Total number of particles ).m  # Convert the distribution from pdf to probability mass function (pmf) number_conc_pms = convert.distribution_convert_pdf_pms(     x_array=diameters,  # Array of diameters     distribution=pdf_dist,  # The generated pdf     to_pdf=False  # Specifies the conversion to pmf ) * number_total  # Scale to the total number of particles   # Convert particle diameters from the base distribution to volumes volume_sizer = convert.length_to_volume(diameters, length_type='diameter')  # Calculate water volume absorbed by particles at different RH volume_water_low = convert.kappa_volume_water(     volume_solute=volume_sizer,     kappa=kappa,     water_activity=water_activity_low)  # showing the input parameters volume_water_mid = convert.kappa_volume_water(     volume_sizer, kappa, water_activity_mid) volume_water_high = convert.kappa_volume_water(     volume_sizer, kappa, water_activity_high)  # Calculate new particle diameters after hygroscopic growth diameters_low = convert.volume_to_length(     volume=volume_sizer + volume_water_low,     length_type='diameter')  # showing the input parameters diameters_mid = convert.volume_to_length(     volume_sizer + volume_water_mid, 'diameter') diameters_high = convert.volume_to_length(     volume_sizer + volume_water_high, 'diameter')  # Plotting the base and grown size distributions fig, ax = plt.subplots() ax.plot(diameters, number_conc_pms, label=\"Base Distribution\") ax.plot(     diameters_low,     number_conc_pms,     label=f\"Low Water Activity: {water_activity_low*100}% RH\") ax.plot(     diameters_mid,     number_conc_pms,     label=f\"Mid Water Activity: {water_activity_mid*100}% RH\") ax.plot(     diameters_high,     number_conc_pms,     label=f\"High Water Activity: {water_activity_high*100}% RH\") ax.set_xscale(\"log\") ax.set_xlabel(\"Diameter (nm)\") ax.set_ylabel(\"Number concentration (#/cm^3)\") ax.legend() plt.show() In\u00a0[11]: Copied! <pre># Define the kappa value and refractive index for dry particles\nkappa = 0.61  # Kappa value for ammonium sulfate\nrefractive_index_dry = 1.45  # Refractive index of dry particles\n\n# Define the wavelength of light for extinction calculations\nwavelength = 450  # Wavelength in nanometers\n\n# Calculate extinction coefficients at different humidities\next_low, ext_base = kappa_via_extinction.extinction_ratio_wet_dry(\n    kappa=kappa,\n    number_per_cm3=number_conc_pms,\n    diameters=diameters,\n    water_activity_sizer=0.0,  # Base condition for sizer water activity\n    water_activity_dry=0.0,    # Dry condition water activity\n    water_activity_wet=water_activity_low,  # Low RH condition\n    refractive_index_dry=refractive_index_dry,\n    wavelength=wavelength,\n    discretize=True,\n    return_coefficients=True,\n    return_all_optics=False\n)\next_mid, _ = kappa_via_extinction.extinction_ratio_wet_dry(\n    kappa=kappa,\n    number_per_cm3=number_conc_pms,\n    diameters=diameters,\n    water_activity_sizer=0.0,\n    water_activity_dry=0.0,\n    water_activity_wet=water_activity_mid,\n    refractive_index_dry=refractive_index_dry,\n    wavelength=wavelength,\n    discretize=True,\n    return_coefficients=True,\n    return_all_optics=False,\n)\next_high, _ = kappa_via_extinction.extinction_ratio_wet_dry(\n    kappa=kappa,\n    number_per_cm3=number_conc_pms,\n    diameters=diameters,\n    water_activity_sizer=0.0,\n    water_activity_dry=0.0,\n    water_activity_wet=water_activity_high,\n    refractive_index_dry=refractive_index_dry,\n    wavelength=wavelength,\n    discretize=True,\n    return_coefficients=True,\n    return_all_optics=False,\n)\n\n# print all extinctions\nprint(f\"Extinction at 0.0% RH: {ext_base}\")\nprint(f\"Extinction at {water_activity_low*100}% RH: {ext_low}\")\nprint(f\"Extinction at {water_activity_mid*100}% RH: {ext_mid}\")\nprint(f\"Extinction at {water_activity_high*100}% RH: {ext_high}\")\n</pre> # Define the kappa value and refractive index for dry particles kappa = 0.61  # Kappa value for ammonium sulfate refractive_index_dry = 1.45  # Refractive index of dry particles  # Define the wavelength of light for extinction calculations wavelength = 450  # Wavelength in nanometers  # Calculate extinction coefficients at different humidities ext_low, ext_base = kappa_via_extinction.extinction_ratio_wet_dry(     kappa=kappa,     number_per_cm3=number_conc_pms,     diameters=diameters,     water_activity_sizer=0.0,  # Base condition for sizer water activity     water_activity_dry=0.0,    # Dry condition water activity     water_activity_wet=water_activity_low,  # Low RH condition     refractive_index_dry=refractive_index_dry,     wavelength=wavelength,     discretize=True,     return_coefficients=True,     return_all_optics=False ) ext_mid, _ = kappa_via_extinction.extinction_ratio_wet_dry(     kappa=kappa,     number_per_cm3=number_conc_pms,     diameters=diameters,     water_activity_sizer=0.0,     water_activity_dry=0.0,     water_activity_wet=water_activity_mid,     refractive_index_dry=refractive_index_dry,     wavelength=wavelength,     discretize=True,     return_coefficients=True,     return_all_optics=False, ) ext_high, _ = kappa_via_extinction.extinction_ratio_wet_dry(     kappa=kappa,     number_per_cm3=number_conc_pms,     diameters=diameters,     water_activity_sizer=0.0,     water_activity_dry=0.0,     water_activity_wet=water_activity_high,     refractive_index_dry=refractive_index_dry,     wavelength=wavelength,     discretize=True,     return_coefficients=True,     return_all_optics=False, )  # print all extinctions print(f\"Extinction at 0.0% RH: {ext_base}\") print(f\"Extinction at {water_activity_low*100}% RH: {ext_low}\") print(f\"Extinction at {water_activity_mid*100}% RH: {ext_mid}\") print(f\"Extinction at {water_activity_high*100}% RH: {ext_high}\") <pre>Extinction at 0.0% RH: 389.78121694944446\nExtinction at 30.0% RH: 455.3096828541398\nExtinction at 60.0% RH: 606.9502182185444\nExtinction at 90.0% RH: 1242.6228046612712\n</pre> In\u00a0[17]: Copied! <pre>fit_low = kappa_via_extinction.fit_extinction_ratio_with_kappa(\n    b_ext_dry=ext_base,\n    b_ext_wet=ext_low,\n    number_per_cm3=number_conc_pms,\n    diameters=diameters,\n    water_activity_sizer=0.0,\n    water_activity_dry=0.0,\n    water_activity_wet=water_activity_low,\n    refractive_index_dry=refractive_index_dry,\n    wavelength=wavelength,\n    discretize=True,\n    kappa_bounds=(0, 1),\n    kappa_tolerance= 1e-12,\n    kappa_maxiter=200,\n)\nfit_mid = kappa_via_extinction.fit_extinction_ratio_with_kappa(\n    b_ext_dry=ext_base,\n    b_ext_wet=ext_mid,\n    number_per_cm3=number_conc_pms,\n    diameters=diameters,\n    water_activity_sizer=0.0,\n    water_activity_dry=0.0,\n    water_activity_wet=water_activity_mid,\n    refractive_index_dry=refractive_index_dry,\n    wavelength=wavelength,\n    discretize=True,\n    kappa_bounds=(0, 1),\n    kappa_tolerance= 1e-12,\n    kappa_maxiter=200,\n)\nfit_high = kappa_via_extinction.fit_extinction_ratio_with_kappa(\n    b_ext_dry=ext_base,\n    b_ext_wet=ext_high,\n    number_per_cm3=number_conc_pms,\n    diameters=diameters,\n    water_activity_sizer=0.0,\n    water_activity_dry=0.0,\n    water_activity_wet=water_activity_high,\n    refractive_index_dry=refractive_index_dry,\n    wavelength=wavelength,\n    discretize=True,\n    kappa_bounds=(0, 1),\n    kappa_tolerance= 1e-12,\n    kappa_maxiter=200,\n)\n\n# print all fits\n\nprint(f\"Kappa at {water_activity_low*100}% RH: {fit_low}\")\nprint(f\"Kappa at {water_activity_mid*100}% RH: {fit_mid}\")\nprint(f\"Kappa at {water_activity_high*100}% RH: {fit_high}\")\n</pre> fit_low = kappa_via_extinction.fit_extinction_ratio_with_kappa(     b_ext_dry=ext_base,     b_ext_wet=ext_low,     number_per_cm3=number_conc_pms,     diameters=diameters,     water_activity_sizer=0.0,     water_activity_dry=0.0,     water_activity_wet=water_activity_low,     refractive_index_dry=refractive_index_dry,     wavelength=wavelength,     discretize=True,     kappa_bounds=(0, 1),     kappa_tolerance= 1e-12,     kappa_maxiter=200, ) fit_mid = kappa_via_extinction.fit_extinction_ratio_with_kappa(     b_ext_dry=ext_base,     b_ext_wet=ext_mid,     number_per_cm3=number_conc_pms,     diameters=diameters,     water_activity_sizer=0.0,     water_activity_dry=0.0,     water_activity_wet=water_activity_mid,     refractive_index_dry=refractive_index_dry,     wavelength=wavelength,     discretize=True,     kappa_bounds=(0, 1),     kappa_tolerance= 1e-12,     kappa_maxiter=200, ) fit_high = kappa_via_extinction.fit_extinction_ratio_with_kappa(     b_ext_dry=ext_base,     b_ext_wet=ext_high,     number_per_cm3=number_conc_pms,     diameters=diameters,     water_activity_sizer=0.0,     water_activity_dry=0.0,     water_activity_wet=water_activity_high,     refractive_index_dry=refractive_index_dry,     wavelength=wavelength,     discretize=True,     kappa_bounds=(0, 1),     kappa_tolerance= 1e-12,     kappa_maxiter=200, )  # print all fits  print(f\"Kappa at {water_activity_low*100}% RH: {fit_low}\") print(f\"Kappa at {water_activity_mid*100}% RH: {fit_mid}\") print(f\"Kappa at {water_activity_high*100}% RH: {fit_high}\") <pre>Kappa at 30.0% RH: 0.6052222023205297\nKappa at 60.0% RH: 0.610000003943248\nKappa at 90.0% RH: 0.610062704938107\n</pre> In\u00a0[19]: Copied! <pre># Perform kappa-HGF fitting with a humid sizer at mid RH\nfit_humid_sizer_mid = kappa_via_extinction.fit_extinction_ratio_with_kappa(\n    b_ext_dry=ext_base,\n    b_ext_wet=ext_mid,\n    number_per_cm3=number_conc_pms,\n    diameters=diameters_mid,\n    water_activity_sizer=water_activity_mid,  # Sizer humidity set to mid RH\n    water_activity_dry=0.0,  # Dry condition\n    water_activity_wet=water_activity_mid,  # Wet condition matches sizer RH\n    refractive_index_dry=refractive_index_dry,\n    wavelength=wavelength,\n    discretize=True,\n    kappa_bounds=(0, 1),\n    kappa_tolerance=1e-12,\n    kappa_maxiter=200\n)\n\n# Repeat fitting with humid sizer at mid RH and extinction measurements at\n# low and high RH\nfit_humid_sizer_mid_and_humid_ext_low = kappa_via_extinction.fit_extinction_ratio_with_kappa(\n    b_ext_dry=ext_low,  # Dry extinction at low RH\n    b_ext_wet=ext_high,  # Wet extinction at high RH\n    number_per_cm3=number_conc_pms,\n    diameters=diameters_mid,  # Diameters adjusted for mid RH\n    water_activity_sizer=water_activity_mid,  # Mid RH for sizer\n    water_activity_dry=water_activity_low,  # Low RH for dry condition\n    water_activity_wet=water_activity_high,  # High RH for wet condition\n    refractive_index_dry=refractive_index_dry,\n    wavelength=wavelength,\n    discretize=True,\n    kappa_bounds=(0, 1),\n    kappa_tolerance=1e-12,\n    kappa_maxiter=200\n)\n\n# Print the fitted kappa values\nprint(\n    f\"Kappa from humid sizer at {water_activity_mid*100}% RH and dry Ext: {fit_humid_sizer_mid}\")\nprint(f\"Kappa from humid sizer at {water_activity_mid*100}% RH and humid Ext from {water_activity_low*100}% RH to {water_activity_high*100}% RH: {fit_humid_sizer_mid_and_humid_ext_low}\")\n</pre> # Perform kappa-HGF fitting with a humid sizer at mid RH fit_humid_sizer_mid = kappa_via_extinction.fit_extinction_ratio_with_kappa(     b_ext_dry=ext_base,     b_ext_wet=ext_mid,     number_per_cm3=number_conc_pms,     diameters=diameters_mid,     water_activity_sizer=water_activity_mid,  # Sizer humidity set to mid RH     water_activity_dry=0.0,  # Dry condition     water_activity_wet=water_activity_mid,  # Wet condition matches sizer RH     refractive_index_dry=refractive_index_dry,     wavelength=wavelength,     discretize=True,     kappa_bounds=(0, 1),     kappa_tolerance=1e-12,     kappa_maxiter=200 )  # Repeat fitting with humid sizer at mid RH and extinction measurements at # low and high RH fit_humid_sizer_mid_and_humid_ext_low = kappa_via_extinction.fit_extinction_ratio_with_kappa(     b_ext_dry=ext_low,  # Dry extinction at low RH     b_ext_wet=ext_high,  # Wet extinction at high RH     number_per_cm3=number_conc_pms,     diameters=diameters_mid,  # Diameters adjusted for mid RH     water_activity_sizer=water_activity_mid,  # Mid RH for sizer     water_activity_dry=water_activity_low,  # Low RH for dry condition     water_activity_wet=water_activity_high,  # High RH for wet condition     refractive_index_dry=refractive_index_dry,     wavelength=wavelength,     discretize=True,     kappa_bounds=(0, 1),     kappa_tolerance=1e-12,     kappa_maxiter=200 )  # Print the fitted kappa values print(     f\"Kappa from humid sizer at {water_activity_mid*100}% RH and dry Ext: {fit_humid_sizer_mid}\") print(f\"Kappa from humid sizer at {water_activity_mid*100}% RH and humid Ext from {water_activity_low*100}% RH to {water_activity_high*100}% RH: {fit_humid_sizer_mid_and_humid_ext_low}\") <pre>Kappa 0.6100000005341284 from humid sizer 60.0% RH and dry Ext: \nKappa 0.6099999998804534 from humid sizer 60.0% RH and humid Ext 30.0% RH: \n</pre> In\u00a0[30]: Copied! <pre># Fitting kappa-HGF with varied assumptions on the dry refractive index\nfit_refractive_index_lower = kappa_via_extinction.fit_extinction_ratio_with_kappa(\n    b_ext_dry=ext_base,\n    b_ext_wet=ext_mid,\n    number_per_cm3=number_conc_pms,\n    diameters=diameters,\n    water_activity_sizer=0.0,\n    water_activity_dry=0.0,\n    water_activity_wet=water_activity_mid,\n    refractive_index_dry=1.4,  # Assumption of a lower refractive index\n    wavelength=wavelength,\n    kappa_bounds=(0, 1),\n    kappa_tolerance=1e-12,\n    kappa_maxiter=200\n)\n\nfit_refractive_index_higher = kappa_via_extinction.fit_extinction_ratio_with_kappa(\n    b_ext_dry=ext_base,\n    b_ext_wet=ext_mid,\n    number_per_cm3=number_conc_pms,\n    diameters=diameters,\n    water_activity_sizer=0.0,\n    water_activity_dry=0.0,\n    water_activity_wet=water_activity_mid,\n    refractive_index_dry=1.55,  # Assumption of a higher refractive index\n    wavelength=wavelength,\n    kappa_bounds=(0, 1),\n    kappa_tolerance=1e-12,\n    kappa_maxiter=200\n)\n\nfit_refractive_index_close = kappa_via_extinction.fit_extinction_ratio_with_kappa(\n    b_ext_dry=ext_base,\n    b_ext_wet=ext_mid,\n    number_per_cm3=number_conc_pms,\n    diameters=diameters,\n    water_activity_sizer=0.0,\n    water_activity_dry=0.0,\n    water_activity_wet=water_activity_mid,\n    refractive_index_dry=1.48,  # A close but distinct refractive index\n    wavelength=wavelength,\n    kappa_bounds=(0, 1),\n    kappa_tolerance=1e-12,\n    kappa_maxiter=200\n)\n\n# Output the fitted kappa values for each refractive index assumption\nprint(f\"Kappa from lower refractive index 1.4: {fit_refractive_index_lower}\")\nprint(\n    f\"Kappa from higher refractive index 1.55: {fit_refractive_index_higher}\")\nprint(f\"Kappa from close refractive index 1.48: {fit_refractive_index_close}\")\n</pre> # Fitting kappa-HGF with varied assumptions on the dry refractive index fit_refractive_index_lower = kappa_via_extinction.fit_extinction_ratio_with_kappa(     b_ext_dry=ext_base,     b_ext_wet=ext_mid,     number_per_cm3=number_conc_pms,     diameters=diameters,     water_activity_sizer=0.0,     water_activity_dry=0.0,     water_activity_wet=water_activity_mid,     refractive_index_dry=1.4,  # Assumption of a lower refractive index     wavelength=wavelength,     kappa_bounds=(0, 1),     kappa_tolerance=1e-12,     kappa_maxiter=200 )  fit_refractive_index_higher = kappa_via_extinction.fit_extinction_ratio_with_kappa(     b_ext_dry=ext_base,     b_ext_wet=ext_mid,     number_per_cm3=number_conc_pms,     diameters=diameters,     water_activity_sizer=0.0,     water_activity_dry=0.0,     water_activity_wet=water_activity_mid,     refractive_index_dry=1.55,  # Assumption of a higher refractive index     wavelength=wavelength,     kappa_bounds=(0, 1),     kappa_tolerance=1e-12,     kappa_maxiter=200 )  fit_refractive_index_close = kappa_via_extinction.fit_extinction_ratio_with_kappa(     b_ext_dry=ext_base,     b_ext_wet=ext_mid,     number_per_cm3=number_conc_pms,     diameters=diameters,     water_activity_sizer=0.0,     water_activity_dry=0.0,     water_activity_wet=water_activity_mid,     refractive_index_dry=1.48,  # A close but distinct refractive index     wavelength=wavelength,     kappa_bounds=(0, 1),     kappa_tolerance=1e-12,     kappa_maxiter=200 )  # Output the fitted kappa values for each refractive index assumption print(f\"Kappa from lower refractive index 1.4: {fit_refractive_index_lower}\") print(     f\"Kappa from higher refractive index 1.55: {fit_refractive_index_higher}\") print(f\"Kappa from close refractive index 1.48: {fit_refractive_index_close}\") <pre>Kappa from lower refractive index 1.4: 0.5112947684591423\nKappa from higher refractive index 1.55: 0.7043352860513862\nKappa from close refractive index 1.48: 0.6563062276765905\n</pre> In\u00a0[32]: Copied! <pre>fit_low_number = kappa_via_extinction.fit_extinction_ratio_with_kappa(\n    b_ext_dry=ext_base,\n    b_ext_wet=ext_high,\n    number_per_cm3=number_conc_pms*0.2,  # 20% of the base number concentration\n    diameters=diameters,\n    water_activity_sizer=0.0,\n    water_activity_dry=0.0,\n    water_activity_wet=water_activity_high,\n    refractive_index_dry=refractive_index_dry,\n    wavelength=wavelength,\n    discretize=True,\n    kappa_bounds=(0, 1),\n    kappa_tolerance=1e-12,\n    kappa_maxiter=200,\n)\n# print result\nprint(f\"Kappa at {water_activity_high*100}% RH with 20% of the particles: {fit_low_number}\")\n</pre> fit_low_number = kappa_via_extinction.fit_extinction_ratio_with_kappa(     b_ext_dry=ext_base,     b_ext_wet=ext_high,     number_per_cm3=number_conc_pms*0.2,  # 20% of the base number concentration     diameters=diameters,     water_activity_sizer=0.0,     water_activity_dry=0.0,     water_activity_wet=water_activity_high,     refractive_index_dry=refractive_index_dry,     wavelength=wavelength,     discretize=True,     kappa_bounds=(0, 1),     kappa_tolerance=1e-12,     kappa_maxiter=200, ) # print result print(f\"Kappa at {water_activity_high*100}% RH with 20% of the particles: {fit_low_number}\") <pre>Kappa at 90.0% RH with 20% of the particles: 0.6100627049381072\n</pre> In\u00a0[33]: Copied! <pre>help(kappa_via_extinction.extinction_ratio_wet_dry)\n</pre> help(kappa_via_extinction.extinction_ratio_wet_dry) <pre>Help on function extinction_ratio_wet_dry in module particula.data.process.kappa_via_extinction:\n\nextinction_ratio_wet_dry(kappa: Union[float, numpy.ndarray[Any, numpy.dtype[numpy.float64]]], number_per_cm3: numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]], diameters: numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]], water_activity_sizer: numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]], water_activity_dry: numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]], water_activity_wet: numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]], refractive_index_dry: Union[complex, float] = 1.45, water_refractive_index: Union[complex, float] = 1.33, wavelength: float = 450, discretize: bool = True, return_coefficients: bool = False, return_all_optics: bool = False) -&gt; Union[float, Tuple[numpy.ndarray[Any, numpy.dtype[+_ScalarType_co]], numpy.ndarray[Any, numpy.dtype[+_ScalarType_co]]]]\n    Calculates the extinction ratio between wet and dry aerosols, considering\n    water uptake through kappa. This function uses Mie theory to determine the\n    optical properties of aerosols with varying water content, allowing for\n    analysis of hygroscopic growth and its impact on aerosol optical\n    characteristics.\n    \n    Parameters\n    ----------\n    kappa : Union[float, NDArray[np.float64]]\n        Hygroscopicity parameter, defining water uptake ability of particles.\n    number_per_cm3 : NDArray[np.float64]\n        Number concentration of particles per cubic centimeter for each size\n        bin.\n    diameters : NDArray[np.float64]\n        Diameters of particles in nanometers for each size bin.\n    water_activity_sizer : NDArray[np.float64]\n        Water activity of the aerosol size distribution.\n    water_activity_dry : NDArray[np.float64]\n        Water activity for the calculation of 'dry' aerosol properties.\n    water_activity_wet : NDArray[np.float64]\n        Water activity for the calculation of 'wet' aerosol properties.\n    refractive_index_dry : Union[complex, float, np.float16], optional\n        Refractive index of the dry aerosol particles.\n    water_refractive_index : Union[complex, float], optional\n        Refractive index of water.\n    wavelength : float, optional\n        Wavelength of the incident light in nanometers.\n    discretize : bool, optional\n        If True, discretizes input parameters for Mie calculations to enable\n        caching.\n    return_coefficients : bool, optional\n        If True, returns the individual extinction coefficients for wet and\n        dry aerosols instead of their ratio.\n    return_all_optics : bool, optional\n        If True, returns all optical properties calculated by Mie theory,\n        not just extinction.\n    \n    Returns\n    -------\n    Union[float, Tuple[NDArray, NDArray]]\n        By default, returns the ratio of wet to dry aerosol extinction.\n        If `return_coefficients` is True, returns a tuple of NDArrays\n        containing the extinction coefficients for wet and dry aerosols,\n        respectively.\n\n</pre> In\u00a0[34]: Copied! <pre>help(kappa_via_extinction.fit_extinction_ratio_with_kappa)\n</pre> help(kappa_via_extinction.fit_extinction_ratio_with_kappa) <pre>Help on function fit_extinction_ratio_with_kappa in module particula.data.process.kappa_via_extinction:\n\nfit_extinction_ratio_with_kappa(b_ext_dry: Union[float, numpy.float64], b_ext_wet: Union[float, numpy.float64], number_per_cm3: numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]], diameters: numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]], water_activity_sizer: numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]], water_activity_dry: numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]], water_activity_wet: numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]], refractive_index_dry: Union[complex, float] = 1.45, water_refractive_index: Union[complex, float] = 1.33, wavelength: float = 450, discretize: bool = True, kappa_bounds: Tuple[float, float] = (0, 1), kappa_tolerance: float = 1e-06, kappa_maxiter: int = 100) -&gt; Union[float, numpy.float64]\n    Fits the kappa parameter based on the measured extinction ratios of dry\n    and wet aerosols, utilizing Mie theory to account for water uptake\n    effects. This method optimizes kappa to minimize the difference between\n    the calculated and observed extinction ratio of wet to dry aerosols.\n    \n    Parameters\n    ----------\n    b_ext_dry : Union[float, np.float64]\n        The measured extinction of the dry aerosol.\n    b_ext_wet : Union[float, np.float64]\n        The measured extinction of the wet aerosol.\n    number_per_cm3 : NDArray[np.float64]\n        The number concentration of particles per cubic centimeter for each\n        size bin.\n    diameters : NDArray[np.float64]\n        The diameters of particles in nanometers for each size bin.\n    water_activity_sizer : NDArray[np.float64]\n        The water activity corresponding to the aerosol size distribution.\n    water_activity_dry : NDArray[np.float64]\n        The water activity for the 'dry' aerosol condition.\n    water_activity_wet : NDArray[np.float64]\n        The water activity for the 'wet' aerosol condition.\n    refractive_index_dry : Union[complex, float, np.float16], optional\n        The refractive index of the dry aerosol particles.\n    water_refractive_index : Union[complex, float], optional\n        The refractive index of water.\n    wavelength : float, optional\n        The wavelength of incident light in nanometers.\n    discretize : bool, optional\n        If True, discretizes input parameters for Mie calculations to enable\n        caching.\n    kappa_bounds : Tuple[float, float], optional\n        The bounds within which to fit the kappa parameter.\n    kappa_tolerance : float, optional\n        The tolerance level for the optimization of kappa.\n    kappa_maxiter : int, optional\n        The maximum number of iterations allowed in the optimization process.\n    \n    Returns\n    -------\n    Union[float, np.float64]\n        The optimized kappa parameter that best fits the observed extinction\n        ratios.\n\n</pre> In\u00a0[37]: Copied! <pre>help(kappa_via_extinction.kappa_from_extinction_looped)\n</pre> help(kappa_via_extinction.kappa_from_extinction_looped) <pre>Help on function kappa_from_extinction_looped in module particula.data.process.kappa_via_extinction:\n\nkappa_from_extinction_looped(extinction_dry: numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]], extinction_wet: numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]], number_per_cm3: numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]], diameter: numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]], water_activity_sizer: numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]], water_activity_sample_dry: numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]], water_activity_sample_wet: numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]], refractive_index_dry: Union[complex, float] = 1.45, water_refractive_index: Union[complex, float] = 1.33, wavelength: float = 450, discretize: bool = True) -&gt; numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]]\n    Fits the extinction ratio to the kappa value for a given set of\n    measurements, looping over time indexes in number_per_cm3. This function\n    is tailored for analyzing data from a CAPS (Cavity Attenuated Phase Shift)\n    instrument under varying humidities.\n    \n    Parameters\n    ----------\n    extinction_dry : NDArray[np.float64]\n        Array of dry aerosol extinction measurements.\n    extinction_wet : NDArray[np.float64]\n        Array of wet aerosol extinction measurements.\n    number_per_cm3 : NDArray[np.float64]\n        Array of particle number concentrations in #/cm\u00b3.\n    diameter : NDArray[np.float64]\n        Array of particle diameters.\n    water_activity_sizer : NDArray[np.float64]\n        Water activity (relative humidity/100) of the sizing instrument's air.\n    water_activity_sample_dry : NDArray[np.float64]\n        Water activity (relative humidity/100) of the air for dry measurements.\n    water_activity_sample_wet : NDArray[np.float64]\n        Water activity (relative humidity/100) of the air for wet measurements.\n    refractive_index_dry : Union[complex, float], optional\n        Refractive index of dry particles. Default is 1.45.\n    water_refractive_index : Union[complex, float], optional\n        Refractive index of water. Default is 1.33.\n    wavelength : float, optional\n        Wavelength of the light source in nanometers. Default is 450.\n    discretize : bool, optional\n        If True, calculations are performed with discretized parameter values\n        to potentially improve performance. Default is True.\n    \n    Returns\n    -------\n    NDArray[np.float64]\n        A 2D array where each row corresponds to the time-indexed kappa value,\n        lower and upper bounds of the kappa estimation, structured as\n        [kappa, lower, upper].\n\n</pre>"},{"location":"How-To-Guides/Light_Scattering/notebooks/kappa_vs_extinction/#fitting-kappa-hgf-from-light-extinction","title":"Fitting Kappa-HGF from Light Extinction\u00b6","text":"<p>In the field of atmospheric science, understanding the hygroscopic growth of aerosol particles is crucial for predicting their impact on climate, weather patterns, and human health. The kappa-Hygroscopic Growth Factor (kappa-HGF) is a parameter that quantifies the ability of aerosol particles to absorb water under varying levels of relative humidity. However, kappa-HGF is not measured directly in atmospheric observations. Instead, researchers infer this parameter by analyzing changes in aerosol properties, such as light extinction, diameter growth, or light scattering, as a function of humidity.</p> <p>This notebook focuses on deriving kappa-HGF from light extinction measurements at different humidity levels. Light extinction, which encompasses both scattering and absorption by aerosol particles, is a fundamental optical property that can significantly vary with particle size and composition, especially as particles undergo hygroscopic growth in humid conditions. By comparing light extinction under low and high humidity conditions, we can back-calculate kappa-HGF, offering insights into the water uptake and swelling behavior of aerosols in the atmosphere.</p> <p>The methodology and analyses presented here for light extinction can be analogously applied to other aerosol properties affected by humidity changes. Understanding these dynamics is key to improving our models of aerosol-cloud interactions, radiative forcing, and visibility impairment.</p> <p>Imports</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/kappa_vs_extinction/#generating-synthetic-data-for-kappa-hgf-analysis","title":"Generating Synthetic Data for Kappa-HGF Analysis\u00b6","text":"<p>To conduct a meaningful analysis of kappa-HGF (Hygroscopic Growth Factor) based on light extinction, we first need to simulate synthetic data that closely mimics atmospheric aerosol properties. This involves creating a size distribution of aerosol particles and calculating their light extinction coefficients under different humidity conditions.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/kappa_vs_extinction/#hygroscopic-growth-parameters","title":"Hygroscopic Growth Parameters\u00b6","text":"<p>For our synthetic dataset, we consider ammonium sulfate as the aerosol composition with a kappa value of 0.61. We examine the particle behavior at three distinct relative humidity (RH) levels: 30%, 60%, and 90%, representing low, mid, and high water activity scenarios, respectively.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/kappa_vs_extinction/#size-distribution","title":"Size Distribution\u00b6","text":"<p>The synthetic size distribution is modeled as a bimodal log-normal distribution, capturing the diversity in particle sizes typically observed in atmospheric aerosols. The distribution spans from 20 nm to 1000 nm with 500 discrete points, encompassing a wide range of aerosol sizes. The distribution is characterized by two modes at 100 nm and 500 nm and a geometric standard deviation of 1.25, simulating a realistic atmospheric aerosol size distribution.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/kappa_vs_extinction/#calculation-steps","title":"Calculation Steps\u00b6","text":"<ol> <li><p>Volume Conversion: Convert the diameters from the base distribution to volumes, facilitating the subsequent calculation of water volume absorbed by the particles at different RH levels.</p> </li> <li><p>Water Volume Calculation: For each RH level, calculate the volume of water absorbed by the particles, leveraging the kappa value to simulate hygroscopic growth.</p> </li> <li><p>Diameter Adjustment: Adjust the particle diameters based on the absorbed water volume to obtain new diameters that reflect hygroscopic growth at each RH level.</p> </li> </ol>"},{"location":"How-To-Guides/Light_Scattering/notebooks/kappa_vs_extinction/#simulating-light-extinction-for-hygroscopic-growth","title":"Simulating Light Extinction for Hygroscopic Growth\u00b6","text":"<p>After generating synthetic aerosol distributions and analyzing their hygroscopic growth, the next crucial step is to simulate how these changes affect the aerosols' light extinction properties at different humidity levels. Light extinction, a key optical property, combines the effects of both scattering and absorption by particles, and varies significantly with particle size, composition, and ambient humidity. In this section, we calculate the extinction coefficients for our simulated aerosol distributions at low, mid, and high relative humidity (RH) conditions.</p> <p>To simulate the extinction at each specified humidity, we employ the <code>extinction_ratio_wet_dry</code> function from the <code>kappa_via_extinction</code> module. This function calculates the extinction coefficients by considering the hygroscopic growth of particles and their resulting optical properties.</p> <p>Note: The size distribution hygroscopic growth and refractive index mixing are handled internally by the <code>extinction_ratio_wet_dry</code> function, so we only need to provide the base size distribution and the RH levels of interest.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/kappa_vs_extinction/#fitting-kappa-hgf-to-dry-aerosol-data","title":"Fitting Kappa-HGF to Dry Aerosol Data\u00b6","text":"<p>After generating synthetic aerosol distributions and simulating their light extinction at various humidity levels, we proceed to fit the kappa-Hygroscopic Growth Factor (kappa-HGF) to our synthetic data. This process involves using the extinction data previously calculated to infer the kappa-HGF values that best describe the observed changes in light extinction due to hygroscopic growth.</p> <p>To achieve this, we employ the <code>fit_extinction_ratio_with_kappa</code> function from the <code>kappa_via_extinction</code> module. This function optimizes the kappa value to match the simulated wet-to-dry extinction ratio, providing a quantitative measure of the particles' hygroscopicity. The fitting is performed for low, mid, and high humidity conditions, allowing us to observe how kappa-HGF varies with relative humidity (RH) of the measurement environment. It should be relatively close to the kappa value used in the synthetic data generation (0.61).</p> <p>This code snippet demonstrates the process of fitting kappa-HGF to the synthetic data, highlighting the kappa values obtained for different RH conditions. The fitting process is crucial for translating the wet-to-dry extinction ratios into a meaningful measure of particle hygroscopicity, which can then be used to improve our understanding of aerosol behavior in the atmosphere.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/kappa_vs_extinction/#insensitivity-to-humidity-in-sizer-and-extinction-measurements","title":"Insensitivity to Humidity in Sizer and Extinction Measurements\u00b6","text":"<p>In the complex world of atmospheric measurements, not all data are perfect. One of the challenges is dealing with the humidity effects on both the size distribution measurements and the extinction coefficients for dry and wet aerosol particles. This section demonstrates that by carefully accounting for humidity in these measurements, the fitted kappa-Hygroscopic Growth Factor (kappa-HGF) remains robust and insensitive to variations in the size distribution caused by humidity. This resilience is particularly crucial when dealing with ambient measurements, where the assumption of perfectly dry particles may not hold.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/kappa_vs_extinction/#fitting-kappa-hgf-under-varied-humidity-conditions","title":"Fitting Kappa-HGF under Varied Humidity Conditions\u00b6","text":"<p>To illustrate this point, we perform kappa-HGF fitting under conditions where the sizer humidity is not zero, simulating more realistic scenarios where dry particles may still retain some moisture. We explore how kappa-HGF responds to changes in the humidity of the sizer used to measure the size distribution and the humidity conditions under which dry and wet extinction coefficients are obtained.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/kappa_vs_extinction/#key-insights","title":"Key Insights\u00b6","text":"<p>The kappa-HGF fitting outcomes demonstrate that the approach remains effective even when the sizer's humidity and the conditions for measuring dry and wet extinctions incorporate realistic humidity levels. This robustness ensures that kappa-HGF can be accurately determined from ambient aerosol measurements, accommodating the inherent moisture that may be present in \"dry\" aerosol samples.</p> <p>Understanding and adjusting for these nuances in humidity is essential for accurately characterizing aerosol optical properties and their environmental impacts. By acknowledging and accounting for these factors in our analysis, we enhance the reliability of kappa-HGF estimations, paving the way for more accurate atmospheric models and predictions.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/kappa_vs_extinction/#examining-the-impact-of-dry-refractive-index-on-kappa-hgf-estimation","title":"Examining the Impact of Dry Refractive Index on Kappa-HGF Estimation\u00b6","text":"<p>The refractive index of aerosol particles plays a pivotal role in determining their optical properties, such as light extinction. When deducing the kappa-Hygroscopic Growth Factor (kappa-HGF) from light extinction data, the choice of the dry aerosol particle's refractive index can significantly influence the precision of the resulting kappa estimation. This exploration delves into the sensitivity of the kappa-HGF fitting process to variations in the assumed dry refractive index, underscoring the necessity of accurately selecting this parameter for reliable hygroscopicity assessments.</p> <p>Initially, we assumed a dry refractive index of (1.45 + 0i) for generating extinction data. Here, we venture into how alterations in this assumed refractive index affect the kappa-HGF fitting outcomes. Specifically, we examine the response of the kappa-HGF fitting to both modest deviations and more pronounced shifts from the initially assumed value, including both lower and higher indices, to ascertain the robustness of kappa estimation against such variations.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/kappa_vs_extinction/#robustness-of-kappa-hgf-estimation-against-particle-number-variations","title":"Robustness of Kappa-HGF Estimation Against Particle Number Variations\u00b6","text":"<p>A noteworthy aspect of estimating the kappa-Hygroscopic Growth Factor (kappa-HGF) from light extinction measurements is its robustness to variations in the total number of aerosol particles. This resilience is attributed to the optimization process focusing on the extinction ratio rather than absolute extinction values. Consequently, discrepancies in the total particle number do not significantly affect the kappa-HGF fitting outcomes. This section demonstrates this principle by applying kappa-HGF fitting to synthetic datasets with deliberately altered particle number concentrations.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/kappa_vs_extinction/#demonstrating-insensitivity-through-particle-number-variation","title":"Demonstrating Insensitivity through Particle Number Variation\u00b6","text":"<p>The experiment involves adjusting the particle number concentration to 20% of its original value in the synthetic dataset. Despite this substantial reduction, we observe that the kappa-HGF estimation process yields consistent results, underscoring the fitting technique's insensitivity to the absolute particle count within the aerosol distribution. This characteristic is particularly advantageous when dealing with ambient measurements, where precise particle counting may be challenging.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/kappa_vs_extinction/#implications-for-ambient-aerosol-measurements","title":"Implications for Ambient Aerosol Measurements\u00b6","text":"<p>The findings from this sensitivity analysis have implications for conducting ambient aerosol measurements and analyses. They highlight the fitting process's adaptability and accuracy, even when the exact particle count is uncertain or varies across measurements. As long as the relative distribution of particle sizes remains representative of the aerosol population under study, kappa-HGF estimates can be reliably derived, facilitating accurate assessments of aerosol hygroscopicity and its atmospheric impacts.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/kappa_vs_extinction/#summary-of-kappa-hgf-fitting-notebook","title":"Summary of Kappa-HGF Fitting Notebook\u00b6","text":"<p>This notebook delves into the intricacies of fitting the kappa-Hygroscopic Growth Factor (kappa-HGF) using synthetic aerosol data. The kappa-HGF is an essential parameter in atmospheric sciences, quantifying the water-absorbing capabilities of aerosol particles and their influence on cloud formation and climate. The notebook methodically guides through generating synthetic aerosol size distributions, simulating their light extinction under various humidity conditions, and employing these simulations to estimate kappa-HGF. Key highlights include:</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/kappa_vs_extinction/#synthetic-data-generation","title":"Synthetic Data Generation\u00b6","text":"<ul> <li>Aerosol Size Distribution: We created synthetic bimodal log-normal size distributions, representing atmospheric aerosol populations. This step is crucial for simulating realistic aerosol behaviors under varying environmental conditions.</li> <li>Hygroscopic Growth Simulation: By adjusting the size distribution for different relative humidity levels, we simulated the hygroscopic growth of aerosols, providing a foundation for subsequent extinction calculations.</li> <li>Extinction Coefficients: We calculated light extinction coefficients for the synthetic aerosol distributions at low, mid, and high humidity levels.</li> </ul>"},{"location":"How-To-Guides/Light_Scattering/notebooks/kappa_vs_extinction/#kappa-hgf-fitting","title":"Kappa-HGF Fitting\u00b6","text":"<ul> <li>Insensitivity to Humidity in Measurements: Demonstrating the fitting process's robustness, we showed that kappa-HGF estimation is insensitive to variations in humidity during size distribution measurements, ensuring reliable kappa estimations from ambient aerosol data.</li> <li>Sensitivity to Dry Refractive Index: Exploring the impact of the assumed dry refractive index on kappa-HGF fitting revealed the importance of accurately selecting this parameter for precise hygroscopicity assessments.</li> <li>Insensitivity Against Particle Number: The kappa-HGF fitting process proved to be resilient to changes in the total number of aerosol particles, emphasizing the method's suitability for ambient aerosol studies where particle counts may fluctuate.</li> </ul>"},{"location":"How-To-Guides/Light_Scattering/notebooks/kappa_vs_extinction/#conclusions-and-implications","title":"Conclusions and Implications\u00b6","text":"<p>The notebook's findings underscore the efficacy and reliability of the kappa-HGF fitting process, even under the inherent variability and uncertainties of atmospheric aerosol measurements. By accurately estimating kappa-HGF from light extinction data, scientists can better understand aerosol hygroscopic growth, improving models of aerosol-cloud interactions and assessing aerosols' environmental and climatic impacts. This work highlights the critical role of precise parameter selection and the robustness of the kappa-HGF estimation process, contributing valuable insights to the field of atmospheric sciences.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/mie_basics/","title":"Mie Scattering","text":"In\u00a0[1]: Copied! <pre>import numpy as np\n\n# particula imports\nfrom particula.data.process import mie_bulk\n</pre> import numpy as np  # particula imports from particula.data.process import mie_bulk In\u00a0[6]: Copied! <pre># Calculate Mie coefficients for a non absorbing sphere\nmie_coefficients = mie_bulk.discretize_auto_mieq(\n    m_sphere=1.5,\n    wavelength=550.0,\n    diameter=200.0\n)\n# Calculate Mie coefficients for a absorbing sphere\nmie_coefficients_abs = mie_bulk.discretize_auto_mieq(\n    m_sphere=1.5 + 0.5j,\n    wavelength=550.0,\n    diameter=200.0\n)\n\n# Print the table header, with padding spaces\nprint(f\"{'Property':&lt;10} {'Non-absorbing Sphere':&lt;25} {'Absorbing Sphere':&lt;25}\")\n# Print each row of Q efficiencies\nproperties = ['Qext', 'Qsca', 'Qabs', 'g', 'Qpr', 'Qback', 'Qratio']\nfor i, prop in enumerate(properties):\n    print(\n        f\"{prop:&lt;10} {mie_coefficients[i]:&lt;25} {mie_coefficients_abs[i]:&lt;25}\")\n</pre> # Calculate Mie coefficients for a non absorbing sphere mie_coefficients = mie_bulk.discretize_auto_mieq(     m_sphere=1.5,     wavelength=550.0,     diameter=200.0 ) # Calculate Mie coefficients for a absorbing sphere mie_coefficients_abs = mie_bulk.discretize_auto_mieq(     m_sphere=1.5 + 0.5j,     wavelength=550.0,     diameter=200.0 )  # Print the table header, with padding spaces print(f\"{'Property':&lt;10} {'Non-absorbing Sphere':&lt;25} {'Absorbing Sphere':&lt;25}\") # Print each row of Q efficiencies properties = ['Qext', 'Qsca', 'Qabs', 'g', 'Qpr', 'Qback', 'Qratio'] for i, prop in enumerate(properties):     print(         f\"{prop:&lt;10} {mie_coefficients[i]:&lt;25} {mie_coefficients_abs[i]:&lt;25}\") <pre>Property   Non-absorbing Sphere      Absorbing Sphere         \nQext       0.3381182292121606        1.6386392163349293       \nQsca       0.33811822921216056       0.44129028057104036      \nQabs       5.551115123125783e-17     1.197348935763889        \ng          0.26718570666763686       0.2920132136174058       \nQpr        0.24777787120289949       1.5097766233672532       \nQback      0.23099105902557251       0.26574242780352025      \nQratio     0.6831665348650324        0.6021941554199722       \n</pre> In\u00a0[8]: Copied! <pre># Define the refractive index of the particles (complex for absorbing,\n# real for non-absorbing)\nm_sphere = 1.5 + 0.01j  # Example for slightly absorbing particles\n\n# Define the wavelength of the incident light in nanometers\nwavelength = 550.0\n\n# Create a linearly spaced array of particle diameters in nanometers\n# From 100 nm to 300 nm, 50 sizes\ndiameter_sizes = np.linspace(100.0, 500.0, 50)\n\n# Simulate a number concentration for each particle size in #/cm\u00b3\n# Decreasing concentration from 1000 to 500 #/cm\u00b3\nnumber_per_cm3 = np.linspace(1000.0, 500.0, 50)\n\n# Refractive index of the surrounding medium (e.g., air)\nn_medium = 1.0\n\n\n# Calculate the Mie scattering parameters for the given size distribution\nmie_results = mie_bulk.mie_size_distribution(\n    m_sphere=m_sphere,\n    wavelength=wavelength,\n    diameter=diameter_sizes,\n    number_per_cm3=number_per_cm3,\n    n_medium=n_medium,\n    as_dict=True\n)\n\n# Print or process the Mie scattering results\n\nfor key, value in mie_results.items():\n    print(f\"{key:&lt;8}: {value}\")\n</pre> # Define the refractive index of the particles (complex for absorbing, # real for non-absorbing) m_sphere = 1.5 + 0.01j  # Example for slightly absorbing particles  # Define the wavelength of the incident light in nanometers wavelength = 550.0  # Create a linearly spaced array of particle diameters in nanometers # From 100 nm to 300 nm, 50 sizes diameter_sizes = np.linspace(100.0, 500.0, 50)  # Simulate a number concentration for each particle size in #/cm\u00b3 # Decreasing concentration from 1000 to 500 #/cm\u00b3 number_per_cm3 = np.linspace(1000.0, 500.0, 50)  # Refractive index of the surrounding medium (e.g., air) n_medium = 1.0   # Calculate the Mie scattering parameters for the given size distribution mie_results = mie_bulk.mie_size_distribution(     m_sphere=m_sphere,     wavelength=wavelength,     diameter=diameter_sizes,     number_per_cm3=number_per_cm3,     n_medium=n_medium,     as_dict=True )  # Print or process the Mie scattering results  for key, value in mie_results.items():     print(f\"{key:&lt;8}: {value}\") <pre>b_ext   : 5024.182718003773\nb_sca   : 4784.810191293377\nb_abs   : 239.3725267103955\nG       : 0.6715751320242711\nb_pr    : 1810.8231820748451\nb_back  : 657.8815183489643\nb_ratio : 584.2817024545769\n</pre> In\u00a0[10]: Copied! <pre>help(mie_bulk.discretize_auto_mieq)\n</pre> help(mie_bulk.discretize_auto_mieq) <pre>Help on _lru_cache_wrapper in module particula.data.process.mie_bulk:\n\ndiscretize_auto_mieq(m_sphere: Union[complex, float], wavelength: float, diameter: float, m_medium: float = 1.0) -&gt; Tuple[float, ...]\n    Computes Mie coefficients for a spherical particle based on its material\n    properties, size, and the properties of the surrounding medium.\n    \n    This function leverages the PyMieScatt library to calculate the extinction\n    (q_ext), scattering (q_sca), absorption (q_abs) efficiencies, the\n    asymmetry factor (g), radiation pressure efficiency (q_pr), backscatter\n    efficiency (q_back), and the ratio of backscatter to extinction efficiency\n    (q_ratio) for a single sphere under specified conditions.\n    \n    This function is optimized with an LRU (Least Recently Used) cache to\n    enhance performance by storing up to 100,000 recent calls. The cache\n    memorizes the results of expensive function calls and returns the cached\n    result when the same inputs occur again, reducing the need to recompute\n    these values.\n    \n    Args\n    ----------\n    m_sphere : The complex refractive index of the sphere. For non-absorbing\n        material a real number can be provided.\n    wavelength : The wavelength of the incident light in nanometers (nm).\n    diameter : The diameter of the sphere in nanometers (nm).\n    mMedium : The refractive index of the surrounding medium.\n        Defaults to 1.0, corresponding to vacuum.\n    \n    Returns\n    -------\n    Tuple[float, float, float, float, float, float, float]\n        A tuple containing the calculated Mie efficiencies and parameters:\n        q_ext (extinction efficiency), q_sca (scattering efficiency),\n        q_abs (absorption efficiency), g (asymmetry factor),\n        q_pr (radiation pressure efficiency), q_back (backscatter efficiency),\n        and q_ratio (the ratio of backscatter to extinction efficiency).\n\n</pre> In\u00a0[11]: Copied! <pre>help(mie_bulk.mie_size_distribution)\n</pre> help(mie_bulk.mie_size_distribution) <pre>Help on function mie_size_distribution in module particula.data.process.mie_bulk:\n\nmie_size_distribution(m_sphere: Union[complex, float], wavelength: float, diameter: numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]], number_per_cm3: numpy.ndarray[typing.Any, numpy.dtype[numpy.float64]], n_medium: float = 1.0, pms: bool = True, as_dict: bool = False, extinction_only: bool = False, discretize: bool = False, truncation_calculation: bool = False, truncation_b_sca_multiple: Optional[float] = None) -&gt; Union[numpy.ndarray[Any, numpy.dtype[numpy.float64]], dict[str, numpy.ndarray[Any, numpy.dtype[numpy.float64]]], Tuple[numpy.ndarray[Any, numpy.dtype[numpy.float64]], ...]]\n    Calculates Mie scattering parameters for a size distribution of spherical\n    particles.\n    \n    This function computes optical properties such as extinction, scattering,\n    absorption coefficients, asymmetry factor, backscatter efficiency, and\n    their ratios for a given size distribution of spherical particles. It\n    supports various modes of calculation, including discretization of input\n    parameters and optional truncation of the scattering efficiency.\n    \n    Parameters\n    ----------\n    m_sphere : Union[complex, float]\n        The complex refractive index of the particles. Real values can be used\n        for non-absorbing materials.\n    wavelength : float\n        The wavelength of the incident light in nanometers (nm).\n    diameter : NDArray[np.float64]\n        An array of particle diameters in nanometers (nm).\n    number_per_cm3 : NDArray[np.float64]\n        The number distribution of particles per cubic centimeter (#/cm^3).\n    n_medium : float, optional\n        The refractive index of the medium. Defaults to 1.0 (air or vacuum).\n    pms : bool, optional\n        Specifies if the size distribution is in probability mass form.\n    as_dict : bool, optional\n        If True, results are returned as a dictionary. Otherwise, as a tuple.\n    extinction_only : bool, optional\n        If True, only the extinction coefficient is calculated and returned.\n    discretize : bool, optional\n        If True, input parameters (m, wavelength, dp) are discretized for\n        computation. Defaults to False.\n    truncation_calculation : bool, optional\n        Enables truncation of the scattering efficiency based on a multiple\n        of the backscattering coefficient. Defaults to False.\n    truncation_b_sca_multiple : Optional[float], optional\n        The multiple of the backscattering coefficient used for truncating the\n        scattering efficiency. Required if `truncation_calculation` is True.\n    \n    Returns\n    -------\n    Union[float, Dict[str, float], Tuple[float, ...]]\n        Depending on the parameters `asDict` and `extinction_only`, the\n        function can return:\n        - A single float (extinction coefficient) if `extinction_only` is True.\n        - A dictionary of computed optical properties if `asDict` is True.\n        - A tuple of computed optical properties.\n    \n    Raises\n    ------\n    ValueError\n        If `truncation_calculation` is True but `truncation_b_sca_multiple`\n        is not specified.\n\n</pre>"},{"location":"How-To-Guides/Light_Scattering/notebooks/mie_basics/#mie-scattering","title":"Mie Scattering\u00b6","text":"<p>Mie scattering is the scattering of light by spherical particles. It is named after the German physicist Gustav Mie. The Mie solution to Maxwell's equations is an exact solution that describes the scattering of electromagnetic radiation by a sphere. Here we will discuss our integration (wrapper) of the pyMieScatt package, which is a Python implementation of the Mie solution.</p> <p>We have built this wrapper for two main reasons:</p> <ol> <li>Reduce the complexity of calling the original package so integrations with data analysis is easier.</li> <li>The codification of data types in the interface. This also allows for Least Recently Used cache (<code>lru_cache</code>) to be used, which is a Python decorator that caches the results of a function, so if the function is called with the same arguments, the result is returned from the cache instead of calling the function again. This only works if the arguments types are hashable, so immutable.</li> </ol> <p>The following imports are needed</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/mie_basics/#mie-coefficients-discretize_auto_mieq","title":"Mie Coefficients: <code>discretize_auto_mieq</code>\u00b6","text":"<p>The <code>discretize_auto_mieq</code> function plays a critical role our interface with pyMieScatt, by computing Mie coefficients for a spherical particle. These coefficients are pivotal in understanding how light interacts with particles in the atmosphere, influencing phenomena such as visibility, climate change, and radiative forcing.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/mie_basics/#function-overview","title":"Function Overview\u00b6","text":"<p>This function utilizes the PyMieScatt library to derive several key efficiencies and factors for a single sphere, given its material properties, size, and the surrounding medium's properties. By leveraging an LRU (Least Recently Used) cache, <code>discretize_auto_mieq</code> significantly enhances performance for repetitive calculations, storing up to 100,000 recent calls to avoid recalculating identical inputs.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/mie_basics/#parameters","title":"Parameters\u00b6","text":"<ul> <li><p><code>m_sphere</code>: Complex or real refractive index of the sphere. Real numbers can be used for non-absorbing materials, while complex numbers account for both the real and imaginary parts of the refractive index, representing absorption characteristics.</p> </li> <li><p><code>wavelength</code>: Wavelength of the incident light, specified in nanometers (nm). This parameter is crucial as Mie scattering varies with wavelength, affecting how light is scattered or absorbed by particles.</p> </li> <li><p><code>diameter</code>: Diameter of the spherical particle in nanometers (nm). Particle size relative to the wavelength influences scattering behavior, making this a key parameter in Mie theory.</p> </li> <li><p><code>m_medium</code> (optional): Refractive index of the medium surrounding the particle, defaulting to 1.0 to represent a vacuum. This context is important for accurately modeling light-particle interactions in various environments.</p> </li> </ul>"},{"location":"How-To-Guides/Light_Scattering/notebooks/mie_basics/#returns","title":"Returns\u00b6","text":"<p>A tuple containing the calculated Mie efficiencies and parameters:</p> <ul> <li><p><code>q_ext</code>: Extinction efficiency, representing the fraction of light extinguished (either absorbed or scattered) by the particle.</p> </li> <li><p><code>q_sca</code>: Scattering efficiency, indicating the fraction of light scattered by the particle.</p> </li> <li><p><code>q_abs</code>: Absorption efficiency, showing the fraction of light absorbed by the particle.</p> </li> <li><p><code>g</code>: Asymmetry factor, describing the average cosine of the scattering angle, which influences the directionality of scattering.</p> </li> <li><p><code>q_pr</code>: Radiation pressure efficiency, quantifying the momentum transfer from the light to the particle, affecting particle movement.</p> </li> <li><p><code>q_back</code>: Backscatter efficiency, indicating the fraction of light scattered in directions reverse to the incident light.</p> </li> <li><p><code>q_ratio</code>: The ratio of backscatter to extinction efficiency, useful for understanding reflective properties.</p> </li> </ul>"},{"location":"How-To-Guides/Light_Scattering/notebooks/mie_basics/#the-mie_size_distribution-function","title":"The <code>mie_size_distribution</code> Function\u00b6","text":"<p>The <code>mie_size_distribution</code> function extends the capabilities of single-particle Mie scattering calculations to entire particle size distributions, providing a comprehensive view of aerosol optical properties. This section focuses on the new variables introduced in this function, which enable it to handle distributions and offer various modes of computation.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/mie_basics/#new-variables-explained","title":"New Variables Explained\u00b6","text":"<ul> <li><p><code>number_per_cm3</code>: This array represents the number distribution of particles per cubic centimeter for each diameter in the size distribution. It's crucial for calculating the collective optical properties of the particle ensemble, allowing for a more accurate representation of aerosol behavior in the atmosphere.</p> </li> <li><p><code>n_medium</code>: The refractive index of the medium surrounding the particles, with a default value of 1.0, representing air or vacuum. This parameter is essential for adjusting the Mie scattering calculations based on the medium's optical properties.</p> </li> <li><p><code>pms</code> (Probability Mass Function): A boolean flag indicating whether the size distribution is provided in the form of a probability mass function. When <code>True</code>, it signifies that the <code>number_per_cm3</code> array represents a binned distribution (sum of bins is total number), affecting how the bulk optical properties are computed. When <code>False</code>, the function assumes the array represents a continuous probability density function, where the area under the curve is equal to total particle number.</p> </li> <li><p><code>as_dict</code>: This boolean flag determines the format of the function's output. If set to <code>True</code>, the function returns a dictionary containing the calculated optical properties, providing a convenient structure for accessing specific values.</p> </li> <li><p><code>extinction_only</code>: When set to <code>True</code>, this flag limits the calculations to only the extinction coefficient, simplifying the output for applications focused solely on particle extinction properties.</p> </li> <li><p><code>discretize</code>: This flag enables the discretization of input parameters (<code>m_sphere</code>, <code>wavelength</code>, <code>diameter</code>) for potentially improved calculation stability and performance. Discretization can introduce computational errors by truncating the significant digits.</p> </li> <li><p><code>truncation_calculation</code>: A boolean flag that, when <code>True</code>, activates the truncation of the scattering efficiency calculation. This adjustment is based on a multiple of the backscattering coefficient, addressing truncation errors inherent in certain measurement instruments.</p> </li> <li><p><code>truncation_b_sca_multiple</code>: An optional float specifying the multiple of the scattering coefficient used for truncating the scattering efficiency. This parameter is required if <code>truncation_calculation</code> is <code>True</code> and is key to accurately correcting for instrument truncation effects.</p> </li> </ul>"},{"location":"How-To-Guides/Light_Scattering/notebooks/mie_basics/#practical-implications","title":"Practical Implications\u00b6","text":"<p>These variables introduce flexibility and precision into aerosol optics modeling, allowing for detailed analysis of particle distributions under varying environmental conditions and measurement setups. By adjusting these parameters, we can simulate a wide range of atmospheric particles, enhancing our understanding of aerosol impacts on climate and air quality.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/mie_basics/#note","title":"Note\u00b6","text":"<p>This is also where we deviate from <code>pyMieScatt</code>, as this is now not a wrapper of the same functions in the original package, but a new function that calls the underlining <code>discretize_auto_mieq</code>. We then calculate the results with more flexibility.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/mie_basics/#summary","title":"Summary\u00b6","text":"<p>The provided code segments form a foundational framework for analyzing aerosol optics, specifically through the calculation of Mie scattering parameters. This framework includes:</p> <ol> <li><p>Discretization of Mie Coefficients (<code>discretize_auto_mieq</code>): This function computes essential Mie scattering parameters such as extinction, scattering, absorption efficiencies, the asymmetry factor, radiation pressure efficiency, backscatter efficiency, and the ratio of backscatter to extinction efficiency for spherical particles. It leverages the PyMieScatt library for calculations and optimizes performance with an LRU cache, effectively reducing computational overhead for repeated calculations.</p> </li> <li><p>Mie Scattering for Size Distributions (<code>mie_size_distribution</code>): Extending the application to aerosol size distributions, this function calculates optical properties across a range of particle sizes. It supports various modes of operation, including discretization of input parameters for improved computational performance and optional truncation of scattering efficiencies. The function can output results as either a dictionary or a tuple, accommodating different analytical needs.</p> </li> <li><p>Example Usage with Linearly Spaced Size Distribution: Demonstrated how to apply the <code>mie_size_distribution</code> function to a linearly spaced array of particle diameters, simulating a realistic aerosol size distribution. This example showcases how to generate a size distribution, calculate Mie scattering parameters for it, and then access these parameters for further analysis.</p> </li> </ol>"},{"location":"How-To-Guides/Light_Scattering/notebooks/mie_basics/#building-blocks-for-advanced-analysis","title":"Building Blocks for Advanced Analysis\u00b6","text":"<p>These components serve as critical building blocks for more advanced analyses, particularly in studying the next section: Humidified Particle Scattering. In real atmospheric conditions, aerosol particles often undergo hygroscopic growth, absorbing water from the air and increasing in size. This water uptake significantly affects the optical properties of aerosols, influencing their scattering and absorption behaviors and, consequently, their impact on climate and visibility.</p> <p>The code and methodologies discussed provide a starting point for such advanced analyses, enabling the exploration of how aerosol optical properties change with humidity. This understanding is crucial for accurately assessing aerosols' environmental and climatic impacts, highlighting the importance of these computational tools in atmospheric sciences.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/scattering_truncation/","title":"Scattering Truncation Corrections","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# particula imports\nfrom particula.next.particles.properties.lognormal_size_distribution import lognormal_pmf_distribution\nfrom particula.data.process import scattering_truncation\n</pre> import numpy as np import matplotlib.pyplot as plt  # particula imports from particula.next.particles.properties.lognormal_size_distribution import lognormal_pmf_distribution from particula.data.process import scattering_truncation  In\u00a0[2]: Copied! <pre># Define the refractive index of the aerosol particle and the light wavelength\nm_sphere = 1.5  # Refractive index of the particle\nwavelength = 450.0  # Wavelength of incident light in nanometers (nm)\n\n# Perform the truncation correction for a single particle of a given diameter\ntrunc_corr, z_axis, qsca_trunc, qsca_ideal, theta1, theta2 = scattering_truncation.trunc_mono(\n    m_sphere=m_sphere,  # Refractive index of the particle\n    wavelength=wavelength,  # Wavelength of incident light\n    diameter=100,  # Diameter of the particle in nanometers\n    full_output=True,  # Request full output for detailed analysis\n    calibrated_trunc=True\n)\n\n# Output the calculated scattering efficiencies and truncation correction\n# factor\nprint(f\"Ideal Q_sca: {qsca_ideal} for a perfect instrument\")\nprint(f\"Truncated Q_sca: {qsca_trunc} for a truncated CAPS instrument\")\nprint(f\"Truncation correction factor: {trunc_corr}\")\n</pre> # Define the refractive index of the aerosol particle and the light wavelength m_sphere = 1.5  # Refractive index of the particle wavelength = 450.0  # Wavelength of incident light in nanometers (nm)  # Perform the truncation correction for a single particle of a given diameter trunc_corr, z_axis, qsca_trunc, qsca_ideal, theta1, theta2 = scattering_truncation.trunc_mono(     m_sphere=m_sphere,  # Refractive index of the particle     wavelength=wavelength,  # Wavelength of incident light     diameter=100,  # Diameter of the particle in nanometers     full_output=True,  # Request full output for detailed analysis     calibrated_trunc=True )  # Output the calculated scattering efficiencies and truncation correction # factor print(f\"Ideal Q_sca: {qsca_ideal} for a perfect instrument\") print(f\"Truncated Q_sca: {qsca_trunc} for a truncated CAPS instrument\") print(f\"Truncation correction factor: {trunc_corr}\") <pre>Ideal Q_sca: 0.5478174528225519 for a perfect instrument\nTruncated Q_sca: 0.5363833503036404 for a truncated CAPS instrument\nTruncation correction factor: 0.99888593093735\n</pre> In\u00a0[3]: Copied! <pre># Generating diameters in lin space from 50 nm to 1000 nm with 200 points\ndiameters = np.linspace(50, 2000, 100)\n\ntruncation_array = scattering_truncation.truncation_for_diameters(\n    m_sphere=m_sphere,\n    wavelength=wavelength,\n    diameter_sizes=diameters,\n    discretize=False,\n    calibrated_trunc=True\n)\n\n# Plot the truncation correction factor as a function of particle diameter\nplt.figure()\nplt.plot(diameters, truncation_array, '.')\nplt.xlabel('Particle diameter (nm)')\nplt.ylabel('Truncation correction factor')\nplt.title('Truncation correction factor as a function of particle diameter')\nplt.show()\n</pre> # Generating diameters in lin space from 50 nm to 1000 nm with 200 points diameters = np.linspace(50, 2000, 100)  truncation_array = scattering_truncation.truncation_for_diameters(     m_sphere=m_sphere,     wavelength=wavelength,     diameter_sizes=diameters,     discretize=False,     calibrated_trunc=True )  # Plot the truncation correction factor as a function of particle diameter plt.figure() plt.plot(diameters, truncation_array, '.') plt.xlabel('Particle diameter (nm)') plt.ylabel('Truncation correction factor') plt.title('Truncation correction factor as a function of particle diameter') plt.show() In\u00a0[5]: Copied! <pre># Define the refractive index and wavelength for the aerosols\nm_sphere = 1.5\nwavelength = 450.0  # in nanometers\n\n# Generate diameters using a log-spaced array for better representation\ndiameters = np.logspace(np.log10(50), np.log10(800), 100)  # From 50 nm to 800 nm\n\n# Parameters for the log-normal size distribution\nsigma = 1.4  # Geometric standard deviation\nmodes = 250  # Peak diameter for monomodal distribution\nnumber_total = 1e3  # Total number of particles\n\nnumber_conc = lognormal_pmf_distribution(\n    x_values=diameters,\n    mode=np.array([modes]),\n    geometric_standard_deviation=np.array([sigma]),\n    number_of_particles=np.array([number_total])\n)\n\n# Calculate the truncation correction for the entire size distribution\ntrunc_correction = scattering_truncation.correction_for_distribution(\n    m_sphere=m_sphere,\n    wavelength=wavelength,\n    diameter_sizes=diameters,\n    number_per_cm3=number_conc,\n    discretize=True\n)\n\n# Visualize the size distribution and truncation correction\nplt.figure()\nplt.plot(diameters, number_conc, label=\"Size Distribution\")\nplt.xlabel('Particle Diameter (nm)')\nplt.ylabel('Number Concentration (#/cm\u00b3)')\nplt.title(f\"Truncation Correction: {trunc_correction:.5f} for the entire distribution\")\nplt.legend()\nplt.show()\n\nprint(f\"Overall truncation correction for the distribution: {trunc_correction}\")\n</pre> # Define the refractive index and wavelength for the aerosols m_sphere = 1.5 wavelength = 450.0  # in nanometers  # Generate diameters using a log-spaced array for better representation diameters = np.logspace(np.log10(50), np.log10(800), 100)  # From 50 nm to 800 nm  # Parameters for the log-normal size distribution sigma = 1.4  # Geometric standard deviation modes = 250  # Peak diameter for monomodal distribution number_total = 1e3  # Total number of particles  number_conc = lognormal_pmf_distribution(     x_values=diameters,     mode=np.array([modes]),     geometric_standard_deviation=np.array([sigma]),     number_of_particles=np.array([number_total]) )  # Calculate the truncation correction for the entire size distribution trunc_correction = scattering_truncation.correction_for_distribution(     m_sphere=m_sphere,     wavelength=wavelength,     diameter_sizes=diameters,     number_per_cm3=number_conc,     discretize=True )  # Visualize the size distribution and truncation correction plt.figure() plt.plot(diameters, number_conc, label=\"Size Distribution\") plt.xlabel('Particle Diameter (nm)') plt.ylabel('Number Concentration (#/cm\u00b3)') plt.title(f\"Truncation Correction: {trunc_correction:.5f} for the entire distribution\") plt.legend() plt.show()  print(f\"Overall truncation correction for the distribution: {trunc_correction}\") <pre>Overall truncation correction for the distribution: 1.0416062342287757\n</pre> In\u00a0[6]: Copied! <pre># Define the refractive index and wavelength for the aerosols\nm_sphere = 1.5\nwavelength = 450.0  # in nanometers\n\n# Generate diameters using a log-spaced array for better representation\ndiameters = np.logspace(\n    np.log10(200),\n    np.log10(2500),\n    100)  # From 50 nm to 800 nm\n\n# Parameters for the log-normal size distribution\nsigma = 1.4  # Geometric standard deviation\nmodes = 1000  # Peak diameter for monomodal distribution\nnumber_total = 1e3  # Total number of particles\n\n# Create a log-normal size distribution\nnumber_conc_large = lognormal_pmf_distribution(\n    x_values=diameters,\n    mode=np.array([modes]),\n    geometric_standard_deviation=np.array([sigma]),\n    number_of_particles=np.array([number_total])\n)\n\n# Calculate the truncation correction for the entire size distribution\ntrunc_correction = scattering_truncation.correction_for_distribution(\n    m_sphere=m_sphere,\n    wavelength=wavelength,\n    diameter_sizes=diameters,\n    number_per_cm3=number_conc_large,\n    discretize=True\n)\n\n# Visualize the size distribution and truncation correction\nplt.figure()\nplt.plot(diameters, number_conc_large, label=\"Size Distribution\")\nplt.xlabel('Particle Diameter (nm)')\nplt.ylabel('Number Concentration (#/cm\u00b3)')\nplt.title(f\"Truncation Correction: {trunc_correction:.5f} for the entire distribution\")\nplt.legend()\nplt.show()\n\nprint(f\"Overall truncation correction for the distribution: {trunc_correction}\")\n</pre> # Define the refractive index and wavelength for the aerosols m_sphere = 1.5 wavelength = 450.0  # in nanometers  # Generate diameters using a log-spaced array for better representation diameters = np.logspace(     np.log10(200),     np.log10(2500),     100)  # From 50 nm to 800 nm  # Parameters for the log-normal size distribution sigma = 1.4  # Geometric standard deviation modes = 1000  # Peak diameter for monomodal distribution number_total = 1e3  # Total number of particles  # Create a log-normal size distribution number_conc_large = lognormal_pmf_distribution(     x_values=diameters,     mode=np.array([modes]),     geometric_standard_deviation=np.array([sigma]),     number_of_particles=np.array([number_total]) )  # Calculate the truncation correction for the entire size distribution trunc_correction = scattering_truncation.correction_for_distribution(     m_sphere=m_sphere,     wavelength=wavelength,     diameter_sizes=diameters,     number_per_cm3=number_conc_large,     discretize=True )  # Visualize the size distribution and truncation correction plt.figure() plt.plot(diameters, number_conc_large, label=\"Size Distribution\") plt.xlabel('Particle Diameter (nm)') plt.ylabel('Number Concentration (#/cm\u00b3)') plt.title(f\"Truncation Correction: {trunc_correction:.5f} for the entire distribution\") plt.legend() plt.show()  print(f\"Overall truncation correction for the distribution: {trunc_correction}\") <pre>Overall truncation correction for the distribution: 1.1821845913839402\n</pre>"},{"location":"How-To-Guides/Light_Scattering/notebooks/scattering_truncation/#scattering-truncation-corrections","title":"Scattering Truncation Corrections\u00b6","text":"<p>The study of aerosol optical properties, such as Single Scattering Albedo (SSA), plays a crucial role in understanding the effects of aerosols on climate and air quality. SSA, a measure of the fraction of light scattered by particles relative to the total light extinction (scattering plus absorption), is essential for assessing aerosol radiative forcing. Instruments like the Cavity Attenuated Phase Shift (CAPS) SSA instrument are pivotal in making these measurements with high accuracy and reliability. However, one of the critical challenges in accurately determining SSA, especially with the CAPS instrument, is the phenomenon of scattering truncation.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/scattering_truncation/#the-importance-of-correcting-for-scattering-truncation","title":"The Importance of Correcting for Scattering Truncation\u00b6","text":"<p>Scattering truncation occurs due to the limited angular range over which scattering measurements can be made, leading to an underestimation of the total scattering by aerosol particles. This limitation is particularly pronounced in instruments like the CAPS, where the design inherently restricts the detection of scattered light to a finite angular range (missing some back scatter and forward scattering light). The consequence of this truncation is a potential bias (low) in the measured SSA values, which can significantly affect the interpretation of aerosol optical properties and, by extension, their climatic and environmental impacts.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/scattering_truncation/#size-dependent-nature-of-scattering-truncation","title":"Size-Dependent Nature of Scattering Truncation\u00b6","text":"<p>The extent of scattering truncation is not uniform across all particle sizes; rather, it exhibits a pronounced size dependency. This variation arises because the scattering efficiency and the angular distribution of scattered light are functions of particle size relative to the wavelength of the incident light. Smaller particles tend to scatter light more isotropically, while larger particles preferentially scatter light in the forward direction. As a result, instruments with limited angular detection ranges may miss a substantial portion of the forward-scattered light from larger particles, leading to more significant truncation effects for these particle sizes.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/scattering_truncation/#addressing-the-challenge","title":"Addressing the Challenge\u00b6","text":"<p>Correcting for scattering truncation is thus vital for ensuring the accuracy of SSA measurements and, by extension, our understanding of aerosol optical properties. This notebook focuses on methodologies for correcting scattering truncation effects in SSA measurements made using the CAPS instrument. By implementing these corrections, we aim to achieve more accurate and representative SSA values, enhancing our ability to model and predict aerosol impacts on atmospheric processes.</p> <p>The following sections will delve into scattering truncation, explore its size-dependent characteristics, and introduce correction techniques tailored to the CAPS SSA instrument.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/scattering_truncation/#addressing-scattering-truncation-for-single-particle-measurements","title":"Addressing Scattering Truncation for Single Particle Measurements\u00b6","text":"<p>In the quest to accurately assess aerosol optical properties using the Cavity Attenuated Phase Shift (CAPS) SSA instrument, accounting for scattering truncation is paramount. Scattering truncation arises due to the instrument's limited angular range in capturing scattered light, necessitating corrections to obtain true scattering coefficients. This section introduces the methodology to correct for scattering truncation for a single aerosol particle using the <code>scattering_truncation.trunc_mono</code> function.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/scattering_truncation/#implementing-truncation-correction-with-python","title":"Implementing Truncation Correction with Python\u00b6","text":"<p>The process begins by defining the optical properties of the particle (refractive index and wavelength) and calculating both the ideal (untruncated) and the actual (truncated) scattering efficiencies. We then determine the correction factor needed to adjust for the truncation effect observed with the CAPS instrument.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/scattering_truncation/#insights-from-truncation-correction","title":"Insights from Truncation Correction\u00b6","text":"<ul> <li><p>Ideal vs. Truncated Scattering Efficiency: The <code>qsca_ideal</code> output represents the scattering efficiency as if measured by a perfect instrument with no angular limitations. In contrast, <code>qsca_trunc</code> reflects the efficiency as captured by the CAPS instrument, which is inherently limited by scattering truncation.</p> </li> <li><p>Correction Factor: The <code>trunc_corr</code> value indicates the factor by which the measured (truncated) scattering efficiency needs to be adjusted to align with the ideal, untruncated scenario. This correction is crucial for accurately interpreting SSA measurements and understanding aerosol scattering behaviors.</p> </li> </ul> <p>This correction approach for a single particle lays the groundwork for more comprehensive analyses.</p> <p>Note: The <code>calibrated_trunc</code> boolean applies an additional correction factor of 1.0224, so at a 150 nm diameter the truncation correction is 1. This factor is numerically determined and it is not clear where this error is introduced in the angular truncation calculation.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/scattering_truncation/#full-size-dependence-of-truncation","title":"Full Size Dependence of Truncation\u00b6","text":"<p>The size-dependent nature of scattering truncation necessitates a thorough understanding of how the phenomenon varies across different particle sizes. This section explores the full size dependence of scattering truncation and introduces the <code>scattering_truncation.truncation_for_diameters</code> function to correct for truncation effects across a range of particle sizes.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/scattering_truncation/#correcting-scattering-truncation-250-nm-distribution","title":"Correcting Scattering Truncation 250 nm Distribution\u00b6","text":"<p>Aerosol populations in the atmosphere exhibit a broad range of particle sizes, each contributing distinctively to the overall optical scattering properties. This section demonstrates the application of the <code>scattering_truncation.correction_for_distribution</code> function, which facilitates the adjustment for scattering truncation across an aerosol size distributions measurement.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/scattering_truncation/#generating-a-representative-aerosol-distribution","title":"Generating a Representative Aerosol Distribution\u00b6","text":"<p>For this analysis, we focus on a distribution centered around 250 nm, a size range significant for many atmospheric aerosol studies. We simulate this aerosol population using a log-normal distribution, a common representation for atmospheric aerosol size distributions.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/scattering_truncation/#correcting-scattering-truncation-1000-nm-distribution","title":"Correcting Scattering Truncation 1000 nm Distribution\u00b6","text":"<p>In addition to the 250 nm distribution, we also explore the correction of scattering truncation for a larger aerosol population centered around 1000 nm. This size range is particularly relevant for understanding the scattering properties of coarse-mode aerosols, which play a crucial role in atmospheric processes.</p> <p>The truncation factor is much larger for the 1000 nm distribution, indicating the more significant impact of truncation for larger particles. This underscores the importance of accounting for scattering truncation across the full range of aerosol sizes to obtain accurate SSA measurements.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/scattering_truncation/#summary","title":"Summary\u00b6","text":"<p>Understanding the climatic and environmental impacts of aerosols necessitates accurate determinations of their optical properties, especially Single Scattering Albedo (SSA). The challenge of scattering truncation, however, complicates the precise measurement of SSA, a dilemma particularly pronounced with the use of the Cavity Attenuated Phase Shift (CAPS) SSA instrument. Throughout this notebook, we have explored and applied methodologies to correct for the effects of scattering truncation, delving into its size-dependent characteristics and the broader implications for accurately assessing SSA.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/scattering_truncation/#addressing-humidified-aerosol-measurements","title":"Addressing Humidified Aerosol Measurements\u00b6","text":"<p>Our exploration does extend to humidified aerosol measurements, where changes in particle refractive index and diameter under varying humidity levels introduce additional complexity. The <code>scattering_truncation</code> module, through its <code>correction_for_humidified</code> and <code>correction_for_humidified_looped</code> functions, offers robust solutions for incorporating these dynamic factors into SSA calculations, ensuring that measurements remain reflective of actual atmospheric conditions.</p>"},{"location":"How-To-Guides/Light_Scattering/notebooks/scattering_truncation/#leveraging-truncation-corrections-for-broader-applications","title":"Leveraging Truncation Corrections for Broader Applications\u00b6","text":"<p>The adaptability of these correction techniques to a wide range of real-world aerosol distributions highlights their significance. Aerosols in the atmosphere exhibit a vast diversity in size, composition, and behavior, necessitating flexible and accurate measurement and analysis methods. By enhancing the precision of SSA and other optical property measurements, we lay a stronger foundation for atmospheric modeling, contributing to more reliable predictions of aerosol impacts on climate and environmental health.</p>"},{"location":"How-To-Guides/Nucleation/","title":"Nucleation","text":"<ul> <li>Single Species</li> </ul>"},{"location":"How-To-Guides/Nucleation/Notebooks/Custom_Nucleation_Single_Species/","title":"Custom Nucleation: Single Species","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# particula imports\nfrom particula.next import particles, dynamics\nfrom particula.next.aerosol import Aerosol\n\n# Gas phase species and atmosphere builders\nfrom particula.next.gas.species_builders import GasSpeciesBuilder\nfrom particula.next.gas.atmosphere_builders import AtmosphereBuilder\n\n# Vapor pressure factory for calculating vapor pressures\nfrom particula.next.gas.vapor_pressure_factories import VaporPressureFactory\n\nfrom particula.util.input_handling import convert_units\n</pre> import numpy as np import matplotlib.pyplot as plt  # particula imports from particula.next import particles, dynamics from particula.next.aerosol import Aerosol  # Gas phase species and atmosphere builders from particula.next.gas.species_builders import GasSpeciesBuilder from particula.next.gas.atmosphere_builders import AtmosphereBuilder  # Vapor pressure factory for calculating vapor pressures from particula.next.gas.vapor_pressure_factories import VaporPressureFactory  from particula.util.input_handling import convert_units In\u00a0[2]: Copied! <pre># Build the sulfate gas species\n\n# Ammonium sulfate properties\nmolar_mass_ammonium_sulfate = 132.14e-3  # kg/mol\ndensity_ammonium_sulfate = 1.77e3  # kg/m^3\n\n# Define vapor pressure parameters for ammonium sulfate\nparameters_vapor = {\n    \"vapor_pressure\": 4e-12,  # pascal\n    \"vapor_pressure_units\": \"atm\",  # units\n}\n\n# Create a constant vapor pressure strategy using the VaporPressureFactory\nvapor_pressure_sulfate = VaporPressureFactory().get_strategy(\n    \"constant\", parameters_vapor\n)\n\n# Calculate the saturation concentration at a given temperature\nsulfate_saturation = vapor_pressure_sulfate.saturation_concentration(\n    molar_mass=molar_mass_ammonium_sulfate,\n    temperature=298.15,  # Kelvin\n)\n\n# Set initial sulfate concentration as a fraction of saturation concentration\ninitial_sulfate_concentration = 0.5 * sulfate_saturation  # kg/m^3\n\n# Build the sulfate gas species using the GasSpeciesBuilder\ngas_sulfate = (\n    GasSpeciesBuilder()\n    .set_name(\"sulfate\")\n    .set_molar_mass(molar_mass_ammonium_sulfate, \"kg/mol\")\n    .set_condensable(True)\n    .set_vapor_pressure_strategy(vapor_pressure_sulfate)\n    .set_concentration(initial_sulfate_concentration, \"kg/m^3\")\n    .build()\n)\n\n# Build the atmosphere with the sulfate species and environmental conditions\natmosphere = (\n    AtmosphereBuilder()\n    .add_species(gas_sulfate)  # Add sulfate to the atmosphere\n    .set_temperature(25, temperature_units=\"degC\")  # Set temperature to 25\u00b0C\n    .set_pressure(1, pressure_units=\"atm\")  # Set pressure to 1 atm\n    .build()\n)\n\n# Generate a lognormal particle size distribution\nparticle_sample = particles.properties.lognormal_sample_distribution(\n    mode=np.array([400e-9]),  # Mean particle diameter of 400 nm\n    geometric_standard_deviation=np.array([1.4]),  # GSD of 1.4\n    number_of_particles=np.array(\n        [1e4]\n    ),  # Number of particles in the distribution\n    number_of_samples=100,  # Number of particle samples\n)\n\n# Calculate the mass of each particle based on its size and ammonium sulfate density\nparticle_mass_sample = (\n    4 / 3 * np.pi * particle_sample**3 * density_ammonium_sulfate  # kg\n)\n\nvolume_sim = 0.1 * convert_units(\"cm^3\", \"m^3\")  # m^3\n# Build the resolved particle mass representation for the aerosol particles\nresolved_masses = (\n    particles.ResolvedParticleMassRepresentationBuilder()\n    .set_distribution_strategy(particles.ParticleResolvedSpeciatedMass())\n    .set_activity_strategy(particles.ActivityIdealMass())\n    .set_surface_strategy(particles.SurfaceStrategyVolume())\n    .set_mass(particle_mass_sample, \"kg\")\n    .set_density(density_ammonium_sulfate, \"kg/m^3\")\n    .set_charge(0)\n    .set_volume(volume_sim, \"m^3\")\n    .build()\n)\n\n# Create the aerosol object with the atmosphere and particles\naerosol = Aerosol(atmosphere=atmosphere, particles=resolved_masses)\n\n# Print the properties of the created aerosol system\nprint(aerosol)\n</pre> # Build the sulfate gas species  # Ammonium sulfate properties molar_mass_ammonium_sulfate = 132.14e-3  # kg/mol density_ammonium_sulfate = 1.77e3  # kg/m^3  # Define vapor pressure parameters for ammonium sulfate parameters_vapor = {     \"vapor_pressure\": 4e-12,  # pascal     \"vapor_pressure_units\": \"atm\",  # units }  # Create a constant vapor pressure strategy using the VaporPressureFactory vapor_pressure_sulfate = VaporPressureFactory().get_strategy(     \"constant\", parameters_vapor )  # Calculate the saturation concentration at a given temperature sulfate_saturation = vapor_pressure_sulfate.saturation_concentration(     molar_mass=molar_mass_ammonium_sulfate,     temperature=298.15,  # Kelvin )  # Set initial sulfate concentration as a fraction of saturation concentration initial_sulfate_concentration = 0.5 * sulfate_saturation  # kg/m^3  # Build the sulfate gas species using the GasSpeciesBuilder gas_sulfate = (     GasSpeciesBuilder()     .set_name(\"sulfate\")     .set_molar_mass(molar_mass_ammonium_sulfate, \"kg/mol\")     .set_condensable(True)     .set_vapor_pressure_strategy(vapor_pressure_sulfate)     .set_concentration(initial_sulfate_concentration, \"kg/m^3\")     .build() )  # Build the atmosphere with the sulfate species and environmental conditions atmosphere = (     AtmosphereBuilder()     .add_species(gas_sulfate)  # Add sulfate to the atmosphere     .set_temperature(25, temperature_units=\"degC\")  # Set temperature to 25\u00b0C     .set_pressure(1, pressure_units=\"atm\")  # Set pressure to 1 atm     .build() )  # Generate a lognormal particle size distribution particle_sample = particles.properties.lognormal_sample_distribution(     mode=np.array([400e-9]),  # Mean particle diameter of 400 nm     geometric_standard_deviation=np.array([1.4]),  # GSD of 1.4     number_of_particles=np.array(         [1e4]     ),  # Number of particles in the distribution     number_of_samples=100,  # Number of particle samples )  # Calculate the mass of each particle based on its size and ammonium sulfate density particle_mass_sample = (     4 / 3 * np.pi * particle_sample**3 * density_ammonium_sulfate  # kg )  volume_sim = 0.1 * convert_units(\"cm^3\", \"m^3\")  # m^3 # Build the resolved particle mass representation for the aerosol particles resolved_masses = (     particles.ResolvedParticleMassRepresentationBuilder()     .set_distribution_strategy(particles.ParticleResolvedSpeciatedMass())     .set_activity_strategy(particles.ActivityIdealMass())     .set_surface_strategy(particles.SurfaceStrategyVolume())     .set_mass(particle_mass_sample, \"kg\")     .set_density(density_ammonium_sulfate, \"kg/m^3\")     .set_charge(0)     .set_volume(volume_sim, \"m^3\")     .build() )  # Create the aerosol object with the atmosphere and particles aerosol = Aerosol(atmosphere=atmosphere, particles=resolved_masses)  # Print the properties of the created aerosol system print(aerosol) <pre>Gas mixture at 298.15 K and 101325.0 Pa consisting of ['sulfate']\n[0]: Particle Representation:\n\tStrategy: ParticleResolvedSpeciatedMass\n\tActivity: ActivityIdealMass\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 8.254e-07 [kg/m^3]\n\tNumber Concentration: 1.000e+09 [#/m^3]\n</pre> In\u00a0[3]: Copied! <pre># Build the sulfate gas species\n\n# Ammonium sulfate and water vapor pressure\nmolar_mass_ammonium_sulfate = 132.14e-3  # kg/mol\ndensity_ammonium_sulfate = 1.77e3  # kg/m^3\nparameters_vapor = {\n    \"vapor_pressure\": 4e-12,  # pascal\n    \"vapor_pressure_units\": \"atm\",\n}\nvapor_pressure_sulfate = VaporPressureFactory().get_strategy(\n    \"constant\", parameters_vapor\n)\n\n# get initial vapor concentration\nsulfate_saturation = vapor_pressure_sulfate.saturation_concentration(\n    molar_mass=molar_mass_ammonium_sulfate,\n    temperature=298.15,\n)\n\ninitial_sulfate_concentration = 0.5 * sulfate_saturation\n\n\n# Create the gas species\ngas_sulfate = (\n    GasSpeciesBuilder()\n    .set_name(\"sulfate\")\n    .set_molar_mass(molar_mass_ammonium_sulfate, \"kg/mol\")\n    .set_condensable(True)\n    .set_vapor_pressure_strategy(vapor_pressure_sulfate)\n    .set_concentration(initial_sulfate_concentration, \"kg/m^3\")\n    .build()\n)\n\n# AtmosphereBuilder constructs the atmosphere with predefined species\natmosphere = (\n    AtmosphereBuilder()\n    .add_species(gas_sulfate)  # Add the sulfate gas species to the atmosphere\n    .set_temperature(25, temperature_units=\"degC\")  # Set temperature to 25\u00b0C\n    .set_pressure(1, pressure_units=\"atm\")  # Set pressure to 1 atmosphere\n    .build()  # Finalize the atmosphere object\n)\n\n# Generate a particle distribution using a lognormal sample distribution\n# This distribution has a mean particle diameter (mode) and geometric standard deviation (GSD)\nparticle_sample = particles.properties.lognormal_sample_distribution(\n    mode=np.array([400e-9]),  # Mean particle diameter of 100 nm\n    geometric_standard_deviation=np.array([1.4]),  # GSD of 1.3\n    number_of_particles=np.array([1e4]),  # Total number of particles\n    number_of_samples=100,  # Number of samples for particle distribution\n)\n\n\n# Calculate the mass of each particle in the sample\nparticle_mass_sample = (\n    4 / 3 * np.pi * particle_sample**3 * density_ammonium_sulfate\n)  # Particle mass in kg\n\n\n# Build a resolved mass representation for each particle\n# This defines how particle mass, activity, and surface are represented\nresolved_masses = (\n    particles.ResolvedParticleMassRepresentationBuilder()\n    .set_distribution_strategy(particles.ParticleResolvedSpeciatedMass())\n    .set_activity_strategy(particles.ActivityIdealMass())\n    .set_surface_strategy(particles.SurfaceStrategyVolume())\n    .set_mass(particle_mass_sample, \"kg\")\n    .set_density(density_ammonium_sulfate, \"kg/m^3\")\n    .set_charge(0)\n    .set_volume(0.1, \"cm^3\")\n    .build()\n)\n\n# # Create an aerosol object with the defined atmosphere and resolved particles\naerosol = Aerosol(atmosphere=atmosphere, particles=resolved_masses)\n\n\n# Print the properties of the atmosphere\nprint(aerosol)\n</pre> # Build the sulfate gas species  # Ammonium sulfate and water vapor pressure molar_mass_ammonium_sulfate = 132.14e-3  # kg/mol density_ammonium_sulfate = 1.77e3  # kg/m^3 parameters_vapor = {     \"vapor_pressure\": 4e-12,  # pascal     \"vapor_pressure_units\": \"atm\", } vapor_pressure_sulfate = VaporPressureFactory().get_strategy(     \"constant\", parameters_vapor )  # get initial vapor concentration sulfate_saturation = vapor_pressure_sulfate.saturation_concentration(     molar_mass=molar_mass_ammonium_sulfate,     temperature=298.15, )  initial_sulfate_concentration = 0.5 * sulfate_saturation   # Create the gas species gas_sulfate = (     GasSpeciesBuilder()     .set_name(\"sulfate\")     .set_molar_mass(molar_mass_ammonium_sulfate, \"kg/mol\")     .set_condensable(True)     .set_vapor_pressure_strategy(vapor_pressure_sulfate)     .set_concentration(initial_sulfate_concentration, \"kg/m^3\")     .build() )  # AtmosphereBuilder constructs the atmosphere with predefined species atmosphere = (     AtmosphereBuilder()     .add_species(gas_sulfate)  # Add the sulfate gas species to the atmosphere     .set_temperature(25, temperature_units=\"degC\")  # Set temperature to 25\u00b0C     .set_pressure(1, pressure_units=\"atm\")  # Set pressure to 1 atmosphere     .build()  # Finalize the atmosphere object )  # Generate a particle distribution using a lognormal sample distribution # This distribution has a mean particle diameter (mode) and geometric standard deviation (GSD) particle_sample = particles.properties.lognormal_sample_distribution(     mode=np.array([400e-9]),  # Mean particle diameter of 100 nm     geometric_standard_deviation=np.array([1.4]),  # GSD of 1.3     number_of_particles=np.array([1e4]),  # Total number of particles     number_of_samples=100,  # Number of samples for particle distribution )   # Calculate the mass of each particle in the sample particle_mass_sample = (     4 / 3 * np.pi * particle_sample**3 * density_ammonium_sulfate )  # Particle mass in kg   # Build a resolved mass representation for each particle # This defines how particle mass, activity, and surface are represented resolved_masses = (     particles.ResolvedParticleMassRepresentationBuilder()     .set_distribution_strategy(particles.ParticleResolvedSpeciatedMass())     .set_activity_strategy(particles.ActivityIdealMass())     .set_surface_strategy(particles.SurfaceStrategyVolume())     .set_mass(particle_mass_sample, \"kg\")     .set_density(density_ammonium_sulfate, \"kg/m^3\")     .set_charge(0)     .set_volume(0.1, \"cm^3\")     .build() )  # # Create an aerosol object with the defined atmosphere and resolved particles aerosol = Aerosol(atmosphere=atmosphere, particles=resolved_masses)   # Print the properties of the atmosphere print(aerosol) <pre>Gas mixture at 298.15 K and 101325.0 Pa consisting of ['sulfate']\n[0]: Particle Representation:\n\tStrategy: ParticleResolvedSpeciatedMass\n\tActivity: ActivityIdealMass\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 8.120e-07 [kg/m^3]\n\tNumber Concentration: 1.000e+09 [#/m^3]\n</pre> In\u00a0[4]: Copied! <pre># setup dynamics for condensation\ncondensation_method = dynamics.condensation.CondensationIsothermal(\n    molar_mass=molar_mass_ammonium_sulfate,\n    accommodation_coefficient=1,\n    diffusion_coefficient=2e-5,\n)\ncondensation_runnable = dynamics.MassCondensation(\n    condensation_strategy=condensation_method\n)\n# setup dynamics for coagulation\ncoagulation_runnable = dynamics.Coagulation(\n    coagulation_strategy=dynamics.coagulation.ParticleResolved()\n)\n\nstep_count = 0\n</pre> # setup dynamics for condensation condensation_method = dynamics.condensation.CondensationIsothermal(     molar_mass=molar_mass_ammonium_sulfate,     accommodation_coefficient=1,     diffusion_coefficient=2e-5, ) condensation_runnable = dynamics.MassCondensation(     condensation_strategy=condensation_method ) # setup dynamics for coagulation coagulation_runnable = dynamics.Coagulation(     coagulation_strategy=dynamics.coagulation.ParticleResolved() )  step_count = 0 <p>You can repeatedly run the next cell to see the evolution of the aerosol system.</p> In\u00a0[5]: Copied! <pre># Initialize or increment step counter\nstep_count += 1\nprint(f\"Step {step_count}\")\n\n# Define key parameters\nvapor_production = sulfate_saturation * 0.2  # Adding 20% of saturation concentration per second\nbase_nucleation_rate = 1e-8 * density_ammonium_sulfate  # Base nucleation rate in kg/m^3/s\nmass_nucleated_particle = 4/3 * np.pi * (2e-9)**3 * density_ammonium_sulfate  # Mass of a 10 nm particle in kg\nexponent_nucleation = 2  # Nucleation rate exponent (empirical)\ntime_step = 1  # Time step in seconds\n\n# 1. Add more vapor to the gas phase (e.g., by external sources)\nprint(\"Current sulfate concentration: \", aerosol.atmosphere.species[0].get_concentration())\naerosol.atmosphere.species[0].add_concentration(vapor_production * time_step)\nprint(\"New sulfate concentration: \", aerosol.atmosphere.species[0].get_concentration())\n\n# 2. Calculate the new saturation ratio for sulfate in the atmosphere\nsaturation_ratio = aerosol.atmosphere.species[0].get_saturation_ratio(temperature=298.15)\nprint(f\"Saturation ratio: {saturation_ratio}\")\n\n# 3. Calculate the nucleation rate based on the saturation ratio\n# Ensure the saturation ratio is above 1, nucleation only occurs above saturation\nsaturation_difference = np.maximum(saturation_ratio - 1, 0)  # No nucleation if S \u2264 1\n# Calculate the nucleation rate using the exponential form (custom)\n# note this is mass based, if you have a volume based nucleation rate, you need to convert it\n# to mass, as the resolved particles are mass based\nnucleation_rate = base_nucleation_rate * (saturation_difference / 500)**exponent_nucleation\nprint(f\"Nucleation rate [mass concentration per sec, kg/m^3/s]: {nucleation_rate}\")\n\n# 4. Calculate the number of new particles nucleated\n# Floor division ensures we only get whole particles\nnumber_of_new_particles = time_step * nucleation_rate // mass_nucleated_particle\nprint(f\"Number of new particles nucleated: {number_of_new_particles}\")\n\n# 5. Determine the number of resolved particles to create (based on simulation volume)\nsingle_resolved_particle = aerosol.particles[0].get_concentration().max()\nnumber_of_new_resolved_particles = int(number_of_new_particles // single_resolved_particle)\nprint(f\"Number of new resolved particles to be created: {number_of_new_resolved_particles}\")\n\n# 6. If new particles are nucleated, proceed to add them to the aerosol\nif number_of_new_resolved_particles &gt; 0:\n    # Remove nucleated mass from the gas phase to conserve mass\n    aerosol.atmosphere.species[0].add_concentration(\n        -number_of_new_resolved_particles * mass_nucleated_particle\n    )\n\n    # Create arrays to store the properties of the newly resolved particles\n    new_resolved_particle_masses = np.full(number_of_new_resolved_particles, mass_nucleated_particle)\n    new_resolved_particle_concentrations = np.ones_like(new_resolved_particle_masses)  # Concentration of 1 per particle\n\n    # Add the new resolved particles to the aerosol\n    aerosol.particles[0].add_concentration(\n        added_concentration=new_resolved_particle_concentrations,\n        added_distribution=new_resolved_particle_masses,\n    )\n\n# Print the total particle concentration before dynamics (for monitoring)\ntotal_particle_concentration = aerosol.particles[0].get_total_concentration()\nprint(f\"Total particle concentration before dynamics [#/m^3]: {total_particle_concentration}\")\n\n# 7. Perform the condensation step\ncondensation_runnable.execute(aerosol, time_step)\n\n# 8. Perform the coagulation step\ncoagulation_runnable.execute(aerosol, time_step)\n\n# Print the total particle concentration and mass after running the dynamics\ntotal_particle_concentration_after_process = aerosol.particles[0].get_total_concentration()\nprint(f\"Total particle concentration after dynamics [#/m^3]: {total_particle_concentration_after_process}\")\n\ntotal_particle_mass_after_process = aerosol.particles[0].get_mass_concentration()\nprint(f\"Total particle mass after dynamics [kg/m^3]: {total_particle_mass_after_process}\")\n\n# Retrieve and print the total number of resolved particles simulated\ntotal_resolved_particles_in_simulation = aerosol.particles[0].concentration.sum()\nprint(f\"Total resolved particles in simulation: {total_resolved_particles_in_simulation}\")\n</pre> # Initialize or increment step counter step_count += 1 print(f\"Step {step_count}\")  # Define key parameters vapor_production = sulfate_saturation * 0.2  # Adding 20% of saturation concentration per second base_nucleation_rate = 1e-8 * density_ammonium_sulfate  # Base nucleation rate in kg/m^3/s mass_nucleated_particle = 4/3 * np.pi * (2e-9)**3 * density_ammonium_sulfate  # Mass of a 10 nm particle in kg exponent_nucleation = 2  # Nucleation rate exponent (empirical) time_step = 1  # Time step in seconds  # 1. Add more vapor to the gas phase (e.g., by external sources) print(\"Current sulfate concentration: \", aerosol.atmosphere.species[0].get_concentration()) aerosol.atmosphere.species[0].add_concentration(vapor_production * time_step) print(\"New sulfate concentration: \", aerosol.atmosphere.species[0].get_concentration())  # 2. Calculate the new saturation ratio for sulfate in the atmosphere saturation_ratio = aerosol.atmosphere.species[0].get_saturation_ratio(temperature=298.15) print(f\"Saturation ratio: {saturation_ratio}\")  # 3. Calculate the nucleation rate based on the saturation ratio # Ensure the saturation ratio is above 1, nucleation only occurs above saturation saturation_difference = np.maximum(saturation_ratio - 1, 0)  # No nucleation if S \u2264 1 # Calculate the nucleation rate using the exponential form (custom) # note this is mass based, if you have a volume based nucleation rate, you need to convert it # to mass, as the resolved particles are mass based nucleation_rate = base_nucleation_rate * (saturation_difference / 500)**exponent_nucleation print(f\"Nucleation rate [mass concentration per sec, kg/m^3/s]: {nucleation_rate}\")  # 4. Calculate the number of new particles nucleated # Floor division ensures we only get whole particles number_of_new_particles = time_step * nucleation_rate // mass_nucleated_particle print(f\"Number of new particles nucleated: {number_of_new_particles}\")  # 5. Determine the number of resolved particles to create (based on simulation volume) single_resolved_particle = aerosol.particles[0].get_concentration().max() number_of_new_resolved_particles = int(number_of_new_particles // single_resolved_particle) print(f\"Number of new resolved particles to be created: {number_of_new_resolved_particles}\")  # 6. If new particles are nucleated, proceed to add them to the aerosol if number_of_new_resolved_particles &gt; 0:     # Remove nucleated mass from the gas phase to conserve mass     aerosol.atmosphere.species[0].add_concentration(         -number_of_new_resolved_particles * mass_nucleated_particle     )      # Create arrays to store the properties of the newly resolved particles     new_resolved_particle_masses = np.full(number_of_new_resolved_particles, mass_nucleated_particle)     new_resolved_particle_concentrations = np.ones_like(new_resolved_particle_masses)  # Concentration of 1 per particle      # Add the new resolved particles to the aerosol     aerosol.particles[0].add_concentration(         added_concentration=new_resolved_particle_concentrations,         added_distribution=new_resolved_particle_masses,     )  # Print the total particle concentration before dynamics (for monitoring) total_particle_concentration = aerosol.particles[0].get_total_concentration() print(f\"Total particle concentration before dynamics [#/m^3]: {total_particle_concentration}\")  # 7. Perform the condensation step condensation_runnable.execute(aerosol, time_step)  # 8. Perform the coagulation step coagulation_runnable.execute(aerosol, time_step)  # Print the total particle concentration and mass after running the dynamics total_particle_concentration_after_process = aerosol.particles[0].get_total_concentration() print(f\"Total particle concentration after dynamics [#/m^3]: {total_particle_concentration_after_process}\")  total_particle_mass_after_process = aerosol.particles[0].get_mass_concentration() print(f\"Total particle mass after dynamics [kg/m^3]: {total_particle_mass_after_process}\")  # Retrieve and print the total number of resolved particles simulated total_resolved_particles_in_simulation = aerosol.particles[0].concentration.sum() print(f\"Total resolved particles in simulation: {total_resolved_particles_in_simulation}\")  <pre>Step 1\nCurrent sulfate concentration:  1.0802192486690696e-11\nNew sulfate concentration:  1.5123069481366975e-11\nSaturation ratio: 0.7\nNucleation rate [mass concentration per sec, kg/m^3/s]: 0.0\nNumber of new particles nucleated: 0.0\nNumber of new resolved particles to be created: 0\nTotal particle concentration before dynamics [#/m^3]: 999999999.9999999\nTotal particle concentration after dynamics [#/m^3]: 999999999.9999999\nTotal particle mass after dynamics [kg/m^3]: 8.120344643329544e-07\nTotal resolved particles in simulation: 100.0\n</pre> In\u00a0[6]: Copied! <pre># Build the sulfate gas species using the GasSpeciesBuilder\ngas_sulfate = (\n    GasSpeciesBuilder()\n    .set_name(\"sulfate\")\n    .set_molar_mass(molar_mass_ammonium_sulfate, \"kg/mol\")\n    .set_condensable(True)\n    .set_vapor_pressure_strategy(vapor_pressure_sulfate)\n    .set_concentration(initial_sulfate_concentration, \"kg/m^3\")\n    .build()\n)\n\n# AtmosphereBuilder constructs the atmosphere with predefined species\natmosphere = (\n    AtmosphereBuilder()\n    .add_species(gas_sulfate)  # Add the sulfate gas species to the atmosphere\n    .set_temperature(25, temperature_units=\"degC\")  # Set temperature to 25\u00b0C\n    .set_pressure(1, pressure_units=\"atm\")  # Set pressure to 1 atmosphere\n    .build()  # Finalize the atmosphere object\n)\n# Build the resolved particle mass representation for the aerosol particles\nresolved_masses = (\n    particles.ResolvedParticleMassRepresentationBuilder()\n    .set_distribution_strategy(particles.ParticleResolvedSpeciatedMass())\n    .set_activity_strategy(particles.ActivityIdealMass())\n    .set_surface_strategy(particles.SurfaceStrategyVolume())\n    .set_mass(particle_mass_sample, \"kg\")\n    .set_density(density_ammonium_sulfate, \"kg/m^3\")\n    .set_charge(0)\n    .set_volume(0.1, \"cm^3\")\n    .build()\n)\n\n# Create the aerosol object with the atmosphere and particles\naerosol = Aerosol(atmosphere=atmosphere, particles=resolved_masses)\n\n# Print the properties of the created aerosol system\nprint(aerosol)\n\n\n# Set up time and sub-steps for the coagulation process\ntotal_time = 200\ntime_step = 1\nsub_steps = 2\n\n# bins\nbins_lognormal = np.logspace(-9, -7, 200)\n\n# output arrays\ntime = np.arange(0, total_time, time_step)\ntotal_mass_resolved = np.ones_like(time, dtype=np.float64)\nnumber_distribution_binned = np.zeros((len(time), len(bins_lognormal) - 1))\ntotal_number_resolved = np.ones_like(time, dtype=np.float64)\nsaturation_ratio_output = np.ones_like(time, dtype=np.float64)\n\nprint(f\"Total iterations to do: {len(time)*sub_steps}\")\n</pre> # Build the sulfate gas species using the GasSpeciesBuilder gas_sulfate = (     GasSpeciesBuilder()     .set_name(\"sulfate\")     .set_molar_mass(molar_mass_ammonium_sulfate, \"kg/mol\")     .set_condensable(True)     .set_vapor_pressure_strategy(vapor_pressure_sulfate)     .set_concentration(initial_sulfate_concentration, \"kg/m^3\")     .build() )  # AtmosphereBuilder constructs the atmosphere with predefined species atmosphere = (     AtmosphereBuilder()     .add_species(gas_sulfate)  # Add the sulfate gas species to the atmosphere     .set_temperature(25, temperature_units=\"degC\")  # Set temperature to 25\u00b0C     .set_pressure(1, pressure_units=\"atm\")  # Set pressure to 1 atmosphere     .build()  # Finalize the atmosphere object ) # Build the resolved particle mass representation for the aerosol particles resolved_masses = (     particles.ResolvedParticleMassRepresentationBuilder()     .set_distribution_strategy(particles.ParticleResolvedSpeciatedMass())     .set_activity_strategy(particles.ActivityIdealMass())     .set_surface_strategy(particles.SurfaceStrategyVolume())     .set_mass(particle_mass_sample, \"kg\")     .set_density(density_ammonium_sulfate, \"kg/m^3\")     .set_charge(0)     .set_volume(0.1, \"cm^3\")     .build() )  # Create the aerosol object with the atmosphere and particles aerosol = Aerosol(atmosphere=atmosphere, particles=resolved_masses)  # Print the properties of the created aerosol system print(aerosol)   # Set up time and sub-steps for the coagulation process total_time = 200 time_step = 1 sub_steps = 2  # bins bins_lognormal = np.logspace(-9, -7, 200)  # output arrays time = np.arange(0, total_time, time_step) total_mass_resolved = np.ones_like(time, dtype=np.float64) number_distribution_binned = np.zeros((len(time), len(bins_lognormal) - 1)) total_number_resolved = np.ones_like(time, dtype=np.float64) saturation_ratio_output = np.ones_like(time, dtype=np.float64)  print(f\"Total iterations to do: {len(time)*sub_steps}\") <pre>Gas mixture at 298.15 K and 101325.0 Pa consisting of ['sulfate']\n[0]: Particle Representation:\n\tStrategy: ParticleResolvedSpeciatedMass\n\tActivity: ActivityIdealMass\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 8.120e-07 [kg/m^3]\n\tNumber Concentration: 1.000e+09 [#/m^3]\nTotal iterations to do: 400\n</pre> In\u00a0[7]: Copied! <pre># Define key parameters\nvapor_production = sulfate_saturation * 0.2  # Adding 20% of saturation concentration per second\nbase_nucleation_rate = 1e-8 * density_ammonium_sulfate  # Base nucleation rate in kg/m^3/s\nmass_nucleated_particle = 4/3 * np.pi * (2e-9)**3 * density_ammonium_sulfate  # Mass of a 10 nm particle in kg\nexponent_nucleation = 2  # Nucleation rate exponent (empirical)\n\n\nfor i, t in enumerate(time):\n    if i &gt; 0:\n        # 1. Add more vapor to the gas phase (e.g., by external sources)\n        aerosol.atmosphere.species[0].add_concentration(vapor_production * time_step)\n\n        # 2. Calculate the new saturation ratio for sulfate in the atmosphere\n        saturation_ratio = aerosol.atmosphere.species[0].get_saturation_ratio(temperature=298.15)\n\n        # 3. Calculate the nucleation rate based on the saturation ratio\n        # Ensure the saturation ratio is above 1, nucleation only occurs above saturation\n        saturation_difference = np.maximum(saturation_ratio - 1, 0)  # No nucleation if S \u2264 1\n        # Calculate the nucleation rate using the exponential form (custom)\n        # note this is mass based, if you have a volume based nucleation rate, you need to convert it\n        # to mass, as the resolved particles are mass based\n        nucleation_rate = base_nucleation_rate * (saturation_difference / 500)**exponent_nucleation\n\n        # 4. Calculate the number of new particles nucleated\n        # Floor division ensures we only get whole particles\n        number_of_new_particles = time_step * nucleation_rate // mass_nucleated_particle\n\n        # 5. Determine the number of resolved particles to create (based on simulation volume)\n        single_resolved_particle = aerosol.particles[0].get_concentration().max()\n        number_of_new_resolved_particles = int(number_of_new_particles // single_resolved_particle)\n\n        # 6. If new particles are nucleated, proceed to add them to the aerosol\n        if number_of_new_resolved_particles &gt; 0:\n            # Remove nucleated mass from the gas phase to conserve mass\n            aerosol.atmosphere.species[0].add_concentration(\n                -number_of_new_resolved_particles * mass_nucleated_particle\n            )\n\n            # Create arrays to store the properties of the newly resolved particles\n            new_resolved_particle_masses = np.full(number_of_new_resolved_particles, mass_nucleated_particle)\n            new_resolved_particle_concentrations = np.ones_like(new_resolved_particle_masses)  # Concentration of 1 per particle\n\n            # Add the new resolved particles to the aerosol\n            aerosol.particles[0].add_concentration(\n                added_concentration=new_resolved_particle_concentrations,\n                added_distribution=new_resolved_particle_masses,\n            )\n\n        # 7. Perform the condensation step\n        condensation_runnable.execute(aerosol, time_step, sub_steps)\n\n        # 8. Perform the coagulation step\n        coagulation_runnable.execute(aerosol, time_step, sub_steps)\n\n    total_mass_resolved[i] = aerosol.particles[0].get_mass_concentration()\n    number_distribution = aerosol.particles[0].get_radius(clone=True)\n    number_distribution_binned[i, :], edges = np.histogram(number_distribution, bins=bins_lognormal)\n    total_number_resolved[i] = np.sum(number_distribution[i]&gt;0)\n    saturation_ratio_output[i] = aerosol.atmosphere.species[0].get_saturation_ratio(\n        temperature=298.15)\n\n    if i % 20 == 0:\n        # Retrieve and print the total number of resolved particles simulated\n        total_resolved_particles_in_simulation = aerosol.particles[0].concentration.sum()\n        print(f\"Index {i}: Total resolved particles in simulation: {total_resolved_particles_in_simulation}\")\n\n\nnumber_distribution_binned = number_distribution_binned / volume_sim\n</pre>  # Define key parameters vapor_production = sulfate_saturation * 0.2  # Adding 20% of saturation concentration per second base_nucleation_rate = 1e-8 * density_ammonium_sulfate  # Base nucleation rate in kg/m^3/s mass_nucleated_particle = 4/3 * np.pi * (2e-9)**3 * density_ammonium_sulfate  # Mass of a 10 nm particle in kg exponent_nucleation = 2  # Nucleation rate exponent (empirical)   for i, t in enumerate(time):     if i &gt; 0:         # 1. Add more vapor to the gas phase (e.g., by external sources)         aerosol.atmosphere.species[0].add_concentration(vapor_production * time_step)          # 2. Calculate the new saturation ratio for sulfate in the atmosphere         saturation_ratio = aerosol.atmosphere.species[0].get_saturation_ratio(temperature=298.15)          # 3. Calculate the nucleation rate based on the saturation ratio         # Ensure the saturation ratio is above 1, nucleation only occurs above saturation         saturation_difference = np.maximum(saturation_ratio - 1, 0)  # No nucleation if S \u2264 1         # Calculate the nucleation rate using the exponential form (custom)         # note this is mass based, if you have a volume based nucleation rate, you need to convert it         # to mass, as the resolved particles are mass based         nucleation_rate = base_nucleation_rate * (saturation_difference / 500)**exponent_nucleation          # 4. Calculate the number of new particles nucleated         # Floor division ensures we only get whole particles         number_of_new_particles = time_step * nucleation_rate // mass_nucleated_particle          # 5. Determine the number of resolved particles to create (based on simulation volume)         single_resolved_particle = aerosol.particles[0].get_concentration().max()         number_of_new_resolved_particles = int(number_of_new_particles // single_resolved_particle)          # 6. If new particles are nucleated, proceed to add them to the aerosol         if number_of_new_resolved_particles &gt; 0:             # Remove nucleated mass from the gas phase to conserve mass             aerosol.atmosphere.species[0].add_concentration(                 -number_of_new_resolved_particles * mass_nucleated_particle             )              # Create arrays to store the properties of the newly resolved particles             new_resolved_particle_masses = np.full(number_of_new_resolved_particles, mass_nucleated_particle)             new_resolved_particle_concentrations = np.ones_like(new_resolved_particle_masses)  # Concentration of 1 per particle              # Add the new resolved particles to the aerosol             aerosol.particles[0].add_concentration(                 added_concentration=new_resolved_particle_concentrations,                 added_distribution=new_resolved_particle_masses,             )          # 7. Perform the condensation step         condensation_runnable.execute(aerosol, time_step, sub_steps)          # 8. Perform the coagulation step         coagulation_runnable.execute(aerosol, time_step, sub_steps)      total_mass_resolved[i] = aerosol.particles[0].get_mass_concentration()     number_distribution = aerosol.particles[0].get_radius(clone=True)     number_distribution_binned[i, :], edges = np.histogram(number_distribution, bins=bins_lognormal)     total_number_resolved[i] = np.sum(number_distribution[i]&gt;0)     saturation_ratio_output[i] = aerosol.atmosphere.species[0].get_saturation_ratio(         temperature=298.15)      if i % 20 == 0:         # Retrieve and print the total number of resolved particles simulated         total_resolved_particles_in_simulation = aerosol.particles[0].concentration.sum()         print(f\"Index {i}: Total resolved particles in simulation: {total_resolved_particles_in_simulation}\")   number_distribution_binned = number_distribution_binned / volume_sim <pre>Index 0: Total resolved particles in simulation: 100.0\n</pre> <pre>Index 20: Total resolved particles in simulation: 321512.0\nIndex 40: Total resolved particles in simulation: 352082.0\nIndex 60: Total resolved particles in simulation: 330653.0\nIndex 80: Total resolved particles in simulation: 309162.0\nIndex 100: Total resolved particles in simulation: 289976.0\nIndex 120: Total resolved particles in simulation: 272910.0\nIndex 140: Total resolved particles in simulation: 257655.0\nIndex 160: Total resolved particles in simulation: 243924.0\nIndex 180: Total resolved particles in simulation: 231418.0\n</pre> In\u00a0[8]: Copied! <pre>fig, ax = plt.subplots(figsize=(8, 5))\n\n# Swap X and Y to reverse axes\nX, Y = np.meshgrid(\n    time, edges[:-1]\n)  # Now time is on the x-axis and edges on the y-axis\n\n# Plot the contour with updated X and Y\nlog_of_number_distribution_binned = np.log10(\n    number_distribution_binned,\n    out=np.nan * np.ones_like(number_distribution_binned),\n    where=number_distribution_binned &gt; 0,\n)\ncontour = ax.contourf(\n    X,\n    Y,\n    log_of_number_distribution_binned.T,\n    cmap=\"viridis\",\n    vmin=5,\n)\n\n# Add the color bar\ncbar = fig.colorbar(contour)\ncbar.set_label(\"Log10 of Number concentration (m^-3)\")\n\nax.set_ylim([1e-9, 1e-7])  # Set limits for y-axis\n\n# Set axis labels\nax.set_yscale(\"log\")  # Log scale for particle radius on y-axis\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(\"Particle radius (m)\")\nfig.tight_layout()\nplt.show()\n</pre> fig, ax = plt.subplots(figsize=(8, 5))  # Swap X and Y to reverse axes X, Y = np.meshgrid(     time, edges[:-1] )  # Now time is on the x-axis and edges on the y-axis  # Plot the contour with updated X and Y log_of_number_distribution_binned = np.log10(     number_distribution_binned,     out=np.nan * np.ones_like(number_distribution_binned),     where=number_distribution_binned &gt; 0, ) contour = ax.contourf(     X,     Y,     log_of_number_distribution_binned.T,     cmap=\"viridis\",     vmin=5, )  # Add the color bar cbar = fig.colorbar(contour) cbar.set_label(\"Log10 of Number concentration (m^-3)\")  ax.set_ylim([1e-9, 1e-7])  # Set limits for y-axis  # Set axis labels ax.set_yscale(\"log\")  # Log scale for particle radius on y-axis ax.set_xlabel(\"Time (s)\") ax.set_ylabel(\"Particle radius (m)\") fig.tight_layout() plt.show() In\u00a0[9]: Copied! <pre># plot the total mass and water saturation on twin y-axis\nfig, ax1 = plt.subplots(figsize=(8, 5))\n\nax1.plot(time, total_mass_resolved, label=\"Total mass\", color=\"blue\")\nax1.set_xlabel(\"Time (s)\")\nax1.set_ylabel(\"Total Particle mass (kg/m^3)\", color=\"blue\")\nax1.tick_params(axis=\"y\", labelcolor=\"blue\")\n\nax2 = ax1.twinx()\nax2.plot(time, saturation_ratio_output, label=\"Satruation Ratio\", color=\"red\")\nax2.set_ylabel(\"Saturation Ratio\", color=\"red\")\nax2.tick_params(axis=\"y\", labelcolor=\"red\")\n\nfig.tight_layout()\nplt.show()\n</pre> # plot the total mass and water saturation on twin y-axis fig, ax1 = plt.subplots(figsize=(8, 5))  ax1.plot(time, total_mass_resolved, label=\"Total mass\", color=\"blue\") ax1.set_xlabel(\"Time (s)\") ax1.set_ylabel(\"Total Particle mass (kg/m^3)\", color=\"blue\") ax1.tick_params(axis=\"y\", labelcolor=\"blue\")  ax2 = ax1.twinx() ax2.plot(time, saturation_ratio_output, label=\"Satruation Ratio\", color=\"red\") ax2.set_ylabel(\"Saturation Ratio\", color=\"red\") ax2.tick_params(axis=\"y\", labelcolor=\"red\")  fig.tight_layout() plt.show()"},{"location":"How-To-Guides/Nucleation/Notebooks/Custom_Nucleation_Single_Species/#custom-nucleation-single-species","title":"Custom Nucleation: Single Species\u00b6","text":"<p>In this How-to Guide, we will demonstrate how to create a custom nucleation model for a single-species aerosol system. We will use fixed nucleation rates for demonstration purposes. This approach highlights the flexibility of adding new processes to your aerosol simulation before full integration into the main codebase.</p> <p>This guide is based on the Dynamics Customization tutorial.</p> <p>Imports</p>"},{"location":"How-To-Guides/Nucleation/Notebooks/Custom_Nucleation_Single_Species/#aerosol-setup","title":"Aerosol Setup\u00b6","text":"<p>We will begin by setting up ammonium sulfate vapor alongside a few pre-existing particles. The vapor phase will include a constant vapor pressure for ammonium sulfate, and a lognormal distribution will be used to represent the initial particle population.</p> <p>The pre-existing particles are also necessary as, the zero particle case is not supported in the current version of the model.</p>"},{"location":"How-To-Guides/Nucleation/Notebooks/Custom_Nucleation_Single_Species/#simulation","title":"Simulation\u00b6","text":"<p>This section performs a step in the simulation using a manual stepping method. The steps include:</p> <ol> <li>Adding more vapors to the gas phase.</li> <li>Calculating the new saturation ratio.</li> <li>Calculating the nucleation rate based on the saturation difference.</li> <li>Determining the number of new particles nucleated.</li> <li>Determining the number of resolved particles to be added to the aerosol.</li> <li>Creating and adding the new particles to the aerosol.</li> <li>Performing a condensation step to account for gas-phase condensation onto existing particles.</li> <li>Performing a coagulation step to account for particle-particle interactions.</li> </ol> <p>And before we start, we also need to initialize the condensation and coagulation runnables.</p>"},{"location":"How-To-Guides/Nucleation/Notebooks/Custom_Nucleation_Single_Species/#time-loop","title":"Time Loop\u00b6","text":"<p>Now that we see the simulation is working, we can put that into a loop and save out the distribution of particles at each time step.</p> <p>We'll first reset the aerosol system to its initial state, create a output matrix, then run the previous simulation in a for loop.</p>"},{"location":"How-To-Guides/Nucleation/Notebooks/Custom_Nucleation_Single_Species/#graphing","title":"Graphing\u00b6","text":"<p>In this section, we will visualize the nucleation events over time. The initial particles will be displayed, followed by their coagulated pairs. As the simulation progresses, particle growth results from both coagulation and condensation processes.</p>"},{"location":"How-To-Guides/Nucleation/Notebooks/Custom_Nucleation_Single_Species/#conclusion","title":"Conclusion\u00b6","text":"<p>In this guide, we demonstrated how to integrate custom nucleation processes into the aerosol simulation. This shows the flexibility of the aerosol model, allowing for the addition of new processes before they are fully integrated into the core framework.</p> <p>Note: Custom nucleation, particularly at high rates, can significantly increase the number of particles simulated, potentially slowing down the computation. A rescaling mechanism to adjust the simulation volume and control the number of resolved particles is planned for future enhancements to address this issue.</p>"},{"location":"How-To-Guides/Setup_Particula/","title":"Index: Setup Particula","text":""},{"location":"How-To-Guides/Setup_Particula/#getting-started-with-python","title":"Getting Started with Python","text":"<p>If you are new to Python, it's highly recommended to go through an introductory course to build a solid foundation. \"Python for Everybody\" is an excellent free resource that covers the basics and beyond:</p> <ul> <li>Access the course and materials at Python for Everybody.</li> </ul>"},{"location":"How-To-Guides/Setup_Particula/#setting-up-your-development-environment","title":"Setting Up Your Development Environment","text":"<p>Step 1: Install Visual Studio Code (VSCode)</p> <p>To edit and manage your code efficiently, download and install Visual Studio Code, a popular code editor that supports Python and many other languages.</p> <ul> <li>Visit the Visual Studio Code website to download the installer for Windows.</li> <li>Follow the installation prompts to install VSCode on your machine.</li> <li>Once installed, launch VSCode to configure it for Python development.</li> </ul> <p>Step 2: Install Miniconda</p> <p>Install Miniconda, which includes Conda, a powerful package and environment manager. This tool will help you manage different project dependencies separately and efficiently.</p> <ul> <li>Download Miniconda for Windows from Miniconda's website.</li> <li>Follow the installation instructions to install Miniconda on your system.</li> </ul> <p>Step 3: Install Git</p> <p>Install Git to manage your code repositories effectively. Git is a version control system that lets you track changes, revert to previous stages, and collaborate on projects with others.</p> <ul> <li>Download Git from Git's official website.</li> <li>Run the downloaded file to start the installation.</li> <li>During the installation, choose your preferred editor for Git, and make sure to select \"Git from the command line and also from 3<sup>rd</sup>-party software\" to ensure it integrates well with your system's command prompt.</li> <li>Complete the installation by following the on-screen instructions.</li> </ul> <p>Once installed, you can verify the installation by opening a command prompt or terminal and typing <code>git --version</code>, which should display the installed version of Git.</p> <p>Step 4: Setup Proxy</p> <p>If you are behind a proxy, you may need to configure your proxy settings to allow Conda, Pip, git, and VScode to access the internet.</p> <p>Step 5: Create a New Python Environment </p> <p>Avoid conflicts with other development projects by creating an isolated Python environment. Here\u2019s how:</p> <ul> <li>Open VSCode, then open the integrated terminal (<code>Terminal &gt; New Terminal</code>).</li> <li>Be sure to select <code>cmd</code> for command prompt.</li> <li>Use the following Conda command to create an environment named <code>analysisV1</code> with Python 3.11:</li> </ul> <pre><code>conda create --name analysisV1 python=3.11\n</code></pre> <p>Step 6: Activate the Environment </p> <p>Ensure you\u2019re working within the context of your new environment: - In the VSCode terminal, activate your environment by running:</p> <pre><code>conda activate analysisV1\n</code></pre>"},{"location":"How-To-Guides/Setup_Particula/#installing-the-project","title":"Installing the Project","text":"<p>Step 7: Install the Project</p> <p>Now, install the <code>Particula</code> using pip in your activated environment, use one of the following methods:</p>"},{"location":"How-To-Guides/Setup_Particula/#install-the-pip-package","title":"Install the pip package","text":"<pre><code>pip install particula\n</code></pre>"},{"location":"How-To-Guides/Setup_Particula/#or-install-the-main-repository","title":"or Install the main repository","text":"<pre><code>pip install git+https://github.com/uncscode/particula.git\n</code></pre>"},{"location":"How-To-Guides/Setup_Particula/#or-install-the-gorkowski-fork","title":"or Install the Gorkowski fork","text":"<pre><code>pip install git+https://github.com/Gorkowski/particula.git\n</code></pre>"},{"location":"Tutorials/","title":"Tutorials","text":"<ul> <li> <p>Aerosol</p> <p>Learn what goes into the Aerosol object and why it is used.</p> <p> Tutorial</p> </li> <li> <p>Dynamics</p> <p>Dynamics is a collection of classes that processes for the <code>Aerosol</code> objects, to perform coagulation, condensation, and other processes.</p> <p> Tutorial</p> </li> <li> <p>Gas Phase</p> <p>Learn how to represent the Gas Phase, including vapor pressures and atmospheric properties.</p> <p> Tutorial</p> </li> <li> <p>Particle Phase</p> <p>Learn about how to represent the Particle Phase, including different particle representations; radius bins, speciated mass bins, and particle resolved.</p> <p> Tutorial</p> </li> <li> <p>Data Analysis </p> <p>in BETA  Some preliminary tools available for Data Analysis.</p> <p> Tutorial</p> </li> </ul>"},{"location":"Tutorials/Aerosol/","title":"Index: Aerosols","text":""},{"location":"Tutorials/Aerosol/#notebooks","title":"Notebooks","text":"<ul> <li>Aerosol Tutorial</li> </ul>"},{"location":"Tutorials/Aerosol/Aerosol_Tutorial/","title":"Aerosol Tutorial","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\nfrom particula.next.particles.representation_builders import LimitedRadiusParticleBuilder\nfrom particula.next.gas.atmosphere_builder import AtmosphereBuilder\nfrom particula.next.gas.vapor_pressure_factories import VaporPressureFactory\nfrom particula.next.gas.species_builder import GasSpeciesBuilder\nfrom particula.next.aerosol import Aerosol\n</pre> import numpy as np import matplotlib.pyplot as plt  from particula.next.particles.representation_builders import LimitedRadiusParticleBuilder from particula.next.gas.atmosphere_builder import AtmosphereBuilder from particula.next.gas.vapor_pressure_factories import VaporPressureFactory from particula.next.gas.species_builder import GasSpeciesBuilder from particula.next.aerosol import Aerosol In\u00a0[2]: Copied! <pre># Glycerol gas\nmolar_mass_glycerol = 92.09382e-3  # kg/mol\nparameters_clausius = {\n    \"latent_heat\": 71.5*molar_mass_glycerol,\n    \"latent_heat_units\": \"kJ/kg\",\n    \"temperature_initial\": 125.5,\n    \"temperature_initial_units\": \"degC\",\n    \"pressure_initial\": 1,\n    \"pressure_initial_units\": \"mmHg\",\n}\nvapor_pressure_strategy = VaporPressureFactory().get_strategy(\"clausius_clapeyron\", parameters_clausius)\n\nsat_concentration = vapor_pressure_strategy.saturation_concentration(molar_mass_glycerol, 298.15)\nprint(f\"Saturation concentration: {sat_concentration:.2e} kg/m^3\")\n\nsat_factor = 0.5  # 50% of saturation concentration\nglycerol_gas = (\n    GasSpeciesBuilder()\n    .set_molar_mass(molar_mass_glycerol, \"kg/mol\")\n    .set_vapor_pressure_strategy(vapor_pressure_strategy)\n    .set_concentration(sat_concentration*sat_factor, \"kg/m^3\")\n    .set_name(\"Glycerol\")\n    .set_condensable(True)\n    .build()\n)\nprint(glycerol_gas)\n\natmosphere = (\n    AtmosphereBuilder()\n    .add_species(glycerol_gas)\n    .set_temperature(25, temperature_units=\"degC\")\n    .set_pressure(1, pressure_units=\"atm\")\n    .build()\n)\nprint(atmosphere)\n\n# Glycerol particle distribution\nlognormal_rep = (\n    LimitedRadiusParticleBuilder()\n    .set_mode(np.array([100]), \"nm\")\n    .set_geometric_standard_deviation(np.array([1.5]))\n    .set_number_concentration(np.array([1e4]), \"1/cm^3\")\n    .set_density(1.26, \"g/cm^3\")\n    .build()\n)\n</pre> # Glycerol gas molar_mass_glycerol = 92.09382e-3  # kg/mol parameters_clausius = {     \"latent_heat\": 71.5*molar_mass_glycerol,     \"latent_heat_units\": \"kJ/kg\",     \"temperature_initial\": 125.5,     \"temperature_initial_units\": \"degC\",     \"pressure_initial\": 1,     \"pressure_initial_units\": \"mmHg\", } vapor_pressure_strategy = VaporPressureFactory().get_strategy(\"clausius_clapeyron\", parameters_clausius)  sat_concentration = vapor_pressure_strategy.saturation_concentration(molar_mass_glycerol, 298.15) print(f\"Saturation concentration: {sat_concentration:.2e} kg/m^3\")  sat_factor = 0.5  # 50% of saturation concentration glycerol_gas = (     GasSpeciesBuilder()     .set_molar_mass(molar_mass_glycerol, \"kg/mol\")     .set_vapor_pressure_strategy(vapor_pressure_strategy)     .set_concentration(sat_concentration*sat_factor, \"kg/m^3\")     .set_name(\"Glycerol\")     .set_condensable(True)     .build() ) print(glycerol_gas)  atmosphere = (     AtmosphereBuilder()     .add_species(glycerol_gas)     .set_temperature(25, temperature_units=\"degC\")     .set_pressure(1, pressure_units=\"atm\")     .build() ) print(atmosphere)  # Glycerol particle distribution lognormal_rep = (     LimitedRadiusParticleBuilder()     .set_mode(np.array([100]), \"nm\")     .set_geometric_standard_deviation(np.array([1.5]))     .set_number_concentration(np.array([1e4]), \"1/cm^3\")     .set_density(1.26, \"g/cm^3\")     .build() ) <pre>Saturation concentration: 2.54e-03 kg/m^3\nGlycerol\nGas mixture at 298.15 K and 101325.0 Pa consisting of ['Glycerol']\n</pre> In\u00a0[3]: Copied! <pre>aerosol = Aerosol(atmosphere=atmosphere, particles=lognormal_rep)\n\nprint(aerosol.atmosphere)\n</pre> aerosol = Aerosol(atmosphere=atmosphere, particles=lognormal_rep)  print(aerosol.atmosphere) <pre>Gas mixture at 298.15 K and 101325.0 Pa consisting of ['Glycerol']\n</pre>"},{"location":"Tutorials/Aerosol/Aerosol_Tutorial/#aerosol-tutorial","title":"Aerosol Tutorial\u00b6","text":"<p>Aerosols are complex systems comprising both gaseous components and particulate matter. To accurately model such systems, we introduce the <code>Aerosol</code> class, which serves as a collection the <code>Atmosphere</code> and <code>ParticleRepresentation</code> objects.</p> <p>In this quick tutorial, we will demonstrate how to create an <code>Aerosol</code> object, as this is the key object that will track the state of the aerosol system during dynamics.</p>"},{"location":"Tutorials/Aerosol/Aerosol_Tutorial/#gas-atmosphere-and-particles","title":"Gas-&gt;Atmosphere and Particles\u00b6","text":"<p>First we'll create a simple <code>Atmosphere</code> object, which will represent the gas phase of the aerosol system. We'll also create a <code>ParticleRepresentation</code> object, which will represent the particulate phase of the aerosol system.</p> <p>For the chemical species, we will use a pure component glycerol system.</p>"},{"location":"Tutorials/Aerosol/Aerosol_Tutorial/#creating-an-aerosol-object","title":"Creating an Aerosol object\u00b6","text":"<p>With both the <code>Atmosphere</code> and <code>ParticleRepresentation</code> objects created, we can now create an <code>Aerosol</code> object. This object will contain both the gas and particle phase objects, and will be used to track the state of the aerosol system during dynamics.</p>"},{"location":"Tutorials/Aerosol/Aerosol_Tutorial/#summary","title":"Summary\u00b6","text":"<p>In this tutorial, we demonstrated how to create an <code>Aerosol</code> object, which is the key object that will track the state of the aerosol system during dynamics. It is pretty simple, as the <code>Aerosol</code> object is just a collection of the <code>Atmosphere</code> and <code>ParticleRepresentation</code> objects and only functions as a container for these objects. It can also iterate over the <code>Atmosphere</code> and <code>ParticleRepresentation</code> objects.</p>"},{"location":"Tutorials/Data_Analysis/","title":"Index: Data Analysis","text":"<ul> <li>Fitting Lognormal PDF: 2 Modes</li> <li>Converting Size Distributions</li> </ul>"},{"location":"Tutorials/Data_Analysis/Converting_Size_Distributions/","title":"Converting Size Distributions","text":"In\u00a0[2]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# particula imports\nfrom particula.util import convert, distribution_discretization\nfrom particula.util.size_distribution_convert import SizerConverter, get_conversion_strategy\n</pre> import numpy as np import matplotlib.pyplot as plt  # particula imports from particula.util import convert, distribution_discretization from particula.util.size_distribution_convert import SizerConverter, get_conversion_strategy In\u00a0[3]: Copied! <pre># Define the range and resolution of particle diameters (in nanometers)\ndiameters = np.linspace(20, 1000, 500)  # From 20 nm to 1000 nm with 500 points\n\n# Standard deviation of the log-normal distribution (dimensionless)\nsigma = 1.25\n\n# Define the modes (peak diameters) for a bimodal distribution\nmodes = [100, 500]\n\n# Total number of particles in the distribution\nnumber_total = 1e3\n\n# Generate a log-normal probability density function (pdf) with an area\n# equal to 1, then scale by total number of particles\npdf_dist = distribution_discretization.discretize(\n    interval=diameters,  # Array of diameters over which to compute the distribution\n    disttype=\"lognormal\",  # Type of distribution\n    gsigma=sigma,  # Geometric standard deviation\n    mode=modes,  # Modes of the distribution\n    nparticles=number_total  # Total number of particles\n).m * number_total\n\n# Visualization\nfig, ax = plt.subplots()\nax.plot(diameters, pdf_dist, label=\"PDF\")\nax.set_xscale(\"log\")  # Logarithmic scale for diameters\nax.set_xlabel(\"Diameter (nm)\")  # X-axis label\nax.set_ylabel(\"Number concentration\")  # Y-axis label\nax.legend()  # Show legend\nplt.show()  # Display the plot\n</pre> # Define the range and resolution of particle diameters (in nanometers) diameters = np.linspace(20, 1000, 500)  # From 20 nm to 1000 nm with 500 points  # Standard deviation of the log-normal distribution (dimensionless) sigma = 1.25  # Define the modes (peak diameters) for a bimodal distribution modes = [100, 500]  # Total number of particles in the distribution number_total = 1e3  # Generate a log-normal probability density function (pdf) with an area # equal to 1, then scale by total number of particles pdf_dist = distribution_discretization.discretize(     interval=diameters,  # Array of diameters over which to compute the distribution     disttype=\"lognormal\",  # Type of distribution     gsigma=sigma,  # Geometric standard deviation     mode=modes,  # Modes of the distribution     nparticles=number_total  # Total number of particles ).m * number_total  # Visualization fig, ax = plt.subplots() ax.plot(diameters, pdf_dist, label=\"PDF\") ax.set_xscale(\"log\")  # Logarithmic scale for diameters ax.set_xlabel(\"Diameter (nm)\")  # X-axis label ax.set_ylabel(\"Number concentration\")  # Y-axis label ax.legend()  # Show legend plt.show()  # Display the plot In\u00a0[4]: Copied! <pre># Get the conversion strategy\npms_to_pdf = get_conversion_strategy(\n    input_scale='pms',\n    output_scale='pdf')\n\n# Create the converter\npms_to_pdf_converter = SizerConverter(pms_to_pdf)\n\n# Convert distribution\npms_dist = pms_to_pdf_converter.convert(\n    diameters=diameters,\n    concentration=pdf_dist,\n    inverse=True,\n)\n\n# Visualization\nfig, ax = plt.subplots()\nax.plot(diameters, pdf_dist, label=\"PDF\")\nax.plot(diameters, pms_dist, label=\"PMS\")\nax.set_xscale(\"log\")  # Logarithmic scale for diameters\nax.set_xlabel(\"Diameter (nm)\")  # X-axis label\nax.set_ylabel(\"Number concentration\")  # Y-axis label\nax.legend()  # Show legend\nplt.show()  # Display the plot\n</pre> # Get the conversion strategy pms_to_pdf = get_conversion_strategy(     input_scale='pms',     output_scale='pdf')  # Create the converter pms_to_pdf_converter = SizerConverter(pms_to_pdf)  # Convert distribution pms_dist = pms_to_pdf_converter.convert(     diameters=diameters,     concentration=pdf_dist,     inverse=True, )  # Visualization fig, ax = plt.subplots() ax.plot(diameters, pdf_dist, label=\"PDF\") ax.plot(diameters, pms_dist, label=\"PMS\") ax.set_xscale(\"log\")  # Logarithmic scale for diameters ax.set_xlabel(\"Diameter (nm)\")  # X-axis label ax.set_ylabel(\"Number concentration\")  # Y-axis label ax.legend()  # Show legend plt.show()  # Display the plot In\u00a0[5]: Copied! <pre># Get the conversion strategy\ndNdlogDp_to_pdf = get_conversion_strategy(\n    input_scale='dn/dlogdp',\n    output_scale='pdf')\n\n# Create the converter\ndNdlogDp_to_pdf_converter = SizerConverter(dNdlogDp_to_pdf)\n\n# Convert distribution\ndNdlogDp_dist = dNdlogDp_to_pdf_converter.convert(\n    diameters=diameters,\n    concentration=pdf_dist,\n    inverse=True,\n)\n\n# Visualization\nfig, ax = plt.subplots()\nax.plot(diameters, pdf_dist, label=\"PDF\")\nax.plot(diameters, pms_dist, label=\"PMS\")\nax.plot(diameters, dNdlogDp_dist, label=\"dN/dlogDp\")\nax.set_xscale(\"log\")  # Logarithmic scale for diameters\nax.set_yscale(\"log\")  # Logarithmic scale for concentrations\nax.set_xlabel(\"Diameter (nm)\")  # X-axis label\nax.set_ylabel(\"Number concentration\")  # Y-axis label\nax.legend()  # Show legend\nplt.show()  # Display the plot\n</pre> # Get the conversion strategy dNdlogDp_to_pdf = get_conversion_strategy(     input_scale='dn/dlogdp',     output_scale='pdf')  # Create the converter dNdlogDp_to_pdf_converter = SizerConverter(dNdlogDp_to_pdf)  # Convert distribution dNdlogDp_dist = dNdlogDp_to_pdf_converter.convert(     diameters=diameters,     concentration=pdf_dist,     inverse=True, )  # Visualization fig, ax = plt.subplots() ax.plot(diameters, pdf_dist, label=\"PDF\") ax.plot(diameters, pms_dist, label=\"PMS\") ax.plot(diameters, dNdlogDp_dist, label=\"dN/dlogDp\") ax.set_xscale(\"log\")  # Logarithmic scale for diameters ax.set_yscale(\"log\")  # Logarithmic scale for concentrations ax.set_xlabel(\"Diameter (nm)\")  # X-axis label ax.set_ylabel(\"Number concentration\")  # Y-axis label ax.legend()  # Show legend plt.show()  # Display the plot In\u00a0[6]: Copied! <pre>help(get_conversion_strategy)\n</pre> help(get_conversion_strategy) <pre>Help on function get_conversion_strategy in module particula.util.size_distribution_convert:\n\nget_conversion_strategy(input_scale: str, output_scale: str) -&gt; particula.util.size_distribution_convert.ConversionStrategy\n    Factory function to create and return an appropriate conversion\n    strategy based on input and output scales. Use the inverse flag in the\n    converter to invert the directions of the input and output scales.\n    \n    Args:\n        input_scale: The scale of the input concentration values.\n            Either 'dn/dlogdp' or 'pms'.\n        output_scale: The desired scale of the output concentration\n            values. Either 'pms' or 'pdf'. Use inverse flag to invert the input\n            and output scales.\n    \n    Returns:\n        ConversionStrategy: A strategy object capable of converting between\n            the specified scales.\n    \n    Raises:\n        ValueError: If the input_scale or output_scale is not supported, or\n            if the specified conversion is unsupported.\n    \n    Example:\n        ``` py title=\"Convert dn/dlogdp to PMS\"\n        strategy = get_conversion_strategy('dn/dlogdp', 'pms')\n        converter = Converter(strategy)\n        converted_concentration = converter.convert(\n            diameters, concentration, inverse=False)\n        ```\n\n</pre> In\u00a0[7]: Copied! <pre>help(SizerConverter)\n</pre> help(SizerConverter) <pre>Help on class SizerConverter in module particula.util.size_distribution_convert:\n\nclass SizerConverter(builtins.object)\n |  SizerConverter(strategy: particula.util.size_distribution_convert.ConversionStrategy)\n |  \n |  A converter that uses a specified ConversionStrategy to convert\n |  particle size distribution data between different formats.\n |  \n |  Methods defined here:\n |  \n |  __init__(self, strategy: particula.util.size_distribution_convert.ConversionStrategy)\n |      Initializes the converter with a conversion strategy.\n |      \n |      Args:\n |          strategy (ConversionStrategy): The strategy to use for conversion.\n |  \n |  convert(self, diameters: numpy.ndarray, concentration: numpy.ndarray, inverse: bool = False) -&gt; numpy.ndarray\n |      Converts particle size distribution data using the specified\n |      strategy.\n |      \n |      Args:\n |          diameters (np.ndarray): The particle diameters.\n |          concentration (np.ndarray): The concentration values.\n |          inverse (bool): Flag to perform the inverse conversion.\n |      \n |      Returns:\n |          np.ndarray: The converted concentration values.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |  \n |  __dict__\n |      dictionary for instance variables\n |  \n |  __weakref__\n |      list of weak references to the object\n\n</pre>"},{"location":"Tutorials/Data_Analysis/Converting_Size_Distributions/#converting-size-distributions","title":"Converting Size Distributions\u00b6","text":"<p>Particle size distributions play a critical role in aerosol science, impacting areas such as air quality monitoring, environmental health, and various industrial processes. These distributions provide insights into the number, volume, or mass concentration of aerosol particles across different size ranges, aiding in the analysis of aerosol behavior and effects. For specific analyses or models, converting between size distribution scales, like from number to volume concentration, is often necessary. This document introduces a Python-based size distribution converter designed to facilitate conversions across different aerosol size distribution scales without the need to manually handle conversion formulas or functions, employing a factory pattern to determine the appropriate conversion strategy based on the scales involved.</p>"},{"location":"Tutorials/Data_Analysis/Converting_Size_Distributions/#aerosol-size-distribution-scales","title":"Aerosol Size Distribution Scales:\u00b6","text":"<p>Aerosol size distributions are characterized through various metrics and scales, with each serving specific purposes in analysis and practical application. These descriptions offer a more nuanced understanding of each type:</p> <ol> <li><p>Number Concentration (dN/dlogDp): This metric quantifies the number of aerosol particles within a specified size range per unit volume of air. It is essential for assessing particle prevalence in environmental and health-related studies, providing a direct measure of how many particles are present in a given volume.</p> </li> <li><p>NOT IMPLEMENTED Mass Concentration (dM/dlogDp): Indicates the total mass of particles within a specific size range per unit volume of air. This measure is crucial for understanding the mass-related impacts of aerosols on health, visibility, and climate, as it relates directly to the amount of material in the atmosphere.</p> </li> <li><p>NOT IMPLEMENTED Volume Concentration (dV/dlogDp): This scale measures the collective volume of particles within a specified size range per unit volume of air. It's particularly useful for understanding the packing density and potential space occupancy of aerosols in a given volume, affecting light scattering and particle deposition processes.</p> </li> <li><p>NOT IMPLEMENTED Surface Area Concentration (dA/dlogDp): Provides the total surface area of particles within each size bin per unit volume of air. Though not implemented yet, this metric is vital for evaluating the interaction potential of aerosols with gases and other particles, as well as their reactivity and potential health impacts related to surface chemistry.</p> </li> <li><p>Probability Density Function (PDF): Wikipedia link A statistical representation that describes the likelihood of particles existing within specific size intervals. The PDF is instrumental in stochastic modeling, offering insights into the overall shape and characteristics of the size distribution, which helps in predicting aerosol behavior under various conditions.</p> </li> <li><p>Probability Mass Spectrum (PMS): Wikipedia link Acts as a discrete counterpart to the PDF, providing a quantized view of the size distribution that is especially useful for numerical and computational modeling. The PMS is essentially a snapshot of the number concentration (dN) distributed across discrete size bins, enabling detailed analysis and simulation of aerosol dynamics.</p> </li> </ol> <p>These metrics facilitate a comprehensive analysis of aerosol properties and behaviors, enabling researchers and practitioners to tailor their approaches based on the specific requirements of their work, whether it be in environmental monitoring, health impact assessment, or atmospheric science.</p>"},{"location":"Tutorials/Data_Analysis/Converting_Size_Distributions/#the-converter-class-and-factory-pattern","title":"The Converter Class and Factory Pattern:\u00b6","text":"<p>The converter class is structured to allow for the conversion between different aerosol size distribution formats efficiently.</p> <p>The core <code>Converter</code> class is designed not to implement conversion behaviors directly. Instead, it utilizes a <code>ConversionStrategy</code> object that follows a specified interface to carry out conversions. This strategy-based design permits the flexible exchange of conversion methodologies without requiring changes to the <code>Converter</code> class, promoting maintainability.</p> <p>A key component of this system is the <code>get_conversion_strategy</code> factory function, which streamlines the acquisition of an appropriate conversion strategy based on the provided input and output scales. This function assesses the scales and furnishes an instance of the suitable strategy class, thus simplifying the conversion operation.</p>"},{"location":"Tutorials/Data_Analysis/Converting_Size_Distributions/#examples","title":"Examples:\u00b6","text":"<p>Subsequent sections will showcase the practical application of the size distribution converter through examples. These examples will cover conversions such as transforming number concentration to the probability mass spectrum and the reverse process, illustrating the converter's utility and flexibility.</p>"},{"location":"Tutorials/Data_Analysis/Converting_Size_Distributions/#generate-pdf","title":"Generate PDF\u00b6","text":"<p>To understand the behavior these different representations, we start by making a PDF. Probability Density Function (PDF), offers a continuous function representing the relative likelihood of particle sizes within a specific range.</p> <p>Lognormal distributions are characterized by their ability to model particle sizes that cannot be negative and are skewed towards larger sizes. This distribution is defined by a geometric mean diameter and a geometric standard deviation, indicating the spread of particle sizes.</p> <p>Expanding on the markdown for generating a Probability Density Function (PDF) for a lognormal distribution, including details for the code example provided:</p>"},{"location":"Tutorials/Data_Analysis/Converting_Size_Distributions/#variables","title":"Variables\u00b6","text":"<ul> <li><p>Diameters: A range of particle diameters is defined from 20 nm to 1000 nm, discretized into 500 points, to cover the typical size range of interest in aerosol studies.</p> </li> <li><p>Sigma &amp; Modes: The lognormal distribution's geometric standard deviation (sigma) and modes (peak diameters) are specified, reflecting the distribution's breadth and the sizes most represented in the sample.</p> </li> <li><p>Number Total: The total number of particles within the distribution is set, allowing for the scaling of the PDF to represent actual particle concentrations.</p> </li> <li><p>Distribution Discretization: The <code>distribution_discretization.discretize</code> function computes the PDF based on the specified parameters. This PDF is then scaled by the total number of particles to reflect the actual size distribution.</p> </li> </ul>"},{"location":"Tutorials/Data_Analysis/Converting_Size_Distributions/#pdf-to-pms-conversion","title":"PDF to PMS Conversion\u00b6","text":"<p>The PDF provides a continuous function indicating the likelihood of particle sizes within a specific range, while the PMS offers a discrete representation, particularly useful for computational modeling and real measurements.</p>"},{"location":"Tutorials/Data_Analysis/Converting_Size_Distributions/#conversion-from-pms-to-pdf","title":"Conversion from PMS to PDF\u00b6","text":"<p>In practice, converting between these distributions allows researchers to leverage the strengths of both representations for comprehensive analysis. The provided code snippet illustrates how to convert a PMS distribution to a PDF using a predefined conversion strategy within a Python implementation. This process involves obtaining the appropriate conversion strategy from <code>pms</code> to <code>pdf</code>, creating a converter with this strategy, and then applying the conversion to a given distribution.</p>"},{"location":"Tutorials/Data_Analysis/Converting_Size_Distributions/#code-description","title":"Code Description\u00b6","text":"<ul> <li>Conversion Strategy: A strategy for converting from PMS to PDF is obtained using <code>get_conversion_strategy</code>, indicating that the conversion will take the form of a probability mass spectrum to a probability density function.<ul> <li>Input_scale can either be 'dn/dlogDp' or 'pms'.</li> <li>Output_scale can either be 'pms' or 'pdf'.</li> <li>Use the inverse flag to invert the direction of the conversion.</li> </ul> </li> <li>Converter Creation: A <code>SizerConverter</code> object is instantiated with the conversion strategy, setting the stage for the conversion process.</li> <li>Distribution Conversion: The actual conversion is performed by calling the <code>convert</code> method on the <code>pms_to_pdf_converter</code>, specifying the diameters and concentration from the original PDF distribution and setting <code>inverse=True</code> to indicate the direction of conversion.</li> </ul>"},{"location":"Tutorials/Data_Analysis/Converting_Size_Distributions/#comparison-insights","title":"Comparison Insights\u00b6","text":"<ul> <li>Scale Adaptability: The logarithmic scale for diameters effectively demonstrates the wide range of particle sizes and emphasizes the adaptability of both distributions across this range.</li> <li>Distribution Form: The PDF, being continuous, smoothly varies across sizes, while the PMS, as a discrete spectrum, provides specific values at each size interval, useful for detailed numerical analysis.</li> <li>Application Suitability: The visualization and comparison underline the suitability of each distribution form for different applications: the PDF for theoretical studies and understanding general trends, and the PMS for detailed numerical simulations and modeling.</li> </ul> <p>Through this conversion and comparison, researchers can better interpret aerosol size distributions, applying the most appropriate representation to their specific research needs and analytical frameworks.</p>"},{"location":"Tutorials/Data_Analysis/Converting_Size_Distributions/#pdf-to-dndlogdp-conversion","title":"PDF to dN/dlogDp Conversion\u00b6","text":"<p>In this code block, we address the conversion of aerosol size distribution data from the $dN/dlogD_p$ format to a probability density function (PDF). The $dN/dlogD_p$ format represents the number concentration of particles distributed per unit log diameter, a common representation in aerosol science for describing size distributions, particularly useful for emphasizing the distribution of particles across logarithmically spaced diameter bins.</p>"},{"location":"Tutorials/Data_Analysis/Converting_Size_Distributions/#code-description","title":"Code Description\u00b6","text":"<p>Obtaining the Conversion Strategy: The first step involves acquiring the appropriate conversion strategy to transition from $dN/dlogD_p$ to PDF. This is achieved through the <code>get_conversion_strategy</code> function, specifying <code>input_scale='dn/dlogdp'</code> and <code>output_scale='pdf'</code>, which determines the correct algorithm or mathematical approach for the conversion.</p> <p>Creating the Converter: A <code>SizerConverter</code> object is then instantiated with the obtained conversion strategy. This converter encapsulates the conversion logic, providing a clean interface for applying the conversion to aerosol size distribution data.</p> <p>Performing the Conversion: The actual conversion is executed by invoking the <code>convert</code> method of the converter, passing in the diameters and concentration values from the previously obtained or generated distribution. The <code>inverse=True</code> parameter indicates that the conversion direction is from the output scale back to the input scale, effectively generating a $dN/dlogD_p$ distribution from a PDF.</p>"},{"location":"Tutorials/Data_Analysis/Converting_Size_Distributions/#visualization","title":"Visualization:\u00b6","text":"<p>The code block concludes with the visualization of the original PDF, the previously converted PMS distribution, and the newly converted $dN/dlogD_p$ distribution. Plotting these distributions together, especially on logarithmic scales for both diameters and concentrations, facilitates a comprehensive comparison of how particle sizes and their concentrations are represented across these different formats.</p> <p>This conversion and visualization process underscores the versatility and analytical depth achieved through transitioning between different aerosol size distribution formats. By comparing the continuous PDF, discrete PMS, and $dN/dlogD_p$ formats, researchers can gain nuanced insights into particle size distributions, enhancing the understanding of aerosol dynamics, source contributions, and environmental impacts.</p>"},{"location":"Tutorials/Data_Analysis/Converting_Size_Distributions/#conclusions","title":"Conclusions\u00b6","text":"<p>This discussion centers around the implementation of a flexible and modular system for converting between various aerosol size distribution formats using Python. The system leverages a factory pattern to dynamically select conversion strategies based on input and output scale requirements. Through examples, we have demonstrated conversions between Probability Density Function (PDF), Probability Mass Spectrum (PMS), and the number concentration (dN/dlogDp) formats.</p>"},{"location":"Tutorials/Data_Analysis/Converting_Size_Distributions/#summary-of-implementation","title":"Summary of Implementation\u00b6","text":"<p>The process begins with the generation of a PDF for a lognormal distribution, representing the likelihood of finding particles within specific size ranges. This foundational step is crucial for understanding aerosol particle distributions and their environmental or health impacts.</p> <p>Subsequently, we showcased how to convert this PDF into a PMS distribution and then from PMS to PDF, utilizing a <code>SizerConverter</code> class. This class applies a strategy pattern, enabling the flexible application of different conversion strategies without altering the core logic of the converter itself.</p> <p>The final code block illustrates converting from the number concentration format (dN/dlogDp) back to a PDF, underscoring the system's versatility in handling diverse aerosol size distribution data. This versatility is critical for aerosol scientists who work across various measurement techniques and modeling approaches.</p>"},{"location":"Tutorials/Data_Analysis/Converting_Size_Distributions/#expand-the-factory","title":"Expand the Factory\u00b6","text":"<p>The factory pattern has proven effective in providing a scalable and maintainable framework for extending the conversion capabilities of the system. To incorporate additional conversions not yet implemented, such as volume or mass concentration (dV/dlogDp or dM/dlogDp) and surface area concentration (dA/dlogDp), the following steps can be followed:</p> <ol> <li><p>Define New Strategy Classes: For each new conversion requirement, a corresponding strategy class implementing the <code>ConversionStrategy</code> interface should be defined. These classes would encapsulate the specific logic for converting between the new formats and the existing ones.</p> </li> <li><p>Extend the Factory Function: The <code>get_conversion_strategy</code> function should be expanded to recognize and return instances of the new strategy classes based on the provided input and output scales. This extension involves updating the function's logic to handle the new scale identifiers and ensuring that all valid conversion paths are accounted for.</p> </li> <li><p>Validation and Testing: With each new conversion strategy added, comprehensive validation and testing are crucial to ensure accuracy and reliability. This may involve comparing the results with known benchmarks or empirical data.</p> </li> </ol> <p>By following this approach, the system can be readily expanded to cover a broader range of aerosol size distribution formats as needed, while maintaining the core advantages of flexibility and modularity provided by the factory pattern. This design not only facilitates the easy integration of new conversion capabilities but also ensures that the system remains adaptable to the evolving needs of aerosol science research and application.</p>"},{"location":"Tutorials/Data_Analysis/Fitting_lognormal_PDFs_2modes/","title":"Fitting Lognormal PDFs: 2 Modes","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nfrom particula.next.particles.properties import lognormal_pdf_distribution\nfrom particula.data.process.ml_analysis import generate_and_train_2mode_sizer\n</pre> import numpy as np import matplotlib.pyplot as plt from particula.next.particles.properties import lognormal_pdf_distribution from particula.data.process.ml_analysis import generate_and_train_2mode_sizer In\u00a0[2]: Copied! <pre># Generate x-values (particle sizes)\nx_values = np.logspace(1.5, 3, 150)\n\n# Generate lognormal PDF with noise\nconcentration_pdf = lognormal_pdf_distribution(\n    x_values=x_values,\n    mode=np.array([80, 150]),\n    geometric_standard_deviation=np.array([1.2, 1.3]),\n    number_of_particles=np.array([200, 500]),\n)\n\n# Introduce noise to the data\nconcentration_pdf = concentration_pdf * np.random.uniform(\n    low=0.8, high=1.2, size=concentration_pdf.shape\n)\n\n# Plot the noisy data\nplt.figure(figsize=(8, 6))\nplt.plot(x_values, concentration_pdf, label=\"Noisy Data\")\nplt.xscale(\"log\")\nplt.xlabel(\"Particle Size\")\nplt.ylabel(\"Concentration PDF\")\nplt.title(\"Simulated Lognormal Data with Noise\")\nplt.legend()\nplt.show()\n</pre> # Generate x-values (particle sizes) x_values = np.logspace(1.5, 3, 150)  # Generate lognormal PDF with noise concentration_pdf = lognormal_pdf_distribution(     x_values=x_values,     mode=np.array([80, 150]),     geometric_standard_deviation=np.array([1.2, 1.3]),     number_of_particles=np.array([200, 500]), )  # Introduce noise to the data concentration_pdf = concentration_pdf * np.random.uniform(     low=0.8, high=1.2, size=concentration_pdf.shape )  # Plot the noisy data plt.figure(figsize=(8, 6)) plt.plot(x_values, concentration_pdf, label=\"Noisy Data\") plt.xscale(\"log\") plt.xlabel(\"Particle Size\") plt.ylabel(\"Concentration PDF\") plt.title(\"Simulated Lognormal Data with Noise\") plt.legend() plt.show() In\u00a0[3]: Copied! <pre># Get initial guess from the ML model\n(\n    mode_values_guess,\n    geometric_standard_deviation_guess,\n    number_of_particles_guess,\n) = generate_and_train_2mode_sizer.lognormal_2mode_ml_guess(\n    logspace_x=x_values,\n    concentration_pdf=concentration_pdf,\n)\n\n# Display the initial guess results\nprint(\"Initial Guess:\")\nprint(f\"Mode: {mode_values_guess}\")\nprint(f\"GSD: {geometric_standard_deviation_guess}\")\nprint(f\"Number of particles: {number_of_particles_guess}\")\n</pre> # Get initial guess from the ML model (     mode_values_guess,     geometric_standard_deviation_guess,     number_of_particles_guess, ) = generate_and_train_2mode_sizer.lognormal_2mode_ml_guess(     logspace_x=x_values,     concentration_pdf=concentration_pdf, )  # Display the initial guess results print(\"Initial Guess:\") print(f\"Mode: {mode_values_guess}\") print(f\"GSD: {geometric_standard_deviation_guess}\") print(f\"Number of particles: {number_of_particles_guess}\") <pre>Initial Guess:\nMode: [ 86.74944005 143.84229739]\nGSD: [1.44827329 1.52694663]\nNumber of particles: [ 69.09804885 647.14554209]\n</pre> In\u00a0[\u00a0]: Copied! <pre>(\n    mode_values_optimized,\n    gsd_optimized,\n    number_of_particles_optimized,\n    r2_optimized,\n    optimization_results,\n) = generate_and_train_2mode_sizer.optimize_lognormal_2mode(\n    mode_guess=mode_values_guess,\n    geometric_standard_deviation_guess=geometric_standard_deviation_guess,\n    number_of_particles_in_mode_guess=number_of_particles_guess,\n    x_values=x_values,\n    concentration_pdf=concentration_pdf,\n)\n</pre> (     mode_values_optimized,     gsd_optimized,     number_of_particles_optimized,     r2_optimized,     optimization_results, ) = generate_and_train_2mode_sizer.optimize_lognormal_2mode(     mode_guess=mode_values_guess,     geometric_standard_deviation_guess=geometric_standard_deviation_guess,     number_of_particles_in_mode_guess=number_of_particles_guess,     x_values=x_values,     concentration_pdf=concentration_pdf, ) In\u00a0[12]: Copied! <pre># Display the optimized results\nprint(\"Optimized Fit:\")\nprint(f\"Optimized mode values: {mode_values_optimized}\")\nprint(f\"Optimized GSD: {gsd_optimized}\")\nprint(f\"Optimized number of particles: {number_of_particles_optimized}\")\nprint(f\"Optimized R\u00b2: {r2_optimized}\")\nprint(f\"Best optimization method: {optimization_results['method']}\")\n</pre> # Display the optimized results print(\"Optimized Fit:\") print(f\"Optimized mode values: {mode_values_optimized}\") print(f\"Optimized GSD: {gsd_optimized}\") print(f\"Optimized number of particles: {number_of_particles_optimized}\") print(f\"Optimized R\u00b2: {r2_optimized}\") print(f\"Best optimization method: {optimization_results['method']}\") <pre>Optimized Fit:\nOptimized mode values: [ 77.92048882 146.4391948 ]\nOptimized GSD: [1.19264682 1.30742154]\nOptimized number of particles: [175.92002921 544.65291938]\nOptimized R\u00b2: 0.9736896055718199\nBest optimization method: trust-constr\n</pre> In\u00a0[13]: Copied! <pre># Generate concentration PDFs for guess and optimized values\nconcentration_pdf_guess = lognormal_pdf_distribution(\n    x_values=x_values,\n    mode=mode_values_guess,\n    geometric_standard_deviation=geometric_standard_deviation_guess,\n    number_of_particles=number_of_particles_guess,\n)\n\nconcentration_pdf_optimized = lognormal_pdf_distribution(\n    x_values=x_values,\n    mode=mode_values_optimized,\n    geometric_standard_deviation=gsd_optimized,\n    number_of_particles=number_of_particles_optimized,\n)\n\n# Plot the original, guess, and optimized PDFs\nplt.figure(figsize=(10, 7))\nplt.plot(x_values, concentration_pdf, label=\"Original Data\", linewidth=2)\nplt.plot(x_values, concentration_pdf_guess, label=\"ML Guess\", linestyle=\"--\", linewidth=3)\nplt.plot(\n    x_values,\n    concentration_pdf_optimized,\n    label=\"Optimized Fit\",\n    linestyle=\"-.\",\n    linewidth=4,\n)\nplt.xscale(\"log\")\nplt.xlabel(\"Particle Size\")\nplt.ylabel(\"Concentration PDF\")\nplt.title(\"Comparison of Original, ML Guess, and Optimized Fit\")\nplt.legend()\nplt.show()\n</pre>   # Generate concentration PDFs for guess and optimized values concentration_pdf_guess = lognormal_pdf_distribution(     x_values=x_values,     mode=mode_values_guess,     geometric_standard_deviation=geometric_standard_deviation_guess,     number_of_particles=number_of_particles_guess, )  concentration_pdf_optimized = lognormal_pdf_distribution(     x_values=x_values,     mode=mode_values_optimized,     geometric_standard_deviation=gsd_optimized,     number_of_particles=number_of_particles_optimized, )  # Plot the original, guess, and optimized PDFs plt.figure(figsize=(10, 7)) plt.plot(x_values, concentration_pdf, label=\"Original Data\", linewidth=2) plt.plot(x_values, concentration_pdf_guess, label=\"ML Guess\", linestyle=\"--\", linewidth=3) plt.plot(     x_values,     concentration_pdf_optimized,     label=\"Optimized Fit\",     linestyle=\"-.\",     linewidth=4, ) plt.xscale(\"log\") plt.xlabel(\"Particle Size\") plt.ylabel(\"Concentration PDF\") plt.title(\"Comparison of Original, ML Guess, and Optimized Fit\") plt.legend() plt.show() In\u00a0[\u00a0]: Copied! <pre># Example\nx_values_example1 = np.logspace(1.2, 4, 150)\nconcentration_pdf_example1 = lognormal_pdf_distribution(\n    x_values=x_values_example1,\n    mode=np.array([100, 800]),\n    geometric_standard_deviation=np.array([1.1, 1.1]),\n    number_of_particles=np.array([300, 800]),\n)\n\n# Add noise\nconcentration_pdf_example1 = concentration_pdf_example1 * np.random.uniform(\n    low=0.8, high=1.25, size=concentration_pdf_example1.shape\n)\n\n# Obtain initial guess\nmode_guess1, gsd_guess1, particles_guess1 = (\n    generate_and_train_2mode_sizer.lognormal_2mode_ml_guess(\n        logspace_x=x_values_example1,\n        concentration_pdf=concentration_pdf_example1,\n    )\n)\n\n# Optimize\nmode_opt1, gsd_opt1, particles_opt1, r2_opt1, results1 = (\n    generate_and_train_2mode_sizer.optimize_lognormal_2mode(\n        mode_guess=mode_guess1,\n        geometric_standard_deviation_guess=gsd_guess1,\n        number_of_particles_in_mode_guess=particles_guess1,\n        x_values=x_values_example1,\n        concentration_pdf=concentration_pdf_example1,\n    )\n)\n</pre>  # Example x_values_example1 = np.logspace(1.2, 4, 150) concentration_pdf_example1 = lognormal_pdf_distribution(     x_values=x_values_example1,     mode=np.array([100, 800]),     geometric_standard_deviation=np.array([1.1, 1.1]),     number_of_particles=np.array([300, 800]), )  # Add noise concentration_pdf_example1 = concentration_pdf_example1 * np.random.uniform(     low=0.8, high=1.25, size=concentration_pdf_example1.shape )  # Obtain initial guess mode_guess1, gsd_guess1, particles_guess1 = (     generate_and_train_2mode_sizer.lognormal_2mode_ml_guess(         logspace_x=x_values_example1,         concentration_pdf=concentration_pdf_example1,     ) )  # Optimize mode_opt1, gsd_opt1, particles_opt1, r2_opt1, results1 = (     generate_and_train_2mode_sizer.optimize_lognormal_2mode(         mode_guess=mode_guess1,         geometric_standard_deviation_guess=gsd_guess1,         number_of_particles_in_mode_guess=particles_guess1,         x_values=x_values_example1,         concentration_pdf=concentration_pdf_example1,     ) ) In\u00a0[15]: Copied! <pre># Display and plot\nprint(\"Example 1:\")\nprint(f\"Initial Guess:\")\nprint(f\"Mode: {mode_guess1}\")\nprint(f\"GSD: {gsd_guess1}\")\nprint(f\"Number of particles: {particles_guess1}\")\n\nprint(f\"Optimized mode values: {mode_opt1}\")\nprint(f\"Optimized GSD: {gsd_opt1}\")\nprint(f\"Optimized number of particles: {particles_opt1}\")\nprint(f\"Optimized R\u00b2: {r2_opt1}\")\nprint(f\"Best optimization method: {results1['method']}\")\nplt.figure(figsize=(8, 6))\nplt.plot(x_values_example1, concentration_pdf_example1, label=\"Original Data\")\nplt.plot(\n    x_values_example1,\n    lognormal_pdf_distribution(\n        x_values=x_values_example1,\n        mode=mode_opt1,\n        geometric_standard_deviation=gsd_opt1,\n        number_of_particles=particles_opt1,\n    ),\n    label=\"Optimized Fit\",\n)\nplt.xscale(\"log\")\nplt.xlabel(\"Particle Size\")\nplt.ylabel(\"Concentration PDF\")\nplt.legend()\nplt.show()\n</pre> # Display and plot print(\"Example 1:\") print(f\"Initial Guess:\") print(f\"Mode: {mode_guess1}\") print(f\"GSD: {gsd_guess1}\") print(f\"Number of particles: {particles_guess1}\")  print(f\"Optimized mode values: {mode_opt1}\") print(f\"Optimized GSD: {gsd_opt1}\") print(f\"Optimized number of particles: {particles_opt1}\") print(f\"Optimized R\u00b2: {r2_opt1}\") print(f\"Best optimization method: {results1['method']}\") plt.figure(figsize=(8, 6)) plt.plot(x_values_example1, concentration_pdf_example1, label=\"Original Data\") plt.plot(     x_values_example1,     lognormal_pdf_distribution(         x_values=x_values_example1,         mode=mode_opt1,         geometric_standard_deviation=gsd_opt1,         number_of_particles=particles_opt1,     ),     label=\"Optimized Fit\", ) plt.xscale(\"log\") plt.xlabel(\"Particle Size\") plt.ylabel(\"Concentration PDF\") plt.legend() plt.show() <pre>Example 1:\nInitial Guess:\nMode: [149.48451487 739.05747291]\nGSD: [1.18937477 1.07885284]\nNumber of particles: [350.00811131 776.51103601]\nOptimized mode values: [ 99.38098192 795.02739947]\nOptimized GSD: [1.10427722 1.09958701]\nOptimized number of particles: [284.06490163 819.18581964]\nOptimized R\u00b2: 0.9779916485645566\nBest optimization method: Powell\n</pre>"},{"location":"Tutorials/Data_Analysis/Fitting_lognormal_PDFs_2modes/#fitting-lognormal-pdfs-2-modes","title":"Fitting Lognormal PDFs: 2 Modes\u00b6","text":"<p>This notebook demonstrates how to use a neural network to obtain an initial guess for fitting a lognormal probability density function (PDF) with two modes. It also shows how to optimize the initial guess using a cost function and visualize the results.</p>"},{"location":"Tutorials/Data_Analysis/Fitting_lognormal_PDFs_2modes/#generate-simulated-data","title":"Generate Simulated Data\u00b6","text":"<p>We start by generating simulated lognormal data for two modes. The data includes some noise to simulate real-world conditions.</p>"},{"location":"Tutorials/Data_Analysis/Fitting_lognormal_PDFs_2modes/#guess-using-neural-network","title":"Guess Using Neural Network\u00b6","text":"<p>Next, we use a pre-trained neural network model to get an initial guess for the lognormal parameters (mode, geometric standard deviation, and number of particles).</p>"},{"location":"Tutorials/Data_Analysis/Fitting_lognormal_PDFs_2modes/#optimize-the-lognormal-fit","title":"Optimize the Lognormal Fit\u00b6","text":"<p>With the initial guess obtained, we now optimize the parameters using a cost function to minimize the difference between the actual data and the fitted lognormal distribution.</p>"},{"location":"Tutorials/Data_Analysis/Fitting_lognormal_PDFs_2modes/#visualization","title":"Visualization\u00b6","text":"<p>Finally, we compare the original data, the initial guess from the neural network, and the optimized fit. This step helps us understand how close the initial guess was and how much improvement was achieved through optimization.</p>"},{"location":"Tutorials/Data_Analysis/Fitting_lognormal_PDFs_2modes/#additional-fits","title":"Additional Fits\u00b6","text":"<p>Let's try different initial conditions to see how the optimization behaves with varying data sets.</p>"},{"location":"Tutorials/Data_Analysis/Fitting_lognormal_PDFs_2modes/#conclusion","title":"Conclusion\u00b6","text":"<p>This notebook demonstrated the use of a neural network for generating an initial guess for fitting a lognormal PDF with two modes. The initial guess was then optimized to improve the fit, and the results were visualized to compare the original data, the initial guess, and the optimized fit.</p>"},{"location":"Tutorials/Dynamics/","title":"Dynamics","text":""},{"location":"Tutorials/Dynamics/#condensation","title":"Condensation","text":"<ul> <li>Condensation 1: Bins</li> <li>Condensation 2: Masses Binned</li> <li>Condensation 3: Masses Resolved</li> </ul>"},{"location":"Tutorials/Dynamics/#coagulation","title":"Coagulation","text":"<ul> <li>Coagulation 1: PMF Pattern</li> </ul> <ul> <li>Coagulation 3: Particle Resolved</li> <li>Coagulation 4: Methods Compared</li> </ul>"},{"location":"Tutorials/Dynamics/#functional","title":"Functional","text":"<ul> <li>Coagulation 1: Probability Mass Function</li> <li>Coagulation Tutorial: Basic 2-PDF</li> <li>Coagulation Tutorial: Basic 3-Compared</li> <li>Coagulation Tutorial: Basic 4-Particle Resolved</li> <li>Coagulation Tutorial: Basic 5-Super Droplet Method</li> </ul>"},{"location":"Tutorials/Dynamics/#customization","title":"Customization","text":"<ul> <li>Adding Particles During Simulation</li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_1_PMF_Pattern/","title":"Coagulation Patterns: PMF Particle Distribution","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# particula imports\nfrom particula.next import particles\nfrom particula.next.aerosol import Aerosol\n\nfrom particula.next.gas.species_builders import PresetGasSpeciesBuilder\nfrom particula.next.gas.atmosphere_builders import AtmosphereBuilder\n\nfrom particula.next.dynamics import particle_process\nfrom particula.next.dynamics import coagulation\n</pre> import numpy as np import matplotlib.pyplot as plt  # particula imports from particula.next import particles from particula.next.aerosol import Aerosol  from particula.next.gas.species_builders import PresetGasSpeciesBuilder from particula.next.gas.atmosphere_builders import AtmosphereBuilder  from particula.next.dynamics import particle_process from particula.next.dynamics import coagulation In\u00a0[2]: Copied! <pre># Preset gas species that does not condense in the atmosphere\n# AtmosphereBuilder constructs the atmosphere with predefined species\natmosphere = (\n    AtmosphereBuilder()\n    .add_species(PresetGasSpeciesBuilder().build())  # Add a preset gas species\n    .set_temperature(25, temperature_units=\"degC\")  # Set temperature to 25\u00b0C\n    .set_pressure(1, pressure_units=\"atm\")  # Set pressure to 1 atmosphere\n    .build()  # Finalize the atmosphere object\n)\n\n\n# Build a resolved mass representation for each particle\n# This defines how particle mass, activity, and surface are represented\nradius_bins = np.logspace(-8, -5, 250)  # Define the radius bins for the resolved mass representation\nresolved_masses = (\n    particles.PresetParticleRadiusBuilder()\n    .set_mode(np.array([100, 800]), mode_units=\"nm\")  # Set the mode radius\n    .set_geometric_standard_deviation(np.array([1.2, 1.5]))  # Set the geometric standard deviation\n    .set_number_concentration(np.array([1e5, 2e5]), number_concentration_units=\"cm^-3\")  # Set the number concentration\n    .set_distribution_type('pmf')  # Set the distribution type to PMF\n    .set_radius_bins(radius_bins, radius_bins_units=\"m\")  # Set the radius bins\n    .build()  # Finalize the resolved mass representation\n)\n\n# Create an aerosol object with the defined atmosphere and resolved particles\naerosol = Aerosol(atmosphere=atmosphere, particles=resolved_masses)\n\n# Print the properties\nprint(aerosol)\n</pre> # Preset gas species that does not condense in the atmosphere # AtmosphereBuilder constructs the atmosphere with predefined species atmosphere = (     AtmosphereBuilder()     .add_species(PresetGasSpeciesBuilder().build())  # Add a preset gas species     .set_temperature(25, temperature_units=\"degC\")  # Set temperature to 25\u00b0C     .set_pressure(1, pressure_units=\"atm\")  # Set pressure to 1 atmosphere     .build()  # Finalize the atmosphere object )   # Build a resolved mass representation for each particle # This defines how particle mass, activity, and surface are represented radius_bins = np.logspace(-8, -5, 250)  # Define the radius bins for the resolved mass representation resolved_masses = (     particles.PresetParticleRadiusBuilder()     .set_mode(np.array([100, 800]), mode_units=\"nm\")  # Set the mode radius     .set_geometric_standard_deviation(np.array([1.2, 1.5]))  # Set the geometric standard deviation     .set_number_concentration(np.array([1e5, 2e5]), number_concentration_units=\"cm^-3\")  # Set the number concentration     .set_distribution_type('pmf')  # Set the distribution type to PMF     .set_radius_bins(radius_bins, radius_bins_units=\"m\")  # Set the radius bins     .build()  # Finalize the resolved mass representation )  # Create an aerosol object with the defined atmosphere and resolved particles aerosol = Aerosol(atmosphere=atmosphere, particles=resolved_masses)  # Print the properties print(aerosol) <pre>Gas mixture at 298.15 K and 101325.0 Pa consisting of ['Preset100']\n[0]: Particle Representation:\n\tStrategy: RadiiBasedMovingBin\n\tActivity: ActivityIdealMass\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 8.993e-04 [kg/m^3]\n\tNumber Concentration: 3.000e+11 [#/m^3]\n</pre> In\u00a0[3]: Copied! <pre># Define the coagulation strategy and process\ncoagulation_strategy = coagulation.DiscreteSimple()\ncoagulation_process = particle_process.Coagulation(\n    coagulation_strategy=coagulation_strategy\n)\n\n# Set up time and sub-steps for the coagulation process\ntime_step = 1000\nsub_steps = 100\n\ninitial_radii = aerosol.particles[0].get_radius()\nconcentration_initial = np.copy(aerosol.particles[0].concentration)\n\n# Perform coagulation process for step 1\naerosol = coagulation_process.execute(\n    aerosol, time_step=time_step, sub_steps=sub_steps\n)\nradii_after_step_1 = aerosol.particles[0].get_radius()\nconcentration_step_1 = np.copy(aerosol.particles[0].concentration)\n\n# Perform coagulation process for step 2\naerosol = coagulation_process.execute(\n    aerosol, time_step=time_step, sub_steps=sub_steps\n)\nradii_after_step_2 = aerosol.particles[0].get_radius()\nconcentration_step_2 = np.copy(aerosol.particles[0].concentration)\n</pre> # Define the coagulation strategy and process coagulation_strategy = coagulation.DiscreteSimple() coagulation_process = particle_process.Coagulation(     coagulation_strategy=coagulation_strategy )  # Set up time and sub-steps for the coagulation process time_step = 1000 sub_steps = 100  initial_radii = aerosol.particles[0].get_radius() concentration_initial = np.copy(aerosol.particles[0].concentration)  # Perform coagulation process for step 1 aerosol = coagulation_process.execute(     aerosol, time_step=time_step, sub_steps=sub_steps ) radii_after_step_1 = aerosol.particles[0].get_radius() concentration_step_1 = np.copy(aerosol.particles[0].concentration)  # Perform coagulation process for step 2 aerosol = coagulation_process.execute(     aerosol, time_step=time_step, sub_steps=sub_steps ) radii_after_step_2 = aerosol.particles[0].get_radius() concentration_step_2 = np.copy(aerosol.particles[0].concentration) In\u00a0[4]: Copied! <pre># Create figure for visualizing the histogram of particle radii\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Plot the histogram of particle radii after step 1\nax.plot(initial_radii, concentration_initial, label=\"Initial\")\nax.plot(radii_after_step_1, concentration_step_1, label=\"Step 1\")\nax.plot(radii_after_step_2, concentration_step_2, label=\"Step 2\")\n\n# Set the labels and title of the plot\nax.set_xlabel(\"Particle Radius (m)\")\nax.set_ylabel(r\"Number Concentration ($m^{-3}$)\")\nax.set_title(\"Particle Radius Distribution After Coagulation Steps\")\nax.legend()\nax.set_xscale(\"log\")\nplt.show()\n</pre> # Create figure for visualizing the histogram of particle radii fig, ax = plt.subplots(figsize=(8, 6))  # Plot the histogram of particle radii after step 1 ax.plot(initial_radii, concentration_initial, label=\"Initial\") ax.plot(radii_after_step_1, concentration_step_1, label=\"Step 1\") ax.plot(radii_after_step_2, concentration_step_2, label=\"Step 2\")  # Set the labels and title of the plot ax.set_xlabel(\"Particle Radius (m)\") ax.set_ylabel(r\"Number Concentration ($m^{-3}$)\") ax.set_title(\"Particle Radius Distribution After Coagulation Steps\") ax.legend() ax.set_xscale(\"log\") plt.show()"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_1_PMF_Pattern/#coagulation-patterns-pmf-particle-distribution","title":"Coagulation Patterns: PMF Particle Distribution\u00b6","text":"<p>This notebook explores the coagulation process using a Probability Mass Function (PMF) to define the initial particle size distribution. A PMF provides a representation of discrete particle sizes bins and their associated counts.</p> <p>The PMF-based distribution allows us to model how the number of particles in each size category changes over time due to coagulation, providing insights into the size distribution's shift toward larger particles.</p> <p>PMF Particle Distribution: We initialize the particle size distribution using a PMF, where each particle bin has a concentration count. This discrete distribution captures the initial population of particles, categorized by size. The PMF provides flexibility in representing systems where specific particle sizes are dominant or where particles are grouped into size bins.</p> <p>Coagulation Process: The coagulation process is modeled using a discrete bin approach. We define the coagulation process using a flexible <code>Coagulation</code> class, which allows us to choose different coagulation strategies. In this notebook, we employ the <code>DiscreteSimple</code> strategy, which tracks each particle's properties as it undergoes coagulation.</p> <p>Imports:</p>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_1_PMF_Pattern/#aerosol-setup","title":"Aerosol Setup\u00b6","text":"<p>This section sets up the aerosol system, defining both the atmospheric conditions and the properties of the particles within it. We use the Builder pattern to construct the atmosphere and the particle mass distribution, ensuring that all parameters are defined explicitly and can be validated during the setup process.</p> <p>Atmospheric Setup</p> <p>The atmosphere is created using the <code>AtmosphereBuilder</code>. This class allows us to define key environmental parameters such as the gas species, temperature, and pressure.</p> <ul> <li>Gas Species: We add a preset gas species using the <code>PresetGasSpeciesBuilder</code>, which represents a non-condensing gas in the atmosphere.</li> <li>Temperature: The temperature is set to 25\u00b0C, representing typical atmospheric conditions.</li> <li>Pressure: Atmospheric pressure is set to 1 atm, simulating standard sea-level pressure.</li> </ul> <p>The <code>build()</code> method finalizes the atmosphere object, which will be used in the aerosol simulation.</p> <p>Resolved Particle Mass Representation</p> <p>Next, we define the particle mass distribution using the <code>PresetParticleRadiusBuilder</code>. This builder allows for setting up a detailed particle distribution based on physical properties such as particle size (mode), geometric standard deviation (GSD), and number concentration.</p> <ul> <li>Mode: The particle size modes are set to 100 nm and 800 nm, defining two distinct groups of particles within the aerosol.</li> <li>Geometric Standard Deviation (GSD): GSD values of 1.2 and 1.5 represent the spread of particle sizes within each mode, with the larger GSD indicating a broader distribution of particle sizes.</li> <li>Number Concentration: The number concentration for the two modes is defined as 1e5 and 2e5 particles per cm\u00b3, respectively.</li> <li>Distribution Type: We specify that the distribution follows a Probability Mass Function (PMF), which allows for a discrete representation of particle sizes.</li> <li>Radius Bins: The radius bins are defined using <code>np.logspace</code> to create a logarithmic spacing between particle radii ranging from 10 nm to 100 \u00b5m. This ensures that the distribution captures a wide range of particle sizes.</li> </ul> <p>Once all parameters are set, the <code>build()</code> method finalizes the particle mass representation.</p> <p>Aerosol Object Creation</p> <p>Finally, the aerosol system is created by combining the atmospheric conditions and the resolved particle masses. The resulting <code>aerosol</code> object contains both the gas phase and particle distribution, ready for use in the coagulation simulation.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_1_PMF_Pattern/#simulation","title":"Simulation\u00b6","text":"<p>In this section, we define the coagulation process and run it over multiple time steps. Coagulation is the process by which particles in an aerosol collide and merge, resulting in fewer, larger particles over time. The <code>Coagulation</code> class is used to simulate this behavior in a stepwise manner, updating the particle size distribution as the simulation progresses.</p> <p>Defining the Coagulation Strategy and Process</p> <p>We start by selecting a coagulation strategy using <code>DiscreteSimple()</code>, which defines how particles will interact and merge during the coagulation process. In this case, the <code>DiscreteSimple</code> strategy simplifies the coagulation by treating particle collisions discretely, allowing for straightforward tracking of particle size and number changes.</p> <ul> <li>Coagulation Strategy: The strategy dictates how particle interactions are handled. Here, <code>DiscreteSimple</code> offers a simplified, yet effective, approach for discrete particle interactions.</li> <li>Coagulation Process: The <code>Coagulation</code> class orchestrates the entire process, taking the defined strategy and applying it to the aerosol particles over the specified time and sub-steps.</li> </ul> <p>Simulation Setup: Time and Sub-Steps</p> <p>The coagulation process runs over defined time steps and sub-steps:</p> <ul> <li>Time Step: Each time step simulates the evolution of the aerosol system over a specific interval. In this case, it is set to 1000, representing a coarse time resolution.</li> <li>Sub-Steps: The time step is further divided into 100 sub-steps, which ensures a finer resolution for particle interactions, capturing the nuances of the coagulation process more accurately.</li> </ul> <p>Running the Coagulation Process</p> <p>The coagulation process is executed for the first time step using the <code>execute()</code> method. This method updates the aerosol object, modifying the particle size distribution as particles collide and merge. After this step:</p> <ul> <li>Radii After Step: The particle radii are extracted again to observe the changes in size distribution due to coagulation.</li> <li>Concentration After Step: The concentration of particles in each size bin is updated and saved for comparison.</li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_1_PMF_Pattern/#graphing","title":"Graphing\u00b6","text":"<p>In this section, we visualize how the particle size distribution evolves after each step of the coagulation process. The graph displays the number concentration of particles (in m\u207b\u00b3) as a function of particle radius (in meters). We use three curves to represent the distribution at different stages of the simulation:</p> <ol> <li>Initial: This curve represents the particle distribution before any coagulation occurs.</li> <li>Step 1: This curve shows how the distribution has changed after one step of the coagulation process.</li> <li>Step 2: This curve reflects the further evolution of the particle sizes after a second step of coagulation.</li> </ol> <p>Coagulation Effect:</p> <ul> <li>After the first step (orange line), the peaks shift downward, indicating a reduction in the number concentration of particles across both size ranges. This is due to smaller particles merging through coagulation, resulting in fewer particles overall.</li> <li>After the second step (green line), the number concentration of particles continues to decrease, with the peaks further reducing in height.</li> <li>The shift towards larger particles becomes more evident as the second peak moves slightly to the right. This is a typical result of coagulation, where larger particles grow as smaller particles merge into them.</li> </ul> <p>Distribution Changes:</p> <ul> <li>Decrease in Number Concentration: Coagulation leads to a reduction in the number of smaller particles as they combine to form larger ones. This is reflected in the decrease in concentration after each step.</li> <li>Shift Toward Larger Particles: The coagulation process shifts the distribution toward larger particle sizes. While the first step results in some particles merging, the second step pushes this trend further, as seen in the slight shift of the second peak to larger radii.</li> <li>Wider Distribution: As the simulation progresses, the particle size distribution becomes broader, indicating increased variability in particle sizes. This suggests that coagulation is affecting particles across a range of sizes, not just those at the peaks.</li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_1_PMF_Pattern/#conclusion","title":"Conclusion\u00b6","text":"<p>This notebook demonstrates how a PMF-based particle distribution can be used to model the coagulation process in an aerosol system. By tracking the changes in particle size distribution over time, we can observe the shift towards larger particles due to coagulation. The discrete representation of particle sizes allows for detailed insights into how particles interact and merge, leading to changes in the aerosol composition.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_3_Particle_Resolved_Pattern/","title":"Coagulation Patterns: Particle-Resolved Approach","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# particula imports\nfrom particula.next import particles\nfrom particula.next.aerosol import Aerosol\n\nfrom particula.next.gas.species_builders import PresetGasSpeciesBuilder\nfrom particula.next.gas.atmosphere_builders import AtmosphereBuilder\n\nfrom particula.next.dynamics import particle_process\nfrom particula.next.dynamics import coagulation\n</pre> import numpy as np import matplotlib.pyplot as plt  # particula imports from particula.next import particles from particula.next.aerosol import Aerosol  from particula.next.gas.species_builders import PresetGasSpeciesBuilder from particula.next.gas.atmosphere_builders import AtmosphereBuilder  from particula.next.dynamics import particle_process from particula.next.dynamics import coagulation In\u00a0[2]: Copied! <pre># Preset gas species that does not condense in the atmosphere\n# AtmosphereBuilder constructs the atmosphere with predefined species\natmosphere = (\n    AtmosphereBuilder()\n    .add_species(PresetGasSpeciesBuilder().build())  # Add a preset gas species\n    .set_temperature(25, temperature_units=\"degC\")  # Set temperature to 25\u00b0C\n    .set_pressure(1, pressure_units=\"atm\")  # Set pressure to 1 atmosphere\n    .build()  # Finalize the atmosphere object\n)\n\n# Generate a particle distribution using a lognormal sample distribution\n# This distribution has a mean particle diameter (mode) and geometric standard deviation (GSD)\nparticle_sample = particles.properties.lognormal_sample_distribution(\n    mode=np.array([100e-9]),  # Mean particle diameter of 100 nm\n    geometric_standard_deviation=np.array([1.3]),  # GSD of 1.3\n    number_of_particles=np.array([1e4]),  # Total number of particles\n    number_of_samples=100_000,  # Number of samples for particle distribution\n)\n\n# Calculate the mass of each particle in the sample, assuming density of 1500 kg/m^3\nparticle_mass_sample = (\n    4 / 3 * np.pi * particle_sample**3 * 1500\n)  # Particle mass in kg\n\n# Build a resolved mass representation for each particle\n# This defines how particle mass, activity, and surface are represented\nresolved_masses = (\n    particles.ResolvedParticleMassRepresentationBuilder()\n    .set_distribution_strategy(particles.ParticleResolvedSpeciatedMass())  # Use speciated mass distribution\n    .set_activity_strategy(particles.ActivityIdealMass())  # Define activity based on ideal mass\n    .set_surface_strategy(particles.SurfaceStrategyVolume())  # Define surface area based on particle volume\n    .set_mass(particle_mass_sample, \"kg\")  # Assign mass of particles (in kg)\n    .set_density(1500, \"kg/m^3\")  # Set particle density to 1500 kg/m^3\n    .set_charge(0)  # Assume neutral particles with no charge\n    .set_volume(0.1, \"cm^3\")  # Set volume of particle distribution\n    .build()  # Finalize the resolved mass representation\n)\n\n# Create an aerosol object with the defined atmosphere and resolved particles\naerosol = Aerosol(atmosphere=atmosphere, particles=resolved_masses)\n\n# Print the properties of the atmosphere\nprint(aerosol)\n</pre> # Preset gas species that does not condense in the atmosphere # AtmosphereBuilder constructs the atmosphere with predefined species atmosphere = (     AtmosphereBuilder()     .add_species(PresetGasSpeciesBuilder().build())  # Add a preset gas species     .set_temperature(25, temperature_units=\"degC\")  # Set temperature to 25\u00b0C     .set_pressure(1, pressure_units=\"atm\")  # Set pressure to 1 atmosphere     .build()  # Finalize the atmosphere object )  # Generate a particle distribution using a lognormal sample distribution # This distribution has a mean particle diameter (mode) and geometric standard deviation (GSD) particle_sample = particles.properties.lognormal_sample_distribution(     mode=np.array([100e-9]),  # Mean particle diameter of 100 nm     geometric_standard_deviation=np.array([1.3]),  # GSD of 1.3     number_of_particles=np.array([1e4]),  # Total number of particles     number_of_samples=100_000,  # Number of samples for particle distribution )  # Calculate the mass of each particle in the sample, assuming density of 1500 kg/m^3 particle_mass_sample = (     4 / 3 * np.pi * particle_sample**3 * 1500 )  # Particle mass in kg  # Build a resolved mass representation for each particle # This defines how particle mass, activity, and surface are represented resolved_masses = (     particles.ResolvedParticleMassRepresentationBuilder()     .set_distribution_strategy(particles.ParticleResolvedSpeciatedMass())  # Use speciated mass distribution     .set_activity_strategy(particles.ActivityIdealMass())  # Define activity based on ideal mass     .set_surface_strategy(particles.SurfaceStrategyVolume())  # Define surface area based on particle volume     .set_mass(particle_mass_sample, \"kg\")  # Assign mass of particles (in kg)     .set_density(1500, \"kg/m^3\")  # Set particle density to 1500 kg/m^3     .set_charge(0)  # Assume neutral particles with no charge     .set_volume(0.1, \"cm^3\")  # Set volume of particle distribution     .build()  # Finalize the resolved mass representation )  # Create an aerosol object with the defined atmosphere and resolved particles aerosol = Aerosol(atmosphere=atmosphere, particles=resolved_masses)  # Print the properties of the atmosphere print(aerosol) <pre>Gas mixture at 298.15 K and 101325.0 Pa consisting of ['Preset100']\n[0]: Particle Representation:\n\tStrategy: ParticleResolvedSpeciatedMass\n\tActivity: ActivityIdealMass\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 8.568e-06 [kg/m^3]\n\tNumber Concentration: 1.000e+12 [#/m^3]\n</pre> In\u00a0[3]: Copied! <pre># Define the coagulation strategy and process\ncoagulation_strategy = coagulation.ParticleResolved()\ncoagulation_process = particle_process.Coagulation(\n    coagulation_strategy=coagulation_strategy\n)\n\n# Set up time and sub-steps for the coagulation process\ntime_step = 1000\nsub_steps = 100\n\n# Define lognormal bins for particle radius histogram\nbins_lognormal = np.logspace(-8, -6, 100)\n\n# Get initial particle radii before the coagulation process\ninitial_radii = aerosol.particles[0].get_radius()\n\n# Perform coagulation process for step 1\naerosol = coagulation_process.execute(\n    aerosol, time_step=time_step, sub_steps=sub_steps\n)\nradii_after_step_1 = aerosol.particles[0].get_radius()\n\n# Perform coagulation process for step 2\naerosol = coagulation_process.execute(\n    aerosol, time_step=time_step, sub_steps=sub_steps\n)\nradii_after_step_2 = aerosol.particles[0].get_radius()\n\n# Count particles that have coagulated (i.e., have zero mass)\nzero_count = np.sum(aerosol.particles[0].get_mass() == 0)\nprint(f\"Particles that coagulated: {zero_count}\")\n</pre> # Define the coagulation strategy and process coagulation_strategy = coagulation.ParticleResolved() coagulation_process = particle_process.Coagulation(     coagulation_strategy=coagulation_strategy )  # Set up time and sub-steps for the coagulation process time_step = 1000 sub_steps = 100  # Define lognormal bins for particle radius histogram bins_lognormal = np.logspace(-8, -6, 100)  # Get initial particle radii before the coagulation process initial_radii = aerosol.particles[0].get_radius()  # Perform coagulation process for step 1 aerosol = coagulation_process.execute(     aerosol, time_step=time_step, sub_steps=sub_steps ) radii_after_step_1 = aerosol.particles[0].get_radius()  # Perform coagulation process for step 2 aerosol = coagulation_process.execute(     aerosol, time_step=time_step, sub_steps=sub_steps ) radii_after_step_2 = aerosol.particles[0].get_radius()  # Count particles that have coagulated (i.e., have zero mass) zero_count = np.sum(aerosol.particles[0].get_mass() == 0) print(f\"Particles that coagulated: {zero_count}\") <pre>Particles that coagulated: 51784\n</pre> In\u00a0[4]: Copied! <pre># Create figure for visualizing the histogram of particle radii\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Plot initial radii distribution\nbins, edges = np.histogram(initial_radii, bins=bins_lognormal)\nax.bar(edges[:-1], bins, width=np.diff(edges), align=\"edge\", label=\"Initial\")\n\n# Plot radii distribution after step 1\nbins, edges = np.histogram(radii_after_step_1, bins=bins_lognormal)\nax.bar(\n    edges[:-1],\n    bins,\n    width=np.diff(edges),\n    align=\"edge\",\n    label=\"After 1 step\",\n    alpha=0.7,\n)\n\n# Plot radii distribution after step 2\nbins, edges = np.histogram(radii_after_step_2, bins=bins_lognormal)\nax.bar(\n    edges[:-1],\n    bins,\n    width=np.diff(edges),\n    align=\"edge\",\n    label=\"After 2 steps\",\n    alpha=0.6,\n)\n\n# Set axes to logarithmic scale for x-axis (particle radius)\nax.set_xscale(\"log\")\n\n# Add labels and legend\nax.set_xlabel(\"Radius (m)\")\nax.set_ylabel(\"Number of particles\")\nplt.legend()\n\n# Show the plot\nplt.show()\n</pre> # Create figure for visualizing the histogram of particle radii fig, ax = plt.subplots(figsize=(8, 6))  # Plot initial radii distribution bins, edges = np.histogram(initial_radii, bins=bins_lognormal) ax.bar(edges[:-1], bins, width=np.diff(edges), align=\"edge\", label=\"Initial\")  # Plot radii distribution after step 1 bins, edges = np.histogram(radii_after_step_1, bins=bins_lognormal) ax.bar(     edges[:-1],     bins,     width=np.diff(edges),     align=\"edge\",     label=\"After 1 step\",     alpha=0.7, )  # Plot radii distribution after step 2 bins, edges = np.histogram(radii_after_step_2, bins=bins_lognormal) ax.bar(     edges[:-1],     bins,     width=np.diff(edges),     align=\"edge\",     label=\"After 2 steps\",     alpha=0.6, )  # Set axes to logarithmic scale for x-axis (particle radius) ax.set_xscale(\"log\")  # Add labels and legend ax.set_xlabel(\"Radius (m)\") ax.set_ylabel(\"Number of particles\") plt.legend()  # Show the plot plt.show()"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_3_Particle_Resolved_Pattern/#coagulation-patterns-particle-resolved-approach","title":"Coagulation Patterns: Particle-Resolved Approach\u00b6","text":"<p>In this notebook, we explore coagulation patterns through a particle-resolved approach. Rather than directly invoking coagulation functions for each calculation, we adopt a more modular and object-oriented programming structure. By employing design patterns, such as the <code>Builder</code> pattern, we simplify the setup and validation of parameters, making the process more maintainable and scalable.</p> <p>This approach allows for the efficient management of both the gas phase and the particle distribution, incorporating the verification of input parameters for accuracy and consistency. The <code>Builder</code> classes facilitate setting up the coagulation environment, from defining the atmospheric conditions to creating particle distributions and specifying their resolved masses.</p> <p>In this example, we preset a non-condensing gas species in the atmosphere and use a lognormal distribution for particles. We represent the particles using a particle-resolved mass framework, where we handle properties like density, charge, and mass with strategies to define the activity, surface area, and distribution.</p> <p>Imports</p>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_3_Particle_Resolved_Pattern/#aerosol-setup","title":"Aerosol Setup\u00b6","text":"<p>In this section, we define the core components of our particle-resolved coagulation system, focusing on the atmosphere setup, particle distribution, and mass resolution. This step-by-step breakdown helps clarify how the <code>Builder</code> pattern organizes the construction of complex objects and ensures input parameters are properly verified.</p> <p>Atmospheric Setup We begin by configuring the atmosphere using the <code>AtmosphereBuilder</code>. This allows for flexibility in defining environmental parameters such as temperature and pressure, as well as adding gas species. In this case, we add a preset gas species that does not condense and set the atmospheric conditions to 25\u00b0C and 1 atm.</p> <p>Particle Distribution The particle distribution is generated using a lognormal distribution, a common approach for representing aerosol particle sizes. The parameters for this distribution include:</p> <ul> <li>A mode of 100 nm, representing the mean particle diameter.</li> <li>A geometric standard deviation (GSD) of 1.3, which controls the spread of particle sizes.</li> <li>The total number of particles is 100,000 samples taken to capture the variability of the distribution.</li> </ul> <p>Mass Calculation The mass of each particle is calculated assuming a particle density of 1500 kg/m\u00b3. This density corresponds to typical aerosol materials like dust or certain types of particulate matter. The particle masses are computed using the formula for the volume of a sphere, multiplied by the density.</p> <p>Resolved Particle Mass Representation To capture the diversity of the aerosol population, we use a particle-resolved representation for mass. This approach explicitly tracks individual particle masses and assigns properties such as density and charge. The key strategies used are:</p> <ul> <li>Distribution strategy: Defines how mass is distributed among particles.</li> <li>Activity strategy: Describes how the activity of the particles is represented, in this case, assuming ideal mass behavior.</li> <li>Surface strategy: Calculates particle surface behavior by volume mixing.</li> </ul> <p>Final Aerosol Object The <code>Aerosol</code> object brings together the atmosphere and the resolved particle masses into a cohesive framework. This encapsulated representation can then be used to simulate particle interactions and coagulation events within the atmosphere.</p> <p>Finally, we print the properties of the <code>aerosol</code> object\u2019s atmosphere to verify the correct setup.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_3_Particle_Resolved_Pattern/#simulation","title":"Simulation\u00b6","text":"<p>In this section, we run the coagulation simulation by first defining the coagulation strategy and the process through which it is executed.</p> <ul> <li><p>Coagulation Strategy: The strategy for how coagulation is performed is selected using <code>coagulation.ParticleResolved()</code>. This specific strategy dictates how particle interactions are handled at the individual particle level, ensuring that the coagulation process respects the details of a particle-resolved approach. In this context, particles are treated as distinct entities, and the merging process is computed explicitly for each pair that interacts.</p> </li> <li><p>Particle Process: Once the strategy is defined, the <code>Coagulation</code> process is initialized by passing the chosen strategy (<code>coagulation_strategy</code>) to the <code>particle_process.Coagulation</code> class. This <code>Coagulation</code> class is responsible for running the actual simulation. It orchestrates the execution of coagulation by applying the selected strategy over the particle distribution. During each execution step, the particle properties\u2014such as mass, size, and count\u2014are updated according to the rules defined by the particle-resolved strategy.</p> </li> <li><p>Execution of the Process: The coagulation process is applied in steps using the <code>coagulation_process.execute()</code> method. In each step, the particles' masses are updated based on the time step and sub-steps provided. The time step controls the temporal resolution of the simulation, while the sub-steps break the time step into finer increments to ensure accurate resolution of coagulation events.</p> </li> </ul> <p>For each step:</p> <ol> <li>The radii of particles are obtained before and after the coagulation step.</li> <li>The updated particle properties, such as radius and mass, are recorded.</li> <li>After the final step, we count the number of particles that have fully coagulated, i.e., those that have a mass of zero.</li> </ol>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_3_Particle_Resolved_Pattern/#graphing","title":"Graphing\u00b6","text":"<p>In this section, we visualize the evolution of the particle size distribution as the coagulation process progresses.</p> <ul> <li>We use a histogram to show the distribution of particle radii at three stages: initially, after step 1, and after step 2.</li> <li>The x-axis is scaled logarithmically to properly represent the range of particle sizes, which can span multiple orders of magnitude.</li> <li>The plot helps illustrate the effect of coagulation, where particles merge over time, shifting the distribution towards larger sizes and reducing the number of smaller particles.</li> </ul> <p>This visual representation provides an intuitive understanding of how the coagulation process influences particle sizes, which is key to understanding aerosol dynamics in various atmospheric conditions.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_3_Particle_Resolved_Pattern/#conclusion","title":"Conclusion\u00b6","text":"<p>In this notebook, we have demonstrated a particle-resolved approach to modeling coagulation patterns in aerosol systems. By leveraging the <code>Builder</code> pattern and modular design, we have created a flexible and extensible framework for simulating particle interactions and tracking their properties over time.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_4_Compared/","title":"Coagulation Patterns: Comparison of Number and Mass","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# particula imports\nfrom particula.next import particles\nfrom particula.next.aerosol import Aerosol\n\nfrom particula.next.gas.species_builders import PresetGasSpeciesBuilder\nfrom particula.next.gas.atmosphere_builders import AtmosphereBuilder\n\nfrom particula.next.dynamics import particle_process\nfrom particula.next.dynamics import coagulation\n\nfrom particula.util.input_handling import convert_units\n</pre> import numpy as np import matplotlib.pyplot as plt  # particula imports from particula.next import particles from particula.next.aerosol import Aerosol  from particula.next.gas.species_builders import PresetGasSpeciesBuilder from particula.next.gas.atmosphere_builders import AtmosphereBuilder  from particula.next.dynamics import particle_process from particula.next.dynamics import coagulation  from particula.util.input_handling import convert_units In\u00a0[2]: Copied! <pre># common parameters\nmode = np.array([100e-9, 300e-9])  # m\ngeometric_standard_deviation = np.array([1.3, 1.3])\nnumber_of_particles = np.array([0.75, 0.25])  # effective when pdf has multiple modes\ndensity = np.array([1.0e3])\nvolume = 1 * convert_units('cm^3', 'm^3')  # cm^-3 to m^-3\n\n# Preset gas species that does not condense in the atmosphere\n# AtmosphereBuilder constructs the atmosphere with predefined species\natmosphere = (\n    AtmosphereBuilder()\n    .add_species(PresetGasSpeciesBuilder().build())  # Add a preset gas species\n    .set_temperature(25, temperature_units=\"degC\")  # Set temperature to 25\u00b0C\n    .set_pressure(1, pressure_units=\"atm\")  # Set pressure to 1 atmosphere\n    .build()  # Finalize the atmosphere object\n)\n</pre> # common parameters mode = np.array([100e-9, 300e-9])  # m geometric_standard_deviation = np.array([1.3, 1.3]) number_of_particles = np.array([0.75, 0.25])  # effective when pdf has multiple modes density = np.array([1.0e3]) volume = 1 * convert_units('cm^3', 'm^3')  # cm^-3 to m^-3  # Preset gas species that does not condense in the atmosphere # AtmosphereBuilder constructs the atmosphere with predefined species atmosphere = (     AtmosphereBuilder()     .add_species(PresetGasSpeciesBuilder().build())  # Add a preset gas species     .set_temperature(25, temperature_units=\"degC\")  # Set temperature to 25\u00b0C     .set_pressure(1, pressure_units=\"atm\")  # Set pressure to 1 atmosphere     .build()  # Finalize the atmosphere object ) <p>Particle Resolved</p> <p>In this section, we generate a particle distribution using a lognormal sample distribution, which is characterized by a specified mode (mean particle diameter) and geometric standard deviation (GSD). We then calculate the mass of each particle, assuming a constant density.</p> <p>Following this, we create a resolved mass representation for each particle, which defines how properties like mass, activity, and particle surfaces represented. The resolved mass representation is built using predefined strategies for mass distribution, activity, and surface area. We assign particle mass, set density, assume neutral particles (with no charge), and define the volume of the distribution.</p> <p>Finally, we combine the resolved particle properties with the atmospheric conditions to create an <code>Aerosol</code> object, which encapsulates both the particles and the atmosphere. The aerosol properties are then printed to provide an overview of the system.</p> In\u00a0[3]: Copied! <pre>number_of_samples = 100_000  # Number of samples for particle distribution\n\n# Generate a particle distribution using a lognormal sample distribution\n# This distribution has a mean particle diameter (mode) and geometric standard deviation (GSD)\nradii_sample= particles.properties.lognormal_sample_distribution(\n    mode=mode,\n    geometric_standard_deviation=geometric_standard_deviation,\n    number_of_particles=number_of_particles,\n    number_of_samples=number_of_samples,  # Number of samples for particle distribution\n)\n\n# Calculate the mass of each particle in the sample, assuming density of 1500 kg/m^3\nparticle_mass_sample = (\n    4 / 3 * np.pi * radii_sample**3 * density\n)  # Particle mass in kg\n\nprint(f\"Total mass of particles: {np.sum(particle_mass_sample):.2e} kg\")\n# Build a resolved mass representation for each particle\n# This defines how particle mass, activity, and surface are represented\nresolved_masses = (\n    particles.ResolvedParticleMassRepresentationBuilder()\n    # Use specieated mass distribution, ideal mass activity, and volume surface strategy\n    .set_distribution_strategy(particles.ParticleResolvedSpeciatedMass())\n    .set_activity_strategy(particles.ActivityIdealMass())\n    .set_surface_strategy(particles.SurfaceStrategyVolume())\n    .set_mass(particle_mass_sample, \"kg\")  # Assign mass of particles (in kg)\n    .set_density(density, \"kg/m^3\")  # Set particle density\n    .set_charge(0)  # Assume neutral particles with no charge\n    .set_volume(volume)  # Set volume of particle distribution\n    .build()  # Finalize the resolved mass representation\n)\n\n# Create an aerosol object with the defined atmosphere and resolved particles\naerosol_resolved = Aerosol(atmosphere=atmosphere, particles=resolved_masses)\n\n# Print the properties of the aerosol\nprint(aerosol_resolved)\n</pre> number_of_samples = 100_000  # Number of samples for particle distribution  # Generate a particle distribution using a lognormal sample distribution # This distribution has a mean particle diameter (mode) and geometric standard deviation (GSD) radii_sample= particles.properties.lognormal_sample_distribution(     mode=mode,     geometric_standard_deviation=geometric_standard_deviation,     number_of_particles=number_of_particles,     number_of_samples=number_of_samples,  # Number of samples for particle distribution )  # Calculate the mass of each particle in the sample, assuming density of 1500 kg/m^3 particle_mass_sample = (     4 / 3 * np.pi * radii_sample**3 * density )  # Particle mass in kg  print(f\"Total mass of particles: {np.sum(particle_mass_sample):.2e} kg\") # Build a resolved mass representation for each particle # This defines how particle mass, activity, and surface are represented resolved_masses = (     particles.ResolvedParticleMassRepresentationBuilder()     # Use specieated mass distribution, ideal mass activity, and volume surface strategy     .set_distribution_strategy(particles.ParticleResolvedSpeciatedMass())     .set_activity_strategy(particles.ActivityIdealMass())     .set_surface_strategy(particles.SurfaceStrategyVolume())     .set_mass(particle_mass_sample, \"kg\")  # Assign mass of particles (in kg)     .set_density(density, \"kg/m^3\")  # Set particle density     .set_charge(0)  # Assume neutral particles with no charge     .set_volume(volume)  # Set volume of particle distribution     .build()  # Finalize the resolved mass representation )  # Create an aerosol object with the defined atmosphere and resolved particles aerosol_resolved = Aerosol(atmosphere=atmosphere, particles=resolved_masses)  # Print the properties of the aerosol print(aerosol_resolved) <pre>Total mass of particles: 4.32e-12 kg\nGas mixture at 298.15 K and 101325.0 Pa consisting of ['Preset100']\n[0]: Particle Representation:\n\tStrategy: ParticleResolvedSpeciatedMass\n\tActivity: ActivityIdealMass\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 4.316e-06 [kg/m^3]\n\tNumber Concentration: 1.000e+11 [#/m^3]\n</pre> <p>PMF</p> <p>Here, we generate a Probability Mass Function (PMF) approach. We define the radius bins using a logarithmic scale and calculate the number concentration of particles based on the total number of particles and the system volume. The PMF distribution is then built by specifying the particle mode, geometric standard deviation, and number concentration.</p> <p>We set the distribution type to 'PMF' and define the radius bins, which represent the particle size categories. The particle density is also specified, and the PMF-based particle representation is finalized.</p> <p>After setting up the PMF particle distribution, we create an aerosol object that combines the PMF particle properties with the previously defined atmospheric conditions. The properties of the aerosol object are printed to give a summary of the system configuration.</p> In\u00a0[4]: Copied! <pre>radius_bins = np.logspace(-8, -6, 250)  # Define the radius bins for the resolved mass representation\n\nnumber_concentration = number_of_particles* np.array([number_of_samples/volume])  # Calculate the number concentration of particles\nprint(f\"Number concentration: {number_concentration[0]:.2e} m^-3\")\nparticle_pmf = (\n    particles.PresetParticleRadiusBuilder()\n    .set_mode(mode)\n    .set_geometric_standard_deviation(geometric_standard_deviation)\n    .set_number_concentration(number_concentration)\n    .set_distribution_type('pmf')  # Set the distribution type to PMF\n    .set_radius_bins(radius_bins, radius_bins_units=\"m\")  # Set the radius bins\n    .set_density(density, \"kg/m^3\")  # Set particle density\n    .build()  # Finalize the resolved mass representation\n)\n\n# Create an aerosol object with the defined atmosphere and resolved particles\naerosol_pmf = Aerosol(atmosphere=atmosphere, particles=particle_pmf)\n\n# Print the properties of the aerosol\nprint(aerosol_pmf)\n</pre> radius_bins = np.logspace(-8, -6, 250)  # Define the radius bins for the resolved mass representation  number_concentration = number_of_particles* np.array([number_of_samples/volume])  # Calculate the number concentration of particles print(f\"Number concentration: {number_concentration[0]:.2e} m^-3\") particle_pmf = (     particles.PresetParticleRadiusBuilder()     .set_mode(mode)     .set_geometric_standard_deviation(geometric_standard_deviation)     .set_number_concentration(number_concentration)     .set_distribution_type('pmf')  # Set the distribution type to PMF     .set_radius_bins(radius_bins, radius_bins_units=\"m\")  # Set the radius bins     .set_density(density, \"kg/m^3\")  # Set particle density     .build()  # Finalize the resolved mass representation )  # Create an aerosol object with the defined atmosphere and resolved particles aerosol_pmf = Aerosol(atmosphere=atmosphere, particles=particle_pmf)  # Print the properties of the aerosol print(aerosol_pmf)  <pre>Number concentration: 7.50e+10 m^-3\nGas mixture at 298.15 K and 101325.0 Pa consisting of ['Preset100']\n[0]: Particle Representation:\n\tStrategy: RadiiBasedMovingBin\n\tActivity: ActivityIdealMass\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 4.282e-06 [kg/m^3]\n\tNumber Concentration: 1.000e+11 [#/m^3]\n</pre> <p>PDF</p> <p>Lastly, we generate a particle distribution using the Probability Density Function (PDF) approach. Similar to the PMF setup, we specify the particle mode, geometric standard deviation, and number concentration. However, in this case, the distribution type is set to \"PDF\", which models the particle distribution as a continuous probability density function over the defined radius bins.</p> <p>We assign the same logarithmic radius bins as before, specify the particle density, and assume the particles are neutral by setting their charge to zero. After defining all necessary parameters, we finalize the PDF-based particle representation.</p> <p>As with the PMF approach, we create an aerosol object by combining the PDF-based particle distribution with the predefined atmospheric conditions. The properties of the resulting aerosol are printed to summarize the system configuration.</p> In\u00a0[5]: Copied! <pre>particle_pdf = (\n    particles.PresetParticleRadiusBuilder()\n    .set_mode(mode)\n    .set_geometric_standard_deviation(geometric_standard_deviation)\n    .set_number_concentration(number_concentration)\n    .set_distribution_type(\"pdf\")  # Set the distribution type to PMF\n    .set_radius_bins(radius_bins, radius_bins_units=\"m\")  # Set the radius bins\n    .set_density(density, \"kg/m^3\")  # Set particle density\n    .set_charge(np.zeros_like(radius_bins))  # Assume neutral particles with no charge\n    .build()  # Finalize the resolved mass representation\n)\n\n# Create an aerosol object with the defined atmosphere and resolved particles\naerosol_pdf = Aerosol(atmosphere=atmosphere, particles=particle_pdf)\n\n# Print the properties of the aerosol\nprint(aerosol_pdf)\n</pre> particle_pdf = (     particles.PresetParticleRadiusBuilder()     .set_mode(mode)     .set_geometric_standard_deviation(geometric_standard_deviation)     .set_number_concentration(number_concentration)     .set_distribution_type(\"pdf\")  # Set the distribution type to PMF     .set_radius_bins(radius_bins, radius_bins_units=\"m\")  # Set the radius bins     .set_density(density, \"kg/m^3\")  # Set particle density     .set_charge(np.zeros_like(radius_bins))  # Assume neutral particles with no charge     .build()  # Finalize the resolved mass representation )  # Create an aerosol object with the defined atmosphere and resolved particles aerosol_pdf = Aerosol(atmosphere=atmosphere, particles=particle_pdf)  # Print the properties of the aerosol print(aerosol_pdf) <pre>Gas mixture at 298.15 K and 101325.0 Pa consisting of ['Preset100']\n[0]: Particle Representation:\n\tStrategy: RadiiBasedMovingBin\n\tActivity: ActivityIdealMass\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 7.797e+02 [kg/m^3]\n\tNumber Concentration: 4.663e+19 [#/m^3]\n</pre> <p>Plot Initial Distributions</p> <p>In this section, we plot the initial particle distributions for the PMF, and particle-resolved approaches. The plots show the number concentration of particles as a function of particle radius for each method. The PMF is a line, and the particle-resolved has been binned into discrete sizes.</p> In\u00a0[6]: Copied! <pre># plot both\nradius_bins = particle_pmf.get_radius()\nradii_resolved = resolved_masses.get_radius()\n\nfig, ax = plt.subplots()\nbins, edges = np.histogram(radii_resolved, bins=radius_bins)\nax.bar(\n    edges[:-1],\n    bins/volume,\n    width=np.diff(edges),\n    align=\"edge\",\n    label=\"Resolved\",\n    alpha=0.7,\n)\nax.plot(\n    radius_bins,\n    particle_pmf.get_concentration(),\n    label=\"PMF\",\n    color=\"red\",\n)\nax.set_xscale(\"log\")\n# ax.set_yscale(\"log\")\nax.set_xlabel(\"Particle radius (m)\")\nax.set_ylabel(\"Number concentration (m^-3)\")\nax.legend()\nplt.show()\n</pre> # plot both radius_bins = particle_pmf.get_radius() radii_resolved = resolved_masses.get_radius()  fig, ax = plt.subplots() bins, edges = np.histogram(radii_resolved, bins=radius_bins) ax.bar(     edges[:-1],     bins/volume,     width=np.diff(edges),     align=\"edge\",     label=\"Resolved\",     alpha=0.7, ) ax.plot(     radius_bins,     particle_pmf.get_concentration(),     label=\"PMF\",     color=\"red\", ) ax.set_xscale(\"log\") # ax.set_yscale(\"log\") ax.set_xlabel(\"Particle radius (m)\") ax.set_ylabel(\"Number concentration (m^-3)\") ax.legend() plt.show() In\u00a0[7]: Copied! <pre># simulate aerosols, and save total mass and number distribution\n\n# Define the coagulation process\ncoagulation_process_pmf = particle_process.Coagulation(\n    coagulation_strategy=coagulation.DiscreteSimple()\n)\n\ncoagulation_process_resolved = particle_process.Coagulation(\n    coagulation_strategy=coagulation.ParticleResolved(\n        kernel_bins_per_decade=10)\n)\nhard_sphere = coagulation.HardSphere()\ncoagulation_process_pdf = particle_process.Coagulation(\n    coagulation_strategy=coagulation.ContinuousGeneralPDF(hard_sphere)\n)\n\n# Set up time and sub-steps for the coagulation process\ntotal_time = 10000\ntime_step = 100\nsub_steps = 1\n\n# output arrays\ntime = np.arange(0, total_time, time_step)\ntotal_mass_pmf = np.zeros_like(time, dtype=np.float64)\ntotal_mass_resolved = np.ones_like(time, dtype=np.float64)\ntotal_mass_pdf = np.zeros_like(time, dtype=np.float64)\nnumber_distribution_pmf = np.zeros((len(time), len(radius_bins)))\nnumber_distribution_resolved = np.zeros((len(time), number_of_samples))\nnumber_distribution_pdf = np.zeros((len(time), len(radius_bins)))\ntotal_number_pmf = np.zeros_like(time, dtype=np.float64)\ntotal_number_resolved = np.ones_like(time, dtype=np.float64)\ntotal_number_pdf = np.zeros_like(time, dtype=np.float64)\n</pre> # simulate aerosols, and save total mass and number distribution  # Define the coagulation process coagulation_process_pmf = particle_process.Coagulation(     coagulation_strategy=coagulation.DiscreteSimple() )  coagulation_process_resolved = particle_process.Coagulation(     coagulation_strategy=coagulation.ParticleResolved(         kernel_bins_per_decade=10) ) hard_sphere = coagulation.HardSphere() coagulation_process_pdf = particle_process.Coagulation(     coagulation_strategy=coagulation.ContinuousGeneralPDF(hard_sphere) )  # Set up time and sub-steps for the coagulation process total_time = 10000 time_step = 100 sub_steps = 1  # output arrays time = np.arange(0, total_time, time_step) total_mass_pmf = np.zeros_like(time, dtype=np.float64) total_mass_resolved = np.ones_like(time, dtype=np.float64) total_mass_pdf = np.zeros_like(time, dtype=np.float64) number_distribution_pmf = np.zeros((len(time), len(radius_bins))) number_distribution_resolved = np.zeros((len(time), number_of_samples)) number_distribution_pdf = np.zeros((len(time), len(radius_bins))) total_number_pmf = np.zeros_like(time, dtype=np.float64) total_number_resolved = np.ones_like(time, dtype=np.float64) total_number_pdf = np.zeros_like(time, dtype=np.float64) <p>Simulation Loop</p> <p>We then run a simulation loop that iterates over the specified time range, updating the particle distribution at each time step.</p> In\u00a0[8]: Copied! <pre># Simulation loop\n\nfor i, t in enumerate(time):\n    if i &gt; 0:\n        # Perform coagulation for the PDF aerosol\n        aerosol_pdf = coagulation_process_pdf.execute(aerosol_pdf, time_step, sub_steps)\n        # Perform coagulation for the PMF aerosol\n        aerosol_pmf = coagulation_process_pmf.execute(aerosol_pmf, time_step, sub_steps)\n        # Perform coagulation for the resolved aerosol\n        aerosol_resolved = coagulation_process_resolved.execute(aerosol_resolved, time_step, sub_steps)\n\n    total_mass_resolved[i] = aerosol_resolved.particles[0].get_mass_concentration()\n    number_distribution_resolved[i, :] = aerosol_resolved.particles[0].get_radius(clone=True)\n    total_number_resolved[i] = np.sum(number_distribution_resolved[i, :]&gt;0)\n\n    total_mass_pmf[i] = aerosol_pmf.particles[0].get_mass_concentration()\n    number_distribution_pmf[i, :] = aerosol_pmf.particles[0].get_concentration(clone=True)\n    total_number_pmf[i] = np.sum(number_distribution_pmf[i, :])\n\n    total_mass_pdf[i] = aerosol_pdf.particles[0].get_mass_concentration()\n    number_distribution_pdf[i, :] = aerosol_pdf.particles[0].get_concentration(clone=True)\n    total_number_pdf[i] = np.trapz(number_distribution_pdf[i, :], radius_bins)\n</pre> # Simulation loop  for i, t in enumerate(time):     if i &gt; 0:         # Perform coagulation for the PDF aerosol         aerosol_pdf = coagulation_process_pdf.execute(aerosol_pdf, time_step, sub_steps)         # Perform coagulation for the PMF aerosol         aerosol_pmf = coagulation_process_pmf.execute(aerosol_pmf, time_step, sub_steps)         # Perform coagulation for the resolved aerosol         aerosol_resolved = coagulation_process_resolved.execute(aerosol_resolved, time_step, sub_steps)      total_mass_resolved[i] = aerosol_resolved.particles[0].get_mass_concentration()     number_distribution_resolved[i, :] = aerosol_resolved.particles[0].get_radius(clone=True)     total_number_resolved[i] = np.sum(number_distribution_resolved[i, :]&gt;0)      total_mass_pmf[i] = aerosol_pmf.particles[0].get_mass_concentration()     number_distribution_pmf[i, :] = aerosol_pmf.particles[0].get_concentration(clone=True)     total_number_pmf[i] = np.sum(number_distribution_pmf[i, :])      total_mass_pdf[i] = aerosol_pdf.particles[0].get_mass_concentration()     number_distribution_pdf[i, :] = aerosol_pdf.particles[0].get_concentration(clone=True)     total_number_pdf[i] = np.trapz(number_distribution_pdf[i, :], radius_bins) In\u00a0[9]: Copied! <pre>print(aerosol_resolved)\nprint(aerosol_pmf)\n# print(aerosol_pdf)\n</pre> print(aerosol_resolved) print(aerosol_pmf) # print(aerosol_pdf) <pre>Gas mixture at 298.15 K and 101325.0 Pa consisting of ['Preset100']\n[0]: Particle Representation:\n\tStrategy: ParticleResolvedSpeciatedMass\n\tActivity: ActivityIdealMass\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 4.315e-06 [kg/m^3]\n\tNumber Concentration: 6.288e+10 [#/m^3]\nGas mixture at 298.15 K and 101325.0 Pa consisting of ['Preset100']\n[0]: Particle Representation:\n\tStrategy: RadiiBasedMovingBin\n\tActivity: ActivityIdealMass\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 4.242e-06 [kg/m^3]\n\tNumber Concentration: 6.259e+10 [#/m^3]\n</pre> In\u00a0[10]: Copied! <pre># plot the initial and final distributions\nfig, ax = plt.subplots(figsize=(8, 5))\n\nbins, edges = np.histogram(\n    number_distribution_resolved[0, :], bins=radius_bins\n)\nax.bar(\n    edges[:-1],\n    bins / volume,\n    width=np.diff(edges),\n    align=\"edge\",\n    label=\"Resolved initial\",\n    color=\"red\",\n    alpha=0.7,\n)\nbins, edges = np.histogram(\n    number_distribution_resolved[-1, :], bins=radius_bins\n)\nax.bar(\n    edges[:-1],\n    bins / volume,\n    width=np.diff(edges),\n    align=\"edge\",\n    label=\"Resolved final\",\n    color=\"blue\",\n    alpha=0.7,\n)\n\nax.plot(radius_bins, number_distribution_pmf[0, :], label=\"PMF initial\", color=\"red\")\nax.plot(radius_bins, number_distribution_pmf[-1, :], label=\"PMF final\", color=\"blue\")\n\nax.set_xscale(\"log\")\nax.set_xlabel(\"Particle radius (m)\")\nax.set_ylabel(\"Number concentration (m^-3)\")\nax.legend()\nplt.show()\n</pre> # plot the initial and final distributions fig, ax = plt.subplots(figsize=(8, 5))  bins, edges = np.histogram(     number_distribution_resolved[0, :], bins=radius_bins ) ax.bar(     edges[:-1],     bins / volume,     width=np.diff(edges),     align=\"edge\",     label=\"Resolved initial\",     color=\"red\",     alpha=0.7, ) bins, edges = np.histogram(     number_distribution_resolved[-1, :], bins=radius_bins ) ax.bar(     edges[:-1],     bins / volume,     width=np.diff(edges),     align=\"edge\",     label=\"Resolved final\",     color=\"blue\",     alpha=0.7, )  ax.plot(radius_bins, number_distribution_pmf[0, :], label=\"PMF initial\", color=\"red\") ax.plot(radius_bins, number_distribution_pmf[-1, :], label=\"PMF final\", color=\"blue\")  ax.set_xscale(\"log\") ax.set_xlabel(\"Particle radius (m)\") ax.set_ylabel(\"Number concentration (m^-3)\") ax.legend() plt.show() <p>Plot Mass Conservation</p> <p>In and ideal system, the mass should be conserved. In this section, we plot the mass conservation for the PMF, PDF, and particle-resolved approaches. The plots show the total mass of particles as a function of time during the coagulation process. The mass should remain constant over time, indicating that mass is conserved in the system.</p> <p>In our case, there is some numerical error in the mass conservation, this is particularly evident in the PMF method.</p> In\u00a0[11]: Copied! <pre># mass conservation plot\n\nmass_pmf_error = (total_mass_pmf - total_mass_pmf[0]) / total_mass_pmf[0]\nmass_resolved_error = (total_mass_resolved - total_mass_resolved[0]) / total_mass_resolved[0]\n\n\nfig, ax = plt.subplots(figsize=(8, 5))\nax.plot(time, mass_pmf_error, label=\"Probability Mass Function\")\nax.plot(time, mass_resolved_error, label=\"Particle Resolved\")\n# ax.set_yscale(\"log\")\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(\"Mass Error (relative to start)\")\nax.set_title(\"Error in mass conservation\")\nax.legend()\nplt.show()\n</pre> # mass conservation plot  mass_pmf_error = (total_mass_pmf - total_mass_pmf[0]) / total_mass_pmf[0] mass_resolved_error = (total_mass_resolved - total_mass_resolved[0]) / total_mass_resolved[0]   fig, ax = plt.subplots(figsize=(8, 5)) ax.plot(time, mass_pmf_error, label=\"Probability Mass Function\") ax.plot(time, mass_resolved_error, label=\"Particle Resolved\") # ax.set_yscale(\"log\") ax.set_xlabel(\"Time (s)\") ax.set_ylabel(\"Mass Error (relative to start)\") ax.set_title(\"Error in mass conservation\") ax.legend() plt.show() <p>Plot Number Error</p> <p>For the number concentration, we use the PDF distribution as the reference. We calculate the percent error in the number concentration for the PMF and particle-resolved approaches compared to the PDF distribution.</p> In\u00a0[12]: Copied! <pre># sum number concentration and plot\n\ntotal_pmf = np.sum(number_distribution_pmf, axis=1)\ntotal_resolved_non_zero = number_distribution_resolved &gt; 0\ntotal_resolved = np.sum(total_resolved_non_zero, axis=1) / volume\n\npercent_diff_resolved = (total_number_pdf - total_resolved) / total_number_pdf * 100\npercent_diff_pmf = (total_number_pdf - total_pmf) / total_number_pdf * 100\n\nprint(\n    f\"Resolved number final: {total_resolved[-1]:.2e}, PMF number final: {total_pmf[-1]:.2e}\"\n)\n\nfig, ax = plt.subplots(figsize=(8, 5))\nax.plot(time, percent_diff_resolved, label=\"Particle Resolved\", linestyle=\"--\")\nax.plot(time, percent_diff_pmf, label=\"Probability Mass Function\", linestyle=\"--\")\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(\"Percent Difference vs Probability Density Function\")\nax.set_title(\"Numerical Error in Number Concentration\")\nax.legend()\nplt.show()\n</pre> # sum number concentration and plot  total_pmf = np.sum(number_distribution_pmf, axis=1) total_resolved_non_zero = number_distribution_resolved &gt; 0 total_resolved = np.sum(total_resolved_non_zero, axis=1) / volume  percent_diff_resolved = (total_number_pdf - total_resolved) / total_number_pdf * 100 percent_diff_pmf = (total_number_pdf - total_pmf) / total_number_pdf * 100  print(     f\"Resolved number final: {total_resolved[-1]:.2e}, PMF number final: {total_pmf[-1]:.2e}\" )  fig, ax = plt.subplots(figsize=(8, 5)) ax.plot(time, percent_diff_resolved, label=\"Particle Resolved\", linestyle=\"--\") ax.plot(time, percent_diff_pmf, label=\"Probability Mass Function\", linestyle=\"--\") ax.set_xlabel(\"Time (s)\") ax.set_ylabel(\"Percent Difference vs Probability Density Function\") ax.set_title(\"Numerical Error in Number Concentration\") ax.legend() plt.show() <pre>Resolved number final: 6.29e+10, PMF number final: 6.26e+10\n</pre>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_4_Compared/#coagulation-patterns-comparison-of-number-and-mass","title":"Coagulation Patterns: Comparison of Number and Mass\u00b6","text":"<p>In this notebook, we explore and compare three distinct methods for representing particle distributions and modeling the coagulation process: the probability mass function (PMF), the probability density function (PDF), and the particle-resolved approach. The goal is to evaluate how each method impacts the number and mass of particles as coagulation progresses, providing insight into their strengths and limitations.</p> <p>Imports</p>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_4_Compared/#setup-distributions","title":"Setup Distributions\u00b6","text":"<p>In this section, we define the common parameters used throughout the notebook for modeling the particle distribution and atmosphere. These parameters include the mode of the particle size distribution, the geometric standard deviation, the number of particles in each mode, and the particle density. Additionally, we set the volume of the system for our simulations. The volume is only needed for the particle resolved approach, as the PMF and PDF methods do not require a volume to be defined.</p> <p>We also construct a simplified atmospheric environment using an <code>AtmosphereBuilder</code>, which includes a preset gas species that does not condense in the atmosphere. The temperature is set to 25\u00b0C and the pressure to 1 atmosphere, reflecting typical ambient conditions.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_4_Compared/#simulate-coagulation","title":"Simulate Coagulation\u00b6","text":"<p>In this section, we simulate the coagulation process for the PMF, PDF, and particle-resolved approaches. We define the time step for the simulation and the total simulation time. The time step is used to update the particle distribution at regular intervals, while the total simulation time determines the duration of the coagulation process.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_4_Compared/#results","title":"Results\u00b6","text":"<p>The results of the coagulation simulations are presented in this section. We compare the number and mass of particles for the PMF, PDF, and particle-resolved approaches at different time points during the coagulation process.</p> <p>The fist thing to check is the final state of the aerosol system.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Coagulation_4_Compared/#conclusion","title":"Conclusion\u00b6","text":"<p>In this notebook, we compared the PMF, PDF, and particle-resolved approaches for modeling particle distributions and the coagulation process. We found that each method has its strengths and limitations, with the PMF and PDF approaches providing a more continuous representation of the particle distribution, while the particle-resolved approach offers a more detailed view of individual particles.</p> <p>They all have numerical errors, but the PDF method is the most accurate in terms of mass conservation and number concentration. The PMF method has the largest error in mass concentration. The particle-resolved method has variable error in number concentration.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/","title":"Coagulation Basic 1: PMF Representation","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# particula imports\nfrom particula.next.dynamics.coagulation import brownian_kernel, rate\nfrom particula.next.particles.properties.lognormal_size_distribution import (\n    lognormal_pmf_distribution,\n)\n\n# The `brownian_kernel` function calculates the Brownian coagulation kernel,\n# which determines the rate at which particles coagulate due to random motion.\n# The `rate` function computes the rate of change in particle concentration\n# due to the coagulation process.\n# The `lognormal_pmf_distribution` function generates a probability mass function\n# based on a lognormal size distribution, commonly used to represent aerosol particles.\n</pre> import numpy as np import matplotlib.pyplot as plt import pandas as pd  # particula imports from particula.next.dynamics.coagulation import brownian_kernel, rate from particula.next.particles.properties.lognormal_size_distribution import (     lognormal_pmf_distribution, )  # The `brownian_kernel` function calculates the Brownian coagulation kernel, # which determines the rate at which particles coagulate due to random motion. # The `rate` function computes the rate of change in particle concentration # due to the coagulation process. # The `lognormal_pmf_distribution` function generates a probability mass function # based on a lognormal size distribution, commonly used to represent aerosol particles. In\u00a0[2]: Copied! <pre># Create a size distribution for aerosol particles\n\n# Define the bins for particle radius using a logarithmic scale\nradius_bins = np.logspace(start=-9, stop=-5, num=10)  # m (1 nm to 10 \u03bcm)\n\n# Calculate the mass of particles for each size bin\n# The mass is calculated using the formula for the volume of a sphere (4/3 * \u03c0 * r^3)\n# and assuming a particle density of 1 g/cm^3 (which is 1000 kg/m^3 in SI units).\nmass_bins = 4 / 3 * np.pi * radius_bins**3 * 1e3  # kg\n</pre> # Create a size distribution for aerosol particles  # Define the bins for particle radius using a logarithmic scale radius_bins = np.logspace(start=-9, stop=-5, num=10)  # m (1 nm to 10 \u03bcm)  # Calculate the mass of particles for each size bin # The mass is calculated using the formula for the volume of a sphere (4/3 * \u03c0 * r^3) # and assuming a particle density of 1 g/cm^3 (which is 1000 kg/m^3 in SI units). mass_bins = 4 / 3 * np.pi * radius_bins**3 * 1e3  # kg In\u00a0[3]: Copied! <pre># Calculate the Brownian coagulation kernel matrix\n\n# The Brownian coagulation kernel is calculated using the `brownian_coagulation_kernel_via_system_state` function.\n# This function takes into account the particle size, mass, temperature, pressure, and collision efficiency\n# to compute the coagulation rates between particles of different sizes.\nkernel = brownian_kernel.brownian_coagulation_kernel_via_system_state(\n    radius_particle=radius_bins,\n    mass_particle=mass_bins,\n    temperature=293.15,  # Temperature in Kelvin (20\u00b0C)\n    pressure=101325,  # Pressure in Pascals (1 atm)\n    alpha_collision_efficiency=1.0,  # Assume perfect collision efficiency\n)\n\n# Display the shape of the kernel matrix to confirm its dimensions\nprint(f\"Kernel shape: {kernel.shape}\")\n\n# Create a pandas DataFrame from the kernel matrix\n# The DataFrame allows for easier analysis and visualization of the coagulation kernel.\n# Rows and columns are indexed by the particle radius bins, making it clear which sizes are interacting.\ndf_kernel = pd.DataFrame(kernel, index=radius_bins, columns=radius_bins)\n\n# Print the first 5 rows of the DataFrame to inspect the computed kernel values\ndf_kernel.head(5)\n\n# Optional: Save the kernel matrix to a CSV file for further analysis or sharing\n# df_kernel.to_csv(\"kernel.csv\")\n</pre> # Calculate the Brownian coagulation kernel matrix  # The Brownian coagulation kernel is calculated using the `brownian_coagulation_kernel_via_system_state` function. # This function takes into account the particle size, mass, temperature, pressure, and collision efficiency # to compute the coagulation rates between particles of different sizes. kernel = brownian_kernel.brownian_coagulation_kernel_via_system_state(     radius_particle=radius_bins,     mass_particle=mass_bins,     temperature=293.15,  # Temperature in Kelvin (20\u00b0C)     pressure=101325,  # Pressure in Pascals (1 atm)     alpha_collision_efficiency=1.0,  # Assume perfect collision efficiency )  # Display the shape of the kernel matrix to confirm its dimensions print(f\"Kernel shape: {kernel.shape}\")  # Create a pandas DataFrame from the kernel matrix # The DataFrame allows for easier analysis and visualization of the coagulation kernel. # Rows and columns are indexed by the particle radius bins, making it clear which sizes are interacting. df_kernel = pd.DataFrame(kernel, index=radius_bins, columns=radius_bins)  # Print the first 5 rows of the DataFrame to inspect the computed kernel values df_kernel.head(5)  # Optional: Save the kernel matrix to a CSV file for further analysis or sharing # df_kernel.to_csv(\"kernel.csv\") <pre>Kernel shape: (10, 10)\n</pre> Out[3]: 1.000000e-09 2.782559e-09 7.742637e-09 2.154435e-08 5.994843e-08 1.668101e-07 4.641589e-07 1.291550e-06 3.593814e-06 1.000000e-05 1.000000e-09 8.812734e-16 2.277171e-15 1.181152e-14 7.503580e-14 4.506909e-13 2.024284e-12 6.824175e-12 2.020759e-11 5.737860e-11 1.607645e-10 2.782559e-09 2.277171e-15 1.461722e-15 3.692369e-15 1.733024e-14 8.141373e-14 3.005388e-13 9.275265e-13 2.670597e-12 7.517319e-12 2.100038e-11 7.742637e-09 1.181152e-14 3.692369e-15 2.224511e-15 4.558035e-15 1.429060e-14 4.375392e-14 1.267816e-13 3.580220e-13 1.001331e-12 2.790647e-12 2.154435e-08 7.503580e-14 1.733024e-14 4.558035e-15 2.123764e-15 3.008409e-15 7.020882e-15 1.858550e-14 5.087944e-14 1.407135e-13 3.904922e-13 5.994843e-08 4.506909e-13 8.141373e-14 1.429060e-14 3.008409e-15 1.304527e-15 1.624475e-15 3.413800e-15 8.588241e-15 2.303139e-14 6.320152e-14 In\u00a0[4]: Copied! <pre># Plot the Brownian coagulation kernel\n\n# Create a figure and axis object using matplotlib\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Plot the kernel values against the particle radius bins\n# The kernel values are plotted on a logarithmic scale (log10) for better visualization.\nax.plot(radius_bins, np.log10(kernel))\n\n# Set the x-axis label to indicate the particle radius in meters\nax.set_xlabel(\"Particle radius (m)\")\n\n# Set the y-axis label to indicate the logarithm of the kernel values\nax.set_ylabel(\"Log10(Kernel)\")\n\n# Use a logarithmic scale for the x-axis to properly represent the wide range of particle sizes\nax.set_xscale(\"log\")\n\n# Optionally, the y-axis can also be set to a logarithmic scale if needed\n# ax.set_yscale(\"log\")\n\n# Display the plot\nplt.show()\n</pre> # Plot the Brownian coagulation kernel  # Create a figure and axis object using matplotlib fig, ax = plt.subplots(figsize=(8, 6))  # Plot the kernel values against the particle radius bins # The kernel values are plotted on a logarithmic scale (log10) for better visualization. ax.plot(radius_bins, np.log10(kernel))  # Set the x-axis label to indicate the particle radius in meters ax.set_xlabel(\"Particle radius (m)\")  # Set the y-axis label to indicate the logarithm of the kernel values ax.set_ylabel(\"Log10(Kernel)\")  # Use a logarithmic scale for the x-axis to properly represent the wide range of particle sizes ax.set_xscale(\"log\")  # Optionally, the y-axis can also be set to a logarithmic scale if needed # ax.set_yscale(\"log\")  # Display the plot plt.show() In\u00a0[5]: Copied! <pre># Define the initial particle concentration\n\n# Set the initial concentration for each size bin\n# The concentration is set uniformly across all bins at 100 particles per cubic centimeter (100 cm^-3),\n# which is equivalent to 100 * 1e6 particles per cubic meter (m^-3).\nconcentration_0 = np.ones_like(radius_bins) * 100 * 1e6  # m^-3\n\n# Plot the initial concentration distribution\n\n# Create a figure and axis object for the plot\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Plot the concentration against the particle radius\nax.plot(radius_bins, concentration_0)\n\n# Set the x-axis label to indicate the particle radius in meters\nax.set_xlabel(\"Particle radius (m)\")\n\n# Set the y-axis label to indicate the concentration in particles per cubic meter\nax.set_ylabel(\"Concentration (m^-3)\")\n\n# Use a logarithmic scale for both the x-axis and y-axis\n# This is because the concentration distribution is typically viewed across several orders of magnitude\nax.set_xscale(\"log\")\nax.set_yscale(\"log\")\n\n# Display the plot\nplt.show()\n</pre> # Define the initial particle concentration  # Set the initial concentration for each size bin # The concentration is set uniformly across all bins at 100 particles per cubic centimeter (100 cm^-3), # which is equivalent to 100 * 1e6 particles per cubic meter (m^-3). concentration_0 = np.ones_like(radius_bins) * 100 * 1e6  # m^-3  # Plot the initial concentration distribution  # Create a figure and axis object for the plot fig, ax = plt.subplots(figsize=(8, 6))  # Plot the concentration against the particle radius ax.plot(radius_bins, concentration_0)  # Set the x-axis label to indicate the particle radius in meters ax.set_xlabel(\"Particle radius (m)\")  # Set the y-axis label to indicate the concentration in particles per cubic meter ax.set_ylabel(\"Concentration (m^-3)\")  # Use a logarithmic scale for both the x-axis and y-axis # This is because the concentration distribution is typically viewed across several orders of magnitude ax.set_xscale(\"log\") ax.set_yscale(\"log\")  # Display the plot plt.show() In\u00a0[6]: Copied! <pre># Coagulation rate calculation\n\n# Calculate the gain, loss, and net change in particle concentration due to coagulation\n# `discrete_gain`: Calculates the rate at which particles are gained due to coagulation\n# `discrete_loss`: Calculates the rate at which particles are lost due to coagulation\ngain_0 = rate.discrete_gain(radius_bins, concentration_0, kernel)\nloss_0 = rate.discrete_loss(concentration_0, kernel)\nnet_0 = gain_0 - loss_0  # Net change in concentration\n\n# Create a DataFrame to display the gain, loss, and net coagulation rates\n# The DataFrame is indexed by particle radius bins for clarity\ndf = pd.DataFrame(\n    data={\"Gain\": gain_0, \"Loss\": loss_0, \"Net\": net_0}, index=radius_bins\n)\n\n# Display the first 5 rows of the DataFrame\ndf.head(5)\n</pre> # Coagulation rate calculation  # Calculate the gain, loss, and net change in particle concentration due to coagulation # `discrete_gain`: Calculates the rate at which particles are gained due to coagulation # `discrete_loss`: Calculates the rate at which particles are lost due to coagulation gain_0 = rate.discrete_gain(radius_bins, concentration_0, kernel) loss_0 = rate.discrete_loss(concentration_0, kernel) net_0 = gain_0 - loss_0  # Net change in concentration  # Create a DataFrame to display the gain, loss, and net coagulation rates # The DataFrame is indexed by particle radius bins for clarity df = pd.DataFrame(     data={\"Gain\": gain_0, \"Loss\": loss_0, \"Net\": net_0}, index=radius_bins )  # Display the first 5 rows of the DataFrame df.head(5) Out[6]: Gain Loss Net 1.000000e-09 4.379653 2.477398e+06 -2.477394e+06 2.782559e-09 25.830601 3.252254e+05 -3.251995e+05 7.742637e-09 79.877700 4.357112e+04 -4.349124e+04 2.154435e-08 1666.815122 7.097477e+03 -5.430662e+03 5.994843e-08 -12799.281898 6.505676e+03 -1.930496e+04 In\u00a0[7]: Copied! <pre># Plot the coagulation gain, loss, and net rates\n\n# Create a figure and axis object for the plot\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Plot the net coagulation rate\n# The net rate is plotted with a thicker gray line for emphasis\nax.plot(radius_bins, net_0, label=\"Net\", color=\"gray\", linewidth=4)\n\n# Plot the gain rate\n# The gain rate is plotted in dark green\nax.plot(radius_bins, gain_0, label=\"Gain\", color=\"darkgreen\")\n\n# Plot the loss rate\n# The loss rate is plotted in red, and multiplied by -1 for plotting to indicate that it's a removal process\nax.plot(radius_bins, -1 * loss_0, label=\"Loss\", color=\"red\")\n\n# Set the x-axis label to indicate the particle radius in meters\nax.set_xlabel(\"Particle radius (m)\")\n\n# Set the y-axis label to indicate the rate of change in concentration, with appropriate units\nax.set_ylabel(r\"Rate $\\dfrac{1}{m^{3} s^{1}}$\")\n\n# Use a logarithmic scale for the x-axis to account for the wide range of particle sizes\nax.set_xscale(\"log\")\n\n# Add a legend to the plot to identify the gain, loss, and net lines\nplt.legend()\n\n# Display the plot\nplt.show()\n</pre> # Plot the coagulation gain, loss, and net rates  # Create a figure and axis object for the plot fig, ax = plt.subplots(figsize=(8, 6))  # Plot the net coagulation rate # The net rate is plotted with a thicker gray line for emphasis ax.plot(radius_bins, net_0, label=\"Net\", color=\"gray\", linewidth=4)  # Plot the gain rate # The gain rate is plotted in dark green ax.plot(radius_bins, gain_0, label=\"Gain\", color=\"darkgreen\")  # Plot the loss rate # The loss rate is plotted in red, and multiplied by -1 for plotting to indicate that it's a removal process ax.plot(radius_bins, -1 * loss_0, label=\"Loss\", color=\"red\")  # Set the x-axis label to indicate the particle radius in meters ax.set_xlabel(\"Particle radius (m)\")  # Set the y-axis label to indicate the rate of change in concentration, with appropriate units ax.set_ylabel(r\"Rate $\\dfrac{1}{m^{3} s^{1}}$\")  # Use a logarithmic scale for the x-axis to account for the wide range of particle sizes ax.set_xscale(\"log\")  # Add a legend to the plot to identify the gain, loss, and net lines plt.legend()  # Display the plot plt.show() In\u00a0[8]: Copied! <pre># Simulating the coagulation process over time manually\n\n# Define the time step for the simulation\nTIME_STEP = 0.1  # seconds\n\n# Time step 1: Calculate the gain, loss, and net rate, then update concentration\n\n# Calculate the rate of change in concentration (gain and loss) for the initial concentration\ngain = rate.discrete_gain(radius_bins, concentration_0, kernel)\nloss = rate.discrete_loss(concentration_0, kernel)\nnet = gain - loss  # Net rate of change\n\n# Update the concentration for the next time step\nconcentration_1 = concentration_0 + net * TIME_STEP\n\n# Time step 2: Recalculate rates with the updated concentration and update again\n\n# Recalculate gain and loss based on the updated concentration from time step 1\ngain = rate.discrete_gain(radius_bins, concentration_1, kernel)\nloss = rate.discrete_loss(concentration_1, kernel)\nnet = gain - loss\n\n# Update the concentration for the next time step\nconcentration_2 = concentration_1 + net * TIME_STEP\n\n# Time step 3: Recalculate rates again and update concentration\n\n# Recalculate gain and loss based on the updated concentration from time step 2\ngain = rate.discrete_gain(radius_bins, concentration_2, kernel)\nloss = rate.discrete_loss(concentration_2, kernel)\nnet = gain - loss\n\n# Update the concentration for the next time step\nconcentration_3 = concentration_2 + net * TIME_STEP\n\n# Print the maximum concentration at each time step to observe changes\nprint(f\"Concentration 0 max: {concentration_0.max()}\")\nprint(f\"Concentration 1 max: {concentration_1.max()}\")\nprint(f\"Concentration 2 max: {concentration_2.max()}\")\nprint(f\"Concentration 3 max: {concentration_3.max()}\")\n\n# Combine the concentrations at each time step into a DataFrame for easy comparison\ndf_concentration = pd.DataFrame(\n    {\n        \"0\": concentration_0,\n        \"1\": concentration_1,\n        \"2\": concentration_2,\n        \"3\": concentration_3,\n    },\n    index=radius_bins,\n)\n\n# Display the first five rows of the DataFrame to inspect the concentration changes\ndf_concentration.head(5)\n\n# Optional: Save the concentration data to a CSV file for further analysis\n# df_concentration.to_csv(\"concentration_uniform_sim.csv\")\n</pre> # Simulating the coagulation process over time manually  # Define the time step for the simulation TIME_STEP = 0.1  # seconds  # Time step 1: Calculate the gain, loss, and net rate, then update concentration  # Calculate the rate of change in concentration (gain and loss) for the initial concentration gain = rate.discrete_gain(radius_bins, concentration_0, kernel) loss = rate.discrete_loss(concentration_0, kernel) net = gain - loss  # Net rate of change  # Update the concentration for the next time step concentration_1 = concentration_0 + net * TIME_STEP  # Time step 2: Recalculate rates with the updated concentration and update again  # Recalculate gain and loss based on the updated concentration from time step 1 gain = rate.discrete_gain(radius_bins, concentration_1, kernel) loss = rate.discrete_loss(concentration_1, kernel) net = gain - loss  # Update the concentration for the next time step concentration_2 = concentration_1 + net * TIME_STEP  # Time step 3: Recalculate rates again and update concentration  # Recalculate gain and loss based on the updated concentration from time step 2 gain = rate.discrete_gain(radius_bins, concentration_2, kernel) loss = rate.discrete_loss(concentration_2, kernel) net = gain - loss  # Update the concentration for the next time step concentration_3 = concentration_2 + net * TIME_STEP  # Print the maximum concentration at each time step to observe changes print(f\"Concentration 0 max: {concentration_0.max()}\") print(f\"Concentration 1 max: {concentration_1.max()}\") print(f\"Concentration 2 max: {concentration_2.max()}\") print(f\"Concentration 3 max: {concentration_3.max()}\")  # Combine the concentrations at each time step into a DataFrame for easy comparison df_concentration = pd.DataFrame(     {         \"0\": concentration_0,         \"1\": concentration_1,         \"2\": concentration_2,         \"3\": concentration_3,     },     index=radius_bins, )  # Display the first five rows of the DataFrame to inspect the concentration changes df_concentration.head(5)  # Optional: Save the concentration data to a CSV file for further analysis # df_concentration.to_csv(\"concentration_uniform_sim.csv\") <pre>Concentration 0 max: 100000000.0\nConcentration 1 max: 1263633883.0015862\nConcentration 2 max: 11241880825.442844\nConcentration 3 max: 98778247873.61397\n</pre> Out[8]: 0 1 2 3 1.000000e-09 100000000.0 9.975226e+07 9.765578e+07 7.995004e+07 2.782559e-09 100000000.0 9.996748e+07 9.969288e+07 9.733161e+07 7.742637e-09 100000000.0 9.999565e+07 9.995912e+07 9.964448e+07 2.154435e-08 100000000.0 9.999946e+07 9.999441e+07 9.995043e+07 5.994843e-08 100000000.0 9.999807e+07 9.999542e+07 9.998650e+07 In\u00a0[9]: Copied! <pre># Plot the evolution of particle concentration over time\n\n# Create a figure and axis object for the plot\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Plot the concentration distribution at each time step\nax.plot(radius_bins, concentration_0, label=\"t=0\", linestyle=\"-\", color=\"blue\")\nax.plot(\n    radius_bins, concentration_1, label=\"t=1\", linestyle=\"--\", color=\"green\"\n)\nax.plot(\n    radius_bins, concentration_2, label=\"t=2\", linestyle=\"-.\", color=\"orange\"\n)\nax.plot(radius_bins, concentration_3, label=\"t=3\", linestyle=\":\", color=\"red\")\n\n# Set the x-axis label to indicate the particle radius in meters\nax.set_xlabel(\"Particle radius (m)\")\n\n# Set the y-axis label to indicate the concentration in particles per cubic meter\nax.set_ylabel(r\"Concentration $\\dfrac{1}{m^{3}}$\")\n\n# Use logarithmic scales for both the x-axis and y-axis\n# This helps in visualizing the broad range of particle sizes and concentration changes\nax.set_xscale(\"log\")\nax.set_yscale(\"log\")\n\n# Add a legend to differentiate between the time steps\nplt.legend()\n\n# Display the plot\nplt.show()\n</pre> # Plot the evolution of particle concentration over time  # Create a figure and axis object for the plot fig, ax = plt.subplots(figsize=(8, 6))  # Plot the concentration distribution at each time step ax.plot(radius_bins, concentration_0, label=\"t=0\", linestyle=\"-\", color=\"blue\") ax.plot(     radius_bins, concentration_1, label=\"t=1\", linestyle=\"--\", color=\"green\" ) ax.plot(     radius_bins, concentration_2, label=\"t=2\", linestyle=\"-.\", color=\"orange\" ) ax.plot(radius_bins, concentration_3, label=\"t=3\", linestyle=\":\", color=\"red\")  # Set the x-axis label to indicate the particle radius in meters ax.set_xlabel(\"Particle radius (m)\")  # Set the y-axis label to indicate the concentration in particles per cubic meter ax.set_ylabel(r\"Concentration $\\dfrac{1}{m^{3}}$\")  # Use logarithmic scales for both the x-axis and y-axis # This helps in visualizing the broad range of particle sizes and concentration changes ax.set_xscale(\"log\") ax.set_yscale(\"log\")  # Add a legend to differentiate between the time steps plt.legend()  # Display the plot plt.show() In\u00a0[10]: Copied! <pre># Define fine scale radius bins and corresponding mass bins for a lognormal distribution\n\n# Create fine scale radius bins on a logarithmic scale from 1 nm to 10 \u03bcm\nradius_bins = np.logspace(start=-9, stop=-4, num=250)  # m (1 nm to 10 \u03bcm)\n\n# Calculate the mass for each particle size bin assuming a density of 1 g/cm^3 (1000 kg/m^3)\nmass_bins = 4 / 3 * np.pi * (radius_bins) ** 3 * 1e3  # kg\n\n# Generate a lognormal particle size distribution\n# This distribution is characterized by a mode (most probable size) of 100 nm,\n# a geometric standard deviation of 1.4, and a total number concentration of 10000 particles per cm^3.\nconcentration_lognormal_0 = lognormal_pmf_distribution(\n    x_values=radius_bins,\n    mode=np.array(100e-9),  # Mode of the distribution (100 nm)\n    geometric_standard_deviation=np.array(1.4),  # Geometric standard deviation\n    number_of_particles=np.array(\n        1e6 * 1e6  # Total concentration (10000 cm^-3 converted to m^-3)\n    ),\n)\n\n# Plot the lognormal concentration distribution\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(radius_bins, concentration_lognormal_0)\n\n# Set the x-axis to a logarithmic scale to capture the wide range of particle sizes\nax.set_xlabel(\"Particle radius (m)\")\n\n# Label the y-axis to show the concentration in particles per cubic meter\nax.set_ylabel(\"Concentration $\\dfrac{1}{m^{3}}$\")\n\n# Use a logarithmic scale for the x-axis to better visualize the distribution across particle sizes\nax.set_xscale(\"log\")\n\n# Set Title\nax.set_title(\"PMF: Lognormal Particle Size Distribution\")\n\n# Display the plot\nplt.show()\n</pre> # Define fine scale radius bins and corresponding mass bins for a lognormal distribution  # Create fine scale radius bins on a logarithmic scale from 1 nm to 10 \u03bcm radius_bins = np.logspace(start=-9, stop=-4, num=250)  # m (1 nm to 10 \u03bcm)  # Calculate the mass for each particle size bin assuming a density of 1 g/cm^3 (1000 kg/m^3) mass_bins = 4 / 3 * np.pi * (radius_bins) ** 3 * 1e3  # kg  # Generate a lognormal particle size distribution # This distribution is characterized by a mode (most probable size) of 100 nm, # a geometric standard deviation of 1.4, and a total number concentration of 10000 particles per cm^3. concentration_lognormal_0 = lognormal_pmf_distribution(     x_values=radius_bins,     mode=np.array(100e-9),  # Mode of the distribution (100 nm)     geometric_standard_deviation=np.array(1.4),  # Geometric standard deviation     number_of_particles=np.array(         1e6 * 1e6  # Total concentration (10000 cm^-3 converted to m^-3)     ), )  # Plot the lognormal concentration distribution fig, ax = plt.subplots(figsize=(8, 6)) ax.plot(radius_bins, concentration_lognormal_0)  # Set the x-axis to a logarithmic scale to capture the wide range of particle sizes ax.set_xlabel(\"Particle radius (m)\")  # Label the y-axis to show the concentration in particles per cubic meter ax.set_ylabel(\"Concentration $\\dfrac{1}{m^{3}}$\")  # Use a logarithmic scale for the x-axis to better visualize the distribution across particle sizes ax.set_xscale(\"log\")  # Set Title ax.set_title(\"PMF: Lognormal Particle Size Distribution\")  # Display the plot plt.show() In\u00a0[11]: Copied! <pre># Simulating the coagulation process over time for a lognormal distribution\n\n# Define the time step for the simulation\nTIME_STEP = 100  # seconds\n\n# Calculate the coagulation kernel\nkernel = brownian_kernel.brownian_coagulation_kernel_via_system_state(\n    radius_particle=radius_bins,\n    mass_particle=mass_bins,\n    temperature=293.15,  # Temperature in Kelvin\n    pressure=101325,  # Pressure in Pascals (1 atm)\n    alpha_collision_efficiency=1.0,  # Assume perfect collision efficiency\n)\n\n# Time step 1: Calculate gain, loss, and update concentration\ngain = rate.discrete_gain(radius_bins, concentration_lognormal_0, kernel)\nloss = rate.discrete_loss(concentration_lognormal_0, kernel)\nnet = gain - loss\nconcentration_lognormal_1 = concentration_lognormal_0 + net * TIME_STEP\nconcentration_lognormal_1[concentration_lognormal_1 &lt; 0] = (\n    0  # Ensure no negative concentrations\n)\n\n# Time step 2: Recalculate rates and update concentration\ngain = rate.discrete_gain(radius_bins, concentration_lognormal_1, kernel)\nloss = rate.discrete_loss(concentration_lognormal_1, kernel)\nnet = gain - loss\nconcentration_lognormal_2 = concentration_lognormal_1 + net * TIME_STEP\nconcentration_lognormal_2[concentration_lognormal_2 &lt; 0] = (\n    0  # Ensure no negative concentrations\n)\n\n# Time step 3: Recalculate rates and update concentration\ngain = rate.discrete_gain(radius_bins, concentration_lognormal_2, kernel)\nloss = rate.discrete_loss(concentration_lognormal_2, kernel)\nnet = gain - loss\nconcentration_lognormal_3 = concentration_lognormal_2 + net * TIME_STEP\nconcentration_lognormal_3[concentration_lognormal_3 &lt; 0] = (\n    0  # Ensure no negative concentrations\n)\n\n# Combine the concentrations at each time step into a DataFrame for easy comparison\ndf_concentration = pd.DataFrame(\n    {\n        \"0\": concentration_lognormal_0,\n        \"1\": concentration_lognormal_1,\n        \"2\": concentration_lognormal_2,\n        \"3\": concentration_lognormal_3,\n    },\n    index=radius_bins,\n)\n\n# Optional: Save the concentration data to a CSV file for further analysis\n# df_concentration.to_csv(\"concentration_lognormal_sim.csv\")\n</pre> # Simulating the coagulation process over time for a lognormal distribution  # Define the time step for the simulation TIME_STEP = 100  # seconds  # Calculate the coagulation kernel kernel = brownian_kernel.brownian_coagulation_kernel_via_system_state(     radius_particle=radius_bins,     mass_particle=mass_bins,     temperature=293.15,  # Temperature in Kelvin     pressure=101325,  # Pressure in Pascals (1 atm)     alpha_collision_efficiency=1.0,  # Assume perfect collision efficiency )  # Time step 1: Calculate gain, loss, and update concentration gain = rate.discrete_gain(radius_bins, concentration_lognormal_0, kernel) loss = rate.discrete_loss(concentration_lognormal_0, kernel) net = gain - loss concentration_lognormal_1 = concentration_lognormal_0 + net * TIME_STEP concentration_lognormal_1[concentration_lognormal_1 &lt; 0] = (     0  # Ensure no negative concentrations )  # Time step 2: Recalculate rates and update concentration gain = rate.discrete_gain(radius_bins, concentration_lognormal_1, kernel) loss = rate.discrete_loss(concentration_lognormal_1, kernel) net = gain - loss concentration_lognormal_2 = concentration_lognormal_1 + net * TIME_STEP concentration_lognormal_2[concentration_lognormal_2 &lt; 0] = (     0  # Ensure no negative concentrations )  # Time step 3: Recalculate rates and update concentration gain = rate.discrete_gain(radius_bins, concentration_lognormal_2, kernel) loss = rate.discrete_loss(concentration_lognormal_2, kernel) net = gain - loss concentration_lognormal_3 = concentration_lognormal_2 + net * TIME_STEP concentration_lognormal_3[concentration_lognormal_3 &lt; 0] = (     0  # Ensure no negative concentrations )  # Combine the concentrations at each time step into a DataFrame for easy comparison df_concentration = pd.DataFrame(     {         \"0\": concentration_lognormal_0,         \"1\": concentration_lognormal_1,         \"2\": concentration_lognormal_2,         \"3\": concentration_lognormal_3,     },     index=radius_bins, )  # Optional: Save the concentration data to a CSV file for further analysis # df_concentration.to_csv(\"concentration_lognormal_sim.csv\") In\u00a0[12]: Copied! <pre># Print the maximum and minimum concentrations at each time step\n\nprint(f\"Max concentration at t=0: {concentration_lognormal_0.max()}\")\nprint(f\"Min concentration at t=0: {concentration_lognormal_0.min()}\")\n\nprint(f\"Max concentration at t=1: {concentration_lognormal_1.max()}\")\nprint(f\"Min concentration at t=1: {concentration_lognormal_1.min()}\")\n\nprint(f\"Max concentration at t=2: {concentration_lognormal_2.max()}\")\nprint(f\"Min concentration at t=2: {concentration_lognormal_2.min()}\")\n\nprint(f\"Max concentration at t=3: {concentration_lognormal_3.max()}\")\nprint(f\"Min concentration at t=3: {concentration_lognormal_3.min()}\")\n</pre> # Print the maximum and minimum concentrations at each time step  print(f\"Max concentration at t=0: {concentration_lognormal_0.max()}\") print(f\"Min concentration at t=0: {concentration_lognormal_0.min()}\")  print(f\"Max concentration at t=1: {concentration_lognormal_1.max()}\") print(f\"Min concentration at t=1: {concentration_lognormal_1.min()}\")  print(f\"Max concentration at t=2: {concentration_lognormal_2.max()}\") print(f\"Min concentration at t=2: {concentration_lognormal_2.min()}\")  print(f\"Max concentration at t=3: {concentration_lognormal_3.max()}\") print(f\"Min concentration at t=3: {concentration_lognormal_3.min()}\") <pre>Max concentration at t=0: 54738275267.16476\nMin concentration at t=0: 1.6445825598006672e-81\nMax concentration at t=1: 51186782324.56813\nMin concentration at t=1: 0.0\nMax concentration at t=2: 48026245801.09982\nMin concentration at t=2: 0.0\nMax concentration at t=3: 45351022236.99084\nMin concentration at t=3: 0.0\n</pre> In\u00a0[13]: Copied! <pre># Plot the coagulation gain, loss, and net rates for the lognormal distribution\n\n# Create a figure and axis object for the plot\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Plot the net coagulation rate\n# The net rate is plotted with a thicker gray line for emphasis\nax.plot(radius_bins, net, label=\"Net\", color=\"gray\", linewidth=4)\n\n# Plot the gain rate\n# The gain rate is plotted in dark green\nax.plot(radius_bins, gain, label=\"Gain\", color=\"darkgreen\")\n\n# Plot the loss rate\n# The loss rate is plotted in red, and multiplied by -1 for plotting to indicate that it's a removal process\nax.plot(radius_bins, -1 * loss, label=\"Loss\", color=\"red\")\n\n# Set the x-axis label to indicate the particle radius in meters\nax.set_xlabel(\"Particle radius (m)\")\n\n# Set the y-axis label to indicate the rate of change in concentration, with appropriate units\nax.set_ylabel(r\"Rate $\\dfrac{1}{m^{3} s^{1}}$\")\n\n# Use a logarithmic scale for the x-axis to account for the wide range of particle sizes\nax.set_xscale(\"log\")\n\n# set title\nax.set_title(\"PMF: Coagulation gain, loss, and net rates\")\n\n# Add a legend to identify the gain, loss, and net lines\nplt.legend()\n\n# Display the plot\nplt.show()\n</pre> # Plot the coagulation gain, loss, and net rates for the lognormal distribution  # Create a figure and axis object for the plot fig, ax = plt.subplots(figsize=(8, 6))  # Plot the net coagulation rate # The net rate is plotted with a thicker gray line for emphasis ax.plot(radius_bins, net, label=\"Net\", color=\"gray\", linewidth=4)  # Plot the gain rate # The gain rate is plotted in dark green ax.plot(radius_bins, gain, label=\"Gain\", color=\"darkgreen\")  # Plot the loss rate # The loss rate is plotted in red, and multiplied by -1 for plotting to indicate that it's a removal process ax.plot(radius_bins, -1 * loss, label=\"Loss\", color=\"red\")  # Set the x-axis label to indicate the particle radius in meters ax.set_xlabel(\"Particle radius (m)\")  # Set the y-axis label to indicate the rate of change in concentration, with appropriate units ax.set_ylabel(r\"Rate $\\dfrac{1}{m^{3} s^{1}}$\")  # Use a logarithmic scale for the x-axis to account for the wide range of particle sizes ax.set_xscale(\"log\")  # set title ax.set_title(\"PMF: Coagulation gain, loss, and net rates\")  # Add a legend to identify the gain, loss, and net lines plt.legend()  # Display the plot plt.show() In\u00a0[14]: Copied! <pre># Plot the evolution of particle concentration over time for the lognormal distribution\n\n# Create a figure and axis object for the plot\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Plot the concentration distribution at each time step\nax.plot(\n    radius_bins,\n    concentration_lognormal_0,\n    label=\"t=0\",\n    linestyle=\"-\",\n    color=\"blue\",\n)\nax.plot(\n    radius_bins,\n    concentration_lognormal_1,\n    label=\"t=1\",\n    linestyle=\"--\",\n    color=\"green\",\n)\nax.plot(\n    radius_bins,\n    concentration_lognormal_2,\n    label=\"t=2\",\n    linestyle=\"-.\",\n    color=\"orange\",\n)\nax.plot(\n    radius_bins,\n    concentration_lognormal_3,\n    label=\"t=3\",\n    linestyle=\":\",\n    color=\"red\",\n)\n\n# Set the x-axis label to indicate the particle radius in meters\nax.set_xlabel(\"Particle radius (m)\")\n\n# Set the y-axis label to indicate the concentration in particles per cubic meter\nax.set_ylabel(r\"Concentration $\\dfrac{1}{m^{3}}$\")\n\n# set title\nax.set_title(\"PMF: Particle concentration evolution over time\")\n\n# Use a logarithmic scale for both the x-axis and y-axis\n# This is essential for visualizing the wide range of particle sizes and concentration changes\nax.set_xscale(\"log\")\n# ax.set_yscale(\"log\")\n\n# Add a legend to differentiate between the time steps\nplt.legend()\n\n# Display the plot\nplt.show()\n</pre> # Plot the evolution of particle concentration over time for the lognormal distribution  # Create a figure and axis object for the plot fig, ax = plt.subplots(figsize=(8, 6))  # Plot the concentration distribution at each time step ax.plot(     radius_bins,     concentration_lognormal_0,     label=\"t=0\",     linestyle=\"-\",     color=\"blue\", ) ax.plot(     radius_bins,     concentration_lognormal_1,     label=\"t=1\",     linestyle=\"--\",     color=\"green\", ) ax.plot(     radius_bins,     concentration_lognormal_2,     label=\"t=2\",     linestyle=\"-.\",     color=\"orange\", ) ax.plot(     radius_bins,     concentration_lognormal_3,     label=\"t=3\",     linestyle=\":\",     color=\"red\", )  # Set the x-axis label to indicate the particle radius in meters ax.set_xlabel(\"Particle radius (m)\")  # Set the y-axis label to indicate the concentration in particles per cubic meter ax.set_ylabel(r\"Concentration $\\dfrac{1}{m^{3}}$\")  # set title ax.set_title(\"PMF: Particle concentration evolution over time\")  # Use a logarithmic scale for both the x-axis and y-axis # This is essential for visualizing the wide range of particle sizes and concentration changes ax.set_xscale(\"log\") # ax.set_yscale(\"log\")  # Add a legend to differentiate between the time steps plt.legend()  # Display the plot plt.show() In\u00a0[15]: Copied! <pre># Summation of PMF distribution\n# Calculate the total concentration of particles at each time step\ntotal_concentration_0 = concentration_lognormal_0.sum()\ntotal_concentration_1 = concentration_lognormal_1.sum()\ntotal_concentration_2 = concentration_lognormal_2.sum()\ntotal_concentration_3 = concentration_lognormal_3.sum()\n\n# Create a figure and axis object for the plot\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Plot the total concentration at each time step\nax.plot(\n    [total_concentration_0, total_concentration_1, total_concentration_2, total_concentration_3],\n    label=\"Total concentration\",\n    marker=\"o\",  # Add markers to indicate each time step\n    linestyle=\"-\",  # Use a solid line to connect the markers\n    color=\"blue\",  # Set the line color to blue\n)\n\n# Set the x-axis label to indicate the time step\nax.set_xlabel(\"Time step\")\n\n# Set the y-axis label to indicate the total concentration in particles per cubic meter\nax.set_ylabel(\"Total concentration $(m^{-3})$\")\nax.set_ylim(bottom=0.84e12)\n\nax.set_title(\"PMF: Total concentration at each time step\")\n\n# Display the plot\nplt.show()\n</pre> # Summation of PMF distribution # Calculate the total concentration of particles at each time step total_concentration_0 = concentration_lognormal_0.sum() total_concentration_1 = concentration_lognormal_1.sum() total_concentration_2 = concentration_lognormal_2.sum() total_concentration_3 = concentration_lognormal_3.sum()  # Create a figure and axis object for the plot fig, ax = plt.subplots(figsize=(8, 6))  # Plot the total concentration at each time step ax.plot(     [total_concentration_0, total_concentration_1, total_concentration_2, total_concentration_3],     label=\"Total concentration\",     marker=\"o\",  # Add markers to indicate each time step     linestyle=\"-\",  # Use a solid line to connect the markers     color=\"blue\",  # Set the line color to blue )  # Set the x-axis label to indicate the time step ax.set_xlabel(\"Time step\")  # Set the y-axis label to indicate the total concentration in particles per cubic meter ax.set_ylabel(\"Total concentration $(m^{-3})$\") ax.set_ylim(bottom=0.84e12)  ax.set_title(\"PMF: Total concentration at each time step\")  # Display the plot plt.show()"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#coagulation-basic-1-pmf-representation","title":"Coagulation Basic 1: PMF Representation\u00b6","text":""},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#direct-implementation-for-discrete-particle-size-distributions","title":"Direct Implementation for Discrete Particle Size Distributions\u00b6","text":"<p>In this section, we present a direct implementation of the coagulation process based on the methodology outlined in Seinfeld and Pandis (2006). This notebook is designed to provide a clear understanding of the fundamental code required to simulate particle coagulation, without the abstraction layers provided by more advanced object-oriented approaches.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#objective","title":"Objective\u00b6","text":"<p>The primary goal is to demonstrate how to calculate the coagulation kernel and the resulting coagulation rates for a given particle size distribution. We will start with a uniform size bin and distribution to establish the basic principles. Then, we will extend this to a more realistic lognormal distribution, which is commonly observed in aerosol science.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#approach","title":"Approach\u00b6","text":"<ul> <li>Uniform Distribution: We first initialize a simple, uniform particle size distribution. This helps in understanding the basic coagulation mechanics.</li> <li>Lognormal Probability Mass Function: After establishing the basics, we move on to a lognormal size distribution, which better represents real-world aerosol size distributions. Probability mass functions (PMFs) is a bin representation of the lognormal distribution, so the sum of all bins equals total concentration.</li> </ul> <p>This step-by-step approach will provide a foundation for understanding more complex implementations, such as those available in the <code>particula</code> library.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#required-libraries","title":"Required Libraries\u00b6","text":"<p>We will utilize standard scientific libraries such as <code>numpy</code> for numerical computations, <code>matplotlib</code> for plotting, and <code>pandas</code> for data handling. Additionally, we import specific functions from the <code>particula</code> library to calculate the coagulation kernel and generate size distributions.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#creating-a-size-distribution","title":"Creating a Size Distribution\u00b6","text":"<p>In this section, we define the size distribution for aerosol particles. The particle sizes are distributed across several bins, allowing us to model the behavior of particles across a wide size range.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#particle-size-bins","title":"Particle Size Bins\u00b6","text":"<p>We first define the bins for particle radii using a logarithmic scale. The logarithmic scale (<code>np.logspace</code>) is particularly useful when dealing with aerosol particles because their sizes often span several orders of magnitude\u2014from nanometers to micrometers. This approach ensures that we capture the full range of particle sizes with more granularity where it matters.</p> <ul> <li><code>radius_bins</code>: These bins represent the particle radii, ranging from 1 nanometer (1e-9 m) to 10 micrometers (1e-5 m).</li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#particle-mass-calculation","title":"Particle Mass Calculation\u00b6","text":"<p>Next, we calculate the mass of particles in each size bin. The mass is determined using the formula for the volume of a sphere (<code>4/3 * \u03c0 * r^3</code>), assuming a uniform particle density of 1 g/cm\u00b3 (which corresponds to 1000 kg/m\u00b3 in SI units).</p> <ul> <li><code>mass_bins</code>: The resulting array contains the masses of particles corresponding to each size bin, which is a key parameter for understanding how these particles will interact and coagulate.</li> </ul> <p>This setup provides a foundation for further analysis of the coagulation process by linking particle size and mass, essential components in determining coagulation rates.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#calculating-the-brownian-coagulation-kernel","title":"Calculating the Brownian Coagulation Kernel\u00b6","text":"<p>In this section, we calculate the Brownian coagulation kernel matrix, which quantifies the rate at which particles of different sizes collide and coagulate due to Brownian motion. The kernel matrix is central to understanding the dynamics of particle coagulation.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#kernel-calculation","title":"Kernel Calculation\u00b6","text":"<p>We use the <code>brownian_coagulation_kernel_via_system_state</code> function from the <code>particula</code> library to compute the kernel matrix. This function requires the following inputs:</p> <ul> <li><code>radius_particle</code>: The array of particle radii, which we previously defined in <code>radius_bins</code>.</li> <li><code>mass_particle</code>: The corresponding array of particle masses from <code>mass_bins</code>.</li> <li><code>temperature</code>: The ambient temperature, set here to 293.15 K (equivalent to 20\u00b0C).</li> <li><code>pressure</code>: The ambient pressure, set to 101325 Pa (standard atmospheric pressure).</li> <li><code>alpha_collision_efficiency</code>: A dimensionless factor representing the efficiency of particle collisions, assumed to be 1.0 for perfect efficiency.</li> </ul> <p>The output is a matrix (kernel) where each element represents the coagulation rate between two specific particle sizes.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#analyzing-the-kernel","title":"Analyzing the Kernel\u00b6","text":"<p>We print the shape of the kernel matrix to verify its dimensions, which should match the number of radius bins (i.e., it will be a square matrix).</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#creating-a-dataframe","title":"Creating a DataFrame\u00b6","text":"<p>To facilitate analysis, we convert the kernel matrix into a <code>pandas</code> DataFrame. The DataFrame format allows for easy manipulation and visualization of the data. The rows and columns of the DataFrame are indexed by the particle radii, making it straightforward to identify which particle sizes are interacting.</p> <p>We then print the first five rows of the DataFrame to inspect the calculated values. This provides a quick glimpse into the interaction rates between the smallest particles.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#optional-saving-the-kernel-matrix","title":"Optional: Saving the Kernel Matrix\u00b6","text":"<p>For further analysis or to share with others, the kernel matrix can be saved as a CSV file. This step is optional but useful if you need to persist the results for future work.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#plotting-the-brownian-coagulation-kernel","title":"Plotting the Brownian Coagulation Kernel\u00b6","text":"<p>After calculating the Brownian coagulation kernel, the next step is to visualize the results. A plot of the kernel values against the particle radius provides insights into how the coagulation rates vary with particle size.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#visualization-setup","title":"Visualization Setup\u00b6","text":"<p>We use <code>matplotlib</code> to create the plot:</p> <ul> <li>Figure and Axis: We begin by creating a figure and an axis object using <code>plt.subplots()</code>, which provides a flexible framework for plotting.</li> <li>Kernel Plot: The kernel values are plotted on the y-axis, and the particle radii on the x-axis. Since the kernel values can span several orders of magnitude, we plot their logarithm (base 10) to better visualize the data.</li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#axes-configuration","title":"Axes Configuration\u00b6","text":"<ul> <li>X-axis: The x-axis represents the particle radius in meters. Given the wide range of particle sizes, we use a logarithmic scale (<code>set_xscale(\"log\")</code>) to evenly distribute the data across the axis.</li> <li>Y-axis: The y-axis represents the logarithm of the kernel values (<code>Log10(Kernel)</code>). This choice makes it easier to observe trends and differences in the coagulation rates across different particle sizes.</li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#optional-y-axis-logarithmic-scale","title":"Optional Y-axis Logarithmic Scale\u00b6","text":"<p>If a deeper examination of the kernel's range is required, the y-axis can also be set to a logarithmic scale by uncommenting the <code>ax.set_yscale(\"log\")</code> line. This is useful when the kernel values span several orders of magnitude and need to be visualized more clearly.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#adding-particle-concentrations","title":"Adding Particle Concentrations\u00b6","text":"<p>Now that we have calculated the Brownian coagulation kernel, the next step is to introduce the particle concentrations. While the coagulation kernel itself does not depend on the particle concentration, the concentrations are critical when calculating the actual rate of coagulation, as they determine how many particles are available to interact.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#initial-concentration-setup","title":"Initial Concentration Setup\u00b6","text":"<p>We define an initial particle concentration for each size bin:</p> <ul> <li>Uniform Concentration: In this example, we set a uniform concentration across all size bins. Specifically, we assign a concentration of 100 particles per cubic centimeter (100 cm^-3), which converts to 100 million particles per cubic meter (100 * 1e6 m^-3). This concentration is representative of a typical ambient particle concentration in the atmosphere.</li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#visualization-of-the-initial-concentration","title":"Visualization of the Initial Concentration\u00b6","text":"<p>To better understand the initial distribution of particle concentrations, we plot these values against the particle radius:</p> <ul> <li>X-axis: The x-axis represents the particle radius in meters, using a logarithmic scale to cover the wide range of particle sizes.</li> <li>Y-axis: The y-axis shows the particle concentration in particles per cubic meter (m^-3), also plotted on a logarithmic scale. The logarithmic scales on both axes allow us to clearly see the distribution across several orders of magnitude, which is common in aerosol science.</li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#importance-of-concentration","title":"Importance of Concentration\u00b6","text":"<p>While the kernel function determines the rate at which particles of different sizes</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#coagulation-rate-calculation","title":"Coagulation Rate Calculation\u00b6","text":"<p>With the coagulation kernel and initial concentrations defined, we can now calculate the rates at which particles are gained, lost, and the net change due to coagulation. These rates are essential for understanding how the particle size distribution evolves over time as particles collide and coagulate.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#gain-loss-and-net-rate-calculation","title":"Gain, Loss, and Net Rate Calculation\u00b6","text":"<ul> <li><p>Gain (<code>discrete_gain</code>): This function calculates the rate at which particles are gained in each size bin due to coagulation. Gain occurs when two smaller particles collide to form a larger particle, increasing the concentration in the corresponding size bin.</p> </li> <li><p>Loss (<code>discrete_loss</code>): This function calculates the rate at which particles are lost from each size bin due to coagulation. Loss happens when particles in a particular size bin collide with other particles, thereby decreasing the concentration in that bin.</p> </li> <li><p>Net Rate: The net rate is the difference between the gain and loss for each size bin (<code>net_0 = gain_0 - loss_0</code>). It represents the overall change in concentration for each particle size due to coagulation.</p> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#displaying-results","title":"Displaying Results\u00b6","text":"<p>We create a <code>pandas</code> DataFrame to organize and display the gain, loss, and net coagulation rates for each particle size bin. The DataFrame is indexed by particle radius, which makes it easy to understand the changes in concentration across different sizes.</p> <ul> <li>Gain: The rate at which particles are added to each bin due to coagulation.</li> <li>Loss: The rate at which particles are removed from each bin due to coagulation.</li> <li>Net: The overall change in concentration for each bin.</li> </ul> <p>Finally, we display the first five rows of the DataFrame to inspect the initial values for gain, loss, and net change. This provides a quick look at how coagulation is expected to alter the particle size distribution in the system.</p> <p>By analyzing these rates, we can predict the dynamic behavior of the aerosol particles over time, as smaller particles merge to form larger ones or disappear from the system.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#plotting-the-coagulation-gain-loss-and-net-rates","title":"Plotting the Coagulation Gain, Loss, and Net Rates\u00b6","text":"<p>After calculating the coagulation rates, it's crucial to visualize how these rates vary across different particle sizes. This plot will show the gain, loss, and net rates of particle concentration as a function of particle radius.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#plot-details","title":"Plot Details\u00b6","text":"<ul> <li>Net Rate: The net rate of change in particle concentration is plotted as a thick gray line. This line highlights the overall effect of coagulation, showing whether the concentration in each size bin is increasing or decreasing.</li> <li>Gain Rate: The gain rate is plotted in dark green. This line shows how particles are being added to each size bin as smaller particles coagulate to form larger ones.</li> <li>Loss Rate: The loss rate is plotted in red. To make it visually distinct and indicate that it's a removal process, the loss rate is plotted as <code>-1 * loss_0</code>. This negative value reflects the decrease in particle concentration due to coagulation.</li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#axes-configuration","title":"Axes Configuration\u00b6","text":"<ul> <li><p>X-axis: The x-axis represents the particle radius in meters, plotted on a logarithmic scale. This scale is essential for accurately representing the wide range of particle sizes, from nanometers to micrometers.</p> </li> <li><p>Y-axis: The y-axis shows the rate of change in concentration, with units of <code>m\u207b\u00b3 s\u207b\u00b9</code>, indicating how quickly particles are being gained, lost, or changing net concentration in the system.</p> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#interpretation","title":"Interpretation\u00b6","text":"<p>By analyzing this plot, you can determine which particle sizes are most affected by coagulation. For instance, sizes where the net rate is positive indicate that coagulation is leading to an increase in concentration, while negative values suggest a decrease. This visualization is crucial for understanding the evolution of the particle size distribution over time.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#simulating-the-coagulation-process-over-time","title":"Simulating the Coagulation Process Over Time\u00b6","text":"<p>In this section, we manually simulate the coagulation process over a few discrete time steps. This manual simulation allows us to observe how particle concentrations evolve as a result of coagulation.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#simulation-setup","title":"Simulation Setup\u00b6","text":"<ul> <li>Time Step: We define a time step of 0.1 seconds (<code>TIME_STEP = 0.1</code>). This value represents the interval at which we update the particle concentrations based on the coagulation rates.</li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#time-step-1","title":"Time Step 1\u00b6","text":"<ol> <li>Calculate Gain and Loss: Using the initial concentration (<code>concentration_0</code>), we calculate the gain and loss rates using the coagulation kernel.</li> <li>Net Rate: The net rate of change in concentration is determined by subtracting the loss from the gain.</li> <li>Update Concentration: The concentration is updated by adding the net rate multiplied by the time step to the initial concentration, resulting in <code>concentration_1</code>.</li> </ol>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#time-step-2","title":"Time Step 2\u00b6","text":"<ol> <li>Recalculate Gain and Loss: With the updated concentration from time step 1 (<code>concentration_1</code>), we recalculate the gain and loss rates.</li> <li>Net Rate: Again, we calculate the net rate of change.</li> <li>Update Concentration: The concentration is updated to <code>concentration_2</code> using the same method as in time step 1.</li> </ol>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#time-step-3","title":"Time Step 3\u00b6","text":"<ol> <li>Recalculate Gain and Loss: We perform the same calculations with the concentration from time step 2 (<code>concentration_2</code>).</li> <li>Update Concentration: The concentration is updated to <code>concentration_3</code>.</li> </ol>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#observing-changes","title":"Observing Changes\u00b6","text":"<p>We print the maximum concentration at each time step to observe how the distribution evolves due to coagulation. This can provide insights into how quickly particles are coalescing into larger sizes or being depleted.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#dataframe-creation","title":"DataFrame Creation\u00b6","text":"<p>The concentrations at each time step are combined into a <code>pandas</code> DataFrame, making it easier to compare how the distribution changes over time. We display the first few rows to inspect these changes.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#optional-saving-results","title":"Optional: Saving Results\u00b6","text":"<p>The concentration data can be saved to a CSV file for further analysis or visualization, allowing you to track the evolution of particle concentrations over time.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#interpretation","title":"Interpretation\u00b6","text":"<p>By manually simulating the coagulation process, we can see the step-by-step changes in particle concentrations. This approach highlights the dynamic nature of coagulation and how it impacts particle size distributions in aerosols over time.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#plotting-the-evolution-of-particle-concentration","title":"Plotting the Evolution of Particle Concentration\u00b6","text":"<p>To visualize how particle concentrations evolve over time due to coagulation, we plot the concentration distributions at different time steps. This allows us to observe the changes in particle size distribution as the coagulation process progresses.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#plot-details","title":"Plot Details\u00b6","text":"<ul> <li><p>Time Step 0 (<code>t=0</code>): The initial concentration distribution is plotted as a solid blue line. This serves as the baseline before any coagulation has occurred.</p> </li> <li><p>Time Step 1 (<code>t=1</code>): After the first time step, the concentration distribution is plotted as a dashed green line. This shows the immediate effect of coagulation on the particle distribution.</p> </li> <li><p>Time Step 2 (<code>t=2</code>): The concentration distribution at the second time step is plotted as a dash-dot orange line. By this point, we can begin to see more noticeable changes as particles coagulate.</p> </li> <li><p>Time Step 3 (<code>t=3</code>): Finally, the concentration distribution after the third time step is plotted as a dotted red line, illustrating further evolution of the particle sizes as the coagulation process continues.</p> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#axes-configuration","title":"Axes Configuration\u00b6","text":"<ul> <li><p>X-axis: The x-axis represents the particle radius in meters, and is plotted on a logarithmic scale to capture the wide range of particle sizes.</p> </li> <li><p>Y-axis: The y-axis shows the concentration in particles per cubic meter (m\u207b\u00b3), also on a logarithmic scale to reflect the changes in concentration across orders of magnitude.</p> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#interpretation","title":"Interpretation\u00b6","text":"<p>As expected, smaller particles tend to coagulate into larger sizes, leading to changes in the overall distribution. This plot provides a visual representation of the dynamic nature of coagulation, making it easier to understand how particle populations evolve in an aerosol system.</p> <p>The plot provides a visual representation of the dynamic nature of coagulation, making it easier to understand how particle populations evolve in an aerosol system.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#end-member-error","title":"End member Error\u00b6","text":"<p>Due to the underlying numerical integration assumptions, a flat distribution is not treated correctly at the largest sizes. But in real-world cases where the distribution is not flat, this error is not significant.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#lognormal-distribution","title":"Lognormal Distribution\u00b6","text":"<p>In this section, we will implement the coagulation process for a lognormal particle size distribution. A lognormal distribution is more representative of real-world aerosol systems, where particles are not uniformly distributed in size but instead follow a distribution where most particles are centered around a particular size with fewer particles in the smaller and larger size ranges.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#why-lognormal-distribution","title":"Why Lognormal Distribution?\u00b6","text":"<p>A lognormal distribution is often observed in natural aerosol populations due to the multiplicative processes that govern particle formation and growth. This distribution is characterized by a peak (or mode) at the most common particle size, with the number of particles decreasing logarithmically for sizes smaller and larger than the mode. Implementing coagulation for this distribution will provide a more realistic simulation of how aerosol particles behave in the atmosphere.</p> <p>We will proceed by defining the lognormal size distribution, calculating the coagulation kernel, and then simulating the coagulation process over time, similar to what we did for the uniform distribution. This approach will allow us to compare the results between the uniform and lognormal distributions, highlighting the differences in coagulation dynamics based on initial particle size distributions.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#defining-the-radius-and-mass-bins","title":"Defining the Radius and Mass Bins\u00b6","text":"<ul> <li>Radius Bins: We define the particle radius bins on a logarithmic scale ranging from 1 nanometer (1e-9 m) to 10 micrometers (1e-4 m). Using 250 bins ensures a fine resolution across this range, which is important for accurately representing the lognormal distribution.</li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#generating-the-lognormal-distribution","title":"Generating the Lognormal Distribution\u00b6","text":"<ul> <li>Lognormal Distribution: We generate the particle concentration using a lognormal distribution, which is characterized by:<ul> <li>A mode (most probable size) of 100 nanometers (100 nm).</li> <li>A geometric standard deviation of 1.4, which controls the spread of the distribution.</li> <li>A total number concentration of 10000 particles per cubic centimeter (10000 cm\u207b\u00b3), converted to particles per cubic meter for consistency with our units.</li> </ul> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#plotting-the-lognormal-distribution","title":"Plotting the Lognormal Distribution\u00b6","text":"<p>The resulting lognormal distribution is plotted with particle radius on the x-axis (logarithmic scale) and particle concentration on the y-axis. This plot visually demonstrates the lognormal distribution, showing a peak around the mode (100 nm) with concentrations decreasing for both smaller and larger particles.</p> <p>This setup provides a more realistic starting point for simulating the coagulation process in an aerosol system.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#simulating-the-coagulation-process-for-a-lognormal-distribution","title":"Simulating the Coagulation Process for a Lognormal Distribution\u00b6","text":"<p>Having established a lognormal particle size distribution, we now proceed to simulate the coagulation process over time. This simulation will show how the distribution evolves as particles coagulate and form larger particles.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#simulation-setup","title":"Simulation Setup\u00b6","text":"<ul> <li><p>Time Step: We set a time step of 100 seconds (<code>TIME_STEP = 100</code>). This interval determines how frequently the particle concentrations are updated based on the calculated coagulation rates.</p> </li> <li><p>Coagulation Kernel: The coagulation kernel is calculated using the same parameters as before (temperature, pressure, and perfect collision efficiency). The kernel remains constant throughout the simulation as it only depends on the physical properties of the particles and the environment.</p> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#time-step-calculations","title":"Time Step Calculations\u00b6","text":"<p>For each time step, we calculate the gain, loss, and net change in particle concentration:</p> <ol> <li><p>Time Step 1:</p> <ul> <li>Calculate the gain and loss rates for the initial concentration (<code>concentration_lognormal_0</code>).</li> <li>Update the concentration to <code>concentration_lognormal_1</code> by applying the net rate of change. Any negative concentrations resulting from numerical errors are set to zero.</li> </ul> </li> <li><p>Time Step 2:</p> <ul> <li>Recalculate the gain and loss rates based on <code>concentration_lognormal_1</code>.</li> <li>Update the concentration to <code>concentration_lognormal_2</code> and ensure no negative values.</li> </ul> </li> <li><p>Time Step 3:</p> <ul> <li>Recalculate the rates again based on <code>concentration_lognormal_2</code>.</li> <li>Update the concentration to <code>concentration_lognormal_3</code>, correcting any negative values.</li> </ul> </li> </ol>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#combining-results","title":"Combining Results\u00b6","text":"<p>The concentrations at each time step are combined into a <code>pandas</code> DataFrame. This structure allows for easy comparison of how the particle size distribution changes over time due to coagulation.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#optional-saving-results","title":"Optional: Saving Results\u00b6","text":"<p>The resulting concentration data can be saved to a CSV file for further analysis or visualization. This step is optional but useful for documenting the evolution of the lognormal distribution over time.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#interpretation","title":"Interpretation\u00b6","text":"<p>By simulating the coagulation process for a lognormal distribution, we can observe how initially peaked distributions broaden and shift as particles merge. The correction for negative concentrations ensures that the physical constraints of the system (i.e., non-negative particle counts) are respected throughout the simulation.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#analyzing-concentration-extremes-over-time","title":"Analyzing Concentration Extremes Over Time\u00b6","text":"<p>To gain insights into how the particle concentrations evolve during the coagulation process, it's important to track the maximum and minimum concentrations at each time step. These values can provide valuable information about the stability and dynamics of the particle distribution.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#concentration-extremes","title":"Concentration Extremes\u00b6","text":"<p>We print the maximum and minimum concentrations for each time step:</p> <ul> <li><p>Time Step 0 (<code>t=0</code>):</p> <ul> <li>Max Concentration: This represents the highest concentration of particles at the initial distribution.</li> <li>Min Concentration: This represents the lowest concentration at the initial distribution.</li> </ul> </li> <li><p>Time Step 1 (<code>t=1</code>):</p> <ul> <li>Max Concentration: After the first time step, we observe the highest concentration to see how it compares with the initial state.</li> <li>Min Concentration: Similarly, the lowest concentration is noted, which may indicate the depletion of certain particle sizes.</li> </ul> </li> <li><p>Time Step 2 (<code>t=2</code>):</p> <ul> <li>Max Concentration: As the simulation progresses, the peak concentration may shift due to ongoing coagulation.</li> <li>Min Concentration: Continued tracking of the minimum concentration helps in understanding the impact of coagulation on smaller particle sizes.</li> </ul> </li> <li><p>Time Step 3 (<code>t=3</code>):</p> <ul> <li>Max Concentration: The final maximum concentration provides an overview of how the distribution has evolved.</li> <li>Min Concentration: The minimum concentration may highlight which particle sizes have been most affected by coagulation.</li> </ul> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#interpretation","title":"Interpretation\u00b6","text":"<p>By examining these extremes, we can infer the following:</p> <ul> <li><p>Max Concentration: Changes in the maximum concentration over time can indicate the formation of larger particles as smaller ones coagulate. A decrease in max concentration suggests that the most abundant particle size at earlier steps is merging with others, leading to a broader or shifted distribution.</p> </li> <li><p>Min Concentration: The minimum concentration helps identify whether certain particle sizes are becoming scarce due to coagulation, which may cause those bins to empty out or reduce significantly.</p> </li> </ul> <p>This analysis is crucial for understanding the dynamic behavior of the particle size distribution under coagulation and for ensuring that the simulation reflects realistic physical constraints.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#plotting-the-coagulation-gain-loss-and-net-rates-for-lognormal-distribution","title":"Plotting the Coagulation Gain, Loss, and Net Rates for Lognormal Distribution\u00b6","text":"<p>To visualize the dynamics of coagulation for a lognormal particle size distribution, we plot the rates of gain, loss, and net change in concentration across the range of particle sizes. This plot provides insights into how particles are interacting during the coagulation process.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#plot-details","title":"Plot Details\u00b6","text":"<ul> <li><p>Net Rate: The net rate of change in particle concentration is plotted as a thick gray line. This line represents the overall effect of coagulation, indicating whether the concentration in each size bin is increasing or decreasing.</p> </li> <li><p>Gain Rate: The gain rate, plotted in dark green, shows how particles are being added to each size bin as smaller particles coagulate to form larger ones. This rate reflects the accumulation of particles in specific size bins.</p> </li> <li><p>Loss Rate: The loss rate is plotted in red, with the values multiplied by -1 to indicate that it represents a reduction in particle concentration. This line shows how particles are being depleted from each size bin due to coagulation.</p> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#axes-configuration","title":"Axes Configuration\u00b6","text":"<ul> <li><p>X-axis: The x-axis represents the particle radius in meters, plotted on a logarithmic scale to capture the wide range of particle sizes present in the distribution.</p> </li> <li><p>Y-axis: The y-axis shows the rate of change in concentration in units of particles per cubic meter per second ($\\dfrac{1}{m^{3} s^{1}}$), providing a clear view of how rapidly particles are being gained, lost, or changing net concentration in the system.</p> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#legend-and-interpretation","title":"Legend and Interpretation\u00b6","text":"<p>A legend is included to clearly differentiate between the net, gain, and loss lines on the plot. By analyzing these rates, we can determine the most active particle sizes in the coagulation process:</p> <ul> <li>Positive Net Rate: Indicates that the particle size bin is gaining particles, likely due to the aggregation of smaller particles.</li> <li>Negative Net Rate: Indicates that the particle size bin is losing particles, either because they are merging into larger particles or being depleted through other processes.</li> </ul> <p>This plot is essential for understanding the detailed behavior of the particle size distribution during coagulation, highlighting which sizes are most affected by the process.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#plotting-the-evolution-of-concentration-for-lognormal-distribution","title":"Plotting the Evolution of Concentration for Lognormal Distribution\u00b6","text":"<p>After simulating the coagulation process over several time steps, it is important to visualize how the particle concentration evolves. This plot shows the concentration distribution at different time steps, allowing us to observe the changes in the lognormal distribution as coagulation progresses.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#plot-details","title":"Plot Details\u00b6","text":"<ul> <li><p>Time Step 0 (<code>t=0</code>): The initial concentration distribution is plotted as a solid blue line. This represents the starting point of the simulation, with a lognormal distribution centered around the mode.</p> </li> <li><p>Time Step 1 (<code>t=1</code>): After the first time step, the concentration distribution is plotted as a dashed green line. This line shows the immediate impact of coagulation on the particle sizes.</p> </li> <li><p>Time Step 2 (<code>t=2</code>): The concentration distribution at the second time step is plotted as a dash-dot orange line. By this time, noticeable shifts in the distribution may start to appear as particles coagulate.</p> </li> <li><p>Time Step 3 (<code>t=3</code>): Finally, the concentration distribution after the third time step is plotted as a dotted red line. This line illustrates further evolution of the distribution, highlighting the ongoing effects of coagulation.</p> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#axes-configuration","title":"Axes Configuration\u00b6","text":"<ul> <li><p>X-axis: The x-axis represents the particle radius in meters, plotted on a logarithmic scale to cover the wide range of particle sizes in the lognormal distribution.</p> </li> <li><p>Y-axis: The y-axis shows the concentration in particles per cubic meter (m\u207b\u00b3), also plotted on a logarithmic scale to reflect the broad range of concentrations.</p> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#interpretation","title":"Interpretation\u00b6","text":"<p>By comparing the concentration distributions at different time steps, you can observe how the lognormal distribution shifts and broadens as particles coagulate. Typically, the concentration of smaller particles decreases over time as they merge to form larger particles, leading to an increase in the concentration of larger particles. This visualization provides a clear, temporal view of the coagulation process and its effects on the particle size distribution.</p> <p>This plot is crucial for understanding the dynamic evolution of aerosol particles under coagulation, particularly when starting with a realistic lognormal distribution.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#total-concentration-over-time","title":"Total Concentration Over Time\u00b6","text":"<p>To understand the overall impact of coagulation on the particle population, it is essential to track the total concentration of particles over time. This plot shows how the total concentration changes as particles coagulate and form larger sizes.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#summary","title":"Summary\u00b6","text":"<p>In this notebook, we explored the process of particle coagulation in aerosols, focusing on both uniform and lognormal particle size distributions. The notebook provided a step-by-step implementation of the coagulation process, highlighting key concepts and calculations necessary to simulate the dynamic behavior of aerosol particles over time.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#key-steps-and-findings","title":"Key Steps and Findings:\u00b6","text":"<ol> <li><p>Coagulation Basics:</p> <ul> <li>We began with a uniform particle size distribution to introduce the fundamental concepts of coagulation, including the calculation of the Brownian coagulation kernel and the rates of particle gain, loss, and net change.</li> <li>The initial uniform distribution allowed us to understand the basic mechanics of how particles interact and merge over time.</li> </ul> </li> <li><p>Transition to Lognormal Distribution:</p> <ul> <li>We then shifted to a more realistic lognormal particle size distribution, which better represents real-world aerosol systems. This distribution was characterized by a mode (most probable particle size), a geometric standard deviation, and a total number concentration.</li> <li>The coagulation process was simulated for this lognormal distribution, with the particle concentrations updated over several discrete time steps.</li> </ul> </li> <li><p>Simulation and Visualization:</p> <ul> <li>The evolution of the particle size distribution was tracked over time, with plots showing the changes in concentration for different particle sizes. These plots illustrated how smaller particles gradually merge to form larger ones, leading to a shift and broadening of the distribution.</li> <li>The rates of particle gain, loss, and net change were also visualized, providing insights into the most active particle sizes during the coagulation process.</li> </ul> </li> <li><p>Key Insights:</p> <ul> <li>The notebook demonstrated that coagulation leads to a decrease in the number concentration of smaller particles as they coalesce to form larger particles. This results in a broader size distribution with fewer small particles and an increased concentration of larger particles.</li> <li>The lognormal distribution, due to its realistic representation of aerosol particles, showed more complex dynamics compared to the uniform distribution, emphasizing the importance of starting with an appropriate initial distribution in simulations.</li> </ul> </li> </ol>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_1_PMF/#conclusion","title":"Conclusion:\u00b6","text":"<p>This notebook provided a guide to simulating the coagulation process in aerosol particles, from basic principles to more advanced applications involving realistic size distributions. By comparing the results from uniform and lognormal distributions, we gained a deeper understanding of how particle populations evolve under coagulation, highlighting the critical role of particle size distribution in aerosol dynamics. The methods and visualizations presented here can be extended to further study and analyze aerosol behavior in various environmental and industrial contexts.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/","title":"Coagulation Basics 2: PDF Representation","text":"In\u00a0[18]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom scipy.integrate import trapezoid\n\n# particula imports\nfrom particula.next.dynamics.coagulation import brownian_kernel, rate\nfrom particula.next.particles.properties.lognormal_size_distribution import (\n    lognormal_pdf_distribution,\n)\nfrom particula.util.convert import distribution_convert_pdf_pms\n\n# The `brownian_kernel` function calculates the Brownian coagulation kernel,\n# determining the rate at which particles coagulate due to random motion.\n# The `rate` function computes the rate of change in particle concentration\n# resulting from coagulation.\n# The `lognormal_pdf_distribution` function generates a probability density\n# function (PDF) representing a lognormal size distribution.\n</pre> import numpy as np import matplotlib.pyplot as plt import pandas as pd from scipy.integrate import trapezoid  # particula imports from particula.next.dynamics.coagulation import brownian_kernel, rate from particula.next.particles.properties.lognormal_size_distribution import (     lognormal_pdf_distribution, ) from particula.util.convert import distribution_convert_pdf_pms  # The `brownian_kernel` function calculates the Brownian coagulation kernel, # determining the rate at which particles coagulate due to random motion. # The `rate` function computes the rate of change in particle concentration # resulting from coagulation. # The `lognormal_pdf_distribution` function generates a probability density # function (PDF) representing a lognormal size distribution. In\u00a0[19]: Copied! <pre># Create fine-scale radius bins on a logarithmic scale from 1 nm to 10 \u03bcm\nradius_bins = np.logspace(start=-9, stop=-4, num=500)  # m (1 nm to 10 \u03bcm)\n\n# Calculate the mass for each particle size bin assuming a density of 1 g/cm\u00b3 (1000 kg/m\u00b3)\nmass_bins = 4 / 3 * np.pi * radius_bins**3 * 1e3  # kg\n</pre> # Create fine-scale radius bins on a logarithmic scale from 1 nm to 10 \u03bcm radius_bins = np.logspace(start=-9, stop=-4, num=500)  # m (1 nm to 10 \u03bcm)  # Calculate the mass for each particle size bin assuming a density of 1 g/cm\u00b3 (1000 kg/m\u00b3) mass_bins = 4 / 3 * np.pi * radius_bins**3 * 1e3  # kg In\u00a0[20]: Copied! <pre># The Brownian coagulation kernel is calculated using the `brownian_coagulation_kernel_via_system_state` function.\n# This function takes into account particle size, mass, temperature, pressure, and collision efficiency\n# to compute the coagulation rates between particles of different sizes.\nkernel = brownian_kernel.brownian_coagulation_kernel_via_system_state(\n    radius_particle=radius_bins,\n    mass_particle=mass_bins,\n    temperature=293.15,  # Temperature in Kelvin (20\u00b0C)\n    pressure=101325,  # Pressure in Pascals (1 atm)\n    alpha_collision_efficiency=1.0,  # Assume perfect collision efficiency\n)\n\n# Display the shape of the kernel matrix to confirm its dimensions\nprint(f\"Kernel shape: {kernel.shape}\")\n\n# Create a pandas DataFrame from the kernel matrix\n# The DataFrame allows for easier analysis and visualization of the coagulation kernel.\n# Rows and columns are indexed by the particle radius bins, making it clear which sizes are interacting.\ndf_kernel = pd.DataFrame(kernel, index=radius_bins, columns=radius_bins)\n\n# Print the first 5 rows of the DataFrame to inspect the computed kernel values\ndf_kernel.head(5)\n\n# Optional: Save the kernel matrix to a CSV file for further analysis or sharing\n# df_kernel.to_csv(\"kernel.csv\")\n</pre> # The Brownian coagulation kernel is calculated using the `brownian_coagulation_kernel_via_system_state` function. # This function takes into account particle size, mass, temperature, pressure, and collision efficiency # to compute the coagulation rates between particles of different sizes. kernel = brownian_kernel.brownian_coagulation_kernel_via_system_state(     radius_particle=radius_bins,     mass_particle=mass_bins,     temperature=293.15,  # Temperature in Kelvin (20\u00b0C)     pressure=101325,  # Pressure in Pascals (1 atm)     alpha_collision_efficiency=1.0,  # Assume perfect collision efficiency )  # Display the shape of the kernel matrix to confirm its dimensions print(f\"Kernel shape: {kernel.shape}\")  # Create a pandas DataFrame from the kernel matrix # The DataFrame allows for easier analysis and visualization of the coagulation kernel. # Rows and columns are indexed by the particle radius bins, making it clear which sizes are interacting. df_kernel = pd.DataFrame(kernel, index=radius_bins, columns=radius_bins)  # Print the first 5 rows of the DataFrame to inspect the computed kernel values df_kernel.head(5)  # Optional: Save the kernel matrix to a CSV file for further analysis or sharing # df_kernel.to_csv(\"kernel.csv\") <pre>Kernel shape: (500, 500)\n</pre> Out[20]: 1.000000e-09 1.023340e-09 1.047225e-09 1.071668e-09 1.096681e-09 1.122277e-09 1.148472e-09 1.175277e-09 1.202708e-09 1.230780e-09 ... 8.124930e-05 8.314568e-05 8.508632e-05 8.707225e-05 8.910453e-05 9.118425e-05 9.331251e-05 9.549045e-05 9.771921e-05 1.000000e-04 1.000000e-09 8.812734e-16 8.867456e-16 8.930227e-16 9.001194e-16 9.080509e-16 9.168335e-16 9.264845e-16 9.370220e-16 9.484651e-16 9.608340e-16 ... 1.310366e-09 1.340961e-09 1.372270e-09 1.404310e-09 1.437098e-09 1.470650e-09 1.504986e-09 1.540123e-09 1.576080e-09 1.612876e-09 1.023340e-09 8.867456e-16 8.914801e-16 8.970151e-16 9.033642e-16 9.105423e-16 9.185649e-16 9.274485e-16 9.372104e-16 9.478690e-16 9.594436e-16 ... 1.251439e-09 1.280658e-09 1.310559e-09 1.341157e-09 1.372470e-09 1.404514e-09 1.437305e-09 1.470862e-09 1.505201e-09 1.540342e-09 1.047225e-09 8.930227e-16 8.970151e-16 9.018038e-16 9.074021e-16 9.138240e-16 9.210845e-16 9.291991e-16 9.381847e-16 9.480587e-16 9.588397e-16 ... 1.195165e-09 1.223070e-09 1.251626e-09 1.280848e-09 1.310753e-09 1.341355e-09 1.372672e-09 1.404719e-09 1.437514e-09 1.471075e-09 1.071668e-09 9.001194e-16 9.033642e-16 9.074021e-16 9.122455e-16 9.179079e-16 9.244034e-16 9.317470e-16 9.399548e-16 9.490434e-16 9.590307e-16 ... 1.141425e-09 1.168075e-09 1.195346e-09 1.223255e-09 1.251814e-09 1.281041e-09 1.310949e-09 1.341555e-09 1.372875e-09 1.404926e-09 1.096681e-09 9.080509e-16 9.105423e-16 9.138240e-16 9.179079e-16 9.228066e-16 9.285337e-16 9.351036e-16 9.425313e-16 9.508330e-16 9.600258e-16 ... 1.090104e-09 1.115556e-09 1.141601e-09 1.168254e-09 1.195530e-09 1.223442e-09 1.252005e-09 1.281235e-09 1.311147e-09 1.341756e-09 <p>5 rows \u00d7 500 columns</p> In\u00a0[21]: Copied! <pre># Generate a lognormal particle size distribution\n# This distribution is characterized by a mode (most probable size) of 100 nm,\n# a geometric standard deviation of 1.4, and a total number concentration of 1e6 particles per cm^3.\nconcentration_lognormal_0 = lognormal_pdf_distribution(\n    x_values=radius_bins,\n    mode=np.array(100e-9),  # Mode of the distribution (100 nm)\n    geometric_standard_deviation=np.array(1.4),  # Geometric standard deviation\n    number_of_particles=np.array(\n        1e6 * 1e6\n    ),  # Total concentration (1e6 cm^-3 converted to m^-3)\n)\n\n# Plot the lognormal concentration distribution\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(radius_bins, concentration_lognormal_0)\n\n# Set the x-axis to a logarithmic scale to capture the wide range of particle sizes\nax.set_xlabel(\"Particle radius (m)\")\n\n# Label the y-axis to show the concentration in particles per cubic meter per unit size\nax.set_ylabel(r\"Concentration $\\dfrac{1}{m^3 \\cdot m}$\")\n\n# Use a logarithmic scale for the x-axis to better visualize the distribution across particle sizes\nax.set_xscale(\"log\")\n\n# Display the plot\nplt.show()\n</pre> # Generate a lognormal particle size distribution # This distribution is characterized by a mode (most probable size) of 100 nm, # a geometric standard deviation of 1.4, and a total number concentration of 1e6 particles per cm^3. concentration_lognormal_0 = lognormal_pdf_distribution(     x_values=radius_bins,     mode=np.array(100e-9),  # Mode of the distribution (100 nm)     geometric_standard_deviation=np.array(1.4),  # Geometric standard deviation     number_of_particles=np.array(         1e6 * 1e6     ),  # Total concentration (1e6 cm^-3 converted to m^-3) )  # Plot the lognormal concentration distribution fig, ax = plt.subplots(figsize=(8, 6)) ax.plot(radius_bins, concentration_lognormal_0)  # Set the x-axis to a logarithmic scale to capture the wide range of particle sizes ax.set_xlabel(\"Particle radius (m)\")  # Label the y-axis to show the concentration in particles per cubic meter per unit size ax.set_ylabel(r\"Concentration $\\dfrac{1}{m^3 \\cdot m}$\")  # Use a logarithmic scale for the x-axis to better visualize the distribution across particle sizes ax.set_xscale(\"log\")  # Display the plot plt.show() In\u00a0[22]: Copied! <pre># Simulating the coagulation process over time for a lognormal distribution\n\n# Define the time step for the simulation\nTIME_STEP = 100  # seconds\n\n# Calculate the coagulation kernel\nkernel = brownian_kernel.brownian_coagulation_kernel_via_system_state(\n    radius_particle=radius_bins,\n    mass_particle=mass_bins,\n    temperature=293.15,  # Temperature in Kelvin\n    pressure=101325,  # Pressure in Pascals (1 atm)\n    alpha_collision_efficiency=1.0,  # Assume perfect collision efficiency\n)\n\n# Time step 1: Calculate gain, loss, and update concentration\ngain = rate.continuous_gain(radius=radius_bins, concentration=concentration_lognormal_0, kernel=kernel)\nloss = rate.continuous_loss(radius=radius_bins, concentration=concentration_lognormal_0, kernel=kernel)\nnet = gain - loss\nconcentration_lognormal_1 = concentration_lognormal_0 + net * TIME_STEP\nconcentration_lognormal_1[concentration_lognormal_1 &lt; 0] = (\n    0  # Ensure no negative concentrations\n)\n\n# Time step 2: Recalculate rates and update concentration\ngain = rate.continuous_gain(radius=radius_bins, concentration=concentration_lognormal_1, kernel=kernel)\nloss = rate.continuous_loss(radius=radius_bins, concentration=concentration_lognormal_1, kernel=kernel)\nnet = gain - loss\nconcentration_lognormal_2 = concentration_lognormal_1 + net * TIME_STEP\nconcentration_lognormal_2[concentration_lognormal_2 &lt; 0] = (\n    0  # Ensure no negative concentrations\n)\n\n# Time step 3: Recalculate rates and update concentration\ngain = rate.continuous_gain(radius=radius_bins, concentration=concentration_lognormal_2, kernel=kernel)\nloss = rate.continuous_loss(radius=radius_bins, concentration=concentration_lognormal_2, kernel=kernel)\nnet = gain - loss\nconcentration_lognormal_3 = concentration_lognormal_2 + net * TIME_STEP\nconcentration_lognormal_3[concentration_lognormal_3 &lt; 0] = (\n    0  # Ensure no negative concentrations\n)\n\n# Combine the concentrations at each time step into a DataFrame for easy comparison\ndf_concentration = pd.DataFrame(\n    {\n        \"0\": concentration_lognormal_0,\n        \"1\": concentration_lognormal_1,\n        \"2\": concentration_lognormal_2,\n        \"3\": concentration_lognormal_3,\n    },\n    index=radius_bins,\n)\n\n# Optional: Save the concentration data to a CSV file for further analysis\n# df_concentration.to_csv(\"concentration_lognormal_sim.csv\")\n</pre> # Simulating the coagulation process over time for a lognormal distribution  # Define the time step for the simulation TIME_STEP = 100  # seconds  # Calculate the coagulation kernel kernel = brownian_kernel.brownian_coagulation_kernel_via_system_state(     radius_particle=radius_bins,     mass_particle=mass_bins,     temperature=293.15,  # Temperature in Kelvin     pressure=101325,  # Pressure in Pascals (1 atm)     alpha_collision_efficiency=1.0,  # Assume perfect collision efficiency )  # Time step 1: Calculate gain, loss, and update concentration gain = rate.continuous_gain(radius=radius_bins, concentration=concentration_lognormal_0, kernel=kernel) loss = rate.continuous_loss(radius=radius_bins, concentration=concentration_lognormal_0, kernel=kernel) net = gain - loss concentration_lognormal_1 = concentration_lognormal_0 + net * TIME_STEP concentration_lognormal_1[concentration_lognormal_1 &lt; 0] = (     0  # Ensure no negative concentrations )  # Time step 2: Recalculate rates and update concentration gain = rate.continuous_gain(radius=radius_bins, concentration=concentration_lognormal_1, kernel=kernel) loss = rate.continuous_loss(radius=radius_bins, concentration=concentration_lognormal_1, kernel=kernel) net = gain - loss concentration_lognormal_2 = concentration_lognormal_1 + net * TIME_STEP concentration_lognormal_2[concentration_lognormal_2 &lt; 0] = (     0  # Ensure no negative concentrations )  # Time step 3: Recalculate rates and update concentration gain = rate.continuous_gain(radius=radius_bins, concentration=concentration_lognormal_2, kernel=kernel) loss = rate.continuous_loss(radius=radius_bins, concentration=concentration_lognormal_2, kernel=kernel) net = gain - loss concentration_lognormal_3 = concentration_lognormal_2 + net * TIME_STEP concentration_lognormal_3[concentration_lognormal_3 &lt; 0] = (     0  # Ensure no negative concentrations )  # Combine the concentrations at each time step into a DataFrame for easy comparison df_concentration = pd.DataFrame(     {         \"0\": concentration_lognormal_0,         \"1\": concentration_lognormal_1,         \"2\": concentration_lognormal_2,         \"3\": concentration_lognormal_3,     },     index=radius_bins, )  # Optional: Save the concentration data to a CSV file for further analysis # df_concentration.to_csv(\"concentration_lognormal_sim.csv\") In\u00a0[23]: Copied! <pre># Plot the coagulation gain, loss, and net rates for the lognormal distribution\n\n# Create a figure and axis object for the plot\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Plot the net coagulation rate\n# The net rate is plotted with a thicker gray line for emphasis\nax.plot(radius_bins, net, label=\"Net\", color=\"gray\", linewidth=4)\n\n# Plot the gain rate\n# The gain rate is plotted in dark green\nax.plot(radius_bins, gain, label=\"Gain\", color=\"darkgreen\")\n\n# Plot the loss rate\n# The loss rate is plotted in red, and multiplied by -1 for plotting to indicate that it's a removal process\nax.plot(radius_bins, -1 * loss, label=\"Loss\", color=\"red\")\n\n# Set the x-axis label to indicate the particle radius in meters\nax.set_xlabel(\"Particle radius (m)\")\n\n# Set the y-axis label to indicate the rate of change in concentration, with appropriate units\nax.set_ylabel(r\"Rate $\\dfrac{1}{m^{3} s^{1} \\cdot m}$\")\n\n# Use a logarithmic scale for the x-axis to account for the wide range of particle sizes\nax.set_xscale(\"log\")\n\n# title\nax.set_title(\"PDF: Coagulation Gain, Loss, and Net Rates\")\n\n# Add a legend to identify the gain, loss, and net lines\nplt.legend()    \n\n# Display the plot\nplt.show()\n</pre> # Plot the coagulation gain, loss, and net rates for the lognormal distribution  # Create a figure and axis object for the plot fig, ax = plt.subplots(figsize=(8, 6))  # Plot the net coagulation rate # The net rate is plotted with a thicker gray line for emphasis ax.plot(radius_bins, net, label=\"Net\", color=\"gray\", linewidth=4)  # Plot the gain rate # The gain rate is plotted in dark green ax.plot(radius_bins, gain, label=\"Gain\", color=\"darkgreen\")  # Plot the loss rate # The loss rate is plotted in red, and multiplied by -1 for plotting to indicate that it's a removal process ax.plot(radius_bins, -1 * loss, label=\"Loss\", color=\"red\")  # Set the x-axis label to indicate the particle radius in meters ax.set_xlabel(\"Particle radius (m)\")  # Set the y-axis label to indicate the rate of change in concentration, with appropriate units ax.set_ylabel(r\"Rate $\\dfrac{1}{m^{3} s^{1} \\cdot m}$\")  # Use a logarithmic scale for the x-axis to account for the wide range of particle sizes ax.set_xscale(\"log\")  # title ax.set_title(\"PDF: Coagulation Gain, Loss, and Net Rates\")  # Add a legend to identify the gain, loss, and net lines plt.legend()      # Display the plot plt.show() In\u00a0[24]: Copied! <pre># Plot the evolution of particle concentration over time for the lognormal distribution\n\n# Create a figure and axis object for the plot\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Plot the concentration distribution at each time step\nax.plot(\n    radius_bins,\n    concentration_lognormal_0,\n    label=\"t=0\",\n    linestyle=\"-\",\n    color=\"blue\",\n)\nax.plot(\n    radius_bins,\n    concentration_lognormal_1,\n    label=\"t=1\",\n    linestyle=\"--\",\n    color=\"green\",\n)\nax.plot(\n    radius_bins,\n    concentration_lognormal_2,\n    label=\"t=2\",\n    linestyle=\"-.\",\n    color=\"orange\",\n)\nax.plot(\n    radius_bins,\n    concentration_lognormal_3,\n    label=\"t=3\",\n    linestyle=\":\",\n    color=\"red\",\n)\n\n# Set the x-axis label to indicate the particle radius in meters\nax.set_xlabel(\"Particle radius (m)\")\n\n# Set the y-axis label to indicate the concentration in particles per cubic meter\nax.set_ylabel(r\"Concentration $\\dfrac{1}{m^3 \\cdot m}$\")\n\n# Set the title of the plot to describe the concentration evolution over time\nax.set_title(\"PDF: Particle concentration evolution over time\")\n\n# Use a logarithmic scale for both the x-axis and y-axis\n# This is essential for visualizing the wide range of particle sizes and concentration changes\nax.set_xscale(\"log\")\n# ax.set_yscale(\"log\")\n\n# Add a legend to differentiate between the time steps\nplt.legend()\n\n# Display the plot\nplt.show()\n</pre> # Plot the evolution of particle concentration over time for the lognormal distribution  # Create a figure and axis object for the plot fig, ax = plt.subplots(figsize=(8, 6))  # Plot the concentration distribution at each time step ax.plot(     radius_bins,     concentration_lognormal_0,     label=\"t=0\",     linestyle=\"-\",     color=\"blue\", ) ax.plot(     radius_bins,     concentration_lognormal_1,     label=\"t=1\",     linestyle=\"--\",     color=\"green\", ) ax.plot(     radius_bins,     concentration_lognormal_2,     label=\"t=2\",     linestyle=\"-.\",     color=\"orange\", ) ax.plot(     radius_bins,     concentration_lognormal_3,     label=\"t=3\",     linestyle=\":\",     color=\"red\", )  # Set the x-axis label to indicate the particle radius in meters ax.set_xlabel(\"Particle radius (m)\")  # Set the y-axis label to indicate the concentration in particles per cubic meter ax.set_ylabel(r\"Concentration $\\dfrac{1}{m^3 \\cdot m}$\")  # Set the title of the plot to describe the concentration evolution over time ax.set_title(\"PDF: Particle concentration evolution over time\")  # Use a logarithmic scale for both the x-axis and y-axis # This is essential for visualizing the wide range of particle sizes and concentration changes ax.set_xscale(\"log\") # ax.set_yscale(\"log\")  # Add a legend to differentiate between the time steps plt.legend()  # Display the plot plt.show() In\u00a0[25]: Copied! <pre># Integrate the concentration to calculate the total number of particles at each time step\ntotal_concentration_lognormal_0 = trapezoid(\n    concentration_lognormal_0, x=radius_bins\n)\ntotal_concentration_lognormal_1 = trapezoid(\n    concentration_lognormal_1, x=radius_bins\n)\ntotal_concentration_lognormal_2 = trapezoid(\n    concentration_lognormal_2, x=radius_bins\n)\ntotal_concentration_lognormal_3 = trapezoid(\n    concentration_lognormal_3, x=radius_bins\n)\n\n# Plot the total concentration at each time step for the lognormal distribution\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Plot the total concentration at each time step\nax.plot(\n    [\n        total_concentration_lognormal_0,\n        total_concentration_lognormal_1,\n        total_concentration_lognormal_2,\n        total_concentration_lognormal_3,\n    ],\n    label=\"Total concentration\",\n    marker=\"o\",  # Add markers to indicate each time step\n    linestyle=\"-\",  # Use a solid line to connect the markers\n    color=\"blue\",  # Set the line color to blue\n)\n\n# Set the x-axis label to indicate the time step\nax.set_xlabel(\"Time step\")\n\n# Set the y-axis label to indicate the total concentration in particles per cubic meter\nax.set_ylabel(\"Total concentration $\\dfrac{1}{m^3}$\")\nax.set_ylim(bottom=0.84e12)\n\n# Set the title of the plot to describe the total concentration evolution over time\nax.set_title(\"Total concentration at each time step\")\n\n# Display the plot\nplt.show()\n</pre> # Integrate the concentration to calculate the total number of particles at each time step total_concentration_lognormal_0 = trapezoid(     concentration_lognormal_0, x=radius_bins ) total_concentration_lognormal_1 = trapezoid(     concentration_lognormal_1, x=radius_bins ) total_concentration_lognormal_2 = trapezoid(     concentration_lognormal_2, x=radius_bins ) total_concentration_lognormal_3 = trapezoid(     concentration_lognormal_3, x=radius_bins )  # Plot the total concentration at each time step for the lognormal distribution fig, ax = plt.subplots(figsize=(8, 6))  # Plot the total concentration at each time step ax.plot(     [         total_concentration_lognormal_0,         total_concentration_lognormal_1,         total_concentration_lognormal_2,         total_concentration_lognormal_3,     ],     label=\"Total concentration\",     marker=\"o\",  # Add markers to indicate each time step     linestyle=\"-\",  # Use a solid line to connect the markers     color=\"blue\",  # Set the line color to blue )  # Set the x-axis label to indicate the time step ax.set_xlabel(\"Time step\")  # Set the y-axis label to indicate the total concentration in particles per cubic meter ax.set_ylabel(\"Total concentration $\\dfrac{1}{m^3}$\") ax.set_ylim(bottom=0.84e12)  # Set the title of the plot to describe the total concentration evolution over time ax.set_title(\"Total concentration at each time step\")  # Display the plot plt.show()"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#coagulation-basics-2-pdf-representation","title":"Coagulation Basics 2: PDF Representation\u00b6","text":""},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#continuous-particle-size-distributions","title":"Continuous Particle Size Distributions\u00b6","text":"<p>In this notebook, we implement the coagulation process for continuous particle size distributions, following the methodology outlined in Seinfeld and Pandis (2006). This work builds on concepts from <code>Coagulation Basics 1: PMF Representation</code> by extending the analysis to probability density function (PDF) representations of particle size distributions.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#objective","title":"Objective\u00b6","text":"<p>The primary objective is to demonstrate the calculation of the coagulation kernel and the resulting coagulation rates for a given particle size distribution. We will compare the PDF representation with the probability mass function (PMF) representation, highlighting how the PDF's continuous nature influences the coagulation process.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#approach","title":"Approach\u00b6","text":"<ol> <li><p>Uniform Distribution:</p> <ul> <li>We begin with a uniform particle size distribution to illustrate the fundamental mechanics of coagulation.</li> </ul> </li> <li><p>Lognormal Probability Density Function:</p> <ul> <li><p>After establishing the basics with a uniform distribution, we proceed to a lognormal size distribution, which more accurately reflects real-world aerosol size distributions. The PDF representation is continuous and describes the probability of finding particles within a specific size range. Integrating the PDF across the entire size range yields the total particle concentration.</p> </li> <li><p>Units:</p> <ul> <li>The units of the PDF are particles per unit volume per unit size, typically expressed as $\\dfrac{1}{m^3 \\cdot m}$ or $\\dfrac{1}{m^4}$. Integration of the PDF over the particle size range gives the total number concentration, expressed in $\\dfrac{1}{m^3}$.</li> </ul> </li> </ul> </li> </ol> <p>This step-by-step approach lays the groundwork for more advanced implementations, such as those in the <code>particula</code> library.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#required-libraries","title":"Required Libraries\u00b6","text":"<p>We will use common scientific libraries, including <code>numpy</code> for numerical calculations, <code>matplotlib</code> for visualization, and <code>pandas</code> for data manipulation. Additionally, we will leverage specific functions from the <code>particula</code> library to compute the coagulation kernel and generate size distributions.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#creating-a-size-distribution","title":"Creating a Size Distribution\u00b6","text":"<p>In this section, we define the size distribution for aerosol particles. The particle sizes are distributed across several fine-scale bins, allowing for detailed modeling of particle behavior over a wide size range.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#particle-size-bins","title":"Particle Size Bins\u00b6","text":"<ul> <li><code>radius_bins</code>: These bins represent particle radii, spanning from 1 nanometer (1e-9 m) to 10 micrometers (1e-5 m) on a logarithmic scale. Using fine-scale bins (500 in total) provides a more detailed resolution of the size distribution, which is crucial for accurate coagulation modeling.</li> <li><code>mass_bins</code>: For each radius bin, we calculate the corresponding particle mass, assuming a particle density of 1 g/cm\u00b3 (1000 kg/m\u00b3 in SI units). This mass calculation is essential for understanding how particles interact and coagulate over time.</li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#calculating-the-brownian-coagulation-kernel","title":"Calculating the Brownian Coagulation Kernel\u00b6","text":"<p>In this section, we calculate the Brownian coagulation kernel matrix, which quantifies the rate at which particles of different sizes collide and coagulate due to Brownian motion. Understanding the kernel matrix is crucial for analyzing the dynamics of particle coagulation.</p> <p>It's important to note that the kernel matrix itself remains consistent whether we're using a Probability Mass Function (PMF) or a Probability Density Function (PDF) representation. The difference lies in how we apply the kernel matrix\u2014using summations in the PMF case and integrations in the PDF case\u2014to calculate coagulation rates.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#generating-lognormal-pdf-size-distribution","title":"Generating Lognormal PDF Size Distribution\u00b6","text":"<p>In this section, we generate a lognormal particle size distribution and visualize it to understand the particle concentration across different sizes. A lognormal distribution is commonly used to represent aerosol particle size distributions due to its ability to model the skewness observed in real-world data.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#key-parameters","title":"Key Parameters\u00b6","text":"<ul> <li>Mode (Most Probable Size): The mode of the distribution is set at 100 nanometers (100 nm), representing the most common particle size within the distribution.</li> <li>Geometric Standard Deviation: A geometric standard deviation of 1.4 is used, which determines the spread of the distribution. This value reflects how broadly the particle sizes are distributed around the mode.</li> <li>Total Number Concentration: The total particle concentration is set at $1 \\times 10^6$ particles per cubic centimeter (cm\u00b3), which is converted to $1 \\times 10^{12}$ particles per cubic meter (m\u00b3) for the calculation.</li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#visualization","title":"Visualization\u00b6","text":"<p>The resulting distribution is plotted with particle radius on the x-axis and particle concentration on the y-axis. The x-axis is scaled logarithmically to effectively display the wide range of particle sizes. This plot helps in visualizing how particle concentration varies with size, providing insights into the distribution characteristics and potential behavior during coagulation processes.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#simulating-the-coagulation-process-for-a-lognormal-distribution","title":"Simulating the Coagulation Process for a Lognormal Distribution\u00b6","text":"<p>After establishing a lognormal particle size distribution, we now simulate the coagulation process over time to observe how the distribution evolves as particles collide and form larger particles.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#simulation-setup","title":"Simulation Setup\u00b6","text":"<ul> <li><p>Time Step: We use a time step of 100 seconds (<code>TIME_STEP = 100</code>). This interval determines the frequency at which particle concentrations are updated based on the calculated coagulation rates.</p> </li> <li><p>Coagulation Kernel: The coagulation kernel is computed using the same environmental parameters (temperature, pressure, and collision efficiency) as before. The kernel remains unchanged throughout the simulation, as it depends solely on the physical properties of the particles and the surrounding environment.</p> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#time-step-calculations","title":"Time Step Calculations\u00b6","text":"<p>For each time step, we perform the following calculations:</p> <ol> <li><p>Time Step 1:</p> <ul> <li>Gain and Loss Rates: Calculate the gain and loss rates for the initial concentration (<code>concentration_lognormal_0</code>) based on the coagulation kernel.</li> <li>Update Concentration: Apply the net rate of change to update the particle concentration to <code>concentration_lognormal_1</code>. Any negative concentrations, which may result from numerical errors, are set to zero.</li> </ul> </li> <li><p>Time Step 2:</p> <ul> <li>Recalculate Rates: Compute the gain and loss rates using the updated concentration (<code>concentration_lognormal_1</code>).</li> <li>Update Concentration: Update the concentration to <code>concentration_lognormal_2</code>, ensuring no negative values.</li> </ul> </li> <li><p>Time Step 3:</p> <ul> <li>Recalculate Rates: Calculate the rates again based on the most recent concentration (<code>concentration_lognormal_2</code>).</li> <li>Update Concentration: Update the concentration to <code>concentration_lognormal_3</code>, correcting any negative concentrations.</li> </ul> </li> </ol>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#combining-results","title":"Combining Results\u00b6","text":"<p>The concentrations at each time step are combined into a <code>pandas</code> DataFrame. This structure facilitates easy comparison of the particle size distribution changes over time, offering insights into the coagulation process.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#optional-saving-results","title":"Optional: Saving Results\u00b6","text":"<p>For further analysis or documentation, the concentration data can be saved to a CSV file. This step is optional but can be useful for detailed post-simulation analysis.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#plotting-the-coagulation-gain-loss-and-net-rates-for-lognormal-distribution","title":"Plotting the Coagulation Gain, Loss, and Net Rates for Lognormal Distribution\u00b6","text":"<p>To visualize the dynamics of coagulation for a lognormal particle size distribution, we plot the rates of gain, loss, and net change in concentration across the range of particle sizes. This plot provides insights into how particles are interacting during the coagulation process.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#plot-details","title":"Plot Details\u00b6","text":"<ul> <li><p>Net Rate: The net rate of change in particle concentration is plotted as a thick gray line. This line represents the overall effect of coagulation, indicating whether the concentration in each size bin is increasing or decreasing.</p> </li> <li><p>Gain Rate: The gain rate, plotted in dark green, shows how particles are being added to each size bin as smaller particles coagulate to form larger ones. This rate reflects the accumulation of particles in specific size bins.</p> </li> <li><p>Loss Rate: The loss rate is plotted in red, with the values multiplied by -1 to indicate that it represents a reduction in particle concentration. This line shows how particles are being depleted from each size bin due to coagulation.</p> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#axes-configuration","title":"Axes Configuration\u00b6","text":"<ul> <li><p>X-axis: The x-axis represents the particle radius in meters, plotted on a logarithmic scale to capture the wide range of particle sizes present in the distribution.</p> </li> <li><p>Y-axis: The y-axis shows the rate of change in concentration in units of particles per cubic meter per second ($\\dfrac{1}{m^{3} s^{1} \\cdot m}$), providing a clear view of how rapidly particles are being gained, lost, or changing net concentration in the system.</p> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#legend-and-interpretation","title":"Legend and Interpretation\u00b6","text":"<p>A legend is included to clearly differentiate between the net, gain, and loss lines on the plot. By analyzing these rates, we can determine the most active particle sizes in the coagulation process:</p> <ul> <li>Positive Net Rate: Indicates that the particle size bin is gaining particles, likely due to the aggregation of smaller particles.</li> <li>Negative Net Rate: Indicates that the particle size bin is losing particles, either because they are merging into larger particles or being depleted through other processes.</li> </ul> <p>This plot is essential for understanding the detailed behavior of the particle size distribution during coagulation, highlighting which sizes are most affected by the process.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#plotting-the-evolution-of-concentration-for-lognormal-distribution","title":"Plotting the Evolution of Concentration for Lognormal Distribution\u00b6","text":"<p>After simulating the coagulation process over several time steps, it is important to visualize how the particle concentration evolves. This plot shows the concentration distribution at different time steps, allowing us to observe the changes in the lognormal distribution as coagulation progresses.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#calculating-and-visualizing-total-particle-concentration-over-time","title":"Calculating and Visualizing Total Particle Concentration Over Time\u00b6","text":"<p>In this section, we calculate the total number of particles at each time step by integrating the particle concentration across the size distribution. This provides a clear view of how the total particle concentration evolves as coagulation progresses.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#integration-of-particle-concentration","title":"Integration of Particle Concentration\u00b6","text":"<p>To determine the total number of particles at each time step, we integrate the concentration across all particle sizes using the trapezoidal rule. This integration gives us the total particle concentration (in particles per cubic meter) at each specific time step.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#plotting-total-concentration-over-time","title":"Plotting Total Concentration Over Time\u00b6","text":"<p>We then plot the total particle concentration for each time step to visualize how the overall concentration decreases as particles coagulate into larger sizes. The x-axis represents the time steps, while the y-axis shows the total particle concentration in particles per cubic meter. Markers are used to highlight the concentration at each time step, connected by a solid line to indicate the trend over time.</p> <p>This plot provides a straightforward representation of the coagulation process's impact on the total number of particles, illustrating the decrease in concentration as particles merge and grow.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#note","title":"Note:\u00b6","text":"<p>You can compare the results obtained from the PDF representation with those from the PMF representation in the previous notebook to observe how similar the results are despite the different representations. They are not exactly equal.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_2_PDF/#summary","title":"Summary\u00b6","text":"<p>In this notebook, we explored the process of particle coagulation in aerosols, with a particular focus on probability density function (PDF) representations of lognormal particle size distributions.</p> <p>We began by defining a lognormal distribution, which is commonly used to represent aerosol particle sizes due to its ability to model the skewed distributions observed in real-world scenarios. We then calculated the Brownian coagulation kernel, a crucial element that quantifies the rate at which particles of different sizes collide and coagulate due to Brownian motion.</p> <p>Through a series of simulations, we observed how the particle size distribution evolves over time as coagulation occurs. By applying the coagulation kernel to the initial distribution, we calculated the gain and loss rates for particles and updated the particle concentrations at each time step. This iterative process illustrated the gradual decrease in total particle concentration as smaller particles combined to form larger ones.</p> <p>Finally, we integrated the particle concentrations across the size distribution at each time step to determine the total number of particles present. This allowed us to visualize the overall reduction in particle concentration over time, providing a clear demonstration of the impact of coagulation on aerosol dynamics.</p> <p>This notebook not only highlights the fundamental principles of aerosol coagulation but also provides a practical framework for modeling and analyzing these processes using PDF representations. The methodologies and tools used here, such as the integration of concentration data and the use of a coagulation kernel, are essential for understanding the behavior of aerosols in various environmental and industrial contexts.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_3_compared/","title":"Coagulation Basic 3: PMF vs. PDF","text":"In\u00a0[1]: Copied! <pre># Import necessary libraries\n\nimport numpy as np  # For numerical operations and array manipulations\nimport matplotlib.pyplot as plt  # For plotting graphs and visualizations\nimport pandas as pd  # For data manipulation and analysis\nfrom scipy.integrate import (\n    trapezoid,\n)  # For numerical integration using the trapezoidal rule\n\n# Import specific modules from the particula package\nfrom particula.next.dynamics.coagulation import brownian_kernel, rate\n\n# The 'brownian_kernel' module calculates the Brownian coagulation kernel,\n# which is used to determine coagulation rates between particles.\n# The 'rate' module includes functions for calculating gain and loss rates during coagulation.\nfrom particula.next.particles.properties.lognormal_size_distribution import (\n    lognormal_pmf_distribution,\n    lognormal_pdf_distribution,\n)\n\n# The 'lognormal_pmf_distribution' function generates a lognormal distribution\n# represented as a Probability Mass Function (PMF).\n# The 'lognormal_pdf_distribution' function generates a lognormal distribution\n# represented as a Probability Density Function (PDF).\nfrom particula.util.convert import distribution_convert_pdf_pms\n\n# The 'distribution_convert_pdf_pms' function is used to convert PDF distributions\n# to PMS (Particle Mass Spectrum) or vice versa for comparison purposes.\n</pre> # Import necessary libraries  import numpy as np  # For numerical operations and array manipulations import matplotlib.pyplot as plt  # For plotting graphs and visualizations import pandas as pd  # For data manipulation and analysis from scipy.integrate import (     trapezoid, )  # For numerical integration using the trapezoidal rule  # Import specific modules from the particula package from particula.next.dynamics.coagulation import brownian_kernel, rate  # The 'brownian_kernel' module calculates the Brownian coagulation kernel, # which is used to determine coagulation rates between particles. # The 'rate' module includes functions for calculating gain and loss rates during coagulation. from particula.next.particles.properties.lognormal_size_distribution import (     lognormal_pmf_distribution,     lognormal_pdf_distribution, )  # The 'lognormal_pmf_distribution' function generates a lognormal distribution # represented as a Probability Mass Function (PMF). # The 'lognormal_pdf_distribution' function generates a lognormal distribution # represented as a Probability Density Function (PDF). from particula.util.convert import distribution_convert_pdf_pms  # The 'distribution_convert_pdf_pms' function is used to convert PDF distributions # to PMS (Particle Mass Spectrum) or vice versa for comparison purposes. In\u00a0[2]: Copied! <pre># Define distribution parameters\nmode = np.array([200e-9])  # Mode of the distribution (200 nm)\nstd = np.array([1.5])  # Geometric standard deviation\nnumber = np.array([1e6]) * 1e6  # 1e6 particles per cm^3 converted to m^3\n\n# Define radius bins on a logarithmic scale from 1 nm to 10 \u03bcm\nradius_bins = np.logspace(start=-9, stop=-4, num=500)\n\n# Create the lognormal PDF distribution\ndistribution_pdf = lognormal_pdf_distribution(\n    x_values=radius_bins,\n    mode=mode,\n    geometric_standard_deviation=std,\n    number_of_particles=number,\n)\n\n# Create the lognormal PMF distribution\ndistribution_pmf = lognormal_pmf_distribution(\n    x_values=radius_bins,\n    mode=mode,\n    geometric_standard_deviation=std,\n    number_of_particles=number,\n)\n\n# Plot the PDF and PMF distributions for comparison\nplt.figure(figsize=(8, 6))\nplt.plot(radius_bins, distribution_pdf, label=\"PDF\")\nplt.plot(radius_bins, distribution_pmf, label=\"PMF\")\nplt.xlabel(\"Particle Radius [m]\")\nplt.ylabel(r\"Concentration $\\dfrac{1}{m^3}$ or $\\dfrac{1}{m^3 \\cdot m}$\")\nplt.xscale(\n    \"log\"\n)  # Logarithmic scale for the x-axis to capture wide size range\nplt.yscale(\n    \"log\"\n)  # Logarithmic scale for the y-axis to highlight distribution differences\nplt.legend()\nplt.show()\n</pre> # Define distribution parameters mode = np.array([200e-9])  # Mode of the distribution (200 nm) std = np.array([1.5])  # Geometric standard deviation number = np.array([1e6]) * 1e6  # 1e6 particles per cm^3 converted to m^3  # Define radius bins on a logarithmic scale from 1 nm to 10 \u03bcm radius_bins = np.logspace(start=-9, stop=-4, num=500)  # Create the lognormal PDF distribution distribution_pdf = lognormal_pdf_distribution(     x_values=radius_bins,     mode=mode,     geometric_standard_deviation=std,     number_of_particles=number, )  # Create the lognormal PMF distribution distribution_pmf = lognormal_pmf_distribution(     x_values=radius_bins,     mode=mode,     geometric_standard_deviation=std,     number_of_particles=number, )  # Plot the PDF and PMF distributions for comparison plt.figure(figsize=(8, 6)) plt.plot(radius_bins, distribution_pdf, label=\"PDF\") plt.plot(radius_bins, distribution_pmf, label=\"PMF\") plt.xlabel(\"Particle Radius [m]\") plt.ylabel(r\"Concentration $\\dfrac{1}{m^3}$ or $\\dfrac{1}{m^3 \\cdot m}$\") plt.xscale(     \"log\" )  # Logarithmic scale for the x-axis to capture wide size range plt.yscale(     \"log\" )  # Logarithmic scale for the y-axis to highlight distribution differences plt.legend() plt.show() In\u00a0[3]: Copied! <pre># Rescale the PDF to PMF\ndistribution_pdf_rescaled = distribution_convert_pdf_pms(\n    x_array=radius_bins,\n    distribution=distribution_pdf,\n    to_pdf=False,  # Convert PDF to PMF\n)\n\n# Plot the rescaled PDF and the original PMF for comparison\nplt.figure(figsize=(8, 6))\nplt.plot(radius_bins, distribution_pdf_rescaled, label=\"PDF Rescaled to PMF\")\nplt.plot(radius_bins, distribution_pmf, label=\"PMF\")\nplt.xlabel(\"Particle Radius [m]\")\nplt.ylabel(\"Concentration $\\dfrac{1}{m^3}$\")\nplt.xscale(\"log\")  # Use a logarithmic scale for the x-axis\n# plt.yscale('log')  # Optionally use a logarithmic scale for the y-axis\nplt.legend()\nplt.show()\n</pre> # Rescale the PDF to PMF distribution_pdf_rescaled = distribution_convert_pdf_pms(     x_array=radius_bins,     distribution=distribution_pdf,     to_pdf=False,  # Convert PDF to PMF )  # Plot the rescaled PDF and the original PMF for comparison plt.figure(figsize=(8, 6)) plt.plot(radius_bins, distribution_pdf_rescaled, label=\"PDF Rescaled to PMF\") plt.plot(radius_bins, distribution_pmf, label=\"PMF\") plt.xlabel(\"Particle Radius [m]\") plt.ylabel(\"Concentration $\\dfrac{1}{m^3}$\") plt.xscale(\"log\")  # Use a logarithmic scale for the x-axis # plt.yscale('log')  # Optionally use a logarithmic scale for the y-axis plt.legend() plt.show() In\u00a0[4]: Copied! <pre># Rescale the PMF to PDF\ndistribution_pmf_rescaled = distribution_convert_pdf_pms(\n    x_array=radius_bins,\n    distribution=distribution_pmf,\n    to_pdf=True,  # Convert PMF to PDF\n)\n\n# Plot the original PDF and the rescaled PMF for comparison\nplt.figure()\nplt.plot(radius_bins, distribution_pdf, label=\"PDF\")\nplt.plot(radius_bins, distribution_pmf_rescaled, label=\"PMF Rescaled to PDF\")\nplt.xlabel(\"Particle Radius [m]\")\nplt.ylabel(\"Concentration $\\dfrac{1}{m^3 \\cdot m}$\")\nplt.xscale(\"log\")  # Logarithmic scale for the x-axis to capture size range\nplt.legend()\nplt.show()\n</pre> # Rescale the PMF to PDF distribution_pmf_rescaled = distribution_convert_pdf_pms(     x_array=radius_bins,     distribution=distribution_pmf,     to_pdf=True,  # Convert PMF to PDF )  # Plot the original PDF and the rescaled PMF for comparison plt.figure() plt.plot(radius_bins, distribution_pdf, label=\"PDF\") plt.plot(radius_bins, distribution_pmf_rescaled, label=\"PMF Rescaled to PDF\") plt.xlabel(\"Particle Radius [m]\") plt.ylabel(\"Concentration $\\dfrac{1}{m^3 \\cdot m}$\") plt.xscale(\"log\")  # Logarithmic scale for the x-axis to capture size range plt.legend() plt.show() In\u00a0[5]: Copied! <pre># Integrate the original PDF to calculate the total number concentration\nnumber_concentration_pdf = trapezoid(distribution_pdf, x=radius_bins)\n\n# Integrate the PMF rescaled to PDF to calculate the total number concentration\nnumber_concentration_pmf_rescaled = trapezoid(\n    distribution_pmf_rescaled, x=radius_bins\n)\n\n# Print the results to compare\nprint(f\"Number concentration from PDF: {number_concentration_pdf}\")\nprint(\n    f\"Number concentration from PMF rescaled to PDF: {number_concentration_pmf_rescaled}\"\n)\n</pre> # Integrate the original PDF to calculate the total number concentration number_concentration_pdf = trapezoid(distribution_pdf, x=radius_bins)  # Integrate the PMF rescaled to PDF to calculate the total number concentration number_concentration_pmf_rescaled = trapezoid(     distribution_pmf_rescaled, x=radius_bins )  # Print the results to compare print(f\"Number concentration from PDF: {number_concentration_pdf}\") print(     f\"Number concentration from PMF rescaled to PDF: {number_concentration_pmf_rescaled}\" ) <pre>Number concentration from PDF: 1000000000000.0\nNumber concentration from PMF rescaled to PDF: 988596064185.8999\n</pre> <p>Verifying Number Concentration for PMF</p> <p>Next, we sum the original PMF distribution and the PDF that has been rescaled to a PMF. Summing these values directly gives the total number concentration, allowing us to verify consistency across the different representations.</p> In\u00a0[6]: Copied! <pre># Sum the original PMF to calculate the total number concentration\nnumber_concentration_pmf = distribution_pmf.sum()\n\n# Sum the PDF rescaled to PMF to calculate the total number concentration\nnumber_concentration_pdf_rescaled = distribution_pdf_rescaled.sum()\n\n# Print the results to compare\nprint(f\"Number concentration from PMF: {number_concentration_pmf}\")\nprint(\n    f\"Number concentration from PDF rescaled to PMF: {number_concentration_pdf_rescaled}\"\n)\n</pre> # Sum the original PMF to calculate the total number concentration number_concentration_pmf = distribution_pmf.sum()  # Sum the PDF rescaled to PMF to calculate the total number concentration number_concentration_pdf_rescaled = distribution_pdf_rescaled.sum()  # Print the results to compare print(f\"Number concentration from PMF: {number_concentration_pmf}\") print(     f\"Number concentration from PDF rescaled to PMF: {number_concentration_pdf_rescaled}\" ) <pre>Number concentration from PMF: 1000000000000.0\nNumber concentration from PDF rescaled to PMF: 1011535485753.2141\n</pre> In\u00a0[7]: Copied! <pre># Calculate the mass of particles for each size bin\nmass_bins = 4 / 3 * np.pi * radius_bins**3 * 1e3  # kg\n\n# Calculate the Brownian coagulation kernel matrix\nkernel = brownian_kernel.brownian_coagulation_kernel_via_system_state(\n    radius_particle=radius_bins,\n    mass_particle=mass_bins,\n    temperature=293.15,  # Temperature in Kelvin (20\u00b0C)\n    pressure=101325,  # Pressure in Pascals (1 atm)\n    alpha_collision_efficiency=1.0,  # Assume perfect collision efficiency\n)\n</pre> # Calculate the mass of particles for each size bin mass_bins = 4 / 3 * np.pi * radius_bins**3 * 1e3  # kg  # Calculate the Brownian coagulation kernel matrix kernel = brownian_kernel.brownian_coagulation_kernel_via_system_state(     radius_particle=radius_bins,     mass_particle=mass_bins,     temperature=293.15,  # Temperature in Kelvin (20\u00b0C)     pressure=101325,  # Pressure in Pascals (1 atm)     alpha_collision_efficiency=1.0,  # Assume perfect collision efficiency ) In\u00a0[8]: Copied! <pre>concentration_0 = distribution_pdf\n\n# Calculate gain and loss rates for the PDF\ngain_pdf = rate.continuous_gain(\n    radius=radius_bins,\n    concentration=concentration_0,\n    kernel=kernel,\n)\nloss_pdf = rate.continuous_loss(\n    radius=radius_bins, concentration=concentration_0, kernel=kernel\n)\nnet_pdf = gain_pdf - loss_pdf\n\n# Convert gain, loss, and net rates to volume distribution\ngain_volume = gain_pdf * 4 / 3 * np.pi * radius_bins**3\nloss_volume = loss_pdf * 4 / 3 * np.pi * radius_bins**3\nnet_volume = net_pdf * 4 / 3 * np.pi * radius_bins**3\n\n# Integrate the gain, loss, and net rates to get the total volume\ngain_total_volume = trapezoid(gain_volume, x=radius_bins)\nloss_total_volume = trapezoid(loss_volume, x=radius_bins)\nnet_total_volume = trapezoid(net_volume, x=radius_bins)\n\n# Print the results to verify volume conservation\nprint(f\"Gain total volume: {gain_total_volume}\")\nprint(f\"Loss total volume: {loss_total_volume}\")\nprint(f\"Net total volume: {net_total_volume}\")\n</pre> concentration_0 = distribution_pdf  # Calculate gain and loss rates for the PDF gain_pdf = rate.continuous_gain(     radius=radius_bins,     concentration=concentration_0,     kernel=kernel, ) loss_pdf = rate.continuous_loss(     radius=radius_bins, concentration=concentration_0, kernel=kernel ) net_pdf = gain_pdf - loss_pdf  # Convert gain, loss, and net rates to volume distribution gain_volume = gain_pdf * 4 / 3 * np.pi * radius_bins**3 loss_volume = loss_pdf * 4 / 3 * np.pi * radius_bins**3 net_volume = net_pdf * 4 / 3 * np.pi * radius_bins**3  # Integrate the gain, loss, and net rates to get the total volume gain_total_volume = trapezoid(gain_volume, x=radius_bins) loss_total_volume = trapezoid(loss_volume, x=radius_bins) net_total_volume = trapezoid(net_volume, x=radius_bins)  # Print the results to verify volume conservation print(f\"Gain total volume: {gain_total_volume}\") print(f\"Loss total volume: {loss_total_volume}\") print(f\"Net total volume: {net_total_volume}\") <pre>Gain total volume: 6.75165104833036e-11\nLoss total volume: 6.752244952802652e-11\nNet total volume: -5.9390447229141716e-15\n</pre> <p>Ensuring Volume Conservation in Coagulation Rates for PMF</p> <p>Similar to the PDF representation, it is essential to ensure that the total particle volume is conserved in the PMF (Probability Mass Function) representation during the coagulation process. The number of particles may decrease as they coagulate into larger particles, but the total volume of particles should remain constant if no other processes (like condensation or evaporation) are involved.</p> <p>Calculating Coagulation Rates for PMF</p> <p>We calculate the gain, loss, and net coagulation rates for the initial PMF concentration. These rates describe how particle concentrations change in each size bin due to coagulation.</p> In\u00a0[9]: Copied! <pre># Initial concentration for the PMF distribution\nconcentration_0_pmf = distribution_pmf\n\n# Calculate gain and loss rates for the PMF\ngain_pmf = rate.discrete_gain(\n    radius=radius_bins,\n    concentration=concentration_0_pmf,\n    kernel=kernel,\n)\nloss_pmf = rate.discrete_loss(concentration=concentration_0_pmf, kernel=kernel)\nnet_pmf = gain_pmf - loss_pmf\n\n# Convert gain, loss, and net rates to volume distribution\ngain_volume_pmf = gain_pmf * 4 / 3 * np.pi * radius_bins**3\nloss_volume_pmf = loss_pmf * 4 / 3 * np.pi * radius_bins**3\nnet_volume_pmf = net_pmf * 4 / 3 * np.pi * radius_bins**3\n\n# Sum the gain, loss, and net volumes\ngain_total_volume_pmf = gain_volume_pmf.sum()\nloss_total_volume_pmf = loss_volume_pmf.sum()\nnet_total_volume_pmf = net_volume_pmf.sum()\n\n# Print the results to verify volume conservation\nprint(f\"Gain total volume PMF: {gain_total_volume_pmf}\")\nprint(f\"Loss total volume PMF: {loss_total_volume_pmf}\")\nprint(f\"Net total volume PMF: {net_total_volume_pmf}\")\n</pre> # Initial concentration for the PMF distribution concentration_0_pmf = distribution_pmf  # Calculate gain and loss rates for the PMF gain_pmf = rate.discrete_gain(     radius=radius_bins,     concentration=concentration_0_pmf,     kernel=kernel, ) loss_pmf = rate.discrete_loss(concentration=concentration_0_pmf, kernel=kernel) net_pmf = gain_pmf - loss_pmf  # Convert gain, loss, and net rates to volume distribution gain_volume_pmf = gain_pmf * 4 / 3 * np.pi * radius_bins**3 loss_volume_pmf = loss_pmf * 4 / 3 * np.pi * radius_bins**3 net_volume_pmf = net_pmf * 4 / 3 * np.pi * radius_bins**3  # Sum the gain, loss, and net volumes gain_total_volume_pmf = gain_volume_pmf.sum() loss_total_volume_pmf = loss_volume_pmf.sum() net_total_volume_pmf = net_volume_pmf.sum()  # Print the results to verify volume conservation print(f\"Gain total volume PMF: {gain_total_volume_pmf}\") print(f\"Loss total volume PMF: {loss_total_volume_pmf}\") print(f\"Net total volume PMF: {net_total_volume_pmf}\") <pre>Gain total volume PMF: 6.674655653136e-11\nLoss total volume PMF: 6.75224495280265e-11\nNet total volume PMF: -7.758929966665061e-13\n</pre> In\u00a0[10]: Copied! <pre># Convert PMF gain and loss rates to PDF\ngain_pmf_to_pdf = distribution_convert_pdf_pms(\n    x_array=radius_bins, distribution=gain_pmf, to_pdf=True\n)\nloss_pmf_to_pdf = distribution_convert_pdf_pms(\n    x_array=radius_bins, distribution=loss_pmf, to_pdf=True\n)\nnet_pmf_to_pdf = gain_pmf_to_pdf - loss_pmf_to_pdf\n\n# Plot the gain and loss rates for both PDF and converted PMF\nplt.figure()\nplt.plot(radius_bins, gain_pdf, label=\"Gain (PDF)\", linewidth=4)\nplt.plot(radius_bins, -1 * loss_pdf, label=\"Loss (PDF)\", linewidth=4)\nplt.plot(radius_bins, gain_pmf_to_pdf, label=\"Gain (PMF to PDF)\", linestyle=\"--\")\nplt.plot(\n    radius_bins,\n    -1 * loss_pmf_to_pdf,\n    label=\"Loss (PMF to PDF)\",\n    linestyle=\"--\",\n)\nplt.xlabel(\"Particle Radius [m]\")\nplt.ylabel(\"Rate $\\dfrac{1}{m^3 s \\cdot m}$\")\nplt.xscale(\"log\")\nplt.title(\"PDF: Gain and Loss Comparison\")\nplt.legend()\nplt.show()\n\n# Plot the net gain and loss rates for both PDF and converted PMF\nplt.figure()\nplt.plot(radius_bins, net_pdf, label=\"Net (PDF)\")\nplt.plot(radius_bins, net_pmf_to_pdf, label=\"Net (PMF to PDF)\")\nplt.xlabel(\"Particle Radius [m]\")\nplt.ylabel(\"Rate $\\dfrac{1}{m^3 s \\cdot m}$\")\nplt.xscale(\"log\")\nplt.title(\"PDF: Net Gain and Loss Comparison\")\nplt.legend()\nplt.show()\n</pre> # Convert PMF gain and loss rates to PDF gain_pmf_to_pdf = distribution_convert_pdf_pms(     x_array=radius_bins, distribution=gain_pmf, to_pdf=True ) loss_pmf_to_pdf = distribution_convert_pdf_pms(     x_array=radius_bins, distribution=loss_pmf, to_pdf=True ) net_pmf_to_pdf = gain_pmf_to_pdf - loss_pmf_to_pdf  # Plot the gain and loss rates for both PDF and converted PMF plt.figure() plt.plot(radius_bins, gain_pdf, label=\"Gain (PDF)\", linewidth=4) plt.plot(radius_bins, -1 * loss_pdf, label=\"Loss (PDF)\", linewidth=4) plt.plot(radius_bins, gain_pmf_to_pdf, label=\"Gain (PMF to PDF)\", linestyle=\"--\") plt.plot(     radius_bins,     -1 * loss_pmf_to_pdf,     label=\"Loss (PMF to PDF)\",     linestyle=\"--\", ) plt.xlabel(\"Particle Radius [m]\") plt.ylabel(\"Rate $\\dfrac{1}{m^3 s \\cdot m}$\") plt.xscale(\"log\") plt.title(\"PDF: Gain and Loss Comparison\") plt.legend() plt.show()  # Plot the net gain and loss rates for both PDF and converted PMF plt.figure() plt.plot(radius_bins, net_pdf, label=\"Net (PDF)\") plt.plot(radius_bins, net_pmf_to_pdf, label=\"Net (PMF to PDF)\") plt.xlabel(\"Particle Radius [m]\") plt.ylabel(\"Rate $\\dfrac{1}{m^3 s \\cdot m}$\") plt.xscale(\"log\") plt.title(\"PDF: Net Gain and Loss Comparison\") plt.legend() plt.show() In\u00a0[11]: Copied! <pre># Initial distribution for the simulation\ndistribution_0 = distribution_pdf\ndistribution_i = distribution_0\n\n# Define the time array for the simulation\ntime_array = np.linspace(\n    start=0, stop=1000, num=50\n)  # Time span of 1000 seconds\ntime_interval = (\n    time_array[1] - time_array[0]\n)  # Time interval between each step\n\n# Array to store the distribution at each time step\ndistribution_time = np.zeros([len(time_array), len(distribution_0)])\n\n# Simulate the coagulation process over time\nfor i, dpa in enumerate(time_array):\n    if i &gt; 0:\n        # Calculate coagulation gain and loss at the current time step\n        coag_gain_i = rate.continuous_gain(\n            radius=radius_bins,\n            concentration=distribution_i,\n            kernel=kernel,\n        )\n        coag_loss_i = rate.continuous_loss(\n            radius=radius_bins, concentration=distribution_i, kernel=kernel\n        )\n\n        # Calculate the net change in distribution due to coagulation\n        net_change = (coag_gain_i - coag_loss_i) * time_interval\n        distribution_i = distribution_i + net_change\n\n        # Ensure no negative concentrations (set to zero if less than zero)\n        distribution_i[distribution_i &lt; 0] = 0\n\n    # Store the updated distribution for the current time step\n    distribution_time[i, :] = distribution_i\n</pre> # Initial distribution for the simulation distribution_0 = distribution_pdf distribution_i = distribution_0  # Define the time array for the simulation time_array = np.linspace(     start=0, stop=1000, num=50 )  # Time span of 1000 seconds time_interval = (     time_array[1] - time_array[0] )  # Time interval between each step  # Array to store the distribution at each time step distribution_time = np.zeros([len(time_array), len(distribution_0)])  # Simulate the coagulation process over time for i, dpa in enumerate(time_array):     if i &gt; 0:         # Calculate coagulation gain and loss at the current time step         coag_gain_i = rate.continuous_gain(             radius=radius_bins,             concentration=distribution_i,             kernel=kernel,         )         coag_loss_i = rate.continuous_loss(             radius=radius_bins, concentration=distribution_i, kernel=kernel         )          # Calculate the net change in distribution due to coagulation         net_change = (coag_gain_i - coag_loss_i) * time_interval         distribution_i = distribution_i + net_change          # Ensure no negative concentrations (set to zero if less than zero)         distribution_i[distribution_i &lt; 0] = 0      # Store the updated distribution for the current time step     distribution_time[i, :] = distribution_i <p>Visualizing the Evolution of the Particle Size Distribution</p> <p>After simulating the coagulation process over time, we can visualize how the particle size distribution evolves at different time steps. This plot compares the initial distribution with the distribution at a mid-point and at the end of the simulation, highlighting the changes that occur due to coagulation.</p> In\u00a0[12]: Copied! <pre># Set up the plot\nfig, ax = plt.subplots(1, 1, figsize=[9, 6])\n\n# Define the radius bins\nradius = radius_bins\n\n# Plot the initial distribution, mid-point distribution, and final distribution\nax.semilogx(\n    radius, distribution_0, \"-b\", label=\"Initial\"\n)  # Initial distribution\nax.semilogx(\n    radius, distribution_time[25, :], \"--\", label=\"t-step=25\"\n)  # Mid-point\nax.semilogx(\n    radius, distribution_time[-1, :], \"-r\", label=\"t=end\"\n)  # Final distribution\n\n# Set the limits for the x-axis to focus on the relevant size range\nax.set_xlim([2e-8, 1e-6])\n\n# Add legend to distinguish between different time steps\nax.legend()\n\n# Label the y-axis to indicate concentration units\nax.set_ylabel(r\"Concentration $\\dfrac{1}{m^3 \\cdot m}$\")\n\n# Label the x-axis for particle radius\nax.set_xlabel(\"Radius [m]\")\n\n# Add grid lines for better readability\nax.grid(True, alpha=0.5)\n\n# Show the plot\nplt.show()\n</pre> # Set up the plot fig, ax = plt.subplots(1, 1, figsize=[9, 6])  # Define the radius bins radius = radius_bins  # Plot the initial distribution, mid-point distribution, and final distribution ax.semilogx(     radius, distribution_0, \"-b\", label=\"Initial\" )  # Initial distribution ax.semilogx(     radius, distribution_time[25, :], \"--\", label=\"t-step=25\" )  # Mid-point ax.semilogx(     radius, distribution_time[-1, :], \"-r\", label=\"t=end\" )  # Final distribution  # Set the limits for the x-axis to focus on the relevant size range ax.set_xlim([2e-8, 1e-6])  # Add legend to distinguish between different time steps ax.legend()  # Label the y-axis to indicate concentration units ax.set_ylabel(r\"Concentration $\\dfrac{1}{m^3 \\cdot m}$\")  # Label the x-axis for particle radius ax.set_xlabel(\"Radius [m]\")  # Add grid lines for better readability ax.grid(True, alpha=0.5)  # Show the plot plt.show() <p>Visualizing Particle Size Distribution Evolution Over Time</p> <p>To further understand how the particle size distribution evolves during the coagulation process, we can create a 2D image plot. In this plot, time is represented on the x-axis, particle size (radius) on the y-axis, and the concentration is color-coded. This type of plot provides a comprehensive view of how both small and large particles change in concentration over the entire simulation period.</p> In\u00a0[13]: Copied! <pre># Set up the plot\nfig, ax = plt.subplots(figsize=(10, 6))\n\n# Create an image plot (2D histogram) with time on the x-axis, radius on the y-axis, and concentration as color\nc = ax.pcolormesh(\n    time_array,\n    radius_bins,\n    distribution_time.T,\n    shading=\"auto\",\n    cmap=\"viridis\",\n)\n\n# Set the y-axis to a logarithmic scale to capture the wide range of particle sizes\nax.set_ylim([5e-8, 1e-6])\nax.set_yscale(\"log\")\n\n# Label the axes\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(\"Particle Radius (m)\")\n\n# Add a color bar to indicate the concentration levels\ncbar = fig.colorbar(c, ax=ax)\ncbar.set_label(r\"Concentration $\\dfrac{1}{m^3 \\cdot m}$\")\n\n# Add a title to the plot\nax.set_title(\"Evolution of Particle Size Distribution Over Time\")\n\n# Show the plot\nplt.show()\n</pre> # Set up the plot fig, ax = plt.subplots(figsize=(10, 6))  # Create an image plot (2D histogram) with time on the x-axis, radius on the y-axis, and concentration as color c = ax.pcolormesh(     time_array,     radius_bins,     distribution_time.T,     shading=\"auto\",     cmap=\"viridis\", )  # Set the y-axis to a logarithmic scale to capture the wide range of particle sizes ax.set_ylim([5e-8, 1e-6]) ax.set_yscale(\"log\")  # Label the axes ax.set_xlabel(\"Time (s)\") ax.set_ylabel(\"Particle Radius (m)\")  # Add a color bar to indicate the concentration levels cbar = fig.colorbar(c, ax=ax) cbar.set_label(r\"Concentration $\\dfrac{1}{m^3 \\cdot m}$\")  # Add a title to the plot ax.set_title(\"Evolution of Particle Size Distribution Over Time\")  # Show the plot plt.show() In\u00a0[24]: Copied! <pre>from scipy.integrate import solve_ivp\nimport numpy as np\n\n\n# Define the coagulation ODE system\ndef coagulation_ode(t, distribution, radius_bins, kernel, rate):\n    \"\"\"\n    Compute the derivative of the distribution with respect to time\n    (i.e., the rate of change due to coagulation).\n\n    Arguments:\n        t: Time variable (not used explicitly here, but required by solve_ivp).\n        distribution: The current particle size distribution (array).\n        radius_bins: The bins for the particle radius.\n        kernel: The coagulation kernel.\n        rate: The object with methods for calculating coagulation gain and loss.\n\n    Returns:\n        The time derivative of the particle distribution.\n    \"\"\"\n    coag_gain = rate.continuous_gain(\n        radius=radius_bins, concentration=distribution, kernel=kernel\n    )\n    coag_loss = rate.continuous_loss(\n        radius=radius_bins, concentration=distribution, kernel=kernel\n    )\n\n    # Net change in distribution due to coagulation\n    net_change = coag_gain - coag_loss\n\n    return net_change\n\n\n# Initial distribution for the simulation\ndistribution_0 = distribution_pdf\n\n# Define the time array for the simulation\ntime_array = np.linspace(\n    start=0, stop=1000, num=50\n)  # Time span of 1000 seconds\n\n# Use scipy's solve_ivp to solve the ODE system\nsolution = solve_ivp(\n    fun=coagulation_ode,  # ODE function\n    t_span=(time_array[0], time_array[-1]),  # Time span\n    y0=distribution_0,  # Initial distribution\n    t_eval=time_array,  # Time points to store the solution\n    args=(\n        radius_bins,\n        kernel,\n        rate,\n    ),  # Additional arguments to coagulation_ode\n    method=\"BDF\",  # Integration method (default)\n    min_step=1e-2,\n    max_step=1e2,\n)\n\n# The solution is stored in solution.y (each column is a time step)\ndistribution_solver = solution.y.T  # Transpose to match original format\n</pre> from scipy.integrate import solve_ivp import numpy as np   # Define the coagulation ODE system def coagulation_ode(t, distribution, radius_bins, kernel, rate):     \"\"\"     Compute the derivative of the distribution with respect to time     (i.e., the rate of change due to coagulation).      Arguments:         t: Time variable (not used explicitly here, but required by solve_ivp).         distribution: The current particle size distribution (array).         radius_bins: The bins for the particle radius.         kernel: The coagulation kernel.         rate: The object with methods for calculating coagulation gain and loss.      Returns:         The time derivative of the particle distribution.     \"\"\"     coag_gain = rate.continuous_gain(         radius=radius_bins, concentration=distribution, kernel=kernel     )     coag_loss = rate.continuous_loss(         radius=radius_bins, concentration=distribution, kernel=kernel     )      # Net change in distribution due to coagulation     net_change = coag_gain - coag_loss      return net_change   # Initial distribution for the simulation distribution_0 = distribution_pdf  # Define the time array for the simulation time_array = np.linspace(     start=0, stop=1000, num=50 )  # Time span of 1000 seconds  # Use scipy's solve_ivp to solve the ODE system solution = solve_ivp(     fun=coagulation_ode,  # ODE function     t_span=(time_array[0], time_array[-1]),  # Time span     y0=distribution_0,  # Initial distribution     t_eval=time_array,  # Time points to store the solution     args=(         radius_bins,         kernel,         rate,     ),  # Additional arguments to coagulation_ode     method=\"BDF\",  # Integration method (default)     min_step=1e-2,     max_step=1e2, )  # The solution is stored in solution.y (each column is a time step) distribution_solver = solution.y.T  # Transpose to match original format In\u00a0[25]: Copied! <pre># Set up the plot\nfig, ax = plt.subplots(1, 1, figsize=[9, 6])\n\n# Define the radius bins\nradius = radius_bins\n\n# Plot the initial distribution, mid-point distribution, and final distribution\nax.semilogx(\n    radius, distribution_solver[0, :], \"-b\", label=\"Initial\"\n)  # Initial distribution\nax.semilogx(\n    radius, distribution_solver[25, :], \"--\", label=\"t-step=25\"\n)  # Mid-point\nax.semilogx(\n    radius, distribution_solver[-1, :], \"-r\", label=\"t=end\"\n)  # Final distribution\n\n# Plot the initial distribution, mid-point distribution, and final distribution\nax.semilogx(\n    radius, distribution_0, \"-b\", label=\"Initial-loop\"\n)  # Initial distribution\nax.semilogx(\n    radius, distribution_time[25, :], \"--\", label=\"t-step=25 loop\"\n)  # Mid-point\nax.semilogx(\n    radius, distribution_time[-1, :], \"-r\", label=\"t=end loop\"\n)  # Final distribution\n\n# Set the limits for the x-axis to focus on the relevant size range\nax.set_xlim([2e-8, 1e-6])\n\n# Add legend to distinguish between different time steps\nax.legend()\n\n# Label the y-axis to indicate concentration units\nax.set_ylabel(r\"Concentration $\\dfrac{1}{m^3 \\cdot m}$\")\n\n# Label the x-axis for particle radius\nax.set_xlabel(\"Radius [m]\")\n\n# Add grid lines for better readability\nax.grid(True, alpha=0.5)\n\n# Show the plot\nplt.show()\n</pre> # Set up the plot fig, ax = plt.subplots(1, 1, figsize=[9, 6])  # Define the radius bins radius = radius_bins  # Plot the initial distribution, mid-point distribution, and final distribution ax.semilogx(     radius, distribution_solver[0, :], \"-b\", label=\"Initial\" )  # Initial distribution ax.semilogx(     radius, distribution_solver[25, :], \"--\", label=\"t-step=25\" )  # Mid-point ax.semilogx(     radius, distribution_solver[-1, :], \"-r\", label=\"t=end\" )  # Final distribution  # Plot the initial distribution, mid-point distribution, and final distribution ax.semilogx(     radius, distribution_0, \"-b\", label=\"Initial-loop\" )  # Initial distribution ax.semilogx(     radius, distribution_time[25, :], \"--\", label=\"t-step=25 loop\" )  # Mid-point ax.semilogx(     radius, distribution_time[-1, :], \"-r\", label=\"t=end loop\" )  # Final distribution  # Set the limits for the x-axis to focus on the relevant size range ax.set_xlim([2e-8, 1e-6])  # Add legend to distinguish between different time steps ax.legend()  # Label the y-axis to indicate concentration units ax.set_ylabel(r\"Concentration $\\dfrac{1}{m^3 \\cdot m}$\")  # Label the x-axis for particle radius ax.set_xlabel(\"Radius [m]\")  # Add grid lines for better readability ax.grid(True, alpha=0.5)  # Show the plot plt.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_3_compared/#coagulation-basic-3-pmf-vs-pdf","title":"Coagulation Basic 3: PMF vs. PDF\u00b6","text":"<p>In this section, we will compare two fundamental approaches to modeling aerosol particle coagulation: the Probability Mass Function (PMF) and the Probability Density Function (PDF) methods. Both methods offer different perspectives on representing particle size distributions and calculating coagulation rates, which are critical for understanding how particles in aerosols interact and evolve over time.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_3_compared/#probability-mass-function-pmf-vs-probability-density-function-pdf","title":"Probability Mass Function (PMF) vs. Probability Density Function (PDF)\u00b6","text":"<ul> <li><p>PMF Representation: The PMF method discretizes the particle size distribution into distinct bins, each representing a specific particle size or mass. This approach counts the number of particles within each bin, making it a straightforward method for tracking how particle populations change due to coagulation. PMF is particularly useful when dealing with discrete particle sizes or when particle number concentrations are of primary interest.</p> </li> <li><p>PDF Representation: In contrast, the PDF method provides a continuous representation of the particle size distribution. Instead of counting particles in discrete bins, PDF describes the likelihood of finding particles within a given size range. This approach is well-suited for scenarios where a smooth distribution of particle sizes is expected or when dealing with very fine size resolutions.</p> </li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_3_compared/#comparison-objectives","title":"Comparison Objectives\u00b6","text":"<p>The objective of this comparison is to demonstrate how the choice between PMF and PDF representations affects the calculation of coagulation rates and the resulting particle size distributions. By applying both methods to a lognormal size distribution, we will analyze the differences in how each method handles the evolution of particle populations during coagulation.</p> <p>To facilitate this comparison, we will:</p> <ol> <li><p>Initialize Lognormal Distributions: Generate lognormal particle size distributions using both PMF and PDF methods, ensuring that both distributions share the same initial parameters (e.g., mode, geometric standard deviation, and total particle concentration).</p> </li> <li><p>Calculate Coagulation Kernel: Compute the Brownian coagulation kernel using identical environmental conditions (e.g., temperature, pressure, collision efficiency) for both methods. This will allow us to isolate the effect of the distribution representation on the coagulation rates.</p> </li> <li><p>Simulate Coagulation: Simulate the coagulation process over several time steps for both PMF and PDF representations, tracking how the particle size distributions evolve and comparing the results.</p> </li> </ol> <p>By the end of this section, we aim to highlight the strengths and limitations of each method, providing insights into when and why one approach might be preferred over the other in aerosol research and modeling.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_3_compared/#setting-up-and-visualizing","title":"Setting Up and Visualizing\u00b6","text":"<p>In this section, we define the parameters for a lognormal particle size distribution and generate both Probability Density Function (PDF) and Probability Mass Function (PMF) representations. We then visualize these distributions to compare how each method represents particle concentrations across different size ranges.</p> <p>Distribution Parameters</p> <p>We start by defining the key parameters for the lognormal distribution:</p> <ul> <li>Mode: The most probable particle size is set to 200 nanometers (200 nm or (200 \\times 10^{-9}) meters).</li> <li>Geometric Standard Deviation: The spread of the distribution is controlled by a geometric standard deviation of 1.5.</li> <li>Total Number Concentration: The total concentration of particles is (1 \\times 10^6) particles per cubic centimeter (cm\u00b3), which we convert to (1 \\times 10^{12}) particles per cubic meter (m\u00b3) for our calculations.</li> </ul> <p>We also define the radius bins, which span a wide range from 1 nanometer to 10 micrometers, using a logarithmic scale to capture the distribution across different particle sizes.</p> <p>Explanation</p> <ul> <li>Parameter Definitions: The mode, geometric standard deviation, and number concentration are clearly defined to set up the lognormal distribution.</li> <li>Distribution Creation: We generate both PDF and PMF representations of the distribution using the defined parameters and radius bins. This allows us to see how each method captures the particle concentrations.</li> <li>Visualization: The plot compares the PDF and PMF distributions on a logarithmic scale, which is essential for accurately displaying the wide range of particle sizes and concentrations. The use of log scales on both axes helps to highlight the differences between the two methods.</li> </ul> <p>By visualizing these distributions side by side, we gain a better understanding of how the PDF and PMF methods differ in representing aerosol particle sizes and concentrations.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_3_compared/#rescaling-pdf","title":"Rescaling PDF\u00b6","text":"<p>In this section, we convert the previously generated Probability Density Function (PDF) into a Probability Mass Function (PMF) to directly compare it with the original PMF distribution. This rescaling is necessary because PDF and PMF represent the distribution in different ways, and aligning them allows for a more accurate comparison.</p> <p>Rescaling the PDF</p> <p>The conversion from PDF to PMF involves rescaling the distribution so that the integral of the PDF over each bin corresponds to the particle count in that bin, similar to what is represented in the PMF. This is done using the <code>distribution_convert_pdf_pms</code> function.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_3_compared/#rescaling-pmf","title":"Rescaling PMF\u00b6","text":"<p>After converting the PDF to a PMF for direct comparison, we now perform the reverse operation: rescaling the PMF to a PDF. This allows us to compare the original PDF with the PMF that has been adjusted to match the continuous representation of particle concentrations.</p> <p>Rescaling the PMF</p> <p>To rescale the PMF to a PDF, we use the <code>distribution_convert_pdf_pms</code> function. This conversion ensures that the PMF, which originally represented discrete particle counts in each bin, is transformed into a continuous probability density function, aligning it with the original PDF format.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_3_compared/#verifying-number-concentration","title":"Verifying Number Concentration\u00b6","text":"<p>In this section, we validate the consistency of the number concentration across different representations (PDF and PMF) by performing numerical integrations and summations. This step ensures that the transformations between PDF and PMF maintain the expected total particle concentrations.</p> <p>Integrating Number Concentration for PDF</p> <p>We first integrate the original PDF distribution and the PMF that has been rescaled to a PDF to check if they yield the same total number concentration. The trapezoidal rule is used for this integration.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_3_compared/#small-errors","title":"Small Errors\u00b6","text":"<p>When comparing the total number concentrations derived from the PDF and PMF representations, as well as their rescaled versions, we observe small discrepancies between the values.</p> <p>Sources of Error</p> <p>These small differences arise from several factors inherent in the process of transforming and integrating discrete and continuous distributions:</p> <ol> <li><p>Numerical Approximation:</p> <ul> <li>The integration of the PDF and the summation of the PMF involve numerical approximations, which can introduce small errors. The trapezoidal rule, used for integrating the PDF, is an approximation method that may not perfectly capture the area under the curve, especially when dealing with finely spaced bins or distributions that change rapidly in certain regions.</li> </ul> </li> <li><p>Discretization of Continuous Distributions:</p> <ul> <li>When rescaling a PDF to a PMF or vice versa, we are essentially converting a continuous function into a discrete one, or vice versa. This discretization process can lead to slight inconsistencies because the continuous distribution is approximated by a finite number of bins. The exact alignment of these bins with the underlying distribution is rarely perfect, leading to small errors.</li> </ul> </li> <li><p>Cumulative Effect of Small Differences:</p> <ul> <li>Small differences across many bins can accumulate, resulting in a noticeable discrepancy when summing or integrating over the entire distribution. Even if each individual difference is minute, the total error can be more significant when considering the entire size range.</li> </ul> </li> </ol> <p>Significance of the Errors</p> <p>While these errors are small relative to the total number concentration (less than 1% in this case), they are important to acknowledge when performing precision calculations. In practical applications, these discrepancies are often considered acceptable, but they highlight the importance of understanding the limitations of numerical methods and transformations between different types of distributions.</p> <p>Mitigating the Errors</p> <ul> <li>Increasing the Number of Bins: Using a higher resolution (more bins) can help reduce the error by more closely approximating the continuous distribution.</li> <li>Refining the Interpolation Method: More sophisticated interpolation methods may provide better alignment between the PDF and PMF during the rescaling process, further minimizing errors.</li> <li>Error Analysis: Incorporating error analysis into the calculations can help quantify and understand the impact of these discrepancies on the overall results.</li> </ul> <p>Overall, these small errors are a natural consequence of the numerical techniques used and do not significantly detract from the accuracy of the coagulation modeling. However, being aware of their existence is crucial for interpreting results with a full understanding of the underlying processes.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_3_compared/#brownian-coagulation-kernel","title":"Brownian Coagulation Kernel\u00b6","text":"<p>Before comparing the coagulation rates between the Probability Mass Function (PMF) and Probability Density Function (PDF) representations, it is essential to calculate the Brownian coagulation kernel. The kernel quantifies the rate at which particles of different sizes collide and coagulate due to Brownian motion. This matrix is a key component in determining how quickly particles in an aerosol system merge to form larger particles.</p> <p>Calculation of Particle Masses</p> <p>To calculate the coagulation kernel, we first need to determine the mass of particles in each size bin. The mass of a particle is calculated using the formula for the volume of a sphere:</p> <p>$$ m = \\frac{4}{3} \\pi r^3 \\times 1000 \\, \\text{kg/m}^3 $$</p> <p>where $r$  is the particle radius and 1000 kg/m\u00b3 is the assumed density of the particles.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_3_compared/#volume-conservation","title":"Volume Conservation\u00b6","text":"<p>In aerosol coagulation processes, one check is to ensure that the total particle volume is conserved. While the number of particles decreases as they coagulate to form larger particles, the total volume of material should remain constant (assuming no other processes such as condensation or evaporation are occurring).</p> <p>In this section, we calculate the gain, loss, and net coagulation rates using the PDF representation and verify that the total volume remains consistent.</p> <p>Calculating Coagulation Rates</p> <p>We start by calculating the gain, loss, and net coagulation rates based on the initial PDF concentration. These rates describe how particles in different size bins gain or lose mass due to coagulation.</p> <p>**Converting to Volume Distribution ** To verify volume conservation, we convert the particle concentration rates (gain, loss, and net) into volume rates by multiplying them by the volume of particles in each size bin. The volume of a particle is given by:</p> <p>$$ V = \\frac{4}{3} \\pi r^3 $$</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_3_compared/#gain-and-loss-rates-comparison","title":"Gain and Loss Rates Comparison\u00b6","text":"<p>To understand the differences and similarities between the PDF and PMF representations in the context of particle coagulation, we convert the PMF gain and loss rates to their corresponding PDF forms. This allows for a direct comparison of how each representation handles particle concentration changes across different size ranges.</p> <p>Converting PMF to PDF</p> <p>The gain and loss rates calculated for the PMF representation are converted to PDF using the <code>distribution_convert_pdf_pms</code> function. This conversion enables us to plot and compare the results on the same scale and with the same units as the original PDF.</p> <p>Explanation</p> <ul> <li><p>Comparison of Gain and Loss Rates: The first plot compares the gain and loss rates between the original PDF and the converted PMF. By plotting these on the same axes, we can observe how closely the PMF (when converted to PDF) matches the behavior of the original PDF. The solid lines represent the PDF results, while the dashed lines represent the PMF converted to PDF.</p> </li> <li><p>Comparison of Net Rates: The second plot focuses on the net gain and loss rates, which are calculated as the difference between the gain and loss rates. This plot helps in understanding whether the differences in the gain and loss rates between the PDF and converted PMF lead to any significant discrepancies in the overall net rate of particle concentration change.</p> </li> </ul> <p>Interpretation</p> <ul> <li><p>Matching Behavior: Ideally, the converted PMF should closely match the original PDF, indicating that both representations handle coagulation rates similarly. Any differences observed in the plots can provide insights into the nuances of each method, such as how they handle small particle sizes or how numerical approximations might affect the results.</p> </li> <li><p>Significance of Differences: While small differences between the PDF and converted PMF may arise due to numerical methods, these differences can highlight the strengths and limitations of each approach in representing particle size distributions and their evolution during coagulation.</p> </li> </ul> <p>PMF Gain Error</p> <p>The PMF gain rate is slightly off, and we are still looking into the issue. We will update this section once we have resolved the discrepancy.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_3_compared/#simulating-pdf-coagulation","title":"Simulating PDF Coagulation\u00b6","text":"<p>In this section, we simulate the evolution of a particle size distribution over time as particles undergo coagulation, using the Probability Density Function (PDF) representation. The simulation tracks how the distribution changes at different time steps, providing insight into how the particle population evolves under the influence of Brownian coagulation.</p> <p>Simulation Setup</p> <ul> <li>Initial Distribution: The simulation begins with the initial particle size distribution (<code>distribution_0</code>), which is based on the PDF calculated earlier.</li> <li>Time Array: The simulation runs over a time span from 0 to 1000 seconds, with 50 discrete time steps. The time interval between each step is calculated to update the distribution as coagulation progresses.</li> </ul>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_3_compared/#add-pmf-simulation-comparison-and-summary","title":"Add PMF simulation, comparison, and summary\u00b6","text":""},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_4_ParticleResolved/","title":"Coagulation Basic 4: Particle Resolved","text":"In\u00a0[1]: Copied! <pre># %% particle resolved coagulation example\nimport numpy as np  # For numerical operations and array manipulations\nimport matplotlib.pyplot as plt  # For plotting graphs and visualizations\n\n# Import specific modules from the particula package\nfrom particula.next.dynamics.coagulation import brownian_kernel\nfrom particula.next.dynamics.coagulation import particle_resolved_method\n\nfrom particula.next.particles.properties.lognormal_size_distribution import (\n    lognormal_sample_distribution,\n)\n</pre> # %% particle resolved coagulation example import numpy as np  # For numerical operations and array manipulations import matplotlib.pyplot as plt  # For plotting graphs and visualizations  # Import specific modules from the particula package from particula.next.dynamics.coagulation import brownian_kernel from particula.next.dynamics.coagulation import particle_resolved_method  from particula.next.particles.properties.lognormal_size_distribution import (     lognormal_sample_distribution, ) In\u00a0[2]: Copied! <pre># lognormal spacing\n\nradius_bins = np.logspace(\n    -9, -6, num=20\n)  # Define the radius bins for the distribution\nmass_bins = (\n    4 / 3 * np.pi * radius_bins**3 * 1000\n)  # Calculate the mass of the particles in the bins\n\nkernel = brownian_kernel.brownian_coagulation_kernel_via_system_state(\n    radius_particle=radius_bins,\n    mass_particle=mass_bins,\n    temperature=298.15,\n    pressure=101325,\n)  # Calculate the Brownian coagulation kernel for the radius bins\n\nrandom_generator = np.random.default_rng(12345)\n</pre> # lognormal spacing  radius_bins = np.logspace(     -9, -6, num=20 )  # Define the radius bins for the distribution mass_bins = (     4 / 3 * np.pi * radius_bins**3 * 1000 )  # Calculate the mass of the particles in the bins  kernel = brownian_kernel.brownian_coagulation_kernel_via_system_state(     radius_particle=radius_bins,     mass_particle=mass_bins,     temperature=298.15,     pressure=101325, )  # Calculate the Brownian coagulation kernel for the radius bins  random_generator = np.random.default_rng(12345) <p>Sampling the Particle Distribution</p> <p>We then sample particles from the lognormal distribution. These particles will be sorted by size to prepare for the coagulation step.</p> In\u00a0[3]: Copied! <pre># %% sample particle distribution\nparticle_radius = lognormal_sample_distribution(\n    mode=np.array([1e-8, 1e-7]),\n    geometric_standard_deviation=np.array([1.4, 1.4]),\n    number_of_particles=np.array([5000, 1000]),\n    number_of_samples=10_000,\n)\n# particle_radius = np.sort(particle_radius)\nparticles_original = particle_radius.copy()\n</pre> # %% sample particle distribution particle_radius = lognormal_sample_distribution(     mode=np.array([1e-8, 1e-7]),     geometric_standard_deviation=np.array([1.4, 1.4]),     number_of_particles=np.array([5000, 1000]),     number_of_samples=10_000, ) # particle_radius = np.sort(particle_radius) particles_original = particle_radius.copy() In\u00a0[4]: Copied! <pre># %% Coagulation step\n\ndelta_t = 100  # time step in seconds\ntotal_number_concentration = 1_000_000 * 1e6  # particles per m^3\ntotal_number_tracked = len(particle_radius)\nvolume_sim = total_number_tracked / total_number_concentration\n\nparticle_radius, loss, gain, loss_gain_index = particle_resolved_method.particle_resolved_coagulation_step(\n    particle_radius=particle_radius,\n    kernel=kernel,\n    kernel_radius=radius_bins,\n    volume=volume_sim,\n    time_step=delta_t,\n    random_generator=random_generator,\n)\n\nprint(loss_gain_index.shape)\nprint(loss_gain_index)\n</pre> # %% Coagulation step  delta_t = 100  # time step in seconds total_number_concentration = 1_000_000 * 1e6  # particles per m^3 total_number_tracked = len(particle_radius) volume_sim = total_number_tracked / total_number_concentration  particle_radius, loss, gain, loss_gain_index = particle_resolved_method.particle_resolved_coagulation_step(     particle_radius=particle_radius,     kernel=kernel,     kernel_radius=radius_bins,     volume=volume_sim,     time_step=delta_t,     random_generator=random_generator, )  print(loss_gain_index.shape) print(loss_gain_index) <pre>(2387, 2)\n[[6101 8884]\n [4989 8652]\n [1949 3784]\n ...\n [8434 9121]\n [8686 9984]\n [8740 9590]]\n</pre> <p>Plotting the New Distribution</p> <p>Finally, we plot the particle size distribution before and after coagulation. This visualization helps us understand the effect of the coagulation process on the particle size distribution.</p> In\u00a0[5]: Copied! <pre># %% plot new distribution\nfig, ax = plt.subplots()\nax.hist(\n    particles_original, bins=100, histtype=\"step\", color=\"black\", density=True\n)\nax.hist(\n    particle_radius[particle_radius&gt;0], bins=100, histtype=\"step\", color=\"blue\", density=True\n)\nax.set_xscale(\"log\")\nax.set_yscale(\"log\")\nax.set_xlabel(\"Particle radius (m)\")\nax.set_ylabel(\"Frequency\")\nplt.show()\n</pre> # %% plot new distribution fig, ax = plt.subplots() ax.hist(     particles_original, bins=100, histtype=\"step\", color=\"black\", density=True ) ax.hist(     particle_radius[particle_radius&gt;0], bins=100, histtype=\"step\", color=\"blue\", density=True ) ax.set_xscale(\"log\") ax.set_yscale(\"log\") ax.set_xlabel(\"Particle radius (m)\") ax.set_ylabel(\"Frequency\") plt.show() <p>Plotting the Loss and Gain of Particles</p> <p>We also plot the loss and gain of particles due to coagulation. This visualization provides insights into the coagulation process and how it affects the particle population.</p> In\u00a0[6]: Copied! <pre>fig, ax = plt.subplots()\nax.hist(loss[loss&gt;0], bins=100, histtype=\"step\", color=\"red\", density=True)\nax.hist(gain[gain&gt;0], bins=100, histtype=\"step\", color=\"green\", density=True)\nax.set_xscale(\"log\")\n# ax.set_yscale(\"log\")\nax.set_xlabel(\"Particle radius (m)\")\nax.set_ylabel(\"Frequency\")\nplt.show()\n</pre> fig, ax = plt.subplots() ax.hist(loss[loss&gt;0], bins=100, histtype=\"step\", color=\"red\", density=True) ax.hist(gain[gain&gt;0], bins=100, histtype=\"step\", color=\"green\", density=True) ax.set_xscale(\"log\") # ax.set_yscale(\"log\") ax.set_xlabel(\"Particle radius (m)\") ax.set_ylabel(\"Frequency\") plt.show() In\u00a0[8]: Copied! <pre># Initial distribution for the simulation\nparticles_0 = particles_original\nparticles_i = particles_0\n\n# Define the time array for the simulation\ntime_array = np.linspace(\n    start=0, stop=1000, num=100\n)  # Time span of 1000 seconds\ntime_interval = (\n    time_array[1] - time_array[0]\n)  # Time interval between each step\n\n# Array to store the distribution at each time step\nparticles_matrix = np.zeros([len(time_array), len(particles_0)])\n\n# Simulate the coagulation process over time\nfor i, dpa in enumerate(time_array):\n    if i &gt; 0:\n\n        particles_i, _, _, _ = (\n            particle_resolved_method.particle_resolved_coagulation_step(\n                particle_radius=particles_i,\n                kernel=kernel,\n                kernel_radius=radius_bins,\n                volume=volume_sim,\n                time_step=time_interval,\n                random_generator=random_generator,\n            )\n        )\n        # Ensure no negative concentrations (set to zero if less than zero)\n        particles_i[particles_i &lt; 0] = 0\n\n    # Store the updated distribution for the current time step\n    particles_matrix[i, :] = particles_i\n</pre> # Initial distribution for the simulation particles_0 = particles_original particles_i = particles_0  # Define the time array for the simulation time_array = np.linspace(     start=0, stop=1000, num=100 )  # Time span of 1000 seconds time_interval = (     time_array[1] - time_array[0] )  # Time interval between each step  # Array to store the distribution at each time step particles_matrix = np.zeros([len(time_array), len(particles_0)])  # Simulate the coagulation process over time for i, dpa in enumerate(time_array):     if i &gt; 0:          particles_i, _, _, _ = (             particle_resolved_method.particle_resolved_coagulation_step(                 particle_radius=particles_i,                 kernel=kernel,                 kernel_radius=radius_bins,                 volume=volume_sim,                 time_step=time_interval,                 random_generator=random_generator,             )         )         # Ensure no negative concentrations (set to zero if less than zero)         particles_i[particles_i &lt; 0] = 0      # Store the updated distribution for the current time step     particles_matrix[i, :] = particles_i <p>Plotting the Final Distribution</p> <p>Finally, we plot the final particle size distribution after multiple coagulation steps. This visualization shows how the particle size distribution evolves over time due to coagulation.</p> In\u00a0[9]: Copied! <pre>filtered = particles_matrix[-1, :]&gt;0\n\nfig, ax = plt.subplots()\nax.hist(\n    particles_original, bins=100, histtype=\"step\", color=\"black\", density=True\n)\nax.hist(\n    particles_matrix[-1, filtered],\n    bins=100,\n    histtype=\"step\",\n    color=\"blue\",\n    density=True,\n)\nax.set_xscale(\"log\")\nax.set_yscale(\"log\")\nax.set_xlabel(\"Particle radius (m)\")\nax.set_ylabel(\"Frequency\")\nplt.show()\n</pre> filtered = particles_matrix[-1, :]&gt;0  fig, ax = plt.subplots() ax.hist(     particles_original, bins=100, histtype=\"step\", color=\"black\", density=True ) ax.hist(     particles_matrix[-1, filtered],     bins=100,     histtype=\"step\",     color=\"blue\",     density=True, ) ax.set_xscale(\"log\") ax.set_yscale(\"log\") ax.set_xlabel(\"Particle radius (m)\") ax.set_ylabel(\"Frequency\") plt.show() In\u00a0[10]: Copied! <pre># plot total number of particles\ntotal_number = np.sum(particles_matrix&gt;0, axis=1)\n\nfig, ax = plt.subplots()\nax.plot(time_array, total_number)\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(\"Number of particles\")\nplt.show()\n</pre> # plot total number of particles total_number = np.sum(particles_matrix&gt;0, axis=1)  fig, ax = plt.subplots() ax.plot(time_array, total_number) ax.set_xlabel(\"Time (s)\") ax.set_ylabel(\"Number of particles\") plt.show() In\u00a0[11]: Copied! <pre># convert to concentration\ntotal_concentration = total_number / volume_sim\n\nfig, ax = plt.subplots()\nax.plot(time_array, total_concentration)\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(r\"Concentration $(m^{-3})$\")\nplt.show()\n</pre> # convert to concentration total_concentration = total_number / volume_sim  fig, ax = plt.subplots() ax.plot(time_array, total_concentration) ax.set_xlabel(\"Time (s)\") ax.set_ylabel(r\"Concentration $(m^{-3})$\") plt.show() In\u00a0[\u00a0]: Copied! <pre>\"\"\"coagulation rewirte\"\"\"\n\nimport numpy as np\n\nfrom particula.next import particles\nfrom particula.next.dynamics import coagulation\nfrom particula.next.dynamics.coagulation import (\n    particle_resolved_method,\n    super_droplet_method,\n)\nfrom scipy.interpolate import RectBivariateSpline\nfrom particula.util.input_handling import convert_units\n\n# %%\n\n\nparticle_radius = particles.properties.lognormal_sample_distribution(\n    mode=np.array([100e-9]),\n    geometric_standard_deviation=np.array([1.3]),\n    number_of_particles=np.array([1]),\n    number_of_samples=100_000,\n)\n\nkernel_radius = np.logspace(-8, -6, 50)\n\n\n# calc mass of particle from density 1000\nmass_particles = 4 / 3 * np.pi * kernel_radius**3 * 1000\nkernel = coagulation.brownian_coagulation_kernel_via_system_state(\n    radius_particle=kernel_radius,\n    mass_particle=mass_particles,\n    temperature=300,\n    pressure=101325,\n)\n# Step 4: Initialize a bivariate spline for interpolating kernel\n# values between bin radii\ninterp_kernel = RectBivariateSpline(x=kernel_radius, y=kernel_radius, z=kernel)\n\nrandom_generator = np.random.default_rng()\n\nvolume = 1 * convert_units(\"cm^3\", \"m^3\")\ntime_step = 100\n# %%\n\ntotal_steps = 100\nprint(f\"total time: {total_steps*time_step:.2f}\")\n\ngain_radius = np.zeros_like(particle_radius, dtype=np.float64)\nloss_radius = np.zeros_like(particle_radius, dtype=np.float64)\nfor time_i in range(total_steps):\n    number_in_bins, bin_indices = super_droplet_method.bin_particles(\n        particle_radius, kernel_radius\n    )\n    # Step 3: Precompute unique bin pairs for efficient coagulation\n    pair_indices = super_droplet_method.get_bin_pairs(bin_indices=bin_indices)\n\n    small_index_total0 = np.array([], dtype=np.int64)\n    large_index_total0 = np.array([], dtype=np.int64)\n\n    # Iterate over each bin pair to calculate potential coagulation events\n    for lower_bin, upper_bin in pair_indices:\n        # get raidius indexes and filter out zeros\n        small_indices = np.flatnonzero(\n            (bin_indices == lower_bin) &amp; (particle_radius &gt; 0)\n        )\n        # filter small indices that are in small indices total\n        small_indices = np.setdiff1d(small_indices, small_index_total0)\n\n        large_indices = np.flatnonzero(\n            (bin_indices == upper_bin) &amp; (particle_radius &gt; 0)\n        )\n        if np.size(small_indices) == 0 or np.size(large_indices) == 0:\n            continue  # Skip to the next bin pair if no particles are present\n        small_count = np.size(small_indices)\n        large_count = np.size(large_indices)\n        # print(f\"small count: {small_count}, large count: {large_count}\")\n\n        # Retrieve the maximum kernel value for the current bin pair\n        kernel_values = interp_kernel.ev(\n            np.min(particle_radius[small_indices]),\n            np.max(particle_radius[large_indices]),\n        )\n        # print(f\"kernel max values: {kernel_values}\")\n\n        # Number of coagulation events\n        if lower_bin == upper_bin:\n            events = small_count * (large_count) / 2\n        events = small_count * large_count\n\n        # events = random_generator.poisson(events)\n        tests = np.ceil(kernel_values * time_step * events / volume).astype(\n            int\n        )\n        # print(f\"events: {events}, tests: {tests}\")\n\n        if tests == 0:\n            continue\n\n        # Randomly select indices of particles involved in the coagulation\n        small_replace = False if small_count &gt; tests else True\n        small_index = random_generator.choice(\n            small_indices, tests, replace=small_replace\n        )\n        large_index = random_generator.choice(large_indices, tests)\n        kernel_value = interp_kernel.ev(\n            particle_radius[small_index], particle_radius[large_index]\n        )\n        # select diagonal\n        if kernel_value.ndim &gt; 1:\n            kernel_value = np.diagonal(kernel_value)\n        # print(f\"kernel value: {kernel_value}\")\n\n        # Determine which coagulation events actually occur based on\n        # interpolated kernel probabilities\n        coagulation_probabilities = (\n            kernel_value * time_step * events / (tests * volume)\n        )\n        # random number\n        r = random_generator.uniform(size=tests)\n        valid_indices = np.flatnonzero(r &lt; coagulation_probabilities)\n        # check if any valid indices are duplicate in small index\n        # error of same small particle going to two different large particles\n        _, unique_index = np.unique(\n            small_index[valid_indices], return_index=True\n        )\n        small_index = small_index[valid_indices][unique_index]\n        large_index = large_index[valid_indices][unique_index]\n\n        # save the coagulation events\n        small_index_total0 = np.append(small_index_total0, small_index)\n        large_index_total0 = np.append(large_index_total0, large_index)\n\n    commons, small_index_in_common, large_index_in_common = np.intersect1d(\n        small_index_total0, large_index_total0, return_indices=True\n    )\n    # sort based on radius\n    radius_argsort = np.argsort(particle_radius[commons])\n    commons = commons[radius_argsort]\n    small_index_in_common = small_index_in_common[radius_argsort]\n    large_index_in_common = large_index_in_common[radius_argsort]\n\n    # remap to largest particle in common\n    for i, common in enumerate(commons):\n        final_value = large_index_total0[small_index_in_common[i]]\n        remap_index = np.flatnonzero(large_index_total0 == common)\n        large_index_total0[remap_index] = final_value\n\n    # update particle radius\n    particle_radius, _, _ = (\n        particle_resolved_method.particle_resolved_update_step(\n            particle_radius=particle_radius,\n            gain=gain_radius,\n            loss=loss_radius,\n            small_index=small_index_total0,\n            large_index=large_index_total0,\n        )\n    )\n\nprint(f\"concenration: {np.sum(number_in_bins) / volume:.4e}\")\n</pre> \"\"\"coagulation rewirte\"\"\"  import numpy as np  from particula.next import particles from particula.next.dynamics import coagulation from particula.next.dynamics.coagulation import (     particle_resolved_method,     super_droplet_method, ) from scipy.interpolate import RectBivariateSpline from particula.util.input_handling import convert_units  # %%   particle_radius = particles.properties.lognormal_sample_distribution(     mode=np.array([100e-9]),     geometric_standard_deviation=np.array([1.3]),     number_of_particles=np.array([1]),     number_of_samples=100_000, )  kernel_radius = np.logspace(-8, -6, 50)   # calc mass of particle from density 1000 mass_particles = 4 / 3 * np.pi * kernel_radius**3 * 1000 kernel = coagulation.brownian_coagulation_kernel_via_system_state(     radius_particle=kernel_radius,     mass_particle=mass_particles,     temperature=300,     pressure=101325, ) # Step 4: Initialize a bivariate spline for interpolating kernel # values between bin radii interp_kernel = RectBivariateSpline(x=kernel_radius, y=kernel_radius, z=kernel)  random_generator = np.random.default_rng()  volume = 1 * convert_units(\"cm^3\", \"m^3\") time_step = 100 # %%  total_steps = 100 print(f\"total time: {total_steps*time_step:.2f}\")  gain_radius = np.zeros_like(particle_radius, dtype=np.float64) loss_radius = np.zeros_like(particle_radius, dtype=np.float64) for time_i in range(total_steps):     number_in_bins, bin_indices = super_droplet_method.bin_particles(         particle_radius, kernel_radius     )     # Step 3: Precompute unique bin pairs for efficient coagulation     pair_indices = super_droplet_method.get_bin_pairs(bin_indices=bin_indices)      small_index_total0 = np.array([], dtype=np.int64)     large_index_total0 = np.array([], dtype=np.int64)      # Iterate over each bin pair to calculate potential coagulation events     for lower_bin, upper_bin in pair_indices:         # get raidius indexes and filter out zeros         small_indices = np.flatnonzero(             (bin_indices == lower_bin) &amp; (particle_radius &gt; 0)         )         # filter small indices that are in small indices total         small_indices = np.setdiff1d(small_indices, small_index_total0)          large_indices = np.flatnonzero(             (bin_indices == upper_bin) &amp; (particle_radius &gt; 0)         )         if np.size(small_indices) == 0 or np.size(large_indices) == 0:             continue  # Skip to the next bin pair if no particles are present         small_count = np.size(small_indices)         large_count = np.size(large_indices)         # print(f\"small count: {small_count}, large count: {large_count}\")          # Retrieve the maximum kernel value for the current bin pair         kernel_values = interp_kernel.ev(             np.min(particle_radius[small_indices]),             np.max(particle_radius[large_indices]),         )         # print(f\"kernel max values: {kernel_values}\")          # Number of coagulation events         if lower_bin == upper_bin:             events = small_count * (large_count) / 2         events = small_count * large_count          # events = random_generator.poisson(events)         tests = np.ceil(kernel_values * time_step * events / volume).astype(             int         )         # print(f\"events: {events}, tests: {tests}\")          if tests == 0:             continue          # Randomly select indices of particles involved in the coagulation         small_replace = False if small_count &gt; tests else True         small_index = random_generator.choice(             small_indices, tests, replace=small_replace         )         large_index = random_generator.choice(large_indices, tests)         kernel_value = interp_kernel.ev(             particle_radius[small_index], particle_radius[large_index]         )         # select diagonal         if kernel_value.ndim &gt; 1:             kernel_value = np.diagonal(kernel_value)         # print(f\"kernel value: {kernel_value}\")          # Determine which coagulation events actually occur based on         # interpolated kernel probabilities         coagulation_probabilities = (             kernel_value * time_step * events / (tests * volume)         )         # random number         r = random_generator.uniform(size=tests)         valid_indices = np.flatnonzero(r &lt; coagulation_probabilities)         # check if any valid indices are duplicate in small index         # error of same small particle going to two different large particles         _, unique_index = np.unique(             small_index[valid_indices], return_index=True         )         small_index = small_index[valid_indices][unique_index]         large_index = large_index[valid_indices][unique_index]          # save the coagulation events         small_index_total0 = np.append(small_index_total0, small_index)         large_index_total0 = np.append(large_index_total0, large_index)      commons, small_index_in_common, large_index_in_common = np.intersect1d(         small_index_total0, large_index_total0, return_indices=True     )     # sort based on radius     radius_argsort = np.argsort(particle_radius[commons])     commons = commons[radius_argsort]     small_index_in_common = small_index_in_common[radius_argsort]     large_index_in_common = large_index_in_common[radius_argsort]      # remap to largest particle in common     for i, common in enumerate(commons):         final_value = large_index_total0[small_index_in_common[i]]         remap_index = np.flatnonzero(large_index_total0 == common)         large_index_total0[remap_index] = final_value      # update particle radius     particle_radius, _, _ = (         particle_resolved_method.particle_resolved_update_step(             particle_radius=particle_radius,             gain=gain_radius,             loss=loss_radius,             small_index=small_index_total0,             large_index=large_index_total0,         )     )  print(f\"concenration: {np.sum(number_in_bins) / volume:.4e}\")"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_4_ParticleResolved/#coagulation-basic-4-particle-resolved","title":"Coagulation Basic 4: Particle Resolved\u00b6","text":"<p>Introduction</p> <p>In aerosol science, understanding particle-particle interactions is crucial for predicting the evolution of particle size distributions. One such interaction is coagulation, where two particles collide and merge into a larger particle. Accurately modeling coagulation at the level of individual particles is known as the particle-resolved method.</p> <p>The particle-resolved method tracks each particle individually, considering its unique properties and interactions. This method provides the most detailed representation of aerosol dynamics, making it ideal for cases where precision is paramount, such as in cloud microphysics or laboratory-scale studies.</p> <p>However, this approach is computationally intensive because it requires simulating every individual particle and its interactions. Unlike the super droplet method, which uses statistical representations to reduce computational load, the direct particle-resolved method does not aggregate particles into larger groups. Instead, every particle is treated independently, ensuring that every interaction is explicitly modeled.</p> <p>This notebook provides a step-by-step guide to simulating coagulation using a pure particle-resolved approach, demonstrating how individual particles evolve over time without any simplifications or approximations in particle grouping.</p> <p>Setup and Imports</p> <p>We'll start by importing the necessary libraries and setting up the environment.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_4_ParticleResolved/#generating-distribution","title":"Generating Distribution\u00b6","text":"<p>In this section, we generate a sample particle size distribution following a lognormal distribution. The lognormal distribution is commonly used in aerosol science to describe particle size distributions.</p> <p>Coagulation Kernel</p> <p>We also calculate the Brownian coagulation kernel for these particles, which quantifies the probability of coagulation between particles of different sizes.</p> <p>Random seed</p> <p>We set a random seed to ensure reproducibility of the results.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_4_ParticleResolved/#coagulation-step","title":"Coagulation Step\u00b6","text":"<p>In the coagulation step, particles collide and merge over a given time step. The super droplet method efficiently simulates this process by adjusting the particle sizes and concentrations based on the calculated kernel and the specified volume and time step.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_4_ParticleResolved/#direct-time-stepping","title":"Direct Time Stepping\u00b6","text":"<p>With the first coagulation step completed, we can now proceed to the next time step. We repeat the coagulation process for the new particle distribution, updating the particle sizes and concentrations accordingly. This iterative approach allows us to simulate the evolution of the particle size distribution over time.</p> <p>Here we use a simple for loop to perform multiple coagulation steps. In practice, more sophisticated time-stepping methods may be used to improve efficiency and accuracy.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_4_ParticleResolved/#conclusion","title":"Conclusion\u00b6","text":"<p>This notebook demonstrated the use of the particle resolved coagulation method to simulate particle coagulation.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_4_ParticleResolved/#to-be-revise-below","title":"To be revise below\u00b6","text":""},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_5_SDM/","title":"Coagulation Basic 5: Super Droplet Method","text":"In\u00a0[22]: Copied! <pre># %% particle resolved coagulation example\nimport numpy as np  # For numerical operations and array manipulations\nimport matplotlib.pyplot as plt  # For plotting graphs and visualizations\n\n# Import specific modules from the particula package\nfrom particula.next.dynamics.coagulation import brownian_kernel\nfrom particula.next.dynamics.coagulation import super_droplet_method\n\nfrom particula.next.particles.properties.lognormal_size_distribution import (\n    lognormal_sample_distribution,\n)\n</pre> # %% particle resolved coagulation example import numpy as np  # For numerical operations and array manipulations import matplotlib.pyplot as plt  # For plotting graphs and visualizations  # Import specific modules from the particula package from particula.next.dynamics.coagulation import brownian_kernel from particula.next.dynamics.coagulation import super_droplet_method  from particula.next.particles.properties.lognormal_size_distribution import (     lognormal_sample_distribution, ) In\u00a0[23]: Copied! <pre># lognormal spacing\n\nradius_bins = np.logspace(\n    -9, -6, num=20\n)  # Define the radius bins for the distribution\nmass_bins = (\n    4 / 3 * np.pi * radius_bins**3 * 1000\n)  # Calculate the mass of the particles in the bins\n\nkernel = brownian_kernel.brownian_coagulation_kernel_via_system_state(\n    radius_particle=radius_bins,\n    mass_particle=mass_bins,\n    temperature=298.15,\n    pressure=101325,\n)  # Calculate the Brownian coagulation kernel for the radius bins\n\nrandom_generator = np.random.default_rng(12345)\n</pre> # lognormal spacing  radius_bins = np.logspace(     -9, -6, num=20 )  # Define the radius bins for the distribution mass_bins = (     4 / 3 * np.pi * radius_bins**3 * 1000 )  # Calculate the mass of the particles in the bins  kernel = brownian_kernel.brownian_coagulation_kernel_via_system_state(     radius_particle=radius_bins,     mass_particle=mass_bins,     temperature=298.15,     pressure=101325, )  # Calculate the Brownian coagulation kernel for the radius bins  random_generator = np.random.default_rng(12345) <p>Sampling the Particle Distribution</p> <p>We then sample particles from the lognormal distribution. These particles will be sorted by size to prepare for the coagulation step.</p> In\u00a0[24]: Copied! <pre># %% sample particle distribution\nparticle_radius = lognormal_sample_distribution(\n    mode=np.array([1e-8, 1e-7]),\n    geometric_standard_deviation=np.array([1.4, 1.4]),\n    number_of_particles=np.array([5000, 1000]),\n    number_of_samples=10000,\n)\nparticle_radius = np.sort(particle_radius)\nparticles_original = particle_radius.copy()\n</pre> # %% sample particle distribution particle_radius = lognormal_sample_distribution(     mode=np.array([1e-8, 1e-7]),     geometric_standard_deviation=np.array([1.4, 1.4]),     number_of_particles=np.array([5000, 1000]),     number_of_samples=10000, ) particle_radius = np.sort(particle_radius) particles_original = particle_radius.copy() In\u00a0[25]: Copied! <pre># %% Coagulation step\n\ndelta_t = 1  # time step in seconds\n\nrandom_concentration = np.random.uniform(1, 10, size=particle_radius.size)\nparticle_concentration = (\n    np.ones_like(particle_radius) * random_concentration * 1e6\n)  # particles per m^3\nparticle_concentration = particle_concentration.astype(np.float64)\nvolume_sim = 1  # m^3\n\nparticle_radius_1, particle_concentration_1 = (\n    super_droplet_method.super_droplet_coagulation_step(\n        particle_radius=particle_radius,\n        particle_concentration=particle_concentration,\n        kernel=kernel,\n        kernel_radius=radius_bins,\n        volume=volume_sim,\n        time_step=delta_t,\n        random_generator=random_generator,\n    )\n)\n\nvolume_final = np.power(particle_radius_1, 3)\nvolume_concentration_final = volume_final * particle_concentration_1\nvolume_total_final = np.sum(volume_concentration_final)\n\nprint(f\"Final volume: {volume_total_final}\")\nprint(f\"Final number of particles: {np.sum(particle_concentration_1)}\")\n</pre> # %% Coagulation step  delta_t = 1  # time step in seconds  random_concentration = np.random.uniform(1, 10, size=particle_radius.size) particle_concentration = (     np.ones_like(particle_radius) * random_concentration * 1e6 )  # particles per m^3 particle_concentration = particle_concentration.astype(np.float64) volume_sim = 1  # m^3  particle_radius_1, particle_concentration_1 = (     super_droplet_method.super_droplet_coagulation_step(         particle_radius=particle_radius,         particle_concentration=particle_concentration,         kernel=kernel,         kernel_radius=radius_bins,         volume=volume_sim,         time_step=delta_t,         random_generator=random_generator,     ) )  volume_final = np.power(particle_radius_1, 3) volume_concentration_final = volume_final * particle_concentration_1 volume_total_final = np.sum(volume_concentration_final)  print(f\"Final volume: {volume_total_final}\") print(f\"Final number of particles: {np.sum(particle_concentration_1)}\") <pre>Final volume: 1.6866138333522715e-11\nFinal number of particles: 39420946809.99734\n</pre> <p>Plotting the New Distribution</p> <p>Finally, we plot the particle size distribution before and after coagulation. This visualization helps us understand the effect of the coagulation process on the particle size distribution.</p> <p>The histogram bins are weighted by the number of particles in each bin to reflect the super droplet method's representation of real particles.</p> In\u00a0[26]: Copied! <pre># %% plot new distribution\nfig, ax = plt.subplots()\nax.hist(\n    particles_original,\n    weights=particle_concentration,\n    bins=100, histtype=\"step\", color=\"black\", density=True\n)\nax.hist(\n    particle_radius,\n    weights=particle_concentration_1,\n    bins=100, histtype=\"step\", color=\"blue\", density=True\n)\nax.set_xscale(\"log\")\nax.set_yscale(\"log\")\nax.set_xlabel(\"Particle radius (m)\")\nax.set_ylabel(\"Frequency\")\nplt.show()\n</pre> # %% plot new distribution fig, ax = plt.subplots() ax.hist(     particles_original,     weights=particle_concentration,     bins=100, histtype=\"step\", color=\"black\", density=True ) ax.hist(     particle_radius,     weights=particle_concentration_1,     bins=100, histtype=\"step\", color=\"blue\", density=True ) ax.set_xscale(\"log\") ax.set_yscale(\"log\") ax.set_xlabel(\"Particle radius (m)\") ax.set_ylabel(\"Frequency\") plt.show() In\u00a0[27]: Copied! <pre># Initial distribution for the simulation\nparticles_i = particle_radius\n\nparticle_concentration_i = particle_concentration\n\n# Define the time array for the simulation\ntime_array = np.linspace(\n    start=0, stop=1000, num=100\n)  # Time span of 1000 seconds\ntime_interval = (\n    time_array[1] - time_array[0]\n)  # Time interval between each step\n\n# Array to store the distribution at each time step\nparticles_matrix = np.zeros([len(time_array), len(particles_i)])\nconcentration_matrix = np.zeros([len(time_array), len(particles_i)])\n\nparticles_matrix[0, :] = particles_i\nconcentration_matrix[0, :] = particle_concentration_i\n# Simulate the coagulation process over time\nfor i, dpa in enumerate(time_array):\n    if i &gt; 0:\n\n        particles_i, particle_concentration_i = (\n            super_droplet_method.super_droplet_coagulation_step(\n                particle_radius=particles_i,\n                particle_concentration=particle_concentration_i,\n                kernel=kernel,\n                kernel_radius=radius_bins,\n                volume=volume_sim,\n                time_step=time_interval,\n                random_generator=random_generator,\n            )\n        )\n        # Ensure no negative concentrations (set to zero if less than zero)\n        particles_i[particles_i &lt; 0] = 0\n\n    # Store the updated distribution for the current time step\n    particles_matrix[i, :] = particles_i\n    concentration_matrix[i, :] = particle_concentration_i\n</pre> # Initial distribution for the simulation particles_i = particle_radius  particle_concentration_i = particle_concentration  # Define the time array for the simulation time_array = np.linspace(     start=0, stop=1000, num=100 )  # Time span of 1000 seconds time_interval = (     time_array[1] - time_array[0] )  # Time interval between each step  # Array to store the distribution at each time step particles_matrix = np.zeros([len(time_array), len(particles_i)]) concentration_matrix = np.zeros([len(time_array), len(particles_i)])  particles_matrix[0, :] = particles_i concentration_matrix[0, :] = particle_concentration_i # Simulate the coagulation process over time for i, dpa in enumerate(time_array):     if i &gt; 0:          particles_i, particle_concentration_i = (             super_droplet_method.super_droplet_coagulation_step(                 particle_radius=particles_i,                 particle_concentration=particle_concentration_i,                 kernel=kernel,                 kernel_radius=radius_bins,                 volume=volume_sim,                 time_step=time_interval,                 random_generator=random_generator,             )         )         # Ensure no negative concentrations (set to zero if less than zero)         particles_i[particles_i &lt; 0] = 0      # Store the updated distribution for the current time step     particles_matrix[i, :] = particles_i     concentration_matrix[i, :] = particle_concentration_i <p>Plotting the Final Distribution</p> <p>Finally, we plot the particle size distribution at the end of the simulation. This visualization provides insights into how the particle size distribution evolves over time due to coagulation.</p> In\u00a0[28]: Copied! <pre>fig, ax = plt.subplots()\nax.hist(\n    particles_original,\n    weights=particle_concentration,\n    bins=100,\n    histtype=\"step\",\n    color=\"black\",\n    density=True,\n)\nax.hist(\n    particles_matrix[-1, :],\n    weights=concentration_matrix[-1, :],\n    bins=100,\n    histtype=\"step\",\n    color=\"blue\",\n    density=True,\n)\nax.set_xscale(\"log\")\nax.set_yscale(\"log\")\nax.set_xlabel(\"Particle radius (m)\")\nax.set_ylabel(\"Frequency\")\nplt.show()\n</pre> fig, ax = plt.subplots() ax.hist(     particles_original,     weights=particle_concentration,     bins=100,     histtype=\"step\",     color=\"black\",     density=True, ) ax.hist(     particles_matrix[-1, :],     weights=concentration_matrix[-1, :],     bins=100,     histtype=\"step\",     color=\"blue\",     density=True, ) ax.set_xscale(\"log\") ax.set_yscale(\"log\") ax.set_xlabel(\"Particle radius (m)\") ax.set_ylabel(\"Frequency\") plt.show() In\u00a0[29]: Copied! <pre># total number of particles\ntotal_concentration = np.sum(concentration_matrix, axis=1)\n\nfig, ax = plt.subplots()\nax.plot(time_array, total_concentration)\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(r\"Concentration (m$^{-3}$)\")\nplt.show()\n</pre> # total number of particles total_concentration = np.sum(concentration_matrix, axis=1)  fig, ax = plt.subplots() ax.plot(time_array, total_concentration) ax.set_xlabel(\"Time (s)\") ax.set_ylabel(r\"Concentration (m$^{-3}$)\") plt.show()"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_5_SDM/#coagulation-basic-5-super-droplet-method","title":"Coagulation Basic 5: Super Droplet Method\u00b6","text":"<p>BETA VERSION</p> <p>*It seems like the underlying SDM method is wrong**</p> <p>Introduction</p> <p>In aerosol science, understanding particle-particle interactions is crucial for predicting the evolution of particle size distributions. One such interaction is coagulation, where two particles collide and merge into a larger particle. Modeling coagulation accurately can be computationally expensive, especially when tracking individual particles.</p> <p>The super droplet method is a technique that allows for the efficient simulation of coagulation in a computationally feasible manner. It represents a large number of real particles with a smaller number of computational particles (super droplets), each carrying a statistical weight that reflects the number of real particles it represents.</p> <p>This notebook provides a step-by-step guide to simulating coagulation using the super droplet method with a particle-resolved approach.</p> <p>Setup and Imports</p> <p>We'll start by importing the necessary libraries and setting up the environment.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_5_SDM/#generating-distribution","title":"Generating Distribution\u00b6","text":"<p>In this section, we generate a sample particle size distribution following a lognormal distribution. The lognormal distribution is commonly used in aerosol science to describe particle size distributions.</p> <p>Coagulation Kernel</p> <p>We also calculate the Brownian coagulation kernel for these particles, which quantifies the probability of coagulation between particles of different sizes.</p> <p>Random seed</p> <p>We set a random seed to ensure reproducibility of the results.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_5_SDM/#coagulation-step","title":"Coagulation Step\u00b6","text":"<p>In the coagulation step, particles collide and merge over a given time step. The super droplet method efficiently simulates this process by adjusting the particle sizes and concentrations based on the calculated kernel and the specified volume and time step.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_5_SDM/#direct-time-stepping","title":"Direct Time Stepping\u00b6","text":"<p>With the first coagulation step completed, we can now proceed to the next time step. We repeat the coagulation process for the new particle distribution, updating the particle sizes and concentrations accordingly. This iterative approach allows us to simulate the evolution of the particle size distribution over time.</p> <p>Here we use a simple for loop to perform multiple coagulation steps. In practice, more sophisticated time-stepping methods may be used to improve efficiency and accuracy.</p>"},{"location":"Tutorials/Dynamics/Coagulation/Functional/Coagulation_Basic_5_SDM/#conclusion","title":"Conclusion\u00b6","text":"<p>This notebook demonstrated the use of the super droplet method to simulate particle coagulation in a computationally efficient manner. By representing multiple real particles with fewer computational particles, we can model complex aerosol dynamics over time without the need for excessive computational resources.</p> <p>Seems like it is over estimating the coagulation rate. Need to follow-up</p>"},{"location":"Tutorials/Dynamics/Condensation/Condensation_1_Bin/","title":"Condensation Tutorial: Radius Bin","text":"In\u00a0[18]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# particula imports\nfrom particula.next import particles\nfrom particula.next.gas.atmosphere_builders import AtmosphereBuilder\nfrom particula.next.gas.vapor_pressure_factories import VaporPressureFactory\nfrom particula.next.gas.species_builders import GasSpeciesBuilder\nfrom particula.next.aerosol import Aerosol\nfrom particula.next.dynamics.particle_process import MassCondensation\nfrom particula.next.dynamics.condensation.condensation_strategies import CondensationIsothermal\n</pre> import numpy as np import matplotlib.pyplot as plt  # particula imports from particula.next import particles from particula.next.gas.atmosphere_builders import AtmosphereBuilder from particula.next.gas.vapor_pressure_factories import VaporPressureFactory from particula.next.gas.species_builders import GasSpeciesBuilder from particula.next.aerosol import Aerosol from particula.next.dynamics.particle_process import MassCondensation from particula.next.dynamics.condensation.condensation_strategies import CondensationIsothermal In\u00a0[19]: Copied! <pre># Glycerol gas\nmolar_mass_glycerol = 92.09382e-3  # kg/mol\nparameters_clausius = {\n    \"latent_heat\": 71.5 * molar_mass_glycerol,\n    \"latent_heat_units\": \"kJ/kg\",\n    \"temperature_initial\": 125.5,\n    \"temperature_initial_units\": \"degC\",\n    \"pressure_initial\": 1,\n    \"pressure_initial_units\": \"mmHg\",\n}\nvapor_pressure_strategy = VaporPressureFactory().get_strategy(\n    \"clausius_clapeyron\", parameters_clausius\n)\n\nsat_concentration = vapor_pressure_strategy.saturation_concentration(\n    molar_mass_glycerol, 298.15\n)\nprint(f\"Saturation concentration: {sat_concentration:.2e} kg/m^3\")\n\nsat_factor = 0.01  # 50% of saturation concentration\nglycerol_gas = (\n    GasSpeciesBuilder()\n    .set_molar_mass(molar_mass_glycerol, \"kg/mol\")\n    .set_vapor_pressure_strategy(vapor_pressure_strategy)\n    .set_concentration(sat_concentration * sat_factor, \"kg/m^3\")\n    .set_name(\"Glycerol\")\n    .set_condensable(True)\n    .build()\n)\n\natmosphere = (\n    AtmosphereBuilder()\n    .add_species(glycerol_gas)\n    .set_temperature(25, temperature_units=\"degC\")\n    .set_pressure(1, pressure_units=\"atm\")\n    .build()\n)\n\n# Glycerol particle distribution\nbins = np.logspace(-8, -5, 500)\nlognormal_rep = (\n    particles.PresetParticleRadiusBuilder()\n    .set_mode(np.array([100]), \"nm\")\n    .set_geometric_standard_deviation(np.array([1.3]))\n    .set_number_concentration(np.array([1e4]), \"1/cm^3\")\n    .set_density(1.26, \"g/cm^3\")\n    .set_distribution_type(\"pmf\")\n    .set_radius_bins(bins, \"m\")\n    .build()\n)\n\naerosol = Aerosol(atmosphere=atmosphere, particles=lognormal_rep)\n\nprint(aerosol)\n</pre> # Glycerol gas molar_mass_glycerol = 92.09382e-3  # kg/mol parameters_clausius = {     \"latent_heat\": 71.5 * molar_mass_glycerol,     \"latent_heat_units\": \"kJ/kg\",     \"temperature_initial\": 125.5,     \"temperature_initial_units\": \"degC\",     \"pressure_initial\": 1,     \"pressure_initial_units\": \"mmHg\", } vapor_pressure_strategy = VaporPressureFactory().get_strategy(     \"clausius_clapeyron\", parameters_clausius )  sat_concentration = vapor_pressure_strategy.saturation_concentration(     molar_mass_glycerol, 298.15 ) print(f\"Saturation concentration: {sat_concentration:.2e} kg/m^3\")  sat_factor = 0.01  # 50% of saturation concentration glycerol_gas = (     GasSpeciesBuilder()     .set_molar_mass(molar_mass_glycerol, \"kg/mol\")     .set_vapor_pressure_strategy(vapor_pressure_strategy)     .set_concentration(sat_concentration * sat_factor, \"kg/m^3\")     .set_name(\"Glycerol\")     .set_condensable(True)     .build() )  atmosphere = (     AtmosphereBuilder()     .add_species(glycerol_gas)     .set_temperature(25, temperature_units=\"degC\")     .set_pressure(1, pressure_units=\"atm\")     .build() )  # Glycerol particle distribution bins = np.logspace(-8, -5, 500) lognormal_rep = (     particles.PresetParticleRadiusBuilder()     .set_mode(np.array([100]), \"nm\")     .set_geometric_standard_deviation(np.array([1.3]))     .set_number_concentration(np.array([1e4]), \"1/cm^3\")     .set_density(1.26, \"g/cm^3\")     .set_distribution_type(\"pmf\")     .set_radius_bins(bins, \"m\")     .build() )  aerosol = Aerosol(atmosphere=atmosphere, particles=lognormal_rep)  print(aerosol) <pre>Saturation concentration: 2.54e-03 kg/m^3\nGas mixture at 298.15 K and 101325.0 Pa consisting of ['Glycerol']\n[0]: Particle Representation:\n\tStrategy: RadiiBasedMovingBin\n\tActivity: ActivityIdealMass\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 7.194e-08 [kg/m^3]\n\tNumber Concentration: 1.000e+10 [#/m^3]\n</pre> In\u00a0[20]: Copied! <pre># define the condensation process\ncondensation_isothermal = CondensationIsothermal(\n    molar_mass=molar_mass_glycerol,\n    diffusion_coefficient=2e-5,\n    accommodation_coefficient=0.1,  #makes things go slower/faster\n)\ncondensation_process = MassCondensation(condensation_strategy=condensation_isothermal)\n\n# define the time array in seconds\ntime_step = 0.5\ntime_array = np.arange(0, 10, time_step)\ntotal_mass = np.zeros_like(time_array)\n\n# output arrays\naerosol_sim = []\n\nrate = condensation_process.rate(aerosol)\n\n# print(f\"Inital rate: {rate[:5]}...\")\n# print(f\"Initial rate shape: {rate.shape}\")\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.semilogx(aerosol.particles[0].get_radius()*1e9, aerosol.particles[0].concentration, label=\"Initial\")\n# singe step\naerosol = condensation_process.execute(aerosol, time_step)\nax.semilogx(aerosol.particles[0].get_radius()*1e9, aerosol.particles[0].concentration, label=\"After 1 step\")\n# second step\naerosol = condensation_process.execute(aerosol, time_step)\nax.semilogx(aerosol.particles[0].get_radius()*1e9, aerosol.particles[0].concentration, label=\"After 2 steps\")\n# 5th step\naerosol = condensation_process.execute(aerosol, time_step)\naerosol = condensation_process.execute(aerosol, time_step)\naerosol = condensation_process.execute(aerosol, time_step)\nax.semilogx(aerosol.particles[0].get_radius()*1e9, aerosol.particles[0].concentration, label=\"After 5 steps\")\nplt.legend()\nax.set_xlabel(\"Radius (nm)\")\nax.set_ylabel(\"Concentration (1/m^3)\")\nplt.show()\n</pre> # define the condensation process condensation_isothermal = CondensationIsothermal(     molar_mass=molar_mass_glycerol,     diffusion_coefficient=2e-5,     accommodation_coefficient=0.1,  #makes things go slower/faster ) condensation_process = MassCondensation(condensation_strategy=condensation_isothermal)  # define the time array in seconds time_step = 0.5 time_array = np.arange(0, 10, time_step) total_mass = np.zeros_like(time_array)  # output arrays aerosol_sim = []  rate = condensation_process.rate(aerosol)  # print(f\"Inital rate: {rate[:5]}...\") # print(f\"Initial rate shape: {rate.shape}\")  fig, ax = plt.subplots(figsize=(8, 6)) ax.semilogx(aerosol.particles[0].get_radius()*1e9, aerosol.particles[0].concentration, label=\"Initial\") # singe step aerosol = condensation_process.execute(aerosol, time_step) ax.semilogx(aerosol.particles[0].get_radius()*1e9, aerosol.particles[0].concentration, label=\"After 1 step\") # second step aerosol = condensation_process.execute(aerosol, time_step) ax.semilogx(aerosol.particles[0].get_radius()*1e9, aerosol.particles[0].concentration, label=\"After 2 steps\") # 5th step aerosol = condensation_process.execute(aerosol, time_step) aerosol = condensation_process.execute(aerosol, time_step) aerosol = condensation_process.execute(aerosol, time_step) ax.semilogx(aerosol.particles[0].get_radius()*1e9, aerosol.particles[0].concentration, label=\"After 5 steps\") plt.legend() ax.set_xlabel(\"Radius (nm)\") ax.set_ylabel(\"Concentration (1/m^3)\") plt.show()"},{"location":"Tutorials/Dynamics/Condensation/Condensation_1_Bin/#condensation-tutorial-radius-bin","title":"Condensation Tutorial: Radius Bin\u00b6","text":"<p>Work in progress, probably split into multiple notebooks, need to find a model system to test this on</p> <p>Condensation, is the first process where this framework we have been building up is applied. Here we need to account for the gas phase, and the particle phase. Then ensure that the partial pressures of species at the surface of the particle are equal to the partial pressure in the gas.</p> <p>Core Concepts:</p> <ul> <li>Runnable: An abstract base class defining the interface for aerosol transformation processes.<ul> <li>Here and aerosol object is passed to the process, and the process is expected to modify the aerosol object in place, returning the modified object.</li> </ul> </li> <li>MassCondensation: A concrete class implementing the RunnableProcess interface for the condensation process. Is an implementation of a <code>Runnable</code> process that adds mass to the aerosol object based on the partial pressures of the gas phase and the particle phase. Then removes the mass from the gas phase.</li> </ul>"},{"location":"Tutorials/Dynamics/Condensation/Condensation_1_Bin/#setup-aerosol","title":"Setup Aerosol\u00b6","text":"<p>First we will repeat the aerosol object that we have been using in the previous notebooks. This object will be passed to the <code>Runnable</code> processes <code>MassCondensation</code>, and modified in place.</p>"},{"location":"Tutorials/Dynamics/Condensation/Condensation_1_Bin/#condensation-process-isothermal","title":"Condensation Process (Isothermal)\u00b6","text":"<p>In code this process is implemented as a <code>Runnable</code> process. This means that the process is expected to modify the aerosol object in place, returning the modified aerosol object. This is defined in <code>Particle_processes.py</code> as the <code>MassCondensation</code> class.</p> <p>The <code>MassCondensation</code> class takes a <code>CondensationStrategy</code> object as an input. This object defines and evaluates the $dm_{i}/dt$ equation for the condensation process. More strategies can be added into the <code>condensation.py</code> file.</p> <p>For now, let's just run it for a few time steps and see what happens.</p> <p>Note: We have a moving bin particle representation, so we would expect all the bins to move.</p>"},{"location":"Tutorials/Dynamics/Condensation/Condensation_1_Bin/#summary","title":"Summary\u00b6","text":"<p>We built out the condensation process, and the equations that define the process. We also defined the inputs and outputs of the process. Next we will build out coagulation and nucleation processes, to complete the aerosol dynamics framework.</p>"},{"location":"Tutorials/Dynamics/Condensation/Condensation_2_MassBin/","title":"Condensation Tutorial: Mass Binned","text":"In\u00a0[11]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# particula imports\nfrom particula.next import particles\nfrom particula.next.gas.atmosphere_builders import AtmosphereBuilder\nfrom particula.next.gas.vapor_pressure_factories import VaporPressureFactory\nfrom particula.next.gas.species_builders import GasSpeciesBuilder\nfrom particula.next.aerosol import Aerosol\nfrom particula.next.dynamics.particle_process import MassCondensation\nfrom particula.next.dynamics.condensation.condensation_strategies import CondensationIsothermal\n</pre> import numpy as np import matplotlib.pyplot as plt  # particula imports from particula.next import particles from particula.next.gas.atmosphere_builders import AtmosphereBuilder from particula.next.gas.vapor_pressure_factories import VaporPressureFactory from particula.next.gas.species_builders import GasSpeciesBuilder from particula.next.aerosol import Aerosol from particula.next.dynamics.particle_process import MassCondensation from particula.next.dynamics.condensation.condensation_strategies import CondensationIsothermal In\u00a0[12]: Copied! <pre># Ammonium sulfate and water vapor pressure\nmolar_mass_ammonium_sulfate = 132.14e-3  # kg/mol\nmolar_mass_water = 18.015e-3  # kg/mol\nparameters_vapor = {\n    \"vapor_pressure\": 1e-20,\n}\nvapor_pressure_ammonium = VaporPressureFactory().get_strategy(\n    \"constant\", parameters_vapor\n)\nvapor_pressure_water = VaporPressureFactory().get_strategy(\n    \"water_buck\"\n)\n\nwater_sat = vapor_pressure_water.saturation_concentration(molar_mass=molar_mass_water, temperature=298.15)\nwater_concentration = 0.8 * water_sat\n\nglycerol_gas = (\n    GasSpeciesBuilder()\n    .set_molar_mass(np.array([molar_mass_water, molar_mass_ammonium_sulfate]), \"kg/mol\")\n    .set_vapor_pressure_strategy([vapor_pressure_water, vapor_pressure_ammonium])\n    .set_concentration(np.array([water_concentration, 0.0]), \"kg/m^3\")\n    .set_name([\"H2O\", \"NH4HSO4\"])\n    .set_condensable([True, True])\n    .build()\n)\n\natmosphere = (\n    AtmosphereBuilder()\n    .add_species(glycerol_gas)\n    .set_temperature(25, temperature_units=\"degC\")\n    .set_pressure(1, pressure_units=\"atm\")\n    .build()\n)\n</pre> # Ammonium sulfate and water vapor pressure molar_mass_ammonium_sulfate = 132.14e-3  # kg/mol molar_mass_water = 18.015e-3  # kg/mol parameters_vapor = {     \"vapor_pressure\": 1e-20, } vapor_pressure_ammonium = VaporPressureFactory().get_strategy(     \"constant\", parameters_vapor ) vapor_pressure_water = VaporPressureFactory().get_strategy(     \"water_buck\" )  water_sat = vapor_pressure_water.saturation_concentration(molar_mass=molar_mass_water, temperature=298.15) water_concentration = 0.8 * water_sat  glycerol_gas = (     GasSpeciesBuilder()     .set_molar_mass(np.array([molar_mass_water, molar_mass_ammonium_sulfate]), \"kg/mol\")     .set_vapor_pressure_strategy([vapor_pressure_water, vapor_pressure_ammonium])     .set_concentration(np.array([water_concentration, 0.0]), \"kg/m^3\")     .set_name([\"H2O\", \"NH4HSO4\"])     .set_condensable([True, True])     .build() )  atmosphere = (     AtmosphereBuilder()     .add_species(glycerol_gas)     .set_temperature(25, temperature_units=\"degC\")     .set_pressure(1, pressure_units=\"atm\")     .build() )    <p>Sample Distribution</p> <p>Next we'll sample the distribution to get a set of particles. We'll then build an aerosol object to represent the aerosol population.</p> In\u00a0[13]: Copied! <pre># sample\nparticles_sample = particles.properties.lognormal_sample_distribution(\n    mode=np.array([100, 1000])*1e-9,\n    geometric_standard_deviation=np.array([1.3, 1.5]),\n    number_of_particles=np.array([1e3, 1e2]),\n    number_of_samples=1000,\n)\n\n# histogram lognormal\nbins_lognormal = np.logspace(-8, -4, 100)\nbins, edges = np.histogram(particles_sample, bins=bins_lognormal, density=True)\n# plot\nfig, ax = plt.subplots(figsize=(8, 6))\nax.bar(edges[:-1], bins, width=np.diff(edges), align=\"edge\")\nax.set_xscale(\"log\")\nax.set_xlabel(\"Diameter (m)\")\nax.set_ylabel(\"Count\")\nplt.show()\n</pre> # sample particles_sample = particles.properties.lognormal_sample_distribution(     mode=np.array([100, 1000])*1e-9,     geometric_standard_deviation=np.array([1.3, 1.5]),     number_of_particles=np.array([1e3, 1e2]),     number_of_samples=1000, )  # histogram lognormal bins_lognormal = np.logspace(-8, -4, 100) bins, edges = np.histogram(particles_sample, bins=bins_lognormal, density=True) # plot fig, ax = plt.subplots(figsize=(8, 6)) ax.bar(edges[:-1], bins, width=np.diff(edges), align=\"edge\") ax.set_xscale(\"log\") ax.set_xlabel(\"Diameter (m)\") ax.set_ylabel(\"Count\") plt.show() In\u00a0[14]: Copied! <pre># particle radis to mass\ndensity = 1.26e3  # kg/m^3\nparticle_mass = density * 4 / 3 * np.pi * particles_sample ** 3\nmass_speciation = np.array([particle_mass*0, particle_mass]).T  # water, ammonium sulfate\nconcentration = np.ones_like(particles_sample) * 1e1\ndensities = np.array([1000, 1.26e3])  # kg/m^3\n\nprint(mass_speciation.shape)\n\nactivity_strat = (\n    particles.ActivityKappaParameterBuilder()\n    .set_density(densities)\n    .set_kappa(np.array([0.0, 0.61]))\n    .set_molar_mass(np.array([molar_mass_water, molar_mass_ammonium_sulfate]))\n    .set_water_index(0)\n    .build()\n)\n\nsurface_strat = (\n    particles.SurfaceStrategyVolumeBuilder()\n    .set_density(densities)\n    .set_surface_tension(np.array([0.072, 0.092]))\n    .build()\n)\n\nparitcle_rep = (\n    particles.ParticleMassRepresentationBuilder()\n    .set_distribution_strategy(particles.SpeciatedMassMovingBinBuilder().build())\n    .set_surface_strategy(surface_strat)\n    .set_activity_strategy(activity_strat)\n    .set_density(densities)\n    .set_charge(0.0)\n    .set_mass(mass_speciation)\n    .set_concentration(concentration, \"1/cm^3\")\n    .build()\n)\n\naerosol = Aerosol(atmosphere=atmosphere, particles=paritcle_rep)\n\nprint(aerosol)\n</pre> # particle radis to mass density = 1.26e3  # kg/m^3 particle_mass = density * 4 / 3 * np.pi * particles_sample ** 3 mass_speciation = np.array([particle_mass*0, particle_mass]).T  # water, ammonium sulfate concentration = np.ones_like(particles_sample) * 1e1 densities = np.array([1000, 1.26e3])  # kg/m^3  print(mass_speciation.shape)  activity_strat = (     particles.ActivityKappaParameterBuilder()     .set_density(densities)     .set_kappa(np.array([0.0, 0.61]))     .set_molar_mass(np.array([molar_mass_water, molar_mass_ammonium_sulfate]))     .set_water_index(0)     .build() )  surface_strat = (     particles.SurfaceStrategyVolumeBuilder()     .set_density(densities)     .set_surface_tension(np.array([0.072, 0.092]))     .build() )  paritcle_rep = (     particles.ParticleMassRepresentationBuilder()     .set_distribution_strategy(particles.SpeciatedMassMovingBinBuilder().build())     .set_surface_strategy(surface_strat)     .set_activity_strategy(activity_strat)     .set_density(densities)     .set_charge(0.0)     .set_mass(mass_speciation)     .set_concentration(concentration, \"1/cm^3\")     .build() )  aerosol = Aerosol(atmosphere=atmosphere, particles=paritcle_rep)  print(aerosol) <pre>(1000, 2)\nGas mixture at 298.15 K and 101325.0 Pa consisting of [\"['H2O', 'NH4HSO4']\"]\n[0]: Particle Representation:\n\tStrategy: SpeciatedMassMovingBin\n\tActivity: ActivityKappaParameter\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 1.482e-05 [kg/m^3]\n\tNumber Concentration: 1.000e+10 [#/m^3]\n</pre> In\u00a0[15]: Copied! <pre># define the condensation process\ncondensation_isothermal = CondensationIsothermal(\n    molar_mass=np.array([molar_mass_water, molar_mass_ammonium_sulfate]),  # kg/mol\n    accommodation_coefficient=0.1,  #makes things go slower/faster\n    update_gases=False,\n)\ncondensation_process = MassCondensation(condensation_strategy=condensation_isothermal)\n\n# define the time array in seconds\ntime_step = 11\nsub_steps = 10000\ntime_array = np.arange(0, 5, time_step)\ntotal_mass = np.zeros_like(time_array)\n\n# output arrays\naerosol_sim = []\n\n\nfig, ax = plt.subplots(figsize=(8, 6))\nbins, edges = np.histogram(\n    aerosol.particles[0].get_radius(), bins=bins_lognormal\n)\nax.bar(edges[:-1], bins, width=np.diff(edges), align=\"edge\", label=\"Initial\")\n\nprint(aerosol)\n# one step\naerosol = condensation_process.execute(aerosol, time_step, sub_steps)\nbins, edges = np.histogram(\n    aerosol.particles[0].get_radius(), bins=bins_lognormal\n)\nax.bar(edges[:-1], bins, width=np.diff(edges), align=\"edge\", label=\"After 1 step\", alpha=0.8)\n\nprint(aerosol)\n# 10 seconds\naerosol = condensation_process.execute(aerosol, time_step, sub_steps)\nbins, edges = np.histogram(\n    aerosol.particles[0].get_radius(), bins=bins_lognormal\n)\nax.bar(edges[:-1], bins, width=np.diff(edges), align=\"edge\", label=\"After 2 steps\", alpha=0.7)\nprint(aerosol)\n\nax.set_xscale(\"log\")\n# ax.set_yscale(\"log\")\nplt.legend()\nax.set_xlabel(\"Radius (m)\")\nax.set_ylabel(\"Concentration (1/m^3)\")\nplt.show()\n</pre> # define the condensation process condensation_isothermal = CondensationIsothermal(     molar_mass=np.array([molar_mass_water, molar_mass_ammonium_sulfate]),  # kg/mol     accommodation_coefficient=0.1,  #makes things go slower/faster     update_gases=False, ) condensation_process = MassCondensation(condensation_strategy=condensation_isothermal)  # define the time array in seconds time_step = 11 sub_steps = 10000 time_array = np.arange(0, 5, time_step) total_mass = np.zeros_like(time_array)  # output arrays aerosol_sim = []   fig, ax = plt.subplots(figsize=(8, 6)) bins, edges = np.histogram(     aerosol.particles[0].get_radius(), bins=bins_lognormal ) ax.bar(edges[:-1], bins, width=np.diff(edges), align=\"edge\", label=\"Initial\")  print(aerosol) # one step aerosol = condensation_process.execute(aerosol, time_step, sub_steps) bins, edges = np.histogram(     aerosol.particles[0].get_radius(), bins=bins_lognormal ) ax.bar(edges[:-1], bins, width=np.diff(edges), align=\"edge\", label=\"After 1 step\", alpha=0.8)  print(aerosol) # 10 seconds aerosol = condensation_process.execute(aerosol, time_step, sub_steps) bins, edges = np.histogram(     aerosol.particles[0].get_radius(), bins=bins_lognormal ) ax.bar(edges[:-1], bins, width=np.diff(edges), align=\"edge\", label=\"After 2 steps\", alpha=0.7) print(aerosol)  ax.set_xscale(\"log\") # ax.set_yscale(\"log\") plt.legend() ax.set_xlabel(\"Radius (m)\") ax.set_ylabel(\"Concentration (1/m^3)\") plt.show() <pre>Gas mixture at 298.15 K and 101325.0 Pa consisting of [\"['H2O', 'NH4HSO4']\"]\n[0]: Particle Representation:\n\tStrategy: SpeciatedMassMovingBin\n\tActivity: ActivityKappaParameter\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 1.482e-05 [kg/m^3]\n\tNumber Concentration: 1.000e+10 [#/m^3]\nGas mixture at 298.15 K and 101325.0 Pa consisting of [\"['H2O', 'NH4HSO4']\"]\n[0]: Particle Representation:\n\tStrategy: SpeciatedMassMovingBin\n\tActivity: ActivityKappaParameter\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 4.344e-05 [kg/m^3]\n\tNumber Concentration: 1.000e+10 [#/m^3]\nGas mixture at 298.15 K and 101325.0 Pa consisting of [\"['H2O', 'NH4HSO4']\"]\n[0]: Particle Representation:\n\tStrategy: SpeciatedMassMovingBin\n\tActivity: ActivityKappaParameter\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 4.344e-05 [kg/m^3]\n\tNumber Concentration: 1.000e+10 [#/m^3]\n</pre>"},{"location":"Tutorials/Dynamics/Condensation/Condensation_2_MassBin/#condensation-tutorial-mass-binned","title":"Condensation Tutorial: Mass Binned\u00b6","text":"<p>NEEDS REVISION: integration unstable</p> <p>A mass binned model is relaxes the assumption of a single composition for all particles in a given bin. Instead, it allows for a distribution of compositions within each bin. This is useful when the composition of particles is separated by masses. This does not account for the same sized particles having different compositions, but rather different sized particles having different compositions.</p>"},{"location":"Tutorials/Dynamics/Condensation/Condensation_2_MassBin/#aerosol-setup","title":"Aerosol Setup\u00b6","text":"<p>First we'll draw from a lognormal distribution to create a set of particles. We'll will then build an aerosol object to represent the aerosol population.</p>"},{"location":"Tutorials/Dynamics/Condensation/Condensation_2_MassBin/#condensation-process","title":"Condensation Process\u00b6","text":"<p>Using the same iso thermal condensation process as in the bulk model, we'll update the properties of the particles in the aerosol object. In this cas we will change the water saturation ratio to be 80% and simulate the condensation process.</p>"},{"location":"Tutorials/Dynamics/Condensation/Condensation_2_MassBin/#small-particles-grow-faster","title":"Small Particles Grow Faster\u00b6","text":"<p>We can see from the previous example that the smaller particles grow faster than the larger particles. This is because the smaller particles have a higher surface area to volume ratio, which means they can take up more water.</p> <p>However, that</p>"},{"location":"Tutorials/Dynamics/Condensation/Condensation_2_MassBin/#summary","title":"Summary\u00b6","text":"<p>We built out the condensation process, and the equations that define the process. We also defined the inputs and outputs of the process. Next we will build out coagulation and nucleation processes, to complete the aerosol dynamics framework.</p>"},{"location":"Tutorials/Dynamics/Condensation/Condensation_3_MassResolved/","title":"Condensation Tutorial: Particle Resolved","text":"In\u00a0[42]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# particula imports\nfrom particula.next import particles\nfrom particula.next.gas.atmosphere_builders import AtmosphereBuilder\nfrom particula.next.gas.vapor_pressure_factories import VaporPressureFactory\nfrom particula.next.gas.species_builders import GasSpeciesBuilder\nfrom particula.next.aerosol import Aerosol\nfrom particula.next.dynamics.particle_process import MassCondensation\nfrom particula.next.dynamics.condensation.condensation_strategies import CondensationIsothermal\n\nfrom particula.util.input_handling import convert_units\n</pre> import numpy as np import matplotlib.pyplot as plt  # particula imports from particula.next import particles from particula.next.gas.atmosphere_builders import AtmosphereBuilder from particula.next.gas.vapor_pressure_factories import VaporPressureFactory from particula.next.gas.species_builders import GasSpeciesBuilder from particula.next.aerosol import Aerosol from particula.next.dynamics.particle_process import MassCondensation from particula.next.dynamics.condensation.condensation_strategies import CondensationIsothermal  from particula.util.input_handling import convert_units In\u00a0[34]: Copied! <pre>initial_water_vapor_activity = 1.025  # Relative humidity/100\n\n# Ammonium sulfate and water vapor pressure\nmolar_mass_ammonium_sulfate = 132.14e-3  # kg/mol\nmolar_mass_water = 18.015e-3  # kg/mol\nparameters_vapor = {\n    \"vapor_pressure\": 1e-24,\n}\nvapor_pressure_ammonium = VaporPressureFactory().get_strategy(\n    \"constant\", parameters_vapor\n)\nvapor_pressure_water = VaporPressureFactory().get_strategy(\n    \"water_buck\"\n)\n\nwater_sat = vapor_pressure_water.saturation_concentration(molar_mass=molar_mass_water, temperature=298.15)\nwater_concentration = water_sat * initial_water_vapor_activity\n\ngas_phase = (\n    GasSpeciesBuilder()\n    .set_molar_mass(np.array([molar_mass_water, molar_mass_ammonium_sulfate]), \"kg/mol\")\n    .set_vapor_pressure_strategy([vapor_pressure_water, vapor_pressure_ammonium])\n    .set_concentration(np.array([water_concentration, 1e-30]), \"kg/m^3\")\n    .set_name([\"H2O\", \"NH4HSO4\"])\n    .set_condensable([True, True])\n    .build()\n)\n\natmosphere = (\n    AtmosphereBuilder()\n    .add_species(gas_phase)\n    .set_temperature(25, temperature_units=\"degC\")\n    .set_pressure(1, pressure_units=\"atm\")\n    .build()\n)\n</pre> initial_water_vapor_activity = 1.025  # Relative humidity/100  # Ammonium sulfate and water vapor pressure molar_mass_ammonium_sulfate = 132.14e-3  # kg/mol molar_mass_water = 18.015e-3  # kg/mol parameters_vapor = {     \"vapor_pressure\": 1e-24, } vapor_pressure_ammonium = VaporPressureFactory().get_strategy(     \"constant\", parameters_vapor ) vapor_pressure_water = VaporPressureFactory().get_strategy(     \"water_buck\" )  water_sat = vapor_pressure_water.saturation_concentration(molar_mass=molar_mass_water, temperature=298.15) water_concentration = water_sat * initial_water_vapor_activity  gas_phase = (     GasSpeciesBuilder()     .set_molar_mass(np.array([molar_mass_water, molar_mass_ammonium_sulfate]), \"kg/mol\")     .set_vapor_pressure_strategy([vapor_pressure_water, vapor_pressure_ammonium])     .set_concentration(np.array([water_concentration, 1e-30]), \"kg/m^3\")     .set_name([\"H2O\", \"NH4HSO4\"])     .set_condensable([True, True])     .build() )  atmosphere = (     AtmosphereBuilder()     .add_species(gas_phase)     .set_temperature(25, temperature_units=\"degC\")     .set_pressure(1, pressure_units=\"atm\")     .build() )  <p>Sample Distribution</p> <p>Next we'll sample the distribution to get a set of particles. We'll then build an aerosol object to represent the aerosol population.</p> In\u00a0[35]: Copied! <pre>density = 1.77e3  # kg/m^3\nvolume_sim = 1 * convert_units(\"cm^3\", \"m^3\")  # m^3\nnumber_of_samples = 10_000\n\n# Generate a particle distribution using a lognormal sample distribution\n# This distribution has a mean particle diameter (mode) and geometric standard deviation (GSD)\nparticle_sample = particles.properties.lognormal_sample_distribution(\n    mode=np.array([100, 400]) * 1e-9,\n    geometric_standard_deviation=np.array([1.3, 1.4]),\n    number_of_particles=np.array([1, 0.5]),  # relative to each mode\n    number_of_samples=number_of_samples,  # Number of samples for particle distribution\n)\n\n# Calculate the mass of each particle in the sample, assuming density of 1500 kg/m^3\nparticle_mass = (\n    4 / 3 * np.pi * particle_sample**3 * density\n)  # Particle mass in kg\n\nmass_speciation = np.column_stack(\n    [particle_mass * 0, particle_mass]\n)  # water, ammonium sulfate\ndensities = np.array([1000, density])  # kg/m^3\n\n# kappa activity\nactivity_strat = (\n    particles.ActivityKappaParameterBuilder()\n    .set_density(densities)\n    .set_kappa(np.array([0.0, 0.61]))\n    .set_molar_mass(np.array([molar_mass_water, molar_mass_ammonium_sulfate]))\n    .set_water_index(0)\n    .build()\n)\n\nsurface_strat = (\n    particles.SurfaceStrategyVolumeBuilder()\n    .set_density(densities)\n    .set_surface_tension(np.array([0.072, 0.092]))\n    .build()\n)\n\n\n# Build a resolved mass representation for each particle\n# This defines how particle mass, activity, and surface are represented\nresolved_masses = (\n    particles.ResolvedParticleMassRepresentationBuilder()\n    .set_distribution_strategy(\n        particles.ParticleResolvedSpeciatedMass()\n    )  # Use speciated mass distribution\n    .set_activity_strategy(\n        activity_strat\n    )  # Define activity based on ideal mass\n    .set_surface_strategy(\n        surface_strat\n    )  # Define surface area based on particle volume\n    .set_mass(mass_speciation, \"kg\")  # Assign mass of particles (in kg)\n    .set_density(densities, \"kg/m^3\")  # Set particle density to 1500 kg/m^3\n    .set_charge(0)  # Assume neutral particles with no charge\n    .set_volume(volume_sim)  # Set volume of particle distribution\n    .build()  # Finalize the resolved mass representation\n)\n\n# Create an aerosol object with the defined atmosphere and resolved particles\naerosol_resolved = Aerosol(atmosphere=atmosphere, particles=resolved_masses)\n\n# Print the properties of the atmosphere\nprint(aerosol_resolved)\n</pre> density = 1.77e3  # kg/m^3 volume_sim = 1 * convert_units(\"cm^3\", \"m^3\")  # m^3 number_of_samples = 10_000  # Generate a particle distribution using a lognormal sample distribution # This distribution has a mean particle diameter (mode) and geometric standard deviation (GSD) particle_sample = particles.properties.lognormal_sample_distribution(     mode=np.array([100, 400]) * 1e-9,     geometric_standard_deviation=np.array([1.3, 1.4]),     number_of_particles=np.array([1, 0.5]),  # relative to each mode     number_of_samples=number_of_samples,  # Number of samples for particle distribution )  # Calculate the mass of each particle in the sample, assuming density of 1500 kg/m^3 particle_mass = (     4 / 3 * np.pi * particle_sample**3 * density )  # Particle mass in kg  mass_speciation = np.column_stack(     [particle_mass * 0, particle_mass] )  # water, ammonium sulfate densities = np.array([1000, density])  # kg/m^3  # kappa activity activity_strat = (     particles.ActivityKappaParameterBuilder()     .set_density(densities)     .set_kappa(np.array([0.0, 0.61]))     .set_molar_mass(np.array([molar_mass_water, molar_mass_ammonium_sulfate]))     .set_water_index(0)     .build() )  surface_strat = (     particles.SurfaceStrategyVolumeBuilder()     .set_density(densities)     .set_surface_tension(np.array([0.072, 0.092]))     .build() )   # Build a resolved mass representation for each particle # This defines how particle mass, activity, and surface are represented resolved_masses = (     particles.ResolvedParticleMassRepresentationBuilder()     .set_distribution_strategy(         particles.ParticleResolvedSpeciatedMass()     )  # Use speciated mass distribution     .set_activity_strategy(         activity_strat     )  # Define activity based on ideal mass     .set_surface_strategy(         surface_strat     )  # Define surface area based on particle volume     .set_mass(mass_speciation, \"kg\")  # Assign mass of particles (in kg)     .set_density(densities, \"kg/m^3\")  # Set particle density to 1500 kg/m^3     .set_charge(0)  # Assume neutral particles with no charge     .set_volume(volume_sim)  # Set volume of particle distribution     .build()  # Finalize the resolved mass representation )  # Create an aerosol object with the defined atmosphere and resolved particles aerosol_resolved = Aerosol(atmosphere=atmosphere, particles=resolved_masses)  # Print the properties of the atmosphere print(aerosol_resolved) <pre>Gas mixture at 298.15 K and 101325.0 Pa consisting of [\"['H2O', 'NH4HSO4']\"]\n[0]: Particle Representation:\n\tStrategy: ParticleResolvedSpeciatedMass\n\tActivity: ActivityKappaParameter\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 2.561e-06 [kg/m^3]\n\tNumber Concentration: 1.000e+10 [#/m^3]\n</pre> In\u00a0[36]: Copied! <pre># define the condensation process\ncondensation_isothermal = CondensationIsothermal(\n    molar_mass=np.array(\n        [molar_mass_water, molar_mass_ammonium_sulfate]\n    ),  # kg/mol\n    diffusion_coefficient=2e-5,  # m^2/s\n    accommodation_coefficient=1,  # makes things go slower/faster\n    update_gases=True,\n)\ncondensation_process = MassCondensation(\n    condensation_strategy=condensation_isothermal\n)\n\n# Set up time and sub-steps for the coagulation process\ntotal_time = 10\ntime_step = 0.01\nsub_steps = 10\n\n# bins\nbins_lognormal = np.logspace(-8, -4, 200)\n\n\n# output arrays\ntime = np.arange(0, total_time, time_step)\ntotal_mass_resolved = np.ones_like(time, dtype=np.float64)\nnumber_distribution_resolved = np.zeros((len(time), number_of_samples))\nnumber_distribution_binned = np.zeros((len(time), len(bins_lognormal) - 1))\ntotal_number_resolved = np.ones_like(time, dtype=np.float64)\nwater_saturation_in_time = np.ones_like(time, dtype=np.float64)\n\nprint(f\"Total iterations to do: {len(time)*sub_steps}\")\n</pre> # define the condensation process condensation_isothermal = CondensationIsothermal(     molar_mass=np.array(         [molar_mass_water, molar_mass_ammonium_sulfate]     ),  # kg/mol     diffusion_coefficient=2e-5,  # m^2/s     accommodation_coefficient=1,  # makes things go slower/faster     update_gases=True, ) condensation_process = MassCondensation(     condensation_strategy=condensation_isothermal )  # Set up time and sub-steps for the coagulation process total_time = 10 time_step = 0.01 sub_steps = 10  # bins bins_lognormal = np.logspace(-8, -4, 200)   # output arrays time = np.arange(0, total_time, time_step) total_mass_resolved = np.ones_like(time, dtype=np.float64) number_distribution_resolved = np.zeros((len(time), number_of_samples)) number_distribution_binned = np.zeros((len(time), len(bins_lognormal) - 1)) total_number_resolved = np.ones_like(time, dtype=np.float64) water_saturation_in_time = np.ones_like(time, dtype=np.float64)  print(f\"Total iterations to do: {len(time)*sub_steps}\") <pre>Total iterations: 10000\n</pre> In\u00a0[37]: Copied! <pre># Simulation loop\nfor i, t in enumerate(time):\n    if i &gt; 0:\n        # Perform condensation for the resolved aerosol\n        aerosol_resolved = condensation_process.execute(aerosol_resolved, time_step, sub_steps)\n\n    total_mass_resolved[i] = aerosol_resolved.particles[0].get_mass_concentration()\n    number_distribution_resolved[i, :] = aerosol_resolved.particles[0].get_radius(clone=True)\n    number_distribution_binned[i, :], edges = np.histogram(number_distribution_resolved[i, :], bins=bins_lognormal)\n    total_number_resolved[i] = np.sum(number_distribution_resolved[i, :]&gt;0)\n    water_saturation_in_time[i] = aerosol_resolved.atmosphere.species[0].get_saturation_ratio(\n        temperature=298.15)[0]\n\n\nnumber_distribution_binned = number_distribution_binned / volume_sim\n\nprint(aerosol_resolved)\n</pre> # Simulation loop for i, t in enumerate(time):     if i &gt; 0:         # Perform condensation for the resolved aerosol         aerosol_resolved = condensation_process.execute(aerosol_resolved, time_step, sub_steps)      total_mass_resolved[i] = aerosol_resolved.particles[0].get_mass_concentration()     number_distribution_resolved[i, :] = aerosol_resolved.particles[0].get_radius(clone=True)     number_distribution_binned[i, :], edges = np.histogram(number_distribution_resolved[i, :], bins=bins_lognormal)     total_number_resolved[i] = np.sum(number_distribution_resolved[i, :]&gt;0)     water_saturation_in_time[i] = aerosol_resolved.atmosphere.species[0].get_saturation_ratio(         temperature=298.15)[0]   number_distribution_binned = number_distribution_binned / volume_sim  print(aerosol_resolved) <pre>Gas mixture at 298.15 K and 101325.0 Pa consisting of [\"['H2O', 'NH4HSO4']\"]\n[0]: Particle Representation:\n\tStrategy: ParticleResolvedSpeciatedMass\n\tActivity: ActivityKappaParameter\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 6.017e-04 [kg/m^3]\n\tNumber Concentration: 1.000e+10 [#/m^3]\n</pre> In\u00a0[58]: Copied! <pre># plot the initial and final distributions\nfig, ax = plt.subplots(figsize=(8, 5))\n\nax.bar(\n    edges[:-1],\n    number_distribution_binned[0, :],\n    width=np.diff(edges),\n    align=\"edge\",\n    label=\"Resolved initial\",\n    color=\"red\",\n    alpha=0.7,\n)\nplot_index = 100\nax.bar(\n    edges[:-1],\n    number_distribution_binned[plot_index, :],\n    width=np.diff(edges),\n    align=\"edge\",\n    label=\"CCN overshoot time: {:.1f} s\".format(time[plot_index]),\n    color=\"purple\",\n    alpha=0.5,\n)\nax.bar(\n    edges[:-1],\n    number_distribution_binned[-1, :],\n    width=np.diff(edges),\n    align=\"edge\",\n    label=\"Resolved final\",\n    color=\"blue\",\n    alpha=0.7,\n)\nax.set_yscale(\"log\")\nax.set_xscale(\"log\")\nax.set_xlabel(\"Particle radius (m)\")\nax.set_ylabel(\"Number concentration (m^-3)\")\nax.legend()\nplt.show()\n</pre> # plot the initial and final distributions fig, ax = plt.subplots(figsize=(8, 5))  ax.bar(     edges[:-1],     number_distribution_binned[0, :],     width=np.diff(edges),     align=\"edge\",     label=\"Resolved initial\",     color=\"red\",     alpha=0.7, ) plot_index = 100 ax.bar(     edges[:-1],     number_distribution_binned[plot_index, :],     width=np.diff(edges),     align=\"edge\",     label=\"CCN overshoot time: {:.1f} s\".format(time[plot_index]),     color=\"purple\",     alpha=0.5, ) ax.bar(     edges[:-1],     number_distribution_binned[-1, :],     width=np.diff(edges),     align=\"edge\",     label=\"Resolved final\",     color=\"blue\",     alpha=0.7, ) ax.set_yscale(\"log\") ax.set_xscale(\"log\") ax.set_xlabel(\"Particle radius (m)\") ax.set_ylabel(\"Number concentration (m^-3)\") ax.legend() plt.show() In\u00a0[60]: Copied! <pre>fig, ax = plt.subplots(figsize=(8, 5))\n\n# Swap X and Y to reverse axes\nX, Y = np.meshgrid(\n    time, edges[:-1]\n)  # Now time is on the x-axis and edges on the y-axis\n\n# Plot the contour with updated X and Y\nlog_of_number_distribution_binned = np.log10(\n    number_distribution_binned,\n    out=np.nan * np.ones_like(number_distribution_binned),\n    where=number_distribution_binned &gt; 0\n)\ncontour = ax.contourf(\n    X, Y, log_of_number_distribution_binned.T, cmap=\"viridis\", vmin=5,\n)\n\n# Add the color bar\ncbar = fig.colorbar(contour)\ncbar.set_label(\"Log10 of Number concentration (m^-3)\")\n\nax.set_ylim([1e-8, 1e-5])  # Set limits for y-axis\n\n# Set axis labels\nax.set_yscale(\"log\")  # Log scale for particle radius on y-axis\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(\"Particle radius (m)\")\nfig.tight_layout()\nplt.show()\n</pre> fig, ax = plt.subplots(figsize=(8, 5))  # Swap X and Y to reverse axes X, Y = np.meshgrid(     time, edges[:-1] )  # Now time is on the x-axis and edges on the y-axis  # Plot the contour with updated X and Y log_of_number_distribution_binned = np.log10(     number_distribution_binned,     out=np.nan * np.ones_like(number_distribution_binned),     where=number_distribution_binned &gt; 0 ) contour = ax.contourf(     X, Y, log_of_number_distribution_binned.T, cmap=\"viridis\", vmin=5, )  # Add the color bar cbar = fig.colorbar(contour) cbar.set_label(\"Log10 of Number concentration (m^-3)\")  ax.set_ylim([1e-8, 1e-5])  # Set limits for y-axis  # Set axis labels ax.set_yscale(\"log\")  # Log scale for particle radius on y-axis ax.set_xlabel(\"Time (s)\") ax.set_ylabel(\"Particle radius (m)\") fig.tight_layout() plt.show() In\u00a0[59]: Copied! <pre># plot the total mass and water saturation on twin y-axis\nfig, ax1 = plt.subplots(figsize=(8, 5))\n\nax1.plot(time, total_mass_resolved, label=\"Total mass\", color=\"blue\")\nax1.set_xlabel(\"Time (s)\")\nax1.set_ylabel(\"Total Particle mass (kg/m^3)\", color=\"blue\")\nax1.tick_params(axis=\"y\", labelcolor=\"blue\")\n\nax2 = ax1.twinx()\nax2.plot(time, water_saturation_in_time, label=\"Water saturation\", color=\"red\")\nax2.set_ylabel(\"Water saturation\", color=\"red\")\nax2.tick_params(axis=\"y\", labelcolor=\"red\")\n\nfig.tight_layout()\nplt.show()\n</pre> # plot the total mass and water saturation on twin y-axis fig, ax1 = plt.subplots(figsize=(8, 5))  ax1.plot(time, total_mass_resolved, label=\"Total mass\", color=\"blue\") ax1.set_xlabel(\"Time (s)\") ax1.set_ylabel(\"Total Particle mass (kg/m^3)\", color=\"blue\") ax1.tick_params(axis=\"y\", labelcolor=\"blue\")  ax2 = ax1.twinx() ax2.plot(time, water_saturation_in_time, label=\"Water saturation\", color=\"red\") ax2.set_ylabel(\"Water saturation\", color=\"red\") ax2.tick_params(axis=\"y\", labelcolor=\"red\")  fig.tight_layout() plt.show()"},{"location":"Tutorials/Dynamics/Condensation/Condensation_3_MassResolved/#condensation-tutorial-particle-resolved","title":"Condensation Tutorial: Particle Resolved\u00b6","text":"<p>A particle resolved model is a model that tracks the properties of individual particles or collection of particles (e.g., super droplets). This is in contrast to a bulk model, which tracks the properties of the entire aerosol population. The particle resolved model can be more computationally expensive, but can provide more detailed information about the aerosol population.</p> <p>To run this type of model we will need to use a speciated distribution representation. This is so that we can track the properties of individual particles.</p>"},{"location":"Tutorials/Dynamics/Condensation/Condensation_3_MassResolved/#setup-aerosol","title":"Setup Aerosol\u00b6","text":"<p>First we'll draw from a lognormal distribution to create a set of particles. We'll will then build an aerosol object to represent the aerosol population.</p>"},{"location":"Tutorials/Dynamics/Condensation/Condensation_3_MassResolved/#condensation-process","title":"Condensation Process\u00b6","text":"<p>Using the same iso thermal condensation process we now setup the particle resolved simulation. We'll track the properties of each particle as they grow.</p>"},{"location":"Tutorials/Dynamics/Condensation/Condensation_3_MassResolved/#visualization","title":"Visualization\u00b6","text":"<p>Finally we'll visualize the results of the simulation. The first plot is a histogram of the particle size distribution. The second plot is 2D distribution plot vs time. Third is our limiting varible of water vapor saturation ratio, and the mass transferred to the particles.</p>"},{"location":"Tutorials/Dynamics/Condensation/Condensation_3_MassResolved/#summary","title":"Summary\u00b6","text":"<p>This tutorial demonstrates how to run a particle resolved model. We performed a cloud condensation simulation and visualized the results. We can see once the aerosol particles activate there is a redistribution of water vapor to the larger particles as the smaller ones are out of equilibrium and evaporate.</p>"},{"location":"Tutorials/Dynamics/Customization/Adding_Particles_During_Simulation/","title":"Adding Particles During Simulation","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# particula imports\nfrom particula.next import particles\nfrom particula.next.aerosol import Aerosol\n\nfrom particula.next.gas.species_builders import PresetGasSpeciesBuilder\nfrom particula.next.gas.atmosphere_builders import AtmosphereBuilder\n</pre> import numpy as np import matplotlib.pyplot as plt  # particula imports from particula.next import particles from particula.next.aerosol import Aerosol  from particula.next.gas.species_builders import PresetGasSpeciesBuilder from particula.next.gas.atmosphere_builders import AtmosphereBuilder In\u00a0[2]: Copied! <pre># Preset gas species that does not condense in the atmosphere\n# AtmosphereBuilder constructs the atmosphere with predefined species\natmosphere = (\n    AtmosphereBuilder()\n    .add_species(PresetGasSpeciesBuilder().build())  # Add a preset gas species\n    .set_temperature(25, temperature_units=\"degC\")  # Set temperature to 25\u00b0C\n    .set_pressure(1, pressure_units=\"atm\")  # Set pressure to 1 atmosphere\n    .build()  # Finalize the atmosphere object\n)\n\n# Generate a particle distribution using a lognormal sample distribution\n# This distribution has a mean particle diameter (mode) and geometric standard deviation (GSD)\nparticle_sample = particles.properties.lognormal_sample_distribution(\n    mode=np.array([100e-9]),  # Mean particle diameter of 100 nm\n    geometric_standard_deviation=np.array([1.3]),  # GSD of 1.3\n    number_of_particles=np.array([1e4]),  # Total number of particles\n    number_of_samples=100_000,  # Number of samples for particle distribution\n)\n\n# Calculate the mass of each particle in the sample, assuming density of 1500 kg/m^3\nparticle_mass_sample = (\n    4 / 3 * np.pi * particle_sample**3 * 1500\n)  # Particle mass in kg\n\n# Build a resolved mass representation for each particle\n# This defines how particle mass, activity, and surface are represented\nresolved_masses = (\n    particles.ResolvedParticleMassRepresentationBuilder()\n    .set_distribution_strategy(particles.ParticleResolvedSpeciatedMass())  # Use speciated mass distribution\n    .set_activity_strategy(particles.ActivityIdealMass())  # Define activity based on ideal mass\n    .set_surface_strategy(particles.SurfaceStrategyVolume())  # Define surface area based on particle volume\n    .set_mass(particle_mass_sample, \"kg\")  # Assign mass of particles (in kg)\n    .set_density(1500, \"kg/m^3\")  # Set particle density to 1500 kg/m^3\n    .set_charge(0)  # Assume neutral particles with no charge\n    .set_volume(1, \"cm^3\")  # Set volume of particle distribution\n    .build()  # Finalize the resolved mass representation\n)\n\n# Create an aerosol object with the defined atmosphere and resolved particles\naerosol = Aerosol(atmosphere=atmosphere, particles=resolved_masses)\n\n# Print the properties of the atmosphere\nprint(aerosol)\n</pre> # Preset gas species that does not condense in the atmosphere # AtmosphereBuilder constructs the atmosphere with predefined species atmosphere = (     AtmosphereBuilder()     .add_species(PresetGasSpeciesBuilder().build())  # Add a preset gas species     .set_temperature(25, temperature_units=\"degC\")  # Set temperature to 25\u00b0C     .set_pressure(1, pressure_units=\"atm\")  # Set pressure to 1 atmosphere     .build()  # Finalize the atmosphere object )  # Generate a particle distribution using a lognormal sample distribution # This distribution has a mean particle diameter (mode) and geometric standard deviation (GSD) particle_sample = particles.properties.lognormal_sample_distribution(     mode=np.array([100e-9]),  # Mean particle diameter of 100 nm     geometric_standard_deviation=np.array([1.3]),  # GSD of 1.3     number_of_particles=np.array([1e4]),  # Total number of particles     number_of_samples=100_000,  # Number of samples for particle distribution )  # Calculate the mass of each particle in the sample, assuming density of 1500 kg/m^3 particle_mass_sample = (     4 / 3 * np.pi * particle_sample**3 * 1500 )  # Particle mass in kg  # Build a resolved mass representation for each particle # This defines how particle mass, activity, and surface are represented resolved_masses = (     particles.ResolvedParticleMassRepresentationBuilder()     .set_distribution_strategy(particles.ParticleResolvedSpeciatedMass())  # Use speciated mass distribution     .set_activity_strategy(particles.ActivityIdealMass())  # Define activity based on ideal mass     .set_surface_strategy(particles.SurfaceStrategyVolume())  # Define surface area based on particle volume     .set_mass(particle_mass_sample, \"kg\")  # Assign mass of particles (in kg)     .set_density(1500, \"kg/m^3\")  # Set particle density to 1500 kg/m^3     .set_charge(0)  # Assume neutral particles with no charge     .set_volume(1, \"cm^3\")  # Set volume of particle distribution     .build()  # Finalize the resolved mass representation )  # Create an aerosol object with the defined atmosphere and resolved particles aerosol = Aerosol(atmosphere=atmosphere, particles=resolved_masses)  # Print the properties of the atmosphere print(aerosol) <pre>Gas mixture at 298.15 K and 101325.0 Pa consisting of ['Preset100']\n[0]: Particle Representation:\n\tStrategy: ParticleResolvedSpeciatedMass\n\tActivity: ActivityIdealMass\n\tSurface: SurfaceStrategyVolume\n\tMass Concentration: 8.605e-07 [kg/m^3]\n\tNumber Concentration: 1.000e+11 [#/m^3]\n</pre> In\u00a0[3]: Copied! <pre># particles to add\n\n# Generate a particle distribution using a lognormal sample distribution\n# This distribution has a mean particle diameter (mode) and geometric standard deviation (GSD)\nparticles_to_add = particles.properties.lognormal_sample_distribution(\n    mode=np.array([1e-9]),  # Mean particle diameter of 100 nm\n    geometric_standard_deviation=np.array([1.1]),  # GSD of 1.3\n    number_of_particles=np.array([1e4]),  # Total number of particles\n    number_of_samples=10_000,  # Number of samples for particle distribution\n)\n\n# Calculate the mass of each particle in the sample, assuming density of 1500 kg/m^3\nparticle_mass_add = (\n    4 / 3 * np.pi * particles_to_add**3 * 1500\n)  # Particle mass in kg\nconcentration_add = np.ones_like(particle_mass_add)\n\n\n# print shapes\nprint(f\"Particles to add: {particle_mass_add.shape}\")\n</pre> # particles to add  # Generate a particle distribution using a lognormal sample distribution # This distribution has a mean particle diameter (mode) and geometric standard deviation (GSD) particles_to_add = particles.properties.lognormal_sample_distribution(     mode=np.array([1e-9]),  # Mean particle diameter of 100 nm     geometric_standard_deviation=np.array([1.1]),  # GSD of 1.3     number_of_particles=np.array([1e4]),  # Total number of particles     number_of_samples=10_000,  # Number of samples for particle distribution )  # Calculate the mass of each particle in the sample, assuming density of 1500 kg/m^3 particle_mass_add = (     4 / 3 * np.pi * particles_to_add**3 * 1500 )  # Particle mass in kg concentration_add = np.ones_like(particle_mass_add)   # print shapes print(f\"Particles to add: {particle_mass_add.shape}\")  <pre>Particles to add: (10000,)\n</pre> In\u00a0[4]: Copied! <pre># Get initial particle radii before adding particle\ninitial_radii = aerosol.particles[0].get_radius(clone=True)\nprint(f\"Initial concentration: {aerosol.particles[0].get_total_concentration()}\")\n\n# Perform the add process\naerosol.particles[0].add_concentration(  # select the particle representation and call add_concentration\n    added_concentration=concentration_add,\n    added_distribution=particle_mass_add,\n)\nradii_after_step_1 = aerosol.particles[0].get_radius(clone=True)\nprint(f\"Concentration after step 1: {aerosol.particles[0].get_total_concentration()}\")\n\n# Perform the add process\naerosol.particles[0].add_concentration(\n    added_concentration=concentration_add,\n    added_distribution=particle_mass_add,\n)\nradii_after_step_2 = aerosol.particles[0].get_radius(clone=True)\n\nprint(f\"Concentration after step 2: {aerosol.particles[0].get_total_concentration()}\")\nconcentration_value = aerosol.particles[0].concentration\n</pre> # Get initial particle radii before adding particle initial_radii = aerosol.particles[0].get_radius(clone=True) print(f\"Initial concentration: {aerosol.particles[0].get_total_concentration()}\")  # Perform the add process aerosol.particles[0].add_concentration(  # select the particle representation and call add_concentration     added_concentration=concentration_add,     added_distribution=particle_mass_add, ) radii_after_step_1 = aerosol.particles[0].get_radius(clone=True) print(f\"Concentration after step 1: {aerosol.particles[0].get_total_concentration()}\")  # Perform the add process aerosol.particles[0].add_concentration(     added_concentration=concentration_add,     added_distribution=particle_mass_add, ) radii_after_step_2 = aerosol.particles[0].get_radius(clone=True)  print(f\"Concentration after step 2: {aerosol.particles[0].get_total_concentration()}\") concentration_value = aerosol.particles[0].concentration <pre>Initial concentration: 99999999999.99998\nConcentration after step 1: 109999999999.99998\nConcentration after step 2: 119999999999.99998\n</pre> In\u00a0[5]: Copied! <pre># Define lognormal bins for particle radius histogram\nbins_lognormal = np.logspace(-10, -6, 100)\n\n# Create figure for visualizing the histogram of particle radii\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Plot radii distribution after step 2\nbins, edges = np.histogram(radii_after_step_2, bins=bins_lognormal)\nax.bar(\n    edges[:-1],\n    bins,\n    width=np.diff(edges),\n    align=\"edge\",\n    label=\"After 2 steps\",\n    alpha=0.6,\n)\n# Plot radii distribution after step 1\n\nbins, edges = np.histogram(radii_after_step_1, bins=bins_lognormal)\nax.bar(\n    edges[:-1],\n    bins,\n    width=np.diff(edges),\n    align=\"edge\",\n    label=\"After 1 step\",\n    alpha=0.5,\n)\n\n# Plot initial radii distribution\nbins, edges = np.histogram(initial_radii, bins=bins_lognormal)\nax.bar(\n    edges[:-1],\n    bins,\n    width=np.diff(edges),\n    align=\"edge\",\n    label=\"Initial\",\n    alpha=0.4,\n    edgecolor=\"black\")\n\n# Set axes to logarithmic scale for x-axis (particle radius)\nax.set_xscale(\"log\")\nax.set_yscale(\"log\")\n\n# Add labels and legend\nax.set_xlabel(\"Radius (m)\")\nax.set_ylabel(\"Number of particles\")\nplt.legend()\n\n# Show the plot\nplt.show()\n</pre> # Define lognormal bins for particle radius histogram bins_lognormal = np.logspace(-10, -6, 100)  # Create figure for visualizing the histogram of particle radii fig, ax = plt.subplots(figsize=(8, 6))  # Plot radii distribution after step 2 bins, edges = np.histogram(radii_after_step_2, bins=bins_lognormal) ax.bar(     edges[:-1],     bins,     width=np.diff(edges),     align=\"edge\",     label=\"After 2 steps\",     alpha=0.6, ) # Plot radii distribution after step 1  bins, edges = np.histogram(radii_after_step_1, bins=bins_lognormal) ax.bar(     edges[:-1],     bins,     width=np.diff(edges),     align=\"edge\",     label=\"After 1 step\",     alpha=0.5, )  # Plot initial radii distribution bins, edges = np.histogram(initial_radii, bins=bins_lognormal) ax.bar(     edges[:-1],     bins,     width=np.diff(edges),     align=\"edge\",     label=\"Initial\",     alpha=0.4,     edgecolor=\"black\")  # Set axes to logarithmic scale for x-axis (particle radius) ax.set_xscale(\"log\") ax.set_yscale(\"log\")  # Add labels and legend ax.set_xlabel(\"Radius (m)\") ax.set_ylabel(\"Number of particles\") plt.legend()  # Show the plot plt.show()"},{"location":"Tutorials/Dynamics/Customization/Adding_Particles_During_Simulation/#adding-particles-during-simulation","title":"Adding Particles During Simulation\u00b6","text":"<p>In this tutorial, we demonstrate how add particles to an aerosol object. This is useful when you want to modify a custom aerosol process during a simulation.</p> <p>The example is for a particle resolved simulation, the same approach can be used for the other types of particle representations (but it has not been tested yet).</p> <p>Imports</p>"},{"location":"Tutorials/Dynamics/Customization/Adding_Particles_During_Simulation/#aerosol-setup","title":"Aerosol Setup\u00b6","text":"<p>We need to first make the aerosol object. Details on this can be found in the Aerosol Tutorial.</p>"},{"location":"Tutorials/Dynamics/Customization/Adding_Particles_During_Simulation/#particles-to-add","title":"Particles to Add\u00b6","text":"<p>For the particle resolved representation, the particles to add must be the provide an array of new particle masses and the concentrations.</p> <p>Currently the concentrations should all be one, as this is the particle resolved representation.</p> <p>If you have multiple species, then the shape of the <code>added_distribution</code> should be <code>(number of particles, number of species)</code>. But <code>added_concentration</code> is still <code>(number of particles,)</code>.</p>"},{"location":"Tutorials/Dynamics/Customization/Adding_Particles_During_Simulation/#graphing","title":"Graphing\u00b6","text":"<p>We now visualize the two particle add steps</p>"},{"location":"Tutorials/Dynamics/Customization/Adding_Particles_During_Simulation/#conclusion","title":"Conclusion\u00b6","text":"<p>We have demonstrated how to add particles to an aerosol object. This is useful when you want to modify a aerosol object with a custom process during a simulation.</p>"},{"location":"Tutorials/Gas_Phase/","title":"Gas Phase","text":""},{"location":"Tutorials/Gas_Phase/#notebooks","title":"Notebooks","text":"<ul> <li>Vapor Pressure Tutorial</li> <li>Gas Species Tutorial</li> <li>Atmosphere Tutorial</li> </ul>"},{"location":"Tutorials/Gas_Phase/AtmosphereTutorial/","title":"Atmosphere Tutorial","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# From particula\nfrom particula.next.gas.atmosphere_builder import AtmosphereBuilder\nfrom particula.next.gas.vapor_pressure_factories import VaporPressureFactory\nfrom particula.next.gas.species_builder import GasSpeciesBuilder\n</pre> import numpy as np import matplotlib.pyplot as plt  # From particula from particula.next.gas.atmosphere_builder import AtmosphereBuilder from particula.next.gas.vapor_pressure_factories import VaporPressureFactory from particula.next.gas.species_builder import GasSpeciesBuilder In\u00a0[2]: Copied! <pre># Define the coefficients for Butanol using the Antoine equation.\nbutanol_coefficients = {'a': 7.838, 'b': 1558.19, 'c': 196.881}\nbutanol_antione = VaporPressureFactory().get_strategy(\n    'antoine', butanol_coefficients)\nstyrene_coefficients = {'a': 6.924, 'b': 1420, 'c': 226}\nstyrene_antione = VaporPressureFactory().get_strategy(\n    'antoine', styrene_coefficients)\n\n# Water uses a different model for vapor pressure calculation called the Buck equation.\nwater_buck = VaporPressureFactory().get_strategy(\n    'water_buck')\n\n# Create the GasSpecies using the GasSpeciesBuilder\n# water species\nwater_species = (\n    GasSpeciesBuilder()\n    .set_name(\"water\")\n    .set_molar_mass(18.01528e-3)\n    .set_vapor_pressure_strategy(water_buck)\n    .set_condensable(True)\n    .set_concentration(1e-3)\n    .build()\n)\n\n# organic species\norganic_molar_mass = np.array([0.074121, 104.15e-3])\norganic_vapor_pressure = [butanol_antione, styrene_antione]\norganic_concentration = np.array([2e-6, 1e-9])\norganic_names = np.array([\"butanol\", \"styrene\"])\norganic_species = (\n    GasSpeciesBuilder()\n    .set_name(organic_names)\n    .set_molar_mass(organic_molar_mass)\n    .set_vapor_pressure_strategy(organic_vapor_pressure)\n    .set_condensable(True)\n    .set_concentration(organic_concentration)\n    .build()\n)\n\n# Print the species\nprint(water_species)\nprint(organic_species)\n</pre>  # Define the coefficients for Butanol using the Antoine equation. butanol_coefficients = {'a': 7.838, 'b': 1558.19, 'c': 196.881} butanol_antione = VaporPressureFactory().get_strategy(     'antoine', butanol_coefficients) styrene_coefficients = {'a': 6.924, 'b': 1420, 'c': 226} styrene_antione = VaporPressureFactory().get_strategy(     'antoine', styrene_coefficients)  # Water uses a different model for vapor pressure calculation called the Buck equation. water_buck = VaporPressureFactory().get_strategy(     'water_buck')  # Create the GasSpecies using the GasSpeciesBuilder # water species water_species = (     GasSpeciesBuilder()     .set_name(\"water\")     .set_molar_mass(18.01528e-3)     .set_vapor_pressure_strategy(water_buck)     .set_condensable(True)     .set_concentration(1e-3)     .build() )  # organic species organic_molar_mass = np.array([0.074121, 104.15e-3]) organic_vapor_pressure = [butanol_antione, styrene_antione] organic_concentration = np.array([2e-6, 1e-9]) organic_names = np.array([\"butanol\", \"styrene\"]) organic_species = (     GasSpeciesBuilder()     .set_name(organic_names)     .set_molar_mass(organic_molar_mass)     .set_vapor_pressure_strategy(organic_vapor_pressure)     .set_condensable(True)     .set_concentration(organic_concentration)     .build() )  # Print the species print(water_species) print(organic_species) <pre>water\n['butanol' 'styrene']\n</pre> In\u00a0[3]: Copied! <pre>gas_mixture = (\n    AtmosphereBuilder()\n    .add_species(water_species)\n    .add_species(organic_species)\n    .set_temperature(25, temperature_units='degC')\n    .set_pressure(1, pressure_units='atm')\n    .build()\n)\n\nprint('Notice the units conversion to base SI:')\nprint(gas_mixture)\n</pre> gas_mixture = (     AtmosphereBuilder()     .add_species(water_species)     .add_species(organic_species)     .set_temperature(25, temperature_units='degC')     .set_pressure(1, pressure_units='atm')     .build() )  print('Notice the units conversion to base SI:') print(gas_mixture) <pre>Notice the units conversion to base SI:\nGas mixture at 298.15 K and 101325.0 Pa consisting of ['water', \"['butanol' 'styrene']\"]\n</pre> In\u00a0[4]: Copied! <pre># Constants for calculations\nsea_level_pressure = 101325  # Reference pressure at sea level (Pa)\nsea_level_temperature = 330  # Reference temperature at sea level (K)\ngravity = 9.80665  # Acceleration due to gravity (m/s^2)\nmolar_mass_air = 0.0289644  # Molar mass of Earth's air (kg/mol)\nuniversal_gas_constant = 8.314    # Universal gas constant (J/(mol\u00b7K))\ntemperature_lapse_rate = 0.0065   # Standard temperature lapse rate (K/m)\n\n# Generate an array of altitudes from sea level (0 meters) to 10 km (10000 meters), divided into 100 intervals\naltitude_range = np.linspace(0, 10000, 100)\n\n# Calculate the temperature at each altitude based on the linear temperature lapse rate\ntemperature_at_altitudes = sea_level_temperature - temperature_lapse_rate * altitude_range\n\n# Calculate the pressure at each altitude using the barometric formula\npressure_at_altitudes = sea_level_pressure * (\n    (1 - temperature_lapse_rate * altitude_range / sea_level_temperature)\n    ** (gravity * molar_mass_air / (universal_gas_constant * temperature_lapse_rate)))\n\n\n# Initialize a matrix to hold saturation ratios for each species at each\n# altitude\nsaturation_ratio = np.zeros(len(altitude_range))\n\n# Loop over each altitude's temperature and pressure\nfor index, (temperature, pressure) in enumerate(zip(temperature_at_altitudes, pressure_at_altitudes)):\n    # Set the current temperature and pressure of the gas mixture\n    gas_mixture.temperature = temperature\n    gas_mixture.total_pressure = pressure\n\n    # Loop over water\n    saturation_ratio[index] = gas_mixture.species[0].get_saturation_ratio(gas_mixture.temperature)\n\n\n# Plot the saturation ratio of water vapor at each altitude\nfig, ax = plt.subplots()\nax.plot(saturation_ratio, altitude_range, label='Water')\nax.set_xscale('log')\nax.set_ylabel('Altitude (m)')\nax.set_xlabel('Water Saturation Ratio')\nax.set_title('Saturation Ratio of Water Vapor at Different Altitudes')\nax.legend()\nplt.show()\n</pre> # Constants for calculations sea_level_pressure = 101325  # Reference pressure at sea level (Pa) sea_level_temperature = 330  # Reference temperature at sea level (K) gravity = 9.80665  # Acceleration due to gravity (m/s^2) molar_mass_air = 0.0289644  # Molar mass of Earth's air (kg/mol) universal_gas_constant = 8.314    # Universal gas constant (J/(mol\u00b7K)) temperature_lapse_rate = 0.0065   # Standard temperature lapse rate (K/m)  # Generate an array of altitudes from sea level (0 meters) to 10 km (10000 meters), divided into 100 intervals altitude_range = np.linspace(0, 10000, 100)  # Calculate the temperature at each altitude based on the linear temperature lapse rate temperature_at_altitudes = sea_level_temperature - temperature_lapse_rate * altitude_range  # Calculate the pressure at each altitude using the barometric formula pressure_at_altitudes = sea_level_pressure * (     (1 - temperature_lapse_rate * altitude_range / sea_level_temperature)     ** (gravity * molar_mass_air / (universal_gas_constant * temperature_lapse_rate)))   # Initialize a matrix to hold saturation ratios for each species at each # altitude saturation_ratio = np.zeros(len(altitude_range))  # Loop over each altitude's temperature and pressure for index, (temperature, pressure) in enumerate(zip(temperature_at_altitudes, pressure_at_altitudes)):     # Set the current temperature and pressure of the gas mixture     gas_mixture.temperature = temperature     gas_mixture.total_pressure = pressure      # Loop over water     saturation_ratio[index] = gas_mixture.species[0].get_saturation_ratio(gas_mixture.temperature)   # Plot the saturation ratio of water vapor at each altitude fig, ax = plt.subplots() ax.plot(saturation_ratio, altitude_range, label='Water') ax.set_xscale('log') ax.set_ylabel('Altitude (m)') ax.set_xlabel('Water Saturation Ratio') ax.set_title('Saturation Ratio of Water Vapor at Different Altitudes') ax.legend() plt.show()"},{"location":"Tutorials/Gas_Phase/AtmosphereTutorial/#atmosphere-tutorial","title":"Atmosphere Tutorial\u00b6","text":"<p>Gases, alongside particles, constitute the essential components of an aerosol system. In their natural state, gases are collections of molecules that move freely, not bound to one another. We introduce the <code>Atmosphere</code> class, a composite that encapsolate <code>GasSpecies</code>, with addition parameters for the atmospheric state.</p> <ul> <li><code>Atmosphere</code>: This class represents the atmospheric environment by detailing properties such as temperature and pressure, alongside a dynamic list of gas species present.</li> <li><code>AtmosphericBuilder</code>: A builder class that simplifies the creation of <code>Atmosphere</code> objects.</li> </ul> <p>We'll continue with our organics and water example, combining the two into a single <code>Atmosphere</code> object.</p>"},{"location":"Tutorials/Gas_Phase/AtmosphereTutorial/#build-gas-species","title":"Build Gas Species\u00b6","text":"<p>First we will build the, <code>GasSpecies</code> objects for the organics and water. Following the same procedure from previously in <code>Gas Species</code>.</p>"},{"location":"Tutorials/Gas_Phase/AtmosphereTutorial/#atmosphere-builder","title":"Atmosphere Builder\u00b6","text":"<p>The <code>AtmosphereBuilder</code> class is a builder class that simplifies the creation of <code>Atmosphere</code> objects. It provides a fluent interface for adding <code>GasSpecies</code> objects to the <code>Atmosphere</code> object. We will use it to build the <code>Atmosphere</code> object for the organics and water. The builder requries the following parameters:</p> <ul> <li><code>pressure</code>: The total pressure of the gas mixture, in Pascals, or provided pressure_units string for conversion.</li> <li><code>temperature</code>: The temperature of the gas mixture, in Kelvin, or provided temperature_units string for conversion.</li> <li><code>species</code>: A list of <code>GasSpecies</code> objects, representing the gases in the mixture. This can be added one by one using the <code>add_species</code> method.</li> </ul>"},{"location":"Tutorials/Gas_Phase/AtmosphereTutorial/#air","title":"Air\u00b6","text":"<p>Air is assumed to be the non-specified component of the gas mixture, making up the remainder of the gas mixture. We do not explicitly add air to the gas mixture, but it is implicitly included in most calculations.</p>"},{"location":"Tutorials/Gas_Phase/AtmosphereTutorial/#iterating-over-gas-species","title":"Iterating Over Gas Species\u00b6","text":"<p>Once the <code>Gas</code> object has been established, it enables us to iterate over each <code>GasSpecies</code> within the mixture. This functionality is particularly valuable for evaluating and adjusting properties dynamically, such as when changes in temperature and pressure occur due to environmental alterations.</p>"},{"location":"Tutorials/Gas_Phase/AtmosphereTutorial/#practical-example-altitude-impact","title":"Practical Example: Altitude Impact\u00b6","text":"<p>Consider a scenario where our gas mixture is transported from sea level to an altitude of 10 kilometers. Such a change in altitude significantly impacts both temperature and pressure, which in turn affects the behavior of each gas species in the mixture.</p>"},{"location":"Tutorials/Gas_Phase/AtmosphereTutorial/#geopotential-height-equation","title":"Geopotential Height Equation\u00b6","text":"<p>The pressure and temperature changes with altitude can be approximated by using the geopotential height equation. Here's how you can calculate these changes:</p> <ol> <li>Pressure Change: The pressure at a given altitude can be estimated by:</li> </ol> <p>$$    P = P_0 \\left(1 - \\frac{L \\cdot h}{T_0}\\right)^{\\frac{g \\cdot M}{R \\cdot L}} $$</p> <p>where:</p> <ul> <li>$ P $ is the pressure at altitude $ h $,</li> <li>$ P_0 $ is the reference pressure at sea level (101325 Pa),</li> <li>$ L $ is the standard temperature lapse rate (approximately 0.0065 K/m),</li> <li>$ h $ is the altitude in meters (10000 m for 10 km),</li> <li>$ T_0 $ is the reference temperature at sea level (288.15 K),</li> <li>$ g $ is the acceleration due to gravity (9.80665 m/s\u00b2),</li> <li>$ M $ is the molar mass of Earth's air (0.0289644 kg/mol),</li> <li>$ R $ is the universal gas constant (8.314 J/(mol\u00b7K)).</li> </ul> <ol> <li><p>Temperature Change: The temperature decreases linearly with altitude at the lapse rate $ L $:</p> <p>$$ T = T_0 - L h $$</p> <p>Using this formula, we can estimate the temperature at an altitude of 10 km:</p> <ul> <li>$T$ = 288.15 K</li> <li>$L$ 0.0065 K/m</li> <li>$h$ = 10000 m</li> </ul> </li> </ol>"},{"location":"Tutorials/Gas_Phase/AtmosphereTutorial/#application","title":"Application\u00b6","text":"<p>By iterating through each <code>GasSpecies</code>, we can apply these formulas to adjust their properties based on the calculated pressure and temperature at 10 km altitude, aiding in simulations or real-world applications where altitude plays a crucial role in gas behavior.</p>"},{"location":"Tutorials/Gas_Phase/AtmosphereTutorial/#summary","title":"Summary\u00b6","text":"<p>In this notebook, we learned how to create an <code>Atmosphere</code> object using the <code>AtmosphereBuilder</code> class. We also explored how to iterate over each <code>GasSpecies</code> within the mixture, enabling us to adjust properties dynamically based on environmental changes. This functionality is particularly useful for simulating real-world scenarios where temperature and pressure variations significantly impact gas behavior.</p> <p>We now need to build the particle representation, so that combined with the <code>Atmosphere</code>, we can create an aerosol system.</p>"},{"location":"Tutorials/Gas_Phase/Gas_Species/","title":"Gas Species Tutorial","text":"In\u00a0[12]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# Particula imports\nfrom particula.next.gas.vapor_pressure_factories import VaporPressureFactory\nfrom particula.next.gas.species import GasSpecies\nfrom particula.next.gas.species_builder import GasSpeciesBuilder\n</pre> import numpy as np import matplotlib.pyplot as plt  # Particula imports from particula.next.gas.vapor_pressure_factories import VaporPressureFactory from particula.next.gas.species import GasSpecies from particula.next.gas.species_builder import GasSpeciesBuilder In\u00a0[13]: Copied! <pre># Define the coefficients for Butanol using the Antoine equation.\n# 'a', 'b', and 'c' are coefficients specific to the Antoine equation used to calculate vapor pressure.\nbutanol_coefficients = {'a': 7.838, 'b': 1558.19, 'c': 196.881}\n# Create a vapor pressure strategy for Butanol using the Antoine equation.\nbutanol_antione = VaporPressureFactory().get_strategy(\n    strategy_type='antoine', parameters=butanol_coefficients)\n\n# Define the coefficients for Styrene, similar to Butanol, using the\n# Antoine equation.\nstyrene_coefficients = {'a': 6.924, 'b': 1420, 'c': 226}\n# Create a vapor pressure strategy for Styrene using the Antoine equation.\nstyrene_antione = VaporPressureFactory().get_strategy(\n    strategy_type='antoine', parameters=styrene_coefficients)\n\n# Water uses a different model for vapor pressure calculation called the Buck equation.\n# The Buck equation is particularly suited for water vapor calculations.\n# No additional parameters are required to be passed for the Buck equation\n# in this instance.\nwater_buck = VaporPressureFactory().get_strategy(\n    strategy_type='water_buck')\n</pre> # Define the coefficients for Butanol using the Antoine equation. # 'a', 'b', and 'c' are coefficients specific to the Antoine equation used to calculate vapor pressure. butanol_coefficients = {'a': 7.838, 'b': 1558.19, 'c': 196.881} # Create a vapor pressure strategy for Butanol using the Antoine equation. butanol_antione = VaporPressureFactory().get_strategy(     strategy_type='antoine', parameters=butanol_coefficients)  # Define the coefficients for Styrene, similar to Butanol, using the # Antoine equation. styrene_coefficients = {'a': 6.924, 'b': 1420, 'c': 226} # Create a vapor pressure strategy for Styrene using the Antoine equation. styrene_antione = VaporPressureFactory().get_strategy(     strategy_type='antoine', parameters=styrene_coefficients)  # Water uses a different model for vapor pressure calculation called the Buck equation. # The Buck equation is particularly suited for water vapor calculations. # No additional parameters are required to be passed for the Buck equation # in this instance. water_buck = VaporPressureFactory().get_strategy(     strategy_type='water_buck') In\u00a0[14]: Copied! <pre># Configure the builder with the necessary properties\nwater_species = (\n    GasSpeciesBuilder()\n    .set_name(\"Water\")\n    .set_molar_mass(18.01528, molar_mass_units=\"g/mol\")\n    .set_vapor_pressure_strategy(water_buck)\n    .set_condensable(True)\n    .set_concentration(1e2, concentration_units=\"ug/m^3\")\n    .build()\n)\n\n\n# molar mass in kg/mol, concentration in kg/m3\n\nprint(water_species)\nprint(f\"Notice the units of the concentration are now in kg/m^3: {water_species.concentration}\")\nprint(f\"Also the units of the molar mass are now in kg/mol: {water_species.molar_mass}\")\n</pre> # Configure the builder with the necessary properties water_species = (     GasSpeciesBuilder()     .set_name(\"Water\")     .set_molar_mass(18.01528, molar_mass_units=\"g/mol\")     .set_vapor_pressure_strategy(water_buck)     .set_condensable(True)     .set_concentration(1e2, concentration_units=\"ug/m^3\")     .build() )   # molar mass in kg/mol, concentration in kg/m3  print(water_species) print(f\"Notice the units of the concentration are now in kg/m^3: {water_species.concentration}\") print(f\"Also the units of the molar mass are now in kg/mol: {water_species.molar_mass}\") <pre>Water\nNotice the units of the concentration are now in kg/m^3: 1.0000000000000001e-07\nAlso the units of the molar mass are now in kg/mol: 0.01801528\n</pre> In\u00a0[15]: Copied! <pre># Define molar masses for organic species (Butanol and Styrene) in kilograms per mole (kg/mol).\norganic_molar_mass = np.array([0.074121, 104.15e-3])  # Molar mass for Butanol and Styrene respectively.\n\n# List of vapor pressure strategies assigned to each organic species.\norganic_vapor_pressure = [butanol_antione, styrene_antione]  # Using Antoine's equation for both.\n\n# Define concentrations for each organic species in the mixture, in kilograms per cubic meter (kg/m^3).\norganic_concentration = np.array([2e-6, 1e-9])  # Concentration values for Butanol and Styrene respectively.\n\n# Names of the organic species.\norganic_names = np.array([\"butanol\", \"styrene\"])\n\n# Using GasSpeciesBuilder to construct a GasSpecies object for organics.\n# Notice how we can directly use arrays to set properties for multiple species.\norganic_species = (\n    GasSpeciesBuilder()\n    .set_name(organic_names)\n    .set_molar_mass(organic_molar_mass)\n    .set_vapor_pressure_strategy(organic_vapor_pressure)\n    .set_condensable([True, True])\n    .set_concentration(organic_concentration)\n    .build()\n)\n\n# The `build()` method validates all the properties are set and returns the constructed GasSpecies object(s).\n# Here, organic_species will contain the built GasSpecies instances for Butanol and Styrene.\nprint(organic_species)\n</pre> # Define molar masses for organic species (Butanol and Styrene) in kilograms per mole (kg/mol). organic_molar_mass = np.array([0.074121, 104.15e-3])  # Molar mass for Butanol and Styrene respectively.  # List of vapor pressure strategies assigned to each organic species. organic_vapor_pressure = [butanol_antione, styrene_antione]  # Using Antoine's equation for both.  # Define concentrations for each organic species in the mixture, in kilograms per cubic meter (kg/m^3). organic_concentration = np.array([2e-6, 1e-9])  # Concentration values for Butanol and Styrene respectively.  # Names of the organic species. organic_names = np.array([\"butanol\", \"styrene\"])  # Using GasSpeciesBuilder to construct a GasSpecies object for organics. # Notice how we can directly use arrays to set properties for multiple species. organic_species = (     GasSpeciesBuilder()     .set_name(organic_names)     .set_molar_mass(organic_molar_mass)     .set_vapor_pressure_strategy(organic_vapor_pressure)     .set_condensable([True, True])     .set_concentration(organic_concentration)     .build() )  # The `build()` method validates all the properties are set and returns the constructed GasSpecies object(s). # Here, organic_species will contain the built GasSpecies instances for Butanol and Styrene. print(organic_species) <pre>['butanol' 'styrene']\n</pre> In\u00a0[16]: Copied! <pre>temperature_range = np.linspace(273.15, 373.15, 100)  # Temperature range from 0 to 100 degrees Celsius.\n\norganic_pure_vapor_pressure = organic_species.get_pure_vapor_pressure(temperature_range)\nwater_pure_vapor_pressure = water_species.get_pure_vapor_pressure(temperature_range)\n\n# Plotting the vapor pressure curves for the organic species.\nfig, ax = plt.subplots(figsize=(8, 6))\nfor i in range(len(organic_names)):\n    ax.plot(temperature_range, organic_pure_vapor_pressure[i], label=organic_names[i])\nax.plot(temperature_range, water_pure_vapor_pressure, label=\"Water\")\nax.set_xlabel(\"Temperature (K)\")\nax.set_ylabel(\"Vapor Pressure (Pa)\")\nax.set_yscale('log')\nax.legend()\nplt.show()\n</pre> temperature_range = np.linspace(273.15, 373.15, 100)  # Temperature range from 0 to 100 degrees Celsius.  organic_pure_vapor_pressure = organic_species.get_pure_vapor_pressure(temperature_range) water_pure_vapor_pressure = water_species.get_pure_vapor_pressure(temperature_range)  # Plotting the vapor pressure curves for the organic species. fig, ax = plt.subplots(figsize=(8, 6)) for i in range(len(organic_names)):     ax.plot(temperature_range, organic_pure_vapor_pressure[i], label=organic_names[i]) ax.plot(temperature_range, water_pure_vapor_pressure, label=\"Water\") ax.set_xlabel(\"Temperature (K)\") ax.set_ylabel(\"Vapor Pressure (Pa)\") ax.set_yscale('log') ax.legend() plt.show() In\u00a0[17]: Copied! <pre># Saturation ratio calculation\norganic_saturation_ratio = organic_species.get_saturation_ratio(temperature_range)\nwater_saturation_ratio = water_species.get_saturation_ratio(temperature_range)\n\n# Plotting the saturation ratio curves for the organic species.\nfig, ax = plt.subplots(figsize=(8, 6))\nfor i in range(len(organic_names)):\n    ax.plot(temperature_range, organic_saturation_ratio[i], label=organic_names[i])\nax.plot(temperature_range, water_saturation_ratio, label=\"Water\")\nax.set_ylim(0, 5)\nax.set_xlabel(\"Temperature (K)\")\nax.set_ylabel(\"Saturation Ratio\")\nax.legend()\nplt.show()\n</pre> # Saturation ratio calculation organic_saturation_ratio = organic_species.get_saturation_ratio(temperature_range) water_saturation_ratio = water_species.get_saturation_ratio(temperature_range)  # Plotting the saturation ratio curves for the organic species. fig, ax = plt.subplots(figsize=(8, 6)) for i in range(len(organic_names)):     ax.plot(temperature_range, organic_saturation_ratio[i], label=organic_names[i]) ax.plot(temperature_range, water_saturation_ratio, label=\"Water\") ax.set_ylim(0, 5) ax.set_xlabel(\"Temperature (K)\") ax.set_ylabel(\"Saturation Ratio\") ax.legend() plt.show()"},{"location":"Tutorials/Gas_Phase/Gas_Species/#gas-species-tutorial","title":"Gas Species Tutorial\u00b6","text":"<p>The <code>GasSpecies</code> is a class that represents a gas species in a simulation or calculation. It includes properties such as the species' name, molar mass, vapor pressure, and whether it is condensable. The class provides methods to set and retrieve these properties, ensuring that each species is fully defined and manageable within simulations.</p> <p>In this notebook, we will demonstrate how to use the <code>GasSpecies</code> class to create and manage gas species. This includes creating new species, setting their properties, and retrieving vapor pressure, concentration, and other properties.</p>"},{"location":"Tutorials/Gas_Phase/Gas_Species/#key-classes","title":"Key Classes\u00b6","text":"<ul> <li><code>GasSpecies</code>: Represents a gas species in a simulation or calculation.</li> <li><code>GasSpeciesBuilder</code>: A builder class that constructs instances of <code>GasSpecies</code> with well-defined properties.</li> </ul>"},{"location":"Tutorials/Gas_Phase/Gas_Species/#define-vapor-pressure-strategies","title":"Define Vapor Pressure Strategies\u00b6","text":"<p>In this section, we'll focus on defining vapor pressure strategies for gas species, specifically Butanol, Styrene, and Water, which were used in our previous examples. To streamline our analysis, we will group Butanol and Styrene into a single organic category, and consider Water separately.</p>"},{"location":"Tutorials/Gas_Phase/Gas_Species/#strategy-assignment","title":"Strategy Assignment\u00b6","text":"<p>For calculating vapor pressures:</p> <ul> <li>Organics (Butanol and Styrene): We will utilize the Antoine equation, a widely recognized method for estimating the vapor pressure of organic compounds based on temperature.</li> <li>Water: We will apply the Buck equation, which is specifically tailored to accurately calculate the vapor pressure of water across a range of temperatures.</li> </ul>"},{"location":"Tutorials/Gas_Phase/Gas_Species/#using-gasspeciesbuilder-to-construct-gas-species","title":"Using <code>GasSpeciesBuilder</code> to Construct Gas Species\u00b6","text":"<p>Now that we have defined the appropriate vapor pressure strategies for our gas species, we can proceed to construct the individual species using the <code>GasSpeciesBuilder</code>. This builder simplifies the process of defining and validating the properties of each gas species before their creation. We'll begin with Water, as it involves a straightforward application of the Buck equation.</p>"},{"location":"Tutorials/Gas_Phase/Gas_Species/#building-the-water-gas-species","title":"Building the Water Gas Species\u00b6","text":"<p>The <code>GasSpeciesBuilder</code> facilitates a structured approach to setting up a gas species. To build a Water gas species, the builder requires the following properties to be set:</p> <ol> <li>Name: Identifies the species, which in this case is \"Water\".</li> <li>Molar Mass: The molar mass of water, essential for calculations involving mass and moles.</li> <li>Vapor Pressure Strategy: The specific strategy used to calculate vapor pressure; for Water, we use the Buck equation.</li> <li>Condensability: Indicates whether the species can condense under certain atmospheric conditions. For Water, this is typically true.</li> <li>Concentration: The initial concentration of Water in the mixture, which could vary based on the scenario.</li> </ol> <p>Here is how you can use the <code>GasSpeciesBuilder</code> to set up Water:</p>"},{"location":"Tutorials/Gas_Phase/Gas_Species/#building-gas-species-for-organics","title":"Building Gas Species for Organics\u00b6","text":"<p>Following Water, you can apply a similar process to build gas species for Organics like Butanol and Styrene. Each will have its set of properties based on the chemical's nature and the desired simulation context.</p> <p>When calling <code>.build()</code>, it checks that all required properties are set correctly, raising an error if any essential attribute is missing or improperly configured. This ensures that each <code>GasSpecies</code> instance is valid and ready usage.</p>"},{"location":"Tutorials/Gas_Phase/Gas_Species/#pure-vapor-pressures","title":"Pure Vapor Pressures\u00b6","text":"<p>With the gas species defined, we can now calculate the pure vapor pressures of Butanol, Styrene, and Water using the respective strategies we assigned earlier. This will help us understand the vapor pressure behavior of each species individually, which is crucial for predicting their behavior in mixtures and under varying conditions.</p>"},{"location":"Tutorials/Gas_Phase/Gas_Species/#saturation-ratios","title":"Saturation Ratios\u00b6","text":"<p>Now that we have established the concentration of each gas species within the mixture, we can proceed to calculate the saturation ratio for each species. The saturation ratio is an essential parameter in determining the condensation behavior of gas species within a mixture.</p> <ul> <li>Above 1: A saturation ratio greater than 1 indicates that the species is supersaturated and is likely to condense.</li> <li>Below 1: Conversely, a saturation ratio below 1 suggests that the species will likely remain in the gas phase.</li> </ul>"},{"location":"Tutorials/Gas_Phase/Gas_Species/#future-exploration","title":"Future Exploration\u00b6","text":"<p>In subsequent sections of this notebook series, we will delve deeper into how these saturation ratios reach equilibrium with a liquid phase, enhancing our understanding of the phase behavior under different conditions.</p>"},{"location":"Tutorials/Gas_Phase/Gas_Species/#summary","title":"Summary\u00b6","text":"<p>The <code>GasSpecies</code> module, along with the <code>GasSpeciesBuilder</code>, provides a robust framework for defining and managing gas species within a mixture. By assigning specific vapor pressure strategies and other essential properties, we can accurately model the behavior of individual species and their interactions in various scenarios. This module serves as a foundational component for more advanced simulations and analyses involving gas mixtures, condensation, and phase equilibrium.</p> <p>The next section is one more layer of abstraction, where we will define the <code>GasMixture</code> class to manage multiple gas species within a single mixture. This class will enable us to handle complex gas mixtures effectively and efficiently, paving the way particle to gas interactions.</p>"},{"location":"Tutorials/Gas_Phase/Vapor_Pressure/","title":"Vapor Pressure Tutorial","text":"In\u00a0[8]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# Import the functions from the particula package\nfrom particula.next.gas.vapor_pressure_strategies import AntoineVaporPressureStrategy\nfrom particula.next.gas.vapor_pressure_builders import AntoineBuilder\nfrom particula.next.gas.vapor_pressure_factories import VaporPressureFactory\n</pre> import numpy as np import matplotlib.pyplot as plt  # Import the functions from the particula package from particula.next.gas.vapor_pressure_strategies import AntoineVaporPressureStrategy from particula.next.gas.vapor_pressure_builders import AntoineBuilder from particula.next.gas.vapor_pressure_factories import VaporPressureFactory In\u00a0[9]: Copied! <pre># Direct instantiation of an AntoineVaporPressureStrategy for butanol.\n# This approach directly sets the coefficients 'a', 'b', and 'c' specific\n# to butanol for calculating its vapor pressure.\nbutanol_antione = AntoineVaporPressureStrategy(\n    a=7.838, b=1558.19, c=196.881)\n\n# Use the Builder pattern to create a vapor pressure strategy for styrene.\n# The Builder pattern allows for more flexible object creation by setting properties step-by-step.\n# This approach, also validates the input parameters and ensures the object is fully defined.\n# Here, coefficients are set individually using setter methods provided by\n# the AntoineBuilder.\nstyrene_coefficients = {'a': 6.924, 'b': 1420, 'c': 226}\nstyrene_antione = (\n    AntoineBuilder()\n    .set_a(styrene_coefficients['a'])\n    .set_b(styrene_coefficients['b'])\n    .set_c(styrene_coefficients['c'])\n    .build()\n)\n\n# Initialize a vapor pressure strategy for water using the factory method.\n# The factory method abstracts the creation logic of the builder and can instantiate different builder strategies based on the input strategy.\n# This approach ensures that object creation is centralized and consistent across the application.\n# Note: The strategy name provided to the factory method is case-insensitive.\nwater_coefficients = {'a': 7.949017, 'b': 1657.462, 'c': 227.02}\nwater_antione = VaporPressureFactory().get_strategy(\n    strategy_type='Antoine',\n    parameters=water_coefficients\n)\n\n\n# Calculate and print the vapor pressures at 300 Kelvin for each substance using the initialized strategies.\n# The function 'pure_vapor_pressure' is used here, which calculates the\n# vapor pressure based on the provided temperature.\n\nprint(f'Butanol Antoine vapor pressure at 300 K: {butanol_antione.pure_vapor_pressure(300)} Pa')\nprint(f'Styrene Antoine vapor pressure at 300 K: {styrene_antione.pure_vapor_pressure(300)} Pa')\nprint(f'Water Antoine vapor pressure at 300 K: {water_antione.pure_vapor_pressure(300)} Pa')\n</pre> # Direct instantiation of an AntoineVaporPressureStrategy for butanol. # This approach directly sets the coefficients 'a', 'b', and 'c' specific # to butanol for calculating its vapor pressure. butanol_antione = AntoineVaporPressureStrategy(     a=7.838, b=1558.19, c=196.881)  # Use the Builder pattern to create a vapor pressure strategy for styrene. # The Builder pattern allows for more flexible object creation by setting properties step-by-step. # This approach, also validates the input parameters and ensures the object is fully defined. # Here, coefficients are set individually using setter methods provided by # the AntoineBuilder. styrene_coefficients = {'a': 6.924, 'b': 1420, 'c': 226} styrene_antione = (     AntoineBuilder()     .set_a(styrene_coefficients['a'])     .set_b(styrene_coefficients['b'])     .set_c(styrene_coefficients['c'])     .build() )  # Initialize a vapor pressure strategy for water using the factory method. # The factory method abstracts the creation logic of the builder and can instantiate different builder strategies based on the input strategy. # This approach ensures that object creation is centralized and consistent across the application. # Note: The strategy name provided to the factory method is case-insensitive. water_coefficients = {'a': 7.949017, 'b': 1657.462, 'c': 227.02} water_antione = VaporPressureFactory().get_strategy(     strategy_type='Antoine',     parameters=water_coefficients )   # Calculate and print the vapor pressures at 300 Kelvin for each substance using the initialized strategies. # The function 'pure_vapor_pressure' is used here, which calculates the # vapor pressure based on the provided temperature.  print(f'Butanol Antoine vapor pressure at 300 K: {butanol_antione.pure_vapor_pressure(300)} Pa') print(f'Styrene Antoine vapor pressure at 300 K: {styrene_antione.pure_vapor_pressure(300)} Pa') print(f'Water Antoine vapor pressure at 300 K: {water_antione.pure_vapor_pressure(300)} Pa') <pre>Butanol Antoine vapor pressure at 300 K: 7.117073414020618e-06 Pa\nStyrene Antoine vapor pressure at 300 K: 7.239567651587212e-11 Pa\nWater Antoine vapor pressure at 300 K: 2.305354272293551e-13 Pa\n</pre> In\u00a0[10]: Copied! <pre># failed build due to missing parameters\nstyrene_fail = (\n    AntoineBuilder()\n    .set_a(styrene_coefficients['a'])\n    .build()\n)\n</pre> # failed build due to missing parameters styrene_fail = (     AntoineBuilder()     .set_a(styrene_coefficients['a'])     .build() ) <pre>[ERROR|abc_builder|L139]: Required parameter(s) not set: b, c\n</pre> <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[10], line 5\n      1 # failed build due to missing parameters\n      2 styrene_fail = (\n      3     AntoineBuilder()\n      4     .set_a(styrene_coefficients['a'])\n----&gt; 5     .build()\n      6 )\n\nFile C:\\GitHub\\particula\\particula\\next\\gas\\vapor_pressure_builders.py:73, in AntoineBuilder.build(self)\n     70 def build(self):\n     71     \"\"\"Build the AntoineVaporPressureStrategy object with the set\n     72     coefficients.\"\"\"\n---&gt; 73     self.pre_build_check()\n     74     return AntoineVaporPressureStrategy(\n     75         self.a, self.b, self.c)\n\nFile C:\\GitHub\\particula\\particula\\next\\abc_builder.py:140, in BuilderABC.pre_build_check(self)\n    136 error_message = (\n    137     f\"Required parameter(s) not set: {', '.join(missing)}\"\n    138 )\n    139 logger.error(error_message)\n--&gt; 140 raise ValueError(error_message)\n\nValueError: Required parameter(s) not set: b, c</pre> In\u00a0[11]: Copied! <pre># create a range of temperatures from 200 to 400 Kelvin\ntemperatures = np.linspace(300, 500, 100)\n\n# Calculate the vapor pressures for each substance at the range of temperatures.\nbutanol_vapor_pressure = butanol_antione.pure_vapor_pressure(temperatures)\nstyrene_vapor_pressure = styrene_antione.pure_vapor_pressure(temperatures)\nwater_vapor_pressure = water_antione.pure_vapor_pressure(temperatures)\n\n# Plot the vapor pressures for each substance.\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(temperatures, butanol_vapor_pressure, label='Butanol')\nax.plot(temperatures, styrene_vapor_pressure, label='Styrene', linestyle='--')\nax.plot(temperatures, water_vapor_pressure, label='Water', linestyle='-.')\nax.set_yscale('log')\nax.set_xlabel('Temperature (K)')\nax.set_ylabel('Pure Vapor Pressure (Pa)')\nax.set_title('Pure Vapor Pressure vs Temperature')\nax.legend()\nplt.show()\n</pre> # create a range of temperatures from 200 to 400 Kelvin temperatures = np.linspace(300, 500, 100)  # Calculate the vapor pressures for each substance at the range of temperatures. butanol_vapor_pressure = butanol_antione.pure_vapor_pressure(temperatures) styrene_vapor_pressure = styrene_antione.pure_vapor_pressure(temperatures) water_vapor_pressure = water_antione.pure_vapor_pressure(temperatures)  # Plot the vapor pressures for each substance. fig, ax = plt.subplots(figsize=(8, 6)) ax.plot(temperatures, butanol_vapor_pressure, label='Butanol') ax.plot(temperatures, styrene_vapor_pressure, label='Styrene', linestyle='--') ax.plot(temperatures, water_vapor_pressure, label='Water', linestyle='-.') ax.set_yscale('log') ax.set_xlabel('Temperature (K)') ax.set_ylabel('Pure Vapor Pressure (Pa)') ax.set_title('Pure Vapor Pressure vs Temperature') ax.legend() plt.show() In\u00a0[12]: Copied! <pre># Define the molar mass of each substance in kg/mol\nbutanol_molar_mass = 74.12e-3\nstyrene_molar_mass = 104.15e-3\nwater_molar_mass = 18.015e-3\n\n# calculate the concentration pressure vs temperature\nbutanol_saturation_concentration = butanol_antione.saturation_concentration(\n    molar_mass=butanol_molar_mass,\n    temperature=temperatures)\nstyrene_saturation_concentration = styrene_antione.saturation_concentration(\n    molar_mass=styrene_molar_mass,\n    temperature=temperatures)\nwater_saturation_concentration = water_antione.saturation_concentration(\n    molar_mass=water_molar_mass,\n    temperature=temperatures)\n\n# Plot the saturation concentrations for each substance.\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(temperatures, butanol_saturation_concentration, label='Butanol')\nax.plot(temperatures, styrene_saturation_concentration, label='Styrene', linestyle='--')\nax.plot(temperatures, water_saturation_concentration, label='Water', linestyle='-.')\nax.set_yscale('log')\nax.set_xlabel('Temperature (K)')\nax.set_ylabel('Saturation Concentration (kg/m^3)')\nax.set_title('Saturation Concentration vs Temperature')\nax.legend()\nplt.show()\n</pre> # Define the molar mass of each substance in kg/mol butanol_molar_mass = 74.12e-3 styrene_molar_mass = 104.15e-3 water_molar_mass = 18.015e-3  # calculate the concentration pressure vs temperature butanol_saturation_concentration = butanol_antione.saturation_concentration(     molar_mass=butanol_molar_mass,     temperature=temperatures) styrene_saturation_concentration = styrene_antione.saturation_concentration(     molar_mass=styrene_molar_mass,     temperature=temperatures) water_saturation_concentration = water_antione.saturation_concentration(     molar_mass=water_molar_mass,     temperature=temperatures)  # Plot the saturation concentrations for each substance. fig, ax = plt.subplots(figsize=(8, 6)) ax.plot(temperatures, butanol_saturation_concentration, label='Butanol') ax.plot(temperatures, styrene_saturation_concentration, label='Styrene', linestyle='--') ax.plot(temperatures, water_saturation_concentration, label='Water', linestyle='-.') ax.set_yscale('log') ax.set_xlabel('Temperature (K)') ax.set_ylabel('Saturation Concentration (kg/m^3)') ax.set_title('Saturation Concentration vs Temperature') ax.legend() plt.show() In\u00a0[13]: Copied! <pre># saturation concentration at 300 K\nbutanol_300K_concentration = butanol_saturation_concentration[0]\nstyrene_300K_concentration = styrene_saturation_concentration[0]\nwater_300K_concentration = water_saturation_concentration[0]\n\n# caculate the partial pressure of each substance at 300 K\nbutanol_partial_pressure = butanol_antione.partial_pressure(\n    concentration=butanol_300K_concentration,\n    molar_mass=butanol_molar_mass,\n    temperature=temperatures)\nstyrene_partial_pressure = styrene_antione.partial_pressure(\n    concentration=styrene_300K_concentration,\n    molar_mass=styrene_molar_mass,\n    temperature=temperatures)\nwater_partial_pressure = water_antione.partial_pressure(\n    concentration=water_300K_concentration,\n    molar_mass=water_molar_mass,\n    temperature=temperatures)\n\n# Plot the partial pressures for each substance.\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(temperatures, butanol_partial_pressure, label='Butanol')\nax.plot(temperatures, styrene_partial_pressure, label='Styrene', linestyle='--')\nax.plot(temperatures, water_partial_pressure, label='Water', linestyle='-.')\nax.set_yscale('log')\nax.set_xlabel('Temperature (K)')\nax.set_ylabel('Partial Pressure (Pa)')\nax.set_title('Partial Pressure vs Temperature')\nax.legend()\nplt.show()\n</pre> # saturation concentration at 300 K butanol_300K_concentration = butanol_saturation_concentration[0] styrene_300K_concentration = styrene_saturation_concentration[0] water_300K_concentration = water_saturation_concentration[0]  # caculate the partial pressure of each substance at 300 K butanol_partial_pressure = butanol_antione.partial_pressure(     concentration=butanol_300K_concentration,     molar_mass=butanol_molar_mass,     temperature=temperatures) styrene_partial_pressure = styrene_antione.partial_pressure(     concentration=styrene_300K_concentration,     molar_mass=styrene_molar_mass,     temperature=temperatures) water_partial_pressure = water_antione.partial_pressure(     concentration=water_300K_concentration,     molar_mass=water_molar_mass,     temperature=temperatures)  # Plot the partial pressures for each substance. fig, ax = plt.subplots(figsize=(8, 6)) ax.plot(temperatures, butanol_partial_pressure, label='Butanol') ax.plot(temperatures, styrene_partial_pressure, label='Styrene', linestyle='--') ax.plot(temperatures, water_partial_pressure, label='Water', linestyle='-.') ax.set_yscale('log') ax.set_xlabel('Temperature (K)') ax.set_ylabel('Partial Pressure (Pa)') ax.set_title('Partial Pressure vs Temperature') ax.legend() plt.show() In\u00a0[14]: Copied! <pre># caculate the saturation ratio\nbutanol_saturation_ratio = butanol_antione.saturation_ratio(\n    concentration=butanol_300K_concentration,\n    molar_mass=butanol_molar_mass,\n    temperature=temperatures)\nstyrene_saturation_ratio = styrene_antione.saturation_ratio(\n    concentration=styrene_300K_concentration,\n    molar_mass=styrene_molar_mass,\n    temperature=temperatures)\nwater_saturation_ratio = water_antione.saturation_ratio(\n    concentration=water_300K_concentration,\n    molar_mass=water_molar_mass,\n    temperature=temperatures)\n\n# Plot the saturation ratios for each substance.\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(temperatures, butanol_saturation_ratio, label='Butanol')\nax.plot(temperatures, styrene_saturation_ratio, label='Styrene', linestyle='--')\nax.plot(temperatures, water_saturation_ratio, label='Water', linestyle='-.')\nax.set_xlabel('Temperature (K)')\nax.set_ylabel('Saturation Ratio')\nax.set_title('Saturation Ratio vs Temperature')\nax.legend()\nplt.show()\n</pre> # caculate the saturation ratio butanol_saturation_ratio = butanol_antione.saturation_ratio(     concentration=butanol_300K_concentration,     molar_mass=butanol_molar_mass,     temperature=temperatures) styrene_saturation_ratio = styrene_antione.saturation_ratio(     concentration=styrene_300K_concentration,     molar_mass=styrene_molar_mass,     temperature=temperatures) water_saturation_ratio = water_antione.saturation_ratio(     concentration=water_300K_concentration,     molar_mass=water_molar_mass,     temperature=temperatures)  # Plot the saturation ratios for each substance. fig, ax = plt.subplots(figsize=(8, 6)) ax.plot(temperatures, butanol_saturation_ratio, label='Butanol') ax.plot(temperatures, styrene_saturation_ratio, label='Styrene', linestyle='--') ax.plot(temperatures, water_saturation_ratio, label='Water', linestyle='-.') ax.set_xlabel('Temperature (K)') ax.set_ylabel('Saturation Ratio') ax.set_title('Saturation Ratio vs Temperature') ax.legend() plt.show() In\u00a0[16]: Copied! <pre># Setting a constant vapor pressure at 300 K for water\nwater_pure_at_300K = {'vapor_pressure': 1234.56}  # in Pascals (Pa)\nwater_constant_strategy = VaporPressureFactory().get_strategy(\n    strategy_type='constant', parameters=water_pure_at_300K)\n\n# Setting parameters for the Clausius-Clapeyron equation for water\nwater_clausius_clapeyron_parameters = {\n    'latent_heat': 40.7e3,  # specific latent heat J/mol\n    'temperature_initial': 300,  # Initial temperature in Kelvin\n    'pressure_initial': 1234.56  # Initial pressure in Pascals\n}\nwater_clausius_clapeyron_strategy = VaporPressureFactory().get_strategy(\n    strategy_type='clausius_clapeyron', parameters=water_clausius_clapeyron_parameters)\n\n# Using the Water Buck strategy, no additional parameters needed\nwater_buck_strategy = VaporPressureFactory().get_strategy(\n    strategy_type='water_buck')\n\n# Define a range of temperatures for which to calculate vapor pressures\ntemperatures = range(250, 500)  # From 280 K to 320 K\n\n# Calculate the pure vapor pressure at different temperatures using\n# various strategies\nwater_pure_constant = [water_constant_strategy.pure_vapor_pressure(\n    temp) for temp in temperatures]\nwater_pure_antione = [water_antione.pure_vapor_pressure(\n    temp) for temp in temperatures]\nwater_pure_clausius_clapeyron = [\n    water_clausius_clapeyron_strategy.pure_vapor_pressure(temp) for temp in temperatures]\nwater_pure_buck = [water_buck_strategy.pure_vapor_pressure(\n    temp) for temp in temperatures]\n\n# Plotting the results using Matplotlib\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(temperatures, water_pure_constant, label='Constant', linestyle='-')\nax.plot(temperatures, water_pure_antione, label='Antoine', linestyle='--')\nax.plot(temperatures, water_pure_clausius_clapeyron,\n        label='Clausius-Clapeyron', linestyle='-.')\nax.plot(temperatures, water_pure_buck, label='Buck', linestyle=':')\nax.set_yscale('log')\nax.set_ylim(bottom=1e-10)\nax.set_xlabel('Temperature (K)')\nax.set_ylabel('Pure Vapor Pressure (Pa)')\nax.set_title('Comparison of Water Vapor Pressure Calculations')\nax.legend(loc='lower right')\nplt.show()\n</pre> # Setting a constant vapor pressure at 300 K for water water_pure_at_300K = {'vapor_pressure': 1234.56}  # in Pascals (Pa) water_constant_strategy = VaporPressureFactory().get_strategy(     strategy_type='constant', parameters=water_pure_at_300K)  # Setting parameters for the Clausius-Clapeyron equation for water water_clausius_clapeyron_parameters = {     'latent_heat': 40.7e3,  # specific latent heat J/mol     'temperature_initial': 300,  # Initial temperature in Kelvin     'pressure_initial': 1234.56  # Initial pressure in Pascals } water_clausius_clapeyron_strategy = VaporPressureFactory().get_strategy(     strategy_type='clausius_clapeyron', parameters=water_clausius_clapeyron_parameters)  # Using the Water Buck strategy, no additional parameters needed water_buck_strategy = VaporPressureFactory().get_strategy(     strategy_type='water_buck')  # Define a range of temperatures for which to calculate vapor pressures temperatures = range(250, 500)  # From 280 K to 320 K  # Calculate the pure vapor pressure at different temperatures using # various strategies water_pure_constant = [water_constant_strategy.pure_vapor_pressure(     temp) for temp in temperatures] water_pure_antione = [water_antione.pure_vapor_pressure(     temp) for temp in temperatures] water_pure_clausius_clapeyron = [     water_clausius_clapeyron_strategy.pure_vapor_pressure(temp) for temp in temperatures] water_pure_buck = [water_buck_strategy.pure_vapor_pressure(     temp) for temp in temperatures]  # Plotting the results using Matplotlib fig, ax = plt.subplots(figsize=(8, 6)) ax.plot(temperatures, water_pure_constant, label='Constant', linestyle='-') ax.plot(temperatures, water_pure_antione, label='Antoine', linestyle='--') ax.plot(temperatures, water_pure_clausius_clapeyron,         label='Clausius-Clapeyron', linestyle='-.') ax.plot(temperatures, water_pure_buck, label='Buck', linestyle=':') ax.set_yscale('log') ax.set_ylim(bottom=1e-10) ax.set_xlabel('Temperature (K)') ax.set_ylabel('Pure Vapor Pressure (Pa)') ax.set_title('Comparison of Water Vapor Pressure Calculations') ax.legend(loc='lower right') plt.show() <p>The source code documentation is described under Gas</p>"},{"location":"Tutorials/Gas_Phase/Vapor_Pressure/#vapor-pressure-tutorial","title":"Vapor Pressure Tutorial\u00b6","text":"<p>Vapor pressure is defined as the pressure exerted by a vapor in equilibrium with its liquid or solid phase. It is a crucial measure for understanding the tendency of molecules to transition from the liquid phase to the gas phase. This property is particularly important in systems where an aerosol (gas phase + particle phase) is in equilibrium with both phases.</p> <p>The vapor pressure varies with temperature, and this variation can manifest in several forms. Understanding these changes is key to predicting how substances will behave under different temperature conditions.</p> <p>In this notebook, we will explore the strategies for calculating vapor pressure as implemented in the <code>vapor_pressure</code> module. These strategies are essential for accurately modeling and understanding the behavior of aerosols in equilibrium with a liquid phase.</p> <p>Wikipedia: Vapor Pressure</p>"},{"location":"Tutorials/Gas_Phase/Vapor_Pressure/#units","title":"Units\u00b6","text":"<p>All measurements and calculations in this module adhere to the base SI units:</p> <ul> <li>Molar mass is in kilograms per mole (kg/mol).</li> <li>Concentration is in kilograms per cubic meter (kg/m^3).</li> <li>Temperature is in Kelvin (K).</li> <li>Pressure is in Pascals (Pa).</li> </ul>"},{"location":"Tutorials/Gas_Phase/Vapor_Pressure/#strategies-for-vapor-pressure-calculations","title":"Strategies for Vapor Pressure Calculations\u00b6","text":"<p>In our framework, all strategies for calculating vapor pressure are encapsulated within classes that inherit from the <code>VaporPressureStrategy</code> abstract base class. This design ensures that each strategy conforms to a standardized interface, making them interchangeable and simplifying integration with other components of our modular framework.</p>"},{"location":"Tutorials/Gas_Phase/Vapor_Pressure/#core-functions","title":"Core Functions\u00b6","text":"<p>We define two primary functions that form the backbone of our vapor pressure calculations:</p> <ul> <li><p><code>calculate_partial_pressure</code>: This function computes the partial pressure of a gas given its concentration, molar mass, and temperature. It applies the ideal gas law to derive the partial pressure in Pascals (Pa).</p> </li> <li><p><code>calculate_concentration</code>: This function inversely calculates the concentration of a gas from its partial pressure, molar mass, and temperature, also using the ideal gas law.</p> </li> </ul> <p>These functions can be reused for different strategies.</p>"},{"location":"Tutorials/Gas_Phase/Vapor_Pressure/#abstract-base-class","title":"Abstract Base Class\u00b6","text":"<p>The <code>VaporPressureStrategy</code> class serves as an abstract base class that outlines the necessary methods for vapor pressure calculations:</p> <ul> <li><p><code>partial_pressure</code>: Calculates the partial pressure of a gas based on its concentration, molar mass, and temperature.</p> </li> <li><p><code>concentration</code>: Calculates the concentration of a gas based on its partial pressure, temperature, and molar mass.</p> </li> <li><p><code>saturation_ratio</code>: Computes the ratio of the current vapor pressure to the saturation vapor pressure, which indicates how \"saturated\" the gas is with respect to a given temperature.</p> </li> <li><p><code>saturation_concentration</code>: Determines the maximum concentration of a gas at saturation at a given temperature.</p> </li> <li><p><code>pure_vapor_pressure</code>: This abstract method must be implemented by each subclass to calculate the pure (saturation) vapor pressure of a gas at specific temperatures.</p> </li> </ul> <p>By structuring our vapor pressure strategies around this abstract base class, we maintain high flexibility and robustness in our approach. Each subclass can implement specific behaviors for different gases or conditions, while relying on a common set of tools and interfaces provided by the base class.</p>"},{"location":"Tutorials/Gas_Phase/Vapor_Pressure/#example-antoine-equation-vapor-pressure-strategy","title":"Example: Antoine Equation Vapor Pressure Strategy\u00b6","text":"<p>The Antoine equation is a widely used empirical formula for estimating the vapor pressure of a substance over a range of temperatures. It takes the form:</p> <p>$$ \\log_{10}(P) = A - \\frac{B}{T - C} $$</p> <p>where:</p> <ul> <li>$P$ is the vapor pressure in mmHg,</li> <li>$T$ is the temperature in Kelvin,</li> <li>$A$, $B$, and $C$ are substance-specific constants.<ul> <li>These constants are typically determined experimentally and can vary for different substances.</li> <li>The Antoine equation is often used for organic compounds and provides a good approximation of vapor pressure behavior, over a limited temperature range.</li> </ul> </li> </ul> <p>We will implement this for the following substances, using constants from link:</p> <ul> <li><p>n-Butanol: \"Formula\": \"C4H10O\", \"A\": 7.838, \"B\": 1558.190, \"C\": 196.881</p> </li> <li><p>Styrene: \"Formula\": \"C8H8\", \"A\": 6.92409, \"B\": 1420, \"C\": 226</p> </li> <li><p>Water: \"Formula\": \"H2O\", \"A\": 7.94917, \"B\": 1657.462, \"C\": 227.02</p> </li> </ul>"},{"location":"Tutorials/Gas_Phase/Vapor_Pressure/#direct-strategy-builder-and-factory-patterns","title":"Direct Strategy, Builder, and Factory Patterns\u00b6","text":"<p>We will demonstrate the use of the direct, builder, and factory patterns to create instances of the <code>AntoineVaporPressure</code> strategy. These patterns provide different levels of abstraction and flexibility in object creation, catering to various use cases and design requirements.</p> <ul> <li>Direct Strategy: This involves directly creating instances of the <code>AntoineVaporPressure</code> class with the required parameters. It is straightforward but may be less flexible when dealing with complex object creation or configuration.</li> <li>Builder Pattern: The builder pattern separates the construction of a complex object from its representation, allowing for more flexible and readable object creation. We will use a <code>VaporPressureBuilder</code> class to construct instances of the <code>AntoineVaporPressure</code> strategy with different parameters. The parameters can be set in any order, and the builder provides a clear and intuitive way to create objects.</li> <li>Factory Pattern: The factory pattern provides an interface for creating objects without specifying the exact class of the object to be created. We will use a <code>VaporPressureFactory</code> class to create instances of the <code>AntoineVaporPressure</code> strategy based on the substance name. This pattern allows for dynamic object creation based on input parameters, enhancing flexibility and extensibility.</li> </ul>"},{"location":"Tutorials/Gas_Phase/Vapor_Pressure/#builder-validation","title":"Builder Validation\u00b6","text":"<p>Here we call the <code>AntoineBuilder</code> pattern, with incomplete parameters, to demonstrate the error handling mechanism.</p>"},{"location":"Tutorials/Gas_Phase/Vapor_Pressure/#temperature-variation","title":"Temperature Variation\u00b6","text":"<p>With the vapor pressure strategy implemented, we can now explore how the vapor pressure of these substances varies with temperature. We will plot the vapor pressure curves for n-Butanol, Styrene, and Water over a range of temperatures to observe their behavior.</p>"},{"location":"Tutorials/Gas_Phase/Vapor_Pressure/#saturation-concentration","title":"Saturation Concentration\u00b6","text":"<p>We will also calculate the concentration of these substances at different temperatures. The saturation concentration represents the maximum amount of a substance that can be in a gas at a given temperature. By examining how the saturation concentration changes with temperature, we can gain insights into the solubility and volatility of these substances.</p> <p>$$ C = \\frac{P_{pure}M}{RT} $$</p> <p>where:</p> <ul> <li>$C$ is the concentration in kg/m^3,</li> <li>$P_{pure}$ is the pure vapor pressure in Pa, (also known as $P_{sat}$, or $P_{0}$),</li> <li>$M$ is the molar mass in kg/mol,</li> <li>$R$ is the ideal gas constant (8.314 J/(mol K)),</li> <li>$T$ is the temperature in Kelvin.</li> </ul> <p>In the case of water, the saturation ratio can be used to determine the relative humidity of the air, as it is a key factor in weather and climate models.</p> <p>We can do this calculation from the directly from the vapor pressure strategy, as it is a common in the abstract base class. So even if we change how the vapor pressure is calculated, we can still use the same method to calculate the saturation concentration.</p>"},{"location":"Tutorials/Gas_Phase/Vapor_Pressure/#partial-pressure","title":"Partial Pressure\u00b6","text":"<p>The partial pressure of a gas is the pressure that the gas would exert if it occupied the entire volume alone. It is a key concept in understanding gas mixtures and the behavior of gases in equilibrium. The partial pressure of a gas is proportional to its concentration and temperature, as described by the ideal gas law.</p> <p>$$ P_{partial} = \\frac{C R T}{M} $$</p> <p>where:</p> <ul> <li>$P_{partial}$ is the partial pressure in Pascals (Pa),</li> <li>$C$ is the concentration of the gas in kg/m^3,</li> <li>$R$ is the ideal gas constant (8.314 J/(mol K)),</li> <li>$T$ is the temperature in Kelvin,</li> <li>$M$ is the molar mass of the gas in kg/mol.</li> </ul> <p>We can use the <code>calculate_partial_pressure</code> method from the vapor pressure strategy to calculate the partial pressure of a gas given its concentration, molar mass, and temperature. This calculation is essential for understanding the behavior of gas mixtures and the distribution of gases in a system.</p> <p>We will use the partial pressure at 300 K and calculate how it changes with temperature for the three substances.</p>"},{"location":"Tutorials/Gas_Phase/Vapor_Pressure/#saturation-ratio","title":"Saturation Ratio\u00b6","text":"<p>The saturation ratio is the ratio of a gas's current vapor pressure to its saturation vapor pressure at a specific temperature. This ratio helps determine how \"saturated\" the gas is with respect to the substance it is in equilibrium with. A saturation ratio of 1 implies that the gas is at equilibrium with the liquid phase. Values less than 1 indicate that the gas is sub-saturated (less than equilibrium), and values greater than 1 indicate supersaturation (more than equilibrium).</p> <p>$$ SR = \\frac{P}{P_{sat}} $$</p> <p>where:</p> <ul> <li>$SR$ is the saturation ratio,</li> <li>$P$ is the partial pressure of the gas,</li> <li>$P_{sat}$ is the saturation vapor pressure of the gas at the given temperature.</li> </ul> <p>To calculate the saturation ratio, we use the concentration of the gas and compare it to the saturation concentration. We calculate the partial pressure from the concentration and the saturation concentration, and then calculate the saturation ratio.</p> <p>We will start with the gas's initial concentration at 300K and calculate the saturation ratio at various temperatures while keeping the concentration constant.</p> <p>This method simulates the behavior of a gas that is initially at equilibrium with its liquid phase at 300K. If the temperature changes but the concentration remains constant, the saturation ratio will begin at 1 and typically decrease as the temperature increases. This decrease reflects the gas moving from a state of equilibrium to a state of sub-saturation as it becomes less capable of remaining in the liquid phase at higher temperatures.</p>"},{"location":"Tutorials/Gas_Phase/Vapor_Pressure/#other-strategies","title":"Other Strategies\u00b6","text":"<p>In addition to the common methods shared across all vapor pressure strategies, we have several specialized strategies that can be employed to calculate vapor pressure based on different principles:</p> <ul> <li>Constant: This strategy applies a fixed value for the vapor pressure, regardless of external conditions.</li> <li>Antoine: Utilizes the Antoine equation to determine the vapor pressure of a substance, adjusting based on temperature changes.</li> <li>Clausius_Clapeyron: Employs the Clausius-Clapeyron equation to estimate changes in vapor pressure in response to temperature variations.</li> <li>Water_Buck: Specifically designed for water, this strategy uses the Buck equation to calculate vapor pressure accurately.</li> </ul> <p>We will apply these different strategies to calculate the pure vapor pressure of water and observe how the values vary with temperature.</p>"},{"location":"Tutorials/Gas_Phase/Vapor_Pressure/#consistency-across-methods","title":"Consistency Across Methods\u00b6","text":"<p>Despite using different calculation strategies, the method calls remain consistent. This uniformity allows for straightforward substitutions between methods without altering the structure of the code.</p>"},{"location":"Tutorials/Gas_Phase/Vapor_Pressure/#summary","title":"Summary\u00b6","text":"<p>In this notebook, we covered how the strategies for vapor pressure calculations are implemented in our system. By using an abstract base class and common core functions, we ensure that each strategy adheres to a standardized interface and can be easily integrated into our framework. We explored the Antoine equation vapor pressure strategy for n-Butanol, Styrene, and Water, examining how their vapor pressures and saturation concentrations change with temperature. We calculated the partial pressure, saturation ratio, and saturation concentration for these substances, providing insights into their behavior in gas-phase systems. Finally, we demonstrated the consistency and flexibility of our approach by applying different vapor pressure strategies to calculate the vapor pressure of water and observing how the values vary with temperature.</p> <p>This modular and extensible design allows us to incorporate various vapor pressure calculation methods while maintaining a consistent interface and ensuring robustness and flexibility in our system.</p>"},{"location":"Tutorials/Particle_Phase/","title":"Index: Particle Phase","text":""},{"location":"Tutorials/Particle_Phase/#notebooks","title":"Notebooks","text":"<ul> <li>Aerosol Surface Tutorial</li> <li>Activity Tutorial</li> <li>Distribution Tutorial</li> <li>Types of Distributions Tutorial</li> <li>Particle Representation Tutorial</li> </ul>"},{"location":"Tutorials/Particle_Phase/#functional-representation","title":"Functional Representation","text":"<ul> <li>Activity Functions</li> </ul>"},{"location":"Tutorials/Particle_Phase/Activity_Tutorial/","title":"Activity Tutorial","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\nfrom particula.next.particles.activity_strategies import IdealActivityMass\nfrom particula.next.particles.activity_builders import IdealActivityMolarBuilder\nfrom particula.next.particles.activity_factories import ActivityFactory\n</pre> import numpy as np import matplotlib.pyplot as plt  from particula.next.particles.activity_strategies import IdealActivityMass from particula.next.particles.activity_builders import IdealActivityMolarBuilder from particula.next.particles.activity_factories import ActivityFactory In\u00a0[2]: Copied! <pre>activity_mass = IdealActivityMass()  # no parameters needed\n\n# mixture\nmass_mixture = np.array([0.2, 0.8])  # water, sucrose\n\nactivities = activity_mass.activity(mass_concentration=mass_mixture)\nprint(f\"Activities: {activities}\")\n\n# partial pressures\npure_pressure = np.array([100, 10])  # water, sucrose\npartial_pressures = activity_mass.partial_pressure(pure_vapor_pressure=pure_pressure, mass_concentration=mass_mixture)\n\nprint(f\"Partial pressures: {partial_pressures}\")\n</pre> activity_mass = IdealActivityMass()  # no parameters needed  # mixture mass_mixture = np.array([0.2, 0.8])  # water, sucrose  activities = activity_mass.activity(mass_concentration=mass_mixture) print(f\"Activities: {activities}\")  # partial pressures pure_pressure = np.array([100, 10])  # water, sucrose partial_pressures = activity_mass.partial_pressure(pure_vapor_pressure=pure_pressure, mass_concentration=mass_mixture)  print(f\"Partial pressures: {partial_pressures}\") <pre>Activities: [0.2 0.8]\nPartial pressures: [20.  8.]\n</pre> In\u00a0[3]: Copied! <pre>activity_molar = (\n    IdealActivityMolarBuilder()\n    .set_molar_mass(np.array([18.01528, 342.29648]))  # water, sucrose\n    .build()\n)\n\n# mixture\nactivities = activity_molar.activity(mass_concentration=mass_mixture)\nprint(f\"Activities: {activities}\")\n\n# partial pressures\npure_pressure = np.array([100, 10])  # water, sucrose\npartial_pressures = activity_molar.partial_pressure(pure_vapor_pressure=pure_pressure, mass_concentration=mass_mixture)\n\nprint(f\"Partial pressures: {partial_pressures}\")\n</pre> activity_molar = (     IdealActivityMolarBuilder()     .set_molar_mass(np.array([18.01528, 342.29648]))  # water, sucrose     .build() )  # mixture activities = activity_molar.activity(mass_concentration=mass_mixture) print(f\"Activities: {activities}\")  # partial pressures pure_pressure = np.array([100, 10])  # water, sucrose partial_pressures = activity_molar.partial_pressure(pure_vapor_pressure=pure_pressure, mass_concentration=mass_mixture)  print(f\"Partial pressures: {partial_pressures}\") <pre>Activities: [0.82608954 0.17391046]\nPartial pressures: [82.6089542   1.73910458]\n</pre> In\u00a0[4]: Copied! <pre>parameters_input={\n    \"density\": np.array([1000, 1500]),  # water, sucrose, kg/m^3 are the base SI default units\n    \"molar_mass\": np.array([18.01528, 342.29648]),  # water, sucrose\n    \"molar_mass_units\": \"g/mol\",  # this tells the factory what the input units are so it can convert to kg/mol\n    \"kappa\": np.array([0, 0.3]),  # water, sucrose\n    \"water_index\": 0  # water is the first component\n}\n\nactivity_kappa = ActivityFactory().get_strategy(\n    strategy_type=\"kappa\",\n    parameters=parameters_input\n)\n\n# mixture\nactivities = activity_kappa.activity(mass_concentration=mass_mixture)\nprint(f\"Activities: {activities}\")\n\n# partial pressures\npure_pressure = np.array([100, 10])  # water, sucrose\npartial_pressures = activity_kappa.partial_pressure(pure_vapor_pressure=pure_pressure, mass_concentration=mass_mixture)\n\nprint(f\"Partial pressures: {partial_pressures}\")\n</pre> parameters_input={     \"density\": np.array([1000, 1500]),  # water, sucrose, kg/m^3 are the base SI default units     \"molar_mass\": np.array([18.01528, 342.29648]),  # water, sucrose     \"molar_mass_units\": \"g/mol\",  # this tells the factory what the input units are so it can convert to kg/mol     \"kappa\": np.array([0, 0.3]),  # water, sucrose     \"water_index\": 0  # water is the first component }  activity_kappa = ActivityFactory().get_strategy(     strategy_type=\"kappa\",     parameters=parameters_input )  # mixture activities = activity_kappa.activity(mass_concentration=mass_mixture) print(f\"Activities: {activities}\")  # partial pressures pure_pressure = np.array([100, 10])  # water, sucrose partial_pressures = activity_kappa.partial_pressure(pure_vapor_pressure=pure_pressure, mass_concentration=mass_mixture)  print(f\"Partial pressures: {partial_pressures}\") <pre>Activities: [0.55555556 0.17391046]\nPartial pressures: [55.55555556  1.73910458]\n</pre> In\u00a0[6]: Copied! <pre>mass_water = np.linspace(0.001, 0.9999, 100)\nmass_sucrose = 1 - mass_water\nmass_mixture = np.array([mass_water, mass_sucrose]).T\n\nactivities_mass = np.zeros_like(mass_mixture)\nactivities_molar = np.zeros_like(mass_mixture)\nactivities_kappa = np.zeros_like(mass_mixture)\n\n\nfor i, mass in enumerate(mass_mixture):\n    activities_mass[i] = activity_mass.activity(mass_concentration=mass)\n    activities_molar[i] = activity_molar.activity(mass_concentration=mass)\n    activities_kappa[i] = activity_kappa.activity(mass_concentration=mass)\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(mass_water, activities_mass[:, 0], label=\"Mass: Water\")\nax.plot(mass_water, activities_mass[:, 1], label=\"Mass: Sucrose\", linestyle=\"--\")\nax.plot(mass_water, activities_molar[:, 0], label=\"Molar: Water\")\nax.plot(mass_water, activities_molar[:, 1], label=\"Molar: Sucrose\", linestyle=\"--\", linewidth=3, alpha=0.85)\nax.plot(mass_water, activities_kappa[:, 0], label=\"Kappa: Water\")\nax.plot(mass_water, activities_kappa[:, 1], label=\"Kappa: Sucrose\", linestyle=\"--\")\nax.set_xlabel(\"Mass fraction water\")\nax.set_ylabel(\"Activity\")\nax.legend()\nplt.show()\n</pre> mass_water = np.linspace(0.001, 0.9999, 100) mass_sucrose = 1 - mass_water mass_mixture = np.array([mass_water, mass_sucrose]).T  activities_mass = np.zeros_like(mass_mixture) activities_molar = np.zeros_like(mass_mixture) activities_kappa = np.zeros_like(mass_mixture)   for i, mass in enumerate(mass_mixture):     activities_mass[i] = activity_mass.activity(mass_concentration=mass)     activities_molar[i] = activity_molar.activity(mass_concentration=mass)     activities_kappa[i] = activity_kappa.activity(mass_concentration=mass)  fig, ax = plt.subplots(figsize=(8, 6)) ax.plot(mass_water, activities_mass[:, 0], label=\"Mass: Water\") ax.plot(mass_water, activities_mass[:, 1], label=\"Mass: Sucrose\", linestyle=\"--\") ax.plot(mass_water, activities_molar[:, 0], label=\"Molar: Water\") ax.plot(mass_water, activities_molar[:, 1], label=\"Molar: Sucrose\", linestyle=\"--\", linewidth=3, alpha=0.85) ax.plot(mass_water, activities_kappa[:, 0], label=\"Kappa: Water\") ax.plot(mass_water, activities_kappa[:, 1], label=\"Kappa: Sucrose\", linestyle=\"--\") ax.set_xlabel(\"Mass fraction water\") ax.set_ylabel(\"Activity\") ax.legend() plt.show()"},{"location":"Tutorials/Particle_Phase/Activity_Tutorial/#activity-tutorial","title":"Activity Tutorial\u00b6","text":"<p>This Jupyter notebook is designed to deepen your understanding of mixing behaviors in solutions, focusing on both theoretical models and practical applications. We will explore ideal and non-ideal mixing rules, differentiate between mass-based and molar-based approaches, and introduce the kappa value parameterization for predicting water activity.</p>"},{"location":"Tutorials/Particle_Phase/Activity_Tutorial/#introduction-to-mixing-rules","title":"Introduction to Mixing Rules\u00b6","text":"<p>Mixing rules are essential for predicting the properties of solutions, including their thermodynamic behavior and phase equilibria. In this notebook, we will:</p> <ul> <li>Define and compare different mixing rules: Understand how various rules apply to different types of solutions.</li> <li>Mass-Based vs. Molar-Based Mixing: Discuss the implications of choosing mass-based or molar-based calculations for different applications.</li> <li>Kappa Value based Activity: Learn about the kappa value parameterization and its role in modeling water activity in non-ideal solutions.</li> </ul>"},{"location":"Tutorials/Particle_Phase/Activity_Tutorial/#structure-of-the-notebook","title":"Structure of the Notebook\u00b6","text":"<ol> <li><p>Mass-Based vs. Molar-Based Mixing</p> <ul> <li>Definitions and when to use each method</li> <li>Examples and comparative analysis</li> </ul> </li> <li><p>Kappa Value Parameterization</p> <ul> <li>Theory behind kappa values</li> <li>Practical exercises on calculating water activity</li> </ul> </li> </ol>"},{"location":"Tutorials/Particle_Phase/Activity_Tutorial/#strategies-builders-and-factories","title":"Strategies, Builders, and Factories\u00b6","text":"<p>We'll show examples for getting the strategy directly, form a builder, and from a factory.</p>"},{"location":"Tutorials/Particle_Phase/Activity_Tutorial/#strategy-ideal-activity-mass-based-mixing","title":"Strategy: Ideal Activity Mass-Based Mixing\u00b6","text":"<p>The ideal in this context refers to all the activity coefficients being equal to 1. This is the simplest case and is often used as a reference point for more complex models. In this case, then we are just mixing based on mass fractions in the solution. Let's start witha mixture of water and sucrose.</p> <p>With an Ideal mass based mixing rule, the activity and partial pressure reduction is just the mass fraction of the component in the mixture.</p>"},{"location":"Tutorials/Particle_Phase/Activity_Tutorial/#builder-molar-based-mixing","title":"Builder: Molar-Based Mixing\u00b6","text":"<p>All strategies have a builder method that can be used to create a new strategy with different parameters. In this case, we will create a molar-based mixing rule using the builder method.</p> <p>Using the same mixture of water and sucrose, we will now calculate the activity and partial pressure reduction based on molar fractions in the solution. We should see a large effect due to the difference in molecular weight between water and sucrose.</p>"},{"location":"Tutorials/Particle_Phase/Activity_Tutorial/#factory-kappa-value-parameterization","title":"Factory: Kappa Value Parameterization\u00b6","text":"<p>Lastly, we will use the factory method to create a kappa value parameterization for predicting water activity in non-ideal solutions. This method is more complex and requires additional parameters to be defined. We will use the same water-sucrose mixture to demonstrate the kappa value approach.</p>"},{"location":"Tutorials/Particle_Phase/Activity_Tutorial/#plotting-mixing-rules","title":"Plotting Mixing Rules\u00b6","text":"<p>We will plot the activity and partial pressure reduction for the water-sucrose mixture using the ideal mass-based mixing rule, molar-based mixing rule, and kappa value parameterization. This will help us visualize the differences between the three methods and understand how they affect the prediction of water activity in the solution.</p> <p>Note: Only water is treated non-ideally in the kappa value parameterization. The other species are treated in a molar-based ideal mixing rule.</p>"},{"location":"Tutorials/Particle_Phase/Activity_Tutorial/#summary","title":"Summary\u00b6","text":"<p>By the end of this notebook, you should have a better understanding of mixing rules, mass-based vs. molar-based calculations, and the kappa value parameterization for predicting water activity in non-ideal solutions. You will also have learned how to apply these concepts to practical examples and visualize the results using plots.</p> <p>You saw how different mixing rules can be used to predict the properties of solutions and how they can affect the accuracy of the predictions. You also learned about the kappa value parameterization and how it can be used to model water activity in non-ideal solutions. These concepts are essential for condensation and phase equilibrium calculations when aerosol particles are present in the atmosphere.</p>"},{"location":"Tutorials/Particle_Phase/Aerosol_Distributions/","title":"Size Distributions Tutorial","text":"In\u00a0[1]: Copied! <pre># %%\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom particula.next.particles.properties.lognormal_size_distribution import (\n    lognormal_pdf_distribution,\n    lognormal_pmf_distribution,\n)\n</pre> # %% import numpy as np import matplotlib.pyplot as plt  from particula.next.particles.properties.lognormal_size_distribution import (     lognormal_pdf_distribution,     lognormal_pmf_distribution, ) In\u00a0[2]: Copied! <pre># Define the x_values as a range of particle diameters\nx_values = np.logspace(-3, 1, 2000)  # From 0.001 to 10 microns\n</pre> # Define the x_values as a range of particle diameters x_values = np.logspace(-3, 1, 2000)  # From 0.001 to 10 microns In\u00a0[3]: Copied! <pre># %%\n# Single mode distribution\nsingle_mode_gsd = np.array([1.4])\nsingle_mode = np.array([0.02])\nsingle_mode_nparticles = np.array([1e3])\n\nsingle_mode_distribution = lognormal_pdf_distribution(\n    x_values, single_mode, single_mode_gsd, single_mode_nparticles\n)\n</pre> # %% # Single mode distribution single_mode_gsd = np.array([1.4]) single_mode = np.array([0.02]) single_mode_nparticles = np.array([1e3])  single_mode_distribution = lognormal_pdf_distribution(     x_values, single_mode, single_mode_gsd, single_mode_nparticles ) In\u00a0[4]: Copied! <pre># %%\n# Multi-mode distribution\nmulti_mode_gsd = np.array([1.4, 1.8])\nmulti_mode = np.array([0.02, 1.0])\nmulti_mode_nparticles = np.array([1e3, 1e3])\n\nmulti_mode_distribution = lognormal_pdf_distribution(\n    x_values, multi_mode, multi_mode_gsd, multi_mode_nparticles\n)\n</pre> # %% # Multi-mode distribution multi_mode_gsd = np.array([1.4, 1.8]) multi_mode = np.array([0.02, 1.0]) multi_mode_nparticles = np.array([1e3, 1e3])  multi_mode_distribution = lognormal_pdf_distribution(     x_values, multi_mode, multi_mode_gsd, multi_mode_nparticles ) In\u00a0[5]: Copied! <pre># %%\nplt.figure(figsize=(10, 6))\nplt.plot(x_values, single_mode_distribution, label=\"Single Mode\", linewidth=4)\nplt.plot(x_values, multi_mode_distribution, label=\"Multi Mode\")\nplt.title(\"Lognormal Particle Size Distribution\")\nplt.xlabel(\"Particle Diameter (\u03bcm)\")\nplt.ylabel(\"Frequency\")\nplt.xscale(\"log\")\nplt.legend()\nplt.grid(True)\nplt.show()\n</pre> # %% plt.figure(figsize=(10, 6)) plt.plot(x_values, single_mode_distribution, label=\"Single Mode\", linewidth=4) plt.plot(x_values, multi_mode_distribution, label=\"Multi Mode\") plt.title(\"Lognormal Particle Size Distribution\") plt.xlabel(\"Particle Diameter (\u03bcm)\") plt.ylabel(\"Frequency\") plt.xscale(\"log\") plt.legend() plt.grid(True) plt.show() In\u00a0[6]: Copied! <pre># %%\nsingle_mode_total_concentration = np.trapz(single_mode_distribution, x_values)\nmulti_mode_total_concentration = np.trapz(multi_mode_distribution, x_values)\n\nprint(\n    f\"Total Concentration for Single Mode: {single_mode_total_concentration}\"\n)\nprint(f\"Total Concentration for Multi Mode: {multi_mode_total_concentration}\")\n</pre> # %% single_mode_total_concentration = np.trapz(single_mode_distribution, x_values) multi_mode_total_concentration = np.trapz(multi_mode_distribution, x_values)  print(     f\"Total Concentration for Single Mode: {single_mode_total_concentration}\" ) print(f\"Total Concentration for Multi Mode: {multi_mode_total_concentration}\") <pre>Total Concentration for Single Mode: 1000.0\nTotal Concentration for Multi Mode: 2000.000000000001\n</pre> In\u00a0[7]: Copied! <pre>single_pmf_distribution = lognormal_pmf_distribution(\n    x_values, single_mode, single_mode_gsd, single_mode_nparticles\n)\nmulti_pmf_distribution = lognormal_pmf_distribution(\n    x_values, multi_mode, multi_mode_gsd, multi_mode_nparticles\n)\n</pre> single_pmf_distribution = lognormal_pmf_distribution(     x_values, single_mode, single_mode_gsd, single_mode_nparticles ) multi_pmf_distribution = lognormal_pmf_distribution(     x_values, multi_mode, multi_mode_gsd, multi_mode_nparticles ) In\u00a0[8]: Copied! <pre>plt.figure(figsize=(10, 6))\nplt.plot(x_values, single_pmf_distribution, label=\"Single Mode\", linewidth=4)\nplt.plot(x_values, multi_pmf_distribution, label=\"Multi Mode\")\nplt.title(\"Lognormal PMF Particle Size Distribution\")\nplt.xlabel(\"Particle Diameter (\u03bcm)\")\nplt.ylabel(\"Number of Particles\")\nplt.xscale(\"log\")\nplt.legend()\nplt.grid(True)\nplt.show()\n</pre> plt.figure(figsize=(10, 6)) plt.plot(x_values, single_pmf_distribution, label=\"Single Mode\", linewidth=4) plt.plot(x_values, multi_pmf_distribution, label=\"Multi Mode\") plt.title(\"Lognormal PMF Particle Size Distribution\") plt.xlabel(\"Particle Diameter (\u03bcm)\") plt.ylabel(\"Number of Particles\") plt.xscale(\"log\") plt.legend() plt.grid(True) plt.show() In\u00a0[9]: Copied! <pre># %%\nsingle_mode_total_concentration = single_pmf_distribution.sum()\nmulti_mode_total_concentration = multi_pmf_distribution.sum()\n\nprint(\n    f\"Total Concentration for Single Mode: {single_mode_total_concentration}\"\n)\nprint(f\"Total Concentration for Multi Mode: {multi_mode_total_concentration}\")\n</pre> # %% single_mode_total_concentration = single_pmf_distribution.sum() multi_mode_total_concentration = multi_pmf_distribution.sum()  print(     f\"Total Concentration for Single Mode: {single_mode_total_concentration}\" ) print(f\"Total Concentration for Multi Mode: {multi_mode_total_concentration}\") <pre>Total Concentration for Single Mode: 1000.0000000000002\nTotal Concentration for Multi Mode: 1999.999999999999\n</pre>"},{"location":"Tutorials/Particle_Phase/Aerosol_Distributions/#size-distributions-tutorial","title":"Size Distributions Tutorial\u00b6","text":"<p>In this tutorial, we will explore how to calculate and plot lognormal distributions for aerosol particles. This is commonly used in aerosol science to model the size distribution of particles in different environmental or experimental conditions.</p>"},{"location":"Tutorials/Particle_Phase/Aerosol_Distributions/#probability-density-function","title":"Probability Density Function\u00b6","text":"<p>(fix this, more details for aerosol science)</p> <p>The probability density function (PDF) of a lognormal distribution is given by:</p> <p>$$ f(x, s) = \\frac{1}{s x \\sqrt{2\\pi}} \\exp\\left(-\\frac{\\log^2(x)}{2s^2}\\right)  $$</p> <p>where $x$ is the particle diameter, and $s$ is the standard deviation of the distribution. $$ for x &gt; 0, s &gt; 0 $$</p> <p>The <code>scale</code> parameter is defined as the mode of the distribution.</p> <p>The probability density above is defined in the \u201cstandardized\u201d form. To shift and/or scale the distribution use the loc and scale parameters. Specifically, <code>lognorm.pdf(x, s, loc, scale)</code> is identically equivalent to <code>lognorm.pdf(y, s) / scale</code> with <code>y = (x - loc) / scale</code>. Note that shifting the location of a distribution does not make it a \u201cnoncentral\u201d distribution; noncentral generalizations of some distributions are available in separate classes.</p> <ul> <li>PDF Wikipedia</li> <li>Log-normal Wikipedia</li> <li>Log-normal Scipy</li> </ul>"},{"location":"Tutorials/Particle_Phase/Aerosol_Distributions/#define-particle-size-ranges","title":"Define Particle Size Ranges\u00b6","text":"<p>We use logarithmic spacing for particle diameters to cover a broad size range typically observed in aerosol particles.</p>"},{"location":"Tutorials/Particle_Phase/Aerosol_Distributions/#single-mode-pdf-particle-size-distribution","title":"Single Mode PDF Particle Size Distribution\u00b6","text":"<p>In this section, we explore modeling a distribution with a single mode, typical for scenarios where particle populations are relatively uniform. The single mode represents a common characteristic size (mode) and spread (geometric standard deviation) of aerosol particles. We utilize parameters for the geometric standard deviation and the modal particle diameter to define this distribution. The distribution is scaled such that the area under the probability density function (PDF) equals the total number of particles, ensuring that it accurately reflects the particle count in terms of probability across different sizes. This method is particularly useful for representing aerosol populations where a single predominant size class exists, making it easier to analyze and predict aerosol behavior in environmental or laboratory settings.</p>"},{"location":"Tutorials/Particle_Phase/Aerosol_Distributions/#multi-mode-pdf-particle-distribution","title":"Multi-Mode PDF Particle Distribution\u00b6","text":"<p>For more complex scenarios, such as urban air samples, we often observe multiple modes. Here we define and calculate distributions for a two-mode system.</p>"},{"location":"Tutorials/Particle_Phase/Aerosol_Distributions/#plotting-the-pdfs-of-particle-size-distributions","title":"Plotting the PDFs of Particle Size Distributions\u00b6","text":"<p>Visualizing the probability density functions (PDFs) helps in understanding the frequency of different particle sizes.</p>"},{"location":"Tutorials/Particle_Phase/Aerosol_Distributions/#calculate-and-display-total-concentration-from-pdfs","title":"Calculate and Display Total Concentration from PDFs\u00b6","text":"<p>Total concentration is important for understanding the overall particle load in a sample.</p>"},{"location":"Tutorials/Particle_Phase/Aerosol_Distributions/#probability-mass-function-pmf-for-aerosol-distributions","title":"Probability Mass Function (PMF) for Aerosol Distributions\u00b6","text":"<p>The Probability Mass Function (PMF) of aerosol distributions provides a distinct perspective compared to the Probability Density Function (PDF). While the PDF represents the probability of particle sizes occurring within a continuous range, ensuring that the integral over all sizes equals the total number of particles, the PMF deals directly with discrete particle counts.</p> <p>In PMF, each value represents the actual number of particles expected at a specific size interval, rather than the probability density. This approach is particularly advantageous when quantifying and visualizing the actual particle counts across various size classes, making it ideal for detailed statistical analysis and practical applications like filter testing or health impact studies.</p> <p>Unlike the PDF, where the area under the curve corresponds to the total number of particles (when scaled appropriately), the PMF sums directly to the total number of particles without needing any integral calculation. Each point on the PMF curve directly indicates the number of particles in that particular size class, thus providing a more intuitive grasp of the size distribution's impact, especially in contexts where the exact count of particles is more relevant than their probability density.</p> <p>PMF Wikipedia</p>"},{"location":"Tutorials/Particle_Phase/Aerosol_Distributions/#plotting-the-pmfs-of-particle-size-distributions","title":"Plotting the PMFs of Particle Size Distributions\u00b6","text":"<p>Particle mass functions (PMFs) tell us about the actual number of particles at different sizes.</p>"},{"location":"Tutorials/Particle_Phase/Aerosol_Distributions/#calculate-and-display-total-number-of-particles-from-pmfs","title":"Calculate and Display Total Number of Particles from PMFs\u00b6","text":"<p>This helps quantify the actual particle count in different modes.</p>"},{"location":"Tutorials/Particle_Phase/Aerosol_Distributions/#summary-of-pdf-vs-pmf-in-aerosol-distributions","title":"Summary of PDF vs. PMF in Aerosol Distributions\u00b6","text":"<p>In this tutorial, we explored two fundamental representations of aerosol size distributions: the Probability Density Function (PDF) and the Particle Mass Function (PMF). Both offer valuable insights into aerosol characteristics but serve different analytical purposes:</p> <ul> <li><p>Probability Density Function (PDF): The PDF provides a normalized view of particle size distribution where the area under the curve represents the total number of particles. It is ideal for understanding the relative frequency of different particle sizes within a continuous range and for conducting probability-based analyses. The PDF is particularly useful in theoretical studies and simulations where understanding the likelihood of particle sizes is crucial.</p> </li> <li><p>Particle Mass Function (PMF): Conversely, the PMF directly quantifies the actual number of particles in each size interval. This discrete representation is especially useful for practical applications such as air quality monitoring and aerosol delivery systems where knowing the exact count of particles at different sizes is necessary. The PMF is straightforward as it adds up to the total particle count directly, providing a more tangible grasp of particle distribution without requiring integration.</p> </li> </ul> <p>Both methods play critical roles in aerosol science, each complementing the other by offering different perspectives on particle size distributions. Understanding when to use each can significantly enhance the accuracy and relevance of aerosol studies.</p>"},{"location":"Tutorials/Particle_Phase/Aerosol_Distributions/#looking-ahead","title":"Looking Ahead\u00b6","text":"<p>In the upcoming tutorial, we will delve into another essential concept in aerosol science: the scaling and measurement of aerosol distributions using ( \\frac{dN}{d\\log D_p} ) (number concentration per unit of log-diameter interval). This approach provides a deeper understanding of how particle sizes are distributed across logarithmic size intervals, which is crucial for comparing aerosol measurements obtained from different instruments and studies. Stay tuned to explore how this scaling method enhances our ability to characterize and compare aerosol distributions effectively.</p>"},{"location":"Tutorials/Particle_Phase/Distribution_Tutorial/","title":"Distribution Strategy Tutorial","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\nfrom particula.next.particles.distribution_strategies import MassBasedMovingBin\nfrom particula.next.particles.distribution_builders import RadiiBasedMovingBinBuilder\nfrom particula.next.particles.distribution_factories import DistributionFactory\n</pre> import numpy as np import matplotlib.pyplot as plt  from particula.next.particles.distribution_strategies import MassBasedMovingBin from particula.next.particles.distribution_builders import RadiiBasedMovingBinBuilder from particula.next.particles.distribution_factories import DistributionFactory In\u00a0[2]: Copied! <pre>mass_distribution = np.linspace(0, 10, 5)  # kg\ndensity = 1000  # kg/m^3\n\nradius = MassBasedMovingBin().get_radius(mass_distribution, density)\nprint(f\"Radius of the particles: {radius} m\")\n\ntotal_mass = MassBasedMovingBin().get_total_mass(\n    mass_distribution, concentration=np.ones_like(mass_distribution), density=density)\nprint(f\"Total mass of the particles: {total_mass} kg\")\nprint(f\"Same as the sum*concentration: {np.sum(mass_distribution)} kg\")\n</pre> mass_distribution = np.linspace(0, 10, 5)  # kg density = 1000  # kg/m^3  radius = MassBasedMovingBin().get_radius(mass_distribution, density) print(f\"Radius of the particles: {radius} m\")  total_mass = MassBasedMovingBin().get_total_mass(     mass_distribution, concentration=np.ones_like(mass_distribution), density=density) print(f\"Total mass of the particles: {total_mass} kg\") print(f\"Same as the sum*concentration: {np.sum(mass_distribution)} kg\") <pre>Radius of the particles: [0.         0.08419452 0.10607844 0.1214295  0.13365046] m\nTotal mass of the particles: 25.0 kg\nSame as the sum*concentration: 25.0 kg\n</pre> In\u00a0[3]: Copied! <pre>radii_distribution = np.linspace(0, 0.1, 5)  # m\ndensity = 1000  # kg/m^3\n\nradii_strategy = RadiiBasedMovingBinBuilder().build()\n\nmass_distribution = radii_strategy.get_mass(radii_distribution, density)\nprint(f\"Mass of the particles: {mass_distribution} kg\")\n\ntotal_mass = radii_strategy.get_total_mass(\n    radii_distribution, concentration=np.ones_like(radii_distribution), density=density)\nprint(f\"Total mass of the particles: {total_mass} kg\")\n</pre> radii_distribution = np.linspace(0, 0.1, 5)  # m density = 1000  # kg/m^3  radii_strategy = RadiiBasedMovingBinBuilder().build()  mass_distribution = radii_strategy.get_mass(radii_distribution, density) print(f\"Mass of the particles: {mass_distribution} kg\")  total_mass = radii_strategy.get_total_mass(     radii_distribution, concentration=np.ones_like(radii_distribution), density=density) print(f\"Total mass of the particles: {total_mass} kg\") <pre>Mass of the particles: [0.         0.06544985 0.52359878 1.76714587 4.1887902 ] kg\nTotal mass of the particles: 6.544984694978737 kg\n</pre> In\u00a0[4]: Copied! <pre>mass_distribution1 = np.linspace(0, 10, 5)  # kg\nmass_distribution2 = np.linspace(0, 10, 5)  # kg\nmasses_combined = np.vstack((mass_distribution1, mass_distribution2)).T\ndensity = np.array([1000.0, 2000.0])  # kg/m^3\n\nspeciated_mass = DistributionFactory().get_strategy(\"speciated_mass_moving_bin\")\n\nradius = speciated_mass.get_radius(masses_combined, density)\n\nprint(f\"Radius of the particles: {radius} m\")\n\ntotal_mass = speciated_mass.get_total_mass(\n    masses_combined, concentration=np.ones_like(mass_distribution1), density=density)\nprint(f\"Total mass of the particles: {total_mass} kg\")\n</pre> mass_distribution1 = np.linspace(0, 10, 5)  # kg mass_distribution2 = np.linspace(0, 10, 5)  # kg masses_combined = np.vstack((mass_distribution1, mass_distribution2)).T density = np.array([1000.0, 2000.0])  # kg/m^3  speciated_mass = DistributionFactory().get_strategy(\"speciated_mass_moving_bin\")  radius = speciated_mass.get_radius(masses_combined, density)  print(f\"Radius of the particles: {radius} m\")  total_mass = speciated_mass.get_total_mass(     masses_combined, concentration=np.ones_like(mass_distribution1), density=density) print(f\"Total mass of the particles: {total_mass} kg\") <pre>Radius of the particles: [0.         0.09637866 0.1214295  0.13900208 0.15299159] m\nTotal mass of the particles: 50.0 kg\n</pre>"},{"location":"Tutorials/Particle_Phase/Distribution_Tutorial/#distribution-strategy-tutorial","title":"Distribution Strategy Tutorial\u00b6","text":"<p>The representation of particle distributions is core to the simulation, but it can vary depending on what you are trying to achieve. In this tutorial, we will cover the  distribution strategies currently implemented.</p> <p>The distribution strategies, define how to calculate properties derived from the particle distribution. These include particle mass, radius, and total mass. All of which can have different methods depending if the distribution is mass-based, radius-based, or speciated-mass based.</p> <p>We will cover the following distribution strategies:</p> <ul> <li><code>MassBasedMovingBin</code></li> <li><code>RadiiBasedMovingBin</code></li> <li><code>SpeciatedMassMovingBin</code></li> </ul> <p>As they are just operational strategies, they do not have any specific parameters to be set. They are just used to calculate the properties of the particles.</p>"},{"location":"Tutorials/Particle_Phase/Distribution_Tutorial/#strategy-massbasedmovingbin","title":"Strategy: MassBasedMovingBin\u00b6","text":"<p>The <code>MassBasedMovingBin</code> strategy is used when the distribution is mass-based. This means that the mass of the particles is known and the radius is calculated from the mass. The <code>MassBasedMovingBin</code> strategy calculates the radius of the particles using the following equation:</p> <p>$$ r = \\left(\\frac{3m}{4\\pi\\rho}\\right)^{1/3} $$</p> <p>where $r$ is the radius of the particle, $m$ is the mass of the particle, and $\\rho$ is the density of the particle.</p>"},{"location":"Tutorials/Particle_Phase/Distribution_Tutorial/#builder-radiibasedmovingbin","title":"Builder: RadiiBasedMovingBin\u00b6","text":"<p>The <code>RadiiBasedMovingBin</code> strategy is used when the distribution is radius-based. This means that the radius of the particles is known and the mass is calculated from the radius. The <code>RadiiBasedMovingBin</code> strategy calculates the mass of the particles using the following equation:</p> <p>$$ m = \\frac{4\\pi\\rho r^3}{3} $$</p> <p>where $m$ is the mass of the particle, $r$ is the radius of the particle, and $\\rho$ is the density of the particle.</p> <p>The builder does nothing in this case, as we just have no parameters to set. We use the builder pattern here to keep the code consistent with the other strategies.</p>"},{"location":"Tutorials/Particle_Phase/Distribution_Tutorial/#factory-speciatedmassmovingbin","title":"Factory: SpeciatedMassMovingBin\u00b6","text":"<p>The <code>SpeciatedMassMovingBin</code> strategy is used when the distribution is speciated-mass based. This means that the mass of the particles is known and the radius is calculated from the mass. The <code>SpeciatedMassMovingBin</code> has multiple species, and the mass of each species is known for that given bin or particle.</p>"},{"location":"Tutorials/Particle_Phase/Distribution_Tutorial/#summary","title":"Summary\u00b6","text":"<p>In this tutorial, we covered the distribution strategies implemented in the simulation. We covered the <code>MassBasedMovingBin</code>, <code>RadiiBasedMovingBin</code>, and <code>SpeciatedMassMovingBin</code> strategies. These strategies are used to calculate the properties of the particles based on the distribution type.</p>"},{"location":"Tutorials/Particle_Phase/Particle_Representation_Tutorial/","title":"Particle Representation","text":"In\u00a0[22]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\nfrom particula.next import particles\n</pre> import numpy as np import matplotlib.pyplot as plt  from particula.next import particles In\u00a0[23]: Copied! <pre># Creating particle distribution examples\nradius = np.array([100, 200, 300], dtype=np.float64)  # in nm\ndensity = 2.5\nconcentration = np.array([1e2, 1e3, 1e4], dtype=np.float64)\n\n# parameters\nsufrace_tension_strategy = (\n    particles.SurfaceStrategyMassBuilder()\n    .set_surface_tension(0.072)\n    .set_density(2.5, \"g/cm^3\")\n)\n\n# Create a Particle instance using the RadiusParticleRepresentationBuilder\nparticle_rep_mass = (\n    particles.ParticleRadiusRepresentationBuilder()\n    .set_distribution_strategy(particles.RadiiBasedMovingBin())\n    .set_activity_strategy(particles.ActivityIdealMass())\n    .set_surface_strategy(sufrace_tension_strategy)\n    .set_concentration(concentration=concentration, concentration_units=\"1/cm^3\")\n    .set_density(density=density, density_units=\"g/cm^3\")\n    .set_radius(radius=radius, radius_units=\"nm\")\n    .set_charge(charge=0)\n    .build()\n)\n\n#Accessing calculated properties\nprint(\"Mass of particles:\", particle_rep_mass.get_mass())\nprint(\"Radius of particles:\", particle_rep_mass.get_radius())\nprint(\"Total mass of the particle distribution:\", particle_rep_mass.get_mass_concentration())\n</pre> # Creating particle distribution examples radius = np.array([100, 200, 300], dtype=np.float64)  # in nm density = 2.5 concentration = np.array([1e2, 1e3, 1e4], dtype=np.float64)  # parameters sufrace_tension_strategy = (     particles.SurfaceStrategyMassBuilder()     .set_surface_tension(0.072)     .set_density(2.5, \"g/cm^3\") )  # Create a Particle instance using the RadiusParticleRepresentationBuilder particle_rep_mass = (     particles.ParticleRadiusRepresentationBuilder()     .set_distribution_strategy(particles.RadiiBasedMovingBin())     .set_activity_strategy(particles.ActivityIdealMass())     .set_surface_strategy(sufrace_tension_strategy)     .set_concentration(concentration=concentration, concentration_units=\"1/cm^3\")     .set_density(density=density, density_units=\"g/cm^3\")     .set_radius(radius=radius, radius_units=\"nm\")     .set_charge(charge=0)     .build() )  #Accessing calculated properties print(\"Mass of particles:\", particle_rep_mass.get_mass()) print(\"Radius of particles:\", particle_rep_mass.get_radius()) print(\"Total mass of the particle distribution:\", particle_rep_mass.get_mass_concentration()) <pre>Mass of particles: [1.04719755e-17 8.37758041e-17 2.82743339e-16]\nRadius of particles: [1.e-07 2.e-07 3.e-07]\nTotal mass of the particle distribution: 2.912256389877738e-06\n</pre> In\u00a0[24]: Copied! <pre># Generating random properties for speciated particles\nmass_distribution = (\n    np.random.rand(500, 3).astype(np.float64)\n)\nconcentration = (\n    np.random.rand(500, 1).astype(np.float64) * 1e3\n)\n\n# Defining surface tension parameters\nsurface_tension_parameter = {\n    \"surface_tension\": 0.072,  # in N/m\n    \"density\": 2.5,  # Density in g/cm^3\n    \"density_units\": \"g/cm^3\",\n}\nsurface_strategy = particles.SurfaceFactory().get_strategy('mass', surface_tension_parameter)\ndistribution_strategy = particles.DistributionFactory().get_strategy('speciated_mass_moving_bin')\nactivity_strategy = particles.ActivityFactory().get_strategy('mass_ideal')\n\n# Setting up parameters for the particle representation factory\nparameters = {\n    \"distribution_strategy\": distribution_strategy,\n    \"activity_strategy\": activity_strategy,\n    \"surface_strategy\": surface_strategy,\n    \"density\": 2.5,\n    \"density_units\": \"g/cm^3\",\n    \"concentration\": concentration,\n    \"concentration_units\": \"1/cm^3\",\n    \"mass\": mass_distribution,\n    \"mass_units\": \"pg\",  # picograms\n    \"charge\": 0,\n}\n\n# Using the factory to create a speciated particle representation\nspeciated_mass_rep = particles.ParticleRepresentationFactory().get_strategy(\n    \"mass\", parameters\n)\n\n# Outputting the total mass of the particle distribution\nprint(\n    f\"Total mass of the particle distribution: {speciated_mass_rep.get_mass_concentration()}\"\n)\n\n# Plot histogram of the mass distribution and number distribution vs radius\nradius = speciated_mass_rep.get_radius()\nmasses = speciated_mass_rep.get_mass()\nconcentration = speciated_mass_rep.get_concentration(clone=True)\n\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.hist(masses*1e6, bins=20, color=\"blue\", alpha=0.7)\nax.set_xlabel(\"Mass (ug)\")\nax.set_ylabel(\"Number of Super Particles (Droplets)\")\nax.set_title(\"Mass Distribution of Super Particles\")\nplt.show()\n\nfig, ax2 = plt.subplots(figsize=(8, 6))\nax2.hist(radius*1e9, bins=20, color=\"red\", alpha=0.7)\nax2.set_ylabel(\"Concentration (1/m^3)\")\nax2.set_xlabel(\"Radius (nm)\")\nax2.set_title(\"Number Distribution of Super Particles\")\nplt.show()\n</pre> # Generating random properties for speciated particles mass_distribution = (     np.random.rand(500, 3).astype(np.float64) ) concentration = (     np.random.rand(500, 1).astype(np.float64) * 1e3 )  # Defining surface tension parameters surface_tension_parameter = {     \"surface_tension\": 0.072,  # in N/m     \"density\": 2.5,  # Density in g/cm^3     \"density_units\": \"g/cm^3\", } surface_strategy = particles.SurfaceFactory().get_strategy('mass', surface_tension_parameter) distribution_strategy = particles.DistributionFactory().get_strategy('speciated_mass_moving_bin') activity_strategy = particles.ActivityFactory().get_strategy('mass_ideal')  # Setting up parameters for the particle representation factory parameters = {     \"distribution_strategy\": distribution_strategy,     \"activity_strategy\": activity_strategy,     \"surface_strategy\": surface_strategy,     \"density\": 2.5,     \"density_units\": \"g/cm^3\",     \"concentration\": concentration,     \"concentration_units\": \"1/cm^3\",     \"mass\": mass_distribution,     \"mass_units\": \"pg\",  # picograms     \"charge\": 0, }  # Using the factory to create a speciated particle representation speciated_mass_rep = particles.ParticleRepresentationFactory().get_strategy(     \"mass\", parameters )  # Outputting the total mass of the particle distribution print(     f\"Total mass of the particle distribution: {speciated_mass_rep.get_mass_concentration()}\" )  # Plot histogram of the mass distribution and number distribution vs radius radius = speciated_mass_rep.get_radius() masses = speciated_mass_rep.get_mass() concentration = speciated_mass_rep.get_concentration(clone=True)   fig, ax = plt.subplots(figsize=(8, 6)) ax.hist(masses*1e6, bins=20, color=\"blue\", alpha=0.7) ax.set_xlabel(\"Mass (ug)\") ax.set_ylabel(\"Number of Super Particles (Droplets)\") ax.set_title(\"Mass Distribution of Super Particles\") plt.show()  fig, ax2 = plt.subplots(figsize=(8, 6)) ax2.hist(radius*1e9, bins=20, color=\"red\", alpha=0.7) ax2.set_ylabel(\"Concentration (1/m^3)\") ax2.set_xlabel(\"Radius (nm)\") ax2.set_title(\"Number Distribution of Super Particles\") plt.show() <pre>Total mass of the particle distribution: 0.18691117766964574\n</pre> In\u00a0[25]: Copied! <pre>lognormal_rep = (\n    particles.PresetParticleRadiusBuilder()\n    .set_mode(np.array([100, 2000]), \"nm\")\n    .set_geometric_standard_deviation(np.array([1.5, 2.0]))\n    .set_number_concentration(np.array([1e4, 1e4]), \"1/cm^3\")\n    .set_distribution_type(\"pmf\")\n    .build()\n)\n\n# plot\nfig, ax = plt.subplots(figsize=(8, 6))\nax.semilogx(lognormal_rep.get_radius(), lognormal_rep.get_concentration(), label=\"Number Distribution\", color=\"blue\")\nax.set_xlabel(\"Radius (m)\")\nax.set_ylabel(\"Concentration (1/m^3)\")\nax.set_title(\"Number Distribution of Particles\")\nplt.legend()\nplt.show()\n</pre>  lognormal_rep = (     particles.PresetParticleRadiusBuilder()     .set_mode(np.array([100, 2000]), \"nm\")     .set_geometric_standard_deviation(np.array([1.5, 2.0]))     .set_number_concentration(np.array([1e4, 1e4]), \"1/cm^3\")     .set_distribution_type(\"pmf\")     .build() )  # plot fig, ax = plt.subplots(figsize=(8, 6)) ax.semilogx(lognormal_rep.get_radius(), lognormal_rep.get_concentration(), label=\"Number Distribution\", color=\"blue\") ax.set_xlabel(\"Radius (m)\") ax.set_ylabel(\"Concentration (1/m^3)\") ax.set_title(\"Number Distribution of Particles\") plt.legend() plt.show()"},{"location":"Tutorials/Particle_Phase/Particle_Representation_Tutorial/#particle-representation","title":"Particle Representation\u00b6","text":"<p>With the different aspects of particles laid out in the previous sections, we can now focus on how to represent them in a simulation. The representation of particles is crucial for having a unified way to handle particles in a system. This section will discuss building a particle representation that can be used in simulations and analyses.</p>"},{"location":"Tutorials/Particle_Phase/Particle_Representation_Tutorial/#builder-particle-representation","title":"Builder: Particle Representation\u00b6","text":"<p>In this section, we will demonstrate how to create a particle distribution using specific particle properties such as radius, density, and concentration. This example will help illustrate the practical application of object-oriented programming in simulating and analyzing particle systems in scientific research. We'll utilize a builder pattern to construct an instance of a Particle class, allowing for flexible configuration of particle characteristics and behaviors.</p> <p>Key Components:</p> <ul> <li>Radius and Concentration: Define the size and number of particles in nanometers and their concentration per cubic centimeter, respectively. Density and Surface Tension: Specify the material's density and the surface tension for the particles, which are critical for calculating various physical and chemical properties.</li> <li>Builder Pattern: Use a builder pattern for creating a particle representation, which facilitates the step-by-step configuration of different strategies for distribution, activity, and surface approximations.</li> </ul> <p>The code snippet below sets up a particle distribution with defined properties using multiple factory methods to specify behavior strategies for distribution, activity, and surface interactions. The use of a builder pattern enhances readability and maintainability of the code by separating the construction of a complex object from its representation.</p>"},{"location":"Tutorials/Particle_Phase/Particle_Representation_Tutorial/#factory-particle-representation-implementation","title":"Factory: Particle Representation Implementation\u00b6","text":"<p>The factory pattern plays a crucial role in the flexibility and extensibility of particle property computations, such as mass, radius, and total mass, within different computational models. It allows for dynamic selection of computational strategies based on the scenario, facilitating accurate and tailored simulations of real-world conditions.</p> <p>In this section, we'll demonstrate how to use a factory to construct speciated particles characterized by varied properties, enhancing our ability to simulate diverse environmental scenarios. Initially, it's beneficial to directly manipulate builders to familiarize yourself with various strategies. Subsequently, parameters can be saved in JSON format. In future iterations, these saved configurations can be rapidly deployed through the factory, streamlining particle creation and modification.</p>"},{"location":"Tutorials/Particle_Phase/Particle_Representation_Tutorial/#limited-representation-builder","title":"Limited Representation Builder\u00b6","text":"<p>The last representation, is a modification of the radii builder, where we can specify a lognomal distribution parameters. This is useful when we want a to start a simulation quick and are not trying to explicitly reproduce a specific system.</p>"},{"location":"Tutorials/Particle_Phase/Particle_Representation_Tutorial/#summary","title":"Summary\u00b6","text":"<p>In this notebook, we have discussed the importance of particle representation in simulations and analyses. We have demonstrated how to create a particle distribution using specific particle properties such as radius, density, and concentration. We have also shown how to use a builder pattern to construct an instance of a Particle class, allowing for flexible configuration of particle characteristics and behaviors. Finally, we have discussed the factory pattern and how it can be used to construct speciated particles characterized by varied properties.</p>"},{"location":"Tutorials/Particle_Phase/Particle_Surface_Tutorial/","title":"Particle Surface Tutorial","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\nfrom particula.next.particles.surface_strategies import SurfaceStrategyMolar\nfrom particula.next.particles.surface_builders import SurfaceStrategyMassBuilder\nfrom particula.next.particles.surface_factories import SurfaceFactory\n</pre> import numpy as np import matplotlib.pyplot as plt  from particula.next.particles.surface_strategies import SurfaceStrategyMolar from particula.next.particles.surface_builders import SurfaceStrategyMassBuilder from particula.next.particles.surface_factories import SurfaceFactory  In\u00a0[2]: Copied! <pre>glycerol_molar_mass = 0.092093 # kg/mol\nglycerol_density = 1261 # kg/m^3\nglycerol_surface_tension = 0.063 # N/m\n\n# Create a surface strategy\nglycerol_surface_strategy = SurfaceStrategyMolar(\n    glycerol_molar_mass, glycerol_density, glycerol_surface_tension\n)\n\nglycerol_kelvin_radius = glycerol_surface_strategy.kelvin_radius(\n    molar_mass=glycerol_molar_mass,\n    mass_concentration=0.1,  # not this doesn't not matter for a single species mixture\n    temperature=300\n)\n\nprint(f\"kelvin radius of glycerol {glycerol_kelvin_radius} m\")\n</pre> glycerol_molar_mass = 0.092093 # kg/mol glycerol_density = 1261 # kg/m^3 glycerol_surface_tension = 0.063 # N/m  # Create a surface strategy glycerol_surface_strategy = SurfaceStrategyMolar(     glycerol_molar_mass, glycerol_density, glycerol_surface_tension )  glycerol_kelvin_radius = glycerol_surface_strategy.kelvin_radius(     molar_mass=glycerol_molar_mass,     mass_concentration=0.1,  # not this doesn't not matter for a single species mixture     temperature=300 )  print(f\"kelvin radius of glycerol {glycerol_kelvin_radius} m\") <pre>kelvin radius of glycerol 5.392780089118282e-09 m\n</pre> In\u00a0[3]: Copied! <pre>radii = np.logspace(-10, -6, 100)\n\nglycerol_kevlin_term = glycerol_surface_strategy.kelvin_term(\n    radius=radii,\n    molar_mass=glycerol_molar_mass,\n    mass_concentration=0.1,\n    temperature=300\n)\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(radii, glycerol_kevlin_term)\nax.plot([glycerol_kelvin_radius, glycerol_kelvin_radius], [min(glycerol_kevlin_term), max(glycerol_kevlin_term)], color=\"red\", linestyle=\"--\")\nax.set_yscale(\"log\")\nax.set_xscale(\"log\")\nax.set_title(\"Kelvin term of glycerol\")\nax.set_xlabel(\"radius (m)\")\nax.set_ylabel(\"Kelvin term\")\nax.legend([\"Kelvin term\", \"Kelvin radius\"])\nplt.show()\n</pre> radii = np.logspace(-10, -6, 100)  glycerol_kevlin_term = glycerol_surface_strategy.kelvin_term(     radius=radii,     molar_mass=glycerol_molar_mass,     mass_concentration=0.1,     temperature=300 )  fig, ax = plt.subplots(figsize=(8, 6)) ax.plot(radii, glycerol_kevlin_term) ax.plot([glycerol_kelvin_radius, glycerol_kelvin_radius], [min(glycerol_kevlin_term), max(glycerol_kevlin_term)], color=\"red\", linestyle=\"--\") ax.set_yscale(\"log\") ax.set_xscale(\"log\") ax.set_title(\"Kelvin term of glycerol\") ax.set_xlabel(\"radius (m)\") ax.set_ylabel(\"Kelvin term\") ax.legend([\"Kelvin term\", \"Kelvin radius\"]) plt.show() In\u00a0[4]: Copied! <pre>squalane_surface = (\n    SurfaceStrategyMassBuilder()\n    .set_density(0.81, density_units=\"g/cm^3\")  # call with parameter name\n    .set_surface_tension(28, \"mN/m\")  # call without parameter name\n    .build()\n)\n\n# create plot\nsqualane_kelvin_radius = squalane_surface.kelvin_radius(\n    molar_mass=0.422, mass_concentration=0.1, temperature=300\n)\nsqualane_kelvin_term = squalane_surface.kelvin_term(\n    radius=radii, molar_mass=0.422, mass_concentration=0.1, temperature=300\n)\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(radii, squalane_kelvin_term)\nax.plot([squalane_kelvin_radius, squalane_kelvin_radius], [min(squalane_kelvin_term), max(squalane_kelvin_term)], color=\"red\", linestyle=\"--\")\nax.set_yscale(\"log\")\nax.set_xscale(\"log\")\nax.set_title(\"Kelvin term of squalane\")\nax.set_xlabel(\"radius (m)\")\nax.set_ylabel(\"Kelvin term\")\nax.legend([\"Kelvin term\", \"Kelvin radius\"])\nplt.show()\n</pre> squalane_surface = (     SurfaceStrategyMassBuilder()     .set_density(0.81, density_units=\"g/cm^3\")  # call with parameter name     .set_surface_tension(28, \"mN/m\")  # call without parameter name     .build() )  # create plot squalane_kelvin_radius = squalane_surface.kelvin_radius(     molar_mass=0.422, mass_concentration=0.1, temperature=300 ) squalane_kelvin_term = squalane_surface.kelvin_term(     radius=radii, molar_mass=0.422, mass_concentration=0.1, temperature=300 )  fig, ax = plt.subplots(figsize=(8, 6)) ax.plot(radii, squalane_kelvin_term) ax.plot([squalane_kelvin_radius, squalane_kelvin_radius], [min(squalane_kelvin_term), max(squalane_kelvin_term)], color=\"red\", linestyle=\"--\") ax.set_yscale(\"log\") ax.set_xscale(\"log\") ax.set_title(\"Kelvin term of squalane\") ax.set_xlabel(\"radius (m)\") ax.set_ylabel(\"Kelvin term\") ax.legend([\"Kelvin term\", \"Kelvin radius\"]) plt.show()   In\u00a0[5]: Copied! <pre>parameters = {  # glycerol, squalane\n        \"density\": np.array([1261, 810]),  # kg/m^3\n        \"surface_tension\": np.array([0.063, 0.028]),  # N/m\n}\n\nmixture_surface = SurfaceFactory().get_strategy(\n    strategy_type=\"volume\",\n    parameters=parameters,\n)\n\nmixture_kelvin_radius = mixture_surface.kelvin_radius(\n    molar_mass=0.092093,\n    mass_concentration=np.array([0.1, 0.1]),\n    temperature=300\n)\nprint(f\"kelvin radius of mixture {mixture_kelvin_radius} m\")\n\nmixture_kelvin_term = mixture_surface.kelvin_term(\n    radius=radii,\n    molar_mass=0.092093,\n    mass_concentration=np.array([0.1, 0.1]),\n    temperature=300\n)\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.plot(radii, mixture_kelvin_term, label=\"Mixure\")\nax.plot([mixture_kelvin_radius, mixture_kelvin_radius], [min(mixture_kelvin_term), max(mixture_kelvin_term)], color=\"red\", linestyle=\"--\")\nax.plot(radii, glycerol_kevlin_term, label=\"Glycerol\")\nax.plot([glycerol_kelvin_radius, glycerol_kelvin_radius], [min(glycerol_kevlin_term), max(glycerol_kevlin_term)], color=\"red\", linestyle=\"--\")\nax.plot(radii, squalane_kelvin_term, label=\"Squalane\")\nax.plot([squalane_kelvin_radius, squalane_kelvin_radius], [min(squalane_kelvin_term), max(squalane_kelvin_term)], color=\"red\", linestyle=\"--\")\nax.set_yscale(\"log\")\nax.set_xscale(\"log\")\nax.set_title(\"Kelvin term of mixture\")\nax.set_xlabel(\"radius (m)\")\nax.set_ylabel(\"Kelvin term\")\nax.legend()\nplt.show()\n</pre> parameters = {  # glycerol, squalane         \"density\": np.array([1261, 810]),  # kg/m^3         \"surface_tension\": np.array([0.063, 0.028]),  # N/m }  mixture_surface = SurfaceFactory().get_strategy(     strategy_type=\"volume\",     parameters=parameters, )  mixture_kelvin_radius = mixture_surface.kelvin_radius(     molar_mass=0.092093,     mass_concentration=np.array([0.1, 0.1]),     temperature=300 ) print(f\"kelvin radius of mixture {mixture_kelvin_radius} m\")  mixture_kelvin_term = mixture_surface.kelvin_term(     radius=radii,     molar_mass=0.092093,     mass_concentration=np.array([0.1, 0.1]),     temperature=300 )  fig, ax = plt.subplots(figsize=(8, 6)) ax.plot(radii, mixture_kelvin_term, label=\"Mixure\") ax.plot([mixture_kelvin_radius, mixture_kelvin_radius], [min(mixture_kelvin_term), max(mixture_kelvin_term)], color=\"red\", linestyle=\"--\") ax.plot(radii, glycerol_kevlin_term, label=\"Glycerol\") ax.plot([glycerol_kelvin_radius, glycerol_kelvin_radius], [min(glycerol_kevlin_term), max(glycerol_kevlin_term)], color=\"red\", linestyle=\"--\") ax.plot(radii, squalane_kelvin_term, label=\"Squalane\") ax.plot([squalane_kelvin_radius, squalane_kelvin_radius], [min(squalane_kelvin_term), max(squalane_kelvin_term)], color=\"red\", linestyle=\"--\") ax.set_yscale(\"log\") ax.set_xscale(\"log\") ax.set_title(\"Kelvin term of mixture\") ax.set_xlabel(\"radius (m)\") ax.set_ylabel(\"Kelvin term\") ax.legend() plt.show()  <pre>kelvin radius of mixture 3.1208511801897936e-09 m\n</pre>"},{"location":"Tutorials/Particle_Phase/Particle_Surface_Tutorial/#particle-surface-tutorial","title":"Particle Surface Tutorial\u00b6","text":"<p>Understanding how particle surfaces are represented is crucial in the study of condensation processes involving water and organic molecules. This is primarily influenced by the Kelvin curvature effect, which describes how the saturation vapor pressure of a liquid droplet varies with its size. This tutorial will introduce the fundamental approaches to modeling the particle surface in aerosol particle simulations.</p> <p>Kelvin Curvature Effect</p>"},{"location":"Tutorials/Particle_Phase/Particle_Surface_Tutorial/#strategies-for-surface-representation","title":"Strategies for Surface Representation\u00b6","text":"<p>To accurately simulate particle surfaces, one must adhere to the <code>SurfaceStrategy</code> abstract base class. This class outlines common methods required for all surface representation strategies:</p> <ul> <li><code>kelvin_radius</code>: Calculates the particle radius that corresponds to the Kelvin curvature effect.</li> <li><code>kelvin_term</code>: Computes the Kelvin term, defined as exp(kelvin_radius / particle_radius).</li> </ul> <p>Specifically, the strategies differ in how they calculate:</p> <ul> <li><code>effective_surface_tension</code>: Determines the effective surface tension of species based on their concentration.</li> <li><code>effective_density</code>: Computes the effective density of species based on their concentration.</li> </ul> <p>While each strategy may require additional parameters, defining surface tension is essential for all. The primary strategies include:</p> <ul> <li><code>SurfaceStrategyMolar</code>: Uses mole fraction weighted values to determine surface tension and density.</li> <li><code>SurfaceStrategyMass</code>: Uses mass fraction weighted values to determine surface tension and density.</li> <li><code>SurfaceStrategyVolume</code>: Uses volume fraction weighted values to determine surface tension and density.</li> </ul> <p>Each strategy is interchangeable and suitable for use in aerosol particle simulations. The choice of strategy should be guided by the available data and the level of detail required for the simulation.</p> <p>In this tutorial, we will demonstrate how to create and use these strategies, employing builders and factories to instantiate them and calculate both the Kelvin radius and term.</p>"},{"location":"Tutorials/Particle_Phase/Particle_Surface_Tutorial/#direct-strategy-creation","title":"Direct Strategy Creation\u00b6","text":"<p>The following code demonstrates how directly create and instance of a molar surface strategy and calculate the Kelvin radius and term.</p> <p>Note this approach assumes base SI units, if you want conversions on the inputs and data validation checks then use the subsequent builder and factory methods.</p>"},{"location":"Tutorials/Particle_Phase/Particle_Surface_Tutorial/#kelvin-term","title":"Kelvin term\u00b6","text":"<p>To see the Kelvin term in action, we will calculate the Kelvin term for an array of glycerol particles. The Kelvin term is a dimensionless quantity that describes the effect of the Kelvin curvature on the saturation vapor pressure of a liquid droplet. It is defined as exp(kelvin_radius / particle_radius).</p> <p>So values of the Kelvin term greater than 1 indicate that the saturation vapor pressure required to maintain the particle's size is higher than the saturation vapor pressure of the bulk liquid (flat surface). This is due to the increased in curvature of the particle surface.</p>"},{"location":"Tutorials/Particle_Phase/Particle_Surface_Tutorial/#builder-for-squalane","title":"Builder for Squalane\u00b6","text":"<p>The following code demonstrates how to use the builder to create a surface strategy for squalane particles. The builder allows for the specification of the surface tension and density of the species, as well as the concentration of the species in the particle.</p> <p>Squalane is a larger molecule with a lower surface tension than glycerol, so the Kelvin term will be lower for the same particle size.</p>"},{"location":"Tutorials/Particle_Phase/Particle_Surface_Tutorial/#factory-approach","title":"Factory Approach\u00b6","text":"<p>Next example is the creation using a factory method, which is more flexible and allows for the use of different units and conversions. The factory method also performs data validation checks to ensure the input values are within the expected range. As the factory is just a wrapper around the builder, the same parameters can/must be used.</p> <p>Here we'll create a mixture of glycerol and squalane particles, and calculate the Kelvin term for a range of particle sizes for a volume fraction of 0.5 for each species. And assume glycerol is the condensing species.</p> <p>[double check the graph output, if the mixture should be lower than the pure or not]</p>"},{"location":"Tutorials/Particle_Phase/Particle_Surface_Tutorial/#summary","title":"Summary\u00b6","text":"<p>This tutorial has demonstrated the fundamental approaches to modeling particle surfaces in aerosol particle simulations. By using the <code>SurfaceStrategy</code> abstract base class, we can create and use different strategies to calculate the Kelvin radius and term. The choice of strategy should be guided by the available data and the level of detail required for the simulation.</p> <p>The <code>SurfaceStrategyMolar</code>, <code>SurfaceStrategyMass</code>, and <code>SurfaceStrategyVolume</code> strategies provide flexibility in determining the effective surface tension and density of species based on their concentration. By using builders and factories, we can create surface strategies with the necessary parameters and perform data validation checks to ensure the input values are within the expected range.</p>"},{"location":"Tutorials/Particle_Phase/Functional/Activity_Functions/","title":"Activity Tutorial","text":"In\u00a0[7]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\nfrom particula.next.particles import properties\nfrom particula.util.converting import convert_mass_concentration\n</pre> import numpy as np import matplotlib.pyplot as plt  from particula.next.particles import properties from particula.util.converting import convert_mass_concentration In\u00a0[8]: Copied! <pre>masses_1 = np.linspace(0, 100, 1000)\nmasses_2 = np.full_like(masses_1, 30)\nmasses_3 = np.linspace(150, 10, 1000)\n\ndensity_1 = 1000  # kg/m^3\ndensity_2 = 2000  # kg/m^3\ndensity_3 = 1500  # kg/m^3\n\nmolar_mass_1 = 18.01528e-3  # g/mol\nmolar_mass_2 = 200e-3  # g/mol\nmolar_mass_3 = 150e-3  # g/mol\n\nmass_2component = np.column_stack((masses_1, masses_2))\nmass_3component = np.column_stack((masses_1, masses_2, masses_3))\n\ndensity_2component = np.array([density_1, density_2])\ndensity_3component = np.array([density_1, density_2, density_3])\n\n# get mass fractions\nmass_fractions_2component = convert_mass_concentration.to_mole_fraction(\n    mass_2component,\n    molar_masses=np.array([molar_mass_1, molar_mass_2])\n)\nmass_fractions_3component = convert_mass_concentration.to_mole_fraction(\n    mass_3component,\n    molar_masses=np.array([molar_mass_1, molar_mass_2, molar_mass_3])\n)\n</pre> masses_1 = np.linspace(0, 100, 1000) masses_2 = np.full_like(masses_1, 30) masses_3 = np.linspace(150, 10, 1000)  density_1 = 1000  # kg/m^3 density_2 = 2000  # kg/m^3 density_3 = 1500  # kg/m^3  molar_mass_1 = 18.01528e-3  # g/mol molar_mass_2 = 200e-3  # g/mol molar_mass_3 = 150e-3  # g/mol  mass_2component = np.column_stack((masses_1, masses_2)) mass_3component = np.column_stack((masses_1, masses_2, masses_3))  density_2component = np.array([density_1, density_2]) density_3component = np.array([density_1, density_2, density_3])  # get mass fractions mass_fractions_2component = convert_mass_concentration.to_mole_fraction(     mass_2component,     molar_masses=np.array([molar_mass_1, molar_mass_2]) ) mass_fractions_3component = convert_mass_concentration.to_mole_fraction(     mass_3component,     molar_masses=np.array([molar_mass_1, molar_mass_2, molar_mass_3]) )  In\u00a0[9]: Copied! <pre>activity_2component_molar = properties.ideal_activity_molar(\n    mass_concentration=mass_2component,\n    molar_mass=np.array([molar_mass_1, molar_mass_2]),\n)\n\n\nactivity_3component_molar = properties.ideal_activity_molar(\n    mass_concentration=mass_3component,\n    molar_mass=np.array([molar_mass_1, molar_mass_2, molar_mass_3]),\n)\n\n\n\n# Create the figure and axis objects\nfig, ax = plt.subplots(2, 1, figsize=(5, 8))\n\n# Plot each component in the 2-component system with separate colors\nax[0].plot(\n    mass_fractions_2component[:, 0],\n    activity_2component_molar[:, 0],\n    color=\"blue\",\n    label=\"Water (1)\",\n)\nax[0].plot(\n    mass_fractions_2component[:, 0],\n    activity_2component_molar[:, 1],\n    color=\"green\",\n    label=\"Component 2\",\n)\nax[0].set_xlabel(\"Water Mole Fraction\")\nax[0].set_ylabel(\"Activity coefficient\")\nax[0].set_title(\"Activity coefficient vs mass fraction for 2 components\")\nax[0].legend()\n\n# Plot the 3-component system without setting specific colors\nax[1].plot(\n    mass_fractions_3component[:, 0],\n    activity_3component_molar[:, 0],\n    label=\"Water (1)\",\n    color=\"blue\",\n)\nax[1].plot(\n    mass_fractions_3component[:, 0],\n    activity_3component_molar[:, 1],\n    label=\"Component 2\",\n    color=\"green\",\n)\nax[1].plot(\n    mass_fractions_3component[:, 0],\n    activity_3component_molar[:, 2],\n    label=\"Component 3\",\n    color=\"red\",\n)\nax[1].set_xlabel(\"Water Mole Fraction\")\nax[1].set_ylabel(\"Activity coefficient\")\nax[1].set_title(\"Activity coefficient vs mass fraction for 3 components\")\nax[1].legend()\n\n# Display the plot\nplt.tight_layout()\nplt.show()\n</pre> activity_2component_molar = properties.ideal_activity_molar(     mass_concentration=mass_2component,     molar_mass=np.array([molar_mass_1, molar_mass_2]), )   activity_3component_molar = properties.ideal_activity_molar(     mass_concentration=mass_3component,     molar_mass=np.array([molar_mass_1, molar_mass_2, molar_mass_3]), )    # Create the figure and axis objects fig, ax = plt.subplots(2, 1, figsize=(5, 8))  # Plot each component in the 2-component system with separate colors ax[0].plot(     mass_fractions_2component[:, 0],     activity_2component_molar[:, 0],     color=\"blue\",     label=\"Water (1)\", ) ax[0].plot(     mass_fractions_2component[:, 0],     activity_2component_molar[:, 1],     color=\"green\",     label=\"Component 2\", ) ax[0].set_xlabel(\"Water Mole Fraction\") ax[0].set_ylabel(\"Activity coefficient\") ax[0].set_title(\"Activity coefficient vs mass fraction for 2 components\") ax[0].legend()  # Plot the 3-component system without setting specific colors ax[1].plot(     mass_fractions_3component[:, 0],     activity_3component_molar[:, 0],     label=\"Water (1)\",     color=\"blue\", ) ax[1].plot(     mass_fractions_3component[:, 0],     activity_3component_molar[:, 1],     label=\"Component 2\",     color=\"green\", ) ax[1].plot(     mass_fractions_3component[:, 0],     activity_3component_molar[:, 2],     label=\"Component 3\",     color=\"red\", ) ax[1].set_xlabel(\"Water Mole Fraction\") ax[1].set_ylabel(\"Activity coefficient\") ax[1].set_title(\"Activity coefficient vs mass fraction for 3 components\") ax[1].legend()  # Display the plot plt.tight_layout() plt.show() In\u00a0[10]: Copied! <pre># Volume activity coefficient\nactivity_2component_volume = properties.ideal_activity_volume(\n    mass_concentration=mass_2component,\n    density=density_2component,\n)\n\nactivity_3component_volume = properties.ideal_activity_volume(\n    mass_concentration=mass_3component,\n    density=density_3component,\n)\n\n# Create the figure and axis objects\nfig, ax = plt.subplots(2, 1, figsize=(5, 8))\n\n# Plot each component in the 2-component system with separate colors\nax[0].plot(\n    mass_fractions_2component[:, 0],\n    activity_2component_volume[:, 0],\n    color=\"blue\",\n    label=\"Water (1)\",\n)\nax[0].plot(\n    mass_fractions_2component[:, 0],\n    activity_2component_volume[:, 1],\n    color=\"green\",\n    label=\"Component 2\",\n)\nax[0].set_xlabel(\"Water Mole Fraction\")\nax[0].set_ylabel(\"Activity coefficient\")\nax[0].set_title(\"Activity coefficient vs mass fraction for 2 components\")\nax[0].legend()\n\n# Plot the 3-component system without setting specific colors\nax[1].plot(\n    mass_fractions_3component[:, 0],\n    activity_3component_volume[:, 0],\n    label=\"Water (1)\",\n    color=\"blue\",\n)\nax[1].plot(\n    mass_fractions_3component[:, 0],\n    activity_3component_volume[:, 1],\n    label=\"Component 2\",\n    color=\"green\",\n)\nax[1].plot(\n    mass_fractions_3component[:, 0],\n    activity_3component_volume[:, 2],\n    label=\"Component 3\",\n    color=\"red\",\n)\nax[1].set_xlabel(\"Water Mole Fraction\")\nax[1].set_ylabel(\"Activity coefficient\")\nax[1].set_title(\"Activity coefficient vs mass fraction for 3 components\")\nax[1].legend()\n\n# Display the plot\nplt.tight_layout()\nplt.show()\n</pre> # Volume activity coefficient activity_2component_volume = properties.ideal_activity_volume(     mass_concentration=mass_2component,     density=density_2component, )  activity_3component_volume = properties.ideal_activity_volume(     mass_concentration=mass_3component,     density=density_3component, )  # Create the figure and axis objects fig, ax = plt.subplots(2, 1, figsize=(5, 8))  # Plot each component in the 2-component system with separate colors ax[0].plot(     mass_fractions_2component[:, 0],     activity_2component_volume[:, 0],     color=\"blue\",     label=\"Water (1)\", ) ax[0].plot(     mass_fractions_2component[:, 0],     activity_2component_volume[:, 1],     color=\"green\",     label=\"Component 2\", ) ax[0].set_xlabel(\"Water Mole Fraction\") ax[0].set_ylabel(\"Activity coefficient\") ax[0].set_title(\"Activity coefficient vs mass fraction for 2 components\") ax[0].legend()  # Plot the 3-component system without setting specific colors ax[1].plot(     mass_fractions_3component[:, 0],     activity_3component_volume[:, 0],     label=\"Water (1)\",     color=\"blue\", ) ax[1].plot(     mass_fractions_3component[:, 0],     activity_3component_volume[:, 1],     label=\"Component 2\",     color=\"green\", ) ax[1].plot(     mass_fractions_3component[:, 0],     activity_3component_volume[:, 2],     label=\"Component 3\",     color=\"red\", ) ax[1].set_xlabel(\"Water Mole Fraction\") ax[1].set_ylabel(\"Activity coefficient\") ax[1].set_title(\"Activity coefficient vs mass fraction for 3 components\") ax[1].legend()  # Display the plot plt.tight_layout() plt.show() In\u00a0[11]: Copied! <pre># Mass activity coefficient\nactivity_2component_mass = properties.ideal_activity_mass(\n    mass_concentration=mass_2component,\n)\nactivity_3component_mass = properties.ideal_activity_mass(\n    mass_concentration=mass_3component,\n)\n\n# Create the figure and axis objects\nfig, ax = plt.subplots(2, 1, figsize=(5, 8))\n\n# Plot each component in the 2-component system with separate colors\nax[0].plot(\n    mass_fractions_2component[:, 0],\n    activity_2component_mass[:, 0],\n    color=\"blue\",\n    label=\"Water (1)\",\n    linewidth=4,\n    linestyle=\"--\",\n)\nax[0].plot(\n    mass_fractions_2component[:, 0],\n    activity_2component_mass[:, 1],\n    color=\"green\",\n    label=\"Component 2\",\n)\nax[0].set_xlabel(\"Water Mole Fraction\")\nax[0].set_ylabel(\"Activity coefficient\")\nax[0].set_title(\"Activity coefficient vs mass fraction for 2 components\")\nax[0].legend()\n\n# Plot the 3-component system without setting specific colors\nax[1].plot(\n    mass_fractions_3component[:, 0],\n    activity_3component_mass[:, 0],\n    label=\"Water (1)\",\n    color=\"blue\",\n    linewidth=4,\n    linestyle=\"--\",\n)\nax[1].plot(\n    mass_fractions_3component[:, 0],\n    activity_3component_mass[:, 1],\n    label=\"Component 2\",\n    color=\"green\",\n    linewidth=3,\n)\nax[1].plot(\n    mass_fractions_3component[:, 0],\n    activity_3component_mass[:, 2],\n    label=\"Component 3\",\n    color=\"red\",\n)\nax[1].set_xlabel(\"Water Mole Fraction\")\nax[1].set_ylabel(\"Activity coefficient\")\nax[1].set_title(\"Activity coefficient vs mass fraction for 3 components\")\nax[1].legend()\n\n# Display the plot\nplt.tight_layout()\nplt.show()\n</pre> # Mass activity coefficient activity_2component_mass = properties.ideal_activity_mass(     mass_concentration=mass_2component, ) activity_3component_mass = properties.ideal_activity_mass(     mass_concentration=mass_3component, )  # Create the figure and axis objects fig, ax = plt.subplots(2, 1, figsize=(5, 8))  # Plot each component in the 2-component system with separate colors ax[0].plot(     mass_fractions_2component[:, 0],     activity_2component_mass[:, 0],     color=\"blue\",     label=\"Water (1)\",     linewidth=4,     linestyle=\"--\", ) ax[0].plot(     mass_fractions_2component[:, 0],     activity_2component_mass[:, 1],     color=\"green\",     label=\"Component 2\", ) ax[0].set_xlabel(\"Water Mole Fraction\") ax[0].set_ylabel(\"Activity coefficient\") ax[0].set_title(\"Activity coefficient vs mass fraction for 2 components\") ax[0].legend()  # Plot the 3-component system without setting specific colors ax[1].plot(     mass_fractions_3component[:, 0],     activity_3component_mass[:, 0],     label=\"Water (1)\",     color=\"blue\",     linewidth=4,     linestyle=\"--\", ) ax[1].plot(     mass_fractions_3component[:, 0],     activity_3component_mass[:, 1],     label=\"Component 2\",     color=\"green\",     linewidth=3, ) ax[1].plot(     mass_fractions_3component[:, 0],     activity_3component_mass[:, 2],     label=\"Component 3\",     color=\"red\", ) ax[1].set_xlabel(\"Water Mole Fraction\") ax[1].set_ylabel(\"Activity coefficient\") ax[1].set_title(\"Activity coefficient vs mass fraction for 3 components\") ax[1].legend()  # Display the plot plt.tight_layout() plt.show() In\u00a0[12]: Copied! <pre># kappa activity coefficient\n\nkappa_1 = 0.0 # kappa of water\nkappa_2 = 0.6 # kappa of component 2\nkappa_3 = 1.2 # kappa of component 3\n\nwater_index = 0\n\nactivity_2component_kappa = properties.kappa_activity(\n    mass_concentration=mass_2component,\n    kappa=np.array([kappa_1, kappa_2]),\n    density=density_2component,\n    molar_mass=np.array([molar_mass_1, molar_mass_2]),\n    water_index=water_index,\n)\nactivity_3component_kappa = properties.kappa_activity(\n    mass_concentration=mass_3component,\n    kappa=np.array([kappa_1, kappa_2, kappa_3]),\n    density=density_3component,\n    molar_mass=np.array([molar_mass_1, molar_mass_2, molar_mass_3]),\n    water_index=water_index,\n)\n\n# Create the figure and axis objects\nfig, ax = plt.subplots(2, 1, figsize=(5, 8))\n\n# Plot each component in the 2-component system with separate colors\nax[0].plot(\n    mass_fractions_2component[:, 0],\n    activity_2component_kappa[:, 0],\n    color=\"blue\",\n    label=\"Water (1)\",\n)\nax[0].plot(\n    mass_fractions_2component[:, 0],\n    activity_2component_kappa[:, 1],\n    color=\"green\",\n    label=\"Component 2\",\n)\nax[0].set_xlabel(\"Water Mole Fraction\")\nax[0].set_ylabel(\"Activity coefficient\")\nax[0].set_title(\"Kappa Activity coefficient vs mass fraction for 2 components\")\nax[0].legend()\n\n# Plot the 3-component system without setting specific colors\nax[1].plot(\n    mass_fractions_3component[:, 0],\n    activity_3component_kappa[:, 0],\n    label=\"Water (1)\",\n    color=\"blue\",\n)\nax[1].plot(\n    mass_fractions_3component[:, 0],\n    activity_3component_kappa[:, 1],\n    label=\"Component 2\",\n    color=\"green\",\n)\nax[1].plot(\n    mass_fractions_3component[:, 0],\n    activity_3component_kappa[:, 2],\n    label=\"Component 3\",\n    color=\"red\",\n)\nax[1].set_xlabel(\"Water Mole Fraction\")\nax[1].set_ylabel(\"Activity coefficient\")\nax[1].set_title(\"Kappa Activity coefficient vs mass fraction for 3 components\")\nax[1].legend()\n\n# Display the plot\nplt.tight_layout()\nplt.show()\n</pre> # kappa activity coefficient  kappa_1 = 0.0 # kappa of water kappa_2 = 0.6 # kappa of component 2 kappa_3 = 1.2 # kappa of component 3  water_index = 0  activity_2component_kappa = properties.kappa_activity(     mass_concentration=mass_2component,     kappa=np.array([kappa_1, kappa_2]),     density=density_2component,     molar_mass=np.array([molar_mass_1, molar_mass_2]),     water_index=water_index, ) activity_3component_kappa = properties.kappa_activity(     mass_concentration=mass_3component,     kappa=np.array([kappa_1, kappa_2, kappa_3]),     density=density_3component,     molar_mass=np.array([molar_mass_1, molar_mass_2, molar_mass_3]),     water_index=water_index, )  # Create the figure and axis objects fig, ax = plt.subplots(2, 1, figsize=(5, 8))  # Plot each component in the 2-component system with separate colors ax[0].plot(     mass_fractions_2component[:, 0],     activity_2component_kappa[:, 0],     color=\"blue\",     label=\"Water (1)\", ) ax[0].plot(     mass_fractions_2component[:, 0],     activity_2component_kappa[:, 1],     color=\"green\",     label=\"Component 2\", ) ax[0].set_xlabel(\"Water Mole Fraction\") ax[0].set_ylabel(\"Activity coefficient\") ax[0].set_title(\"Kappa Activity coefficient vs mass fraction for 2 components\") ax[0].legend()  # Plot the 3-component system without setting specific colors ax[1].plot(     mass_fractions_3component[:, 0],     activity_3component_kappa[:, 0],     label=\"Water (1)\",     color=\"blue\", ) ax[1].plot(     mass_fractions_3component[:, 0],     activity_3component_kappa[:, 1],     label=\"Component 2\",     color=\"green\", ) ax[1].plot(     mass_fractions_3component[:, 0],     activity_3component_kappa[:, 2],     label=\"Component 3\",     color=\"red\", ) ax[1].set_xlabel(\"Water Mole Fraction\") ax[1].set_ylabel(\"Activity coefficient\") ax[1].set_title(\"Kappa Activity coefficient vs mass fraction for 3 components\") ax[1].legend()  # Display the plot plt.tight_layout() plt.show()"},{"location":"Tutorials/Particle_Phase/Functional/Activity_Functions/#activity-tutorial","title":"Activity Tutorial\u00b6","text":"<p>This Jupyter notebook is designed to deepen your understanding of mixing behaviors in solutions, focusing on both theoretical models and practical applications. We will explore ideal and non-ideal mixing rules, differentiate between mass-based and molar-based approaches, and introduce the kappa value parameterization for predicting water activity.</p>"},{"location":"Tutorials/Particle_Phase/Functional/Activity_Functions/#introduction-to-mixing-rules","title":"Introduction to Mixing Rules\u00b6","text":"<p>Mixing rules are essential for predicting the properties of solutions, including their thermodynamic behavior and phase equilibria. In this notebook, we will:</p> <ul> <li>Define and compare different mixing rules: Understand how various rules apply to different types of solutions.</li> <li>Mass-Based vs. Molar-Based Mixing: Discuss the implications of choosing mass-based or molar-based calculations for different applications.</li> <li>Kappa Value based Activity: Learn about the kappa value parameterization and its role in modeling water activity in non-ideal solutions.</li> </ul>"},{"location":"Tutorials/Particle_Phase/Functional/Activity_Functions/#structure-of-the-notebook","title":"Structure of the Notebook\u00b6","text":"<ol> <li><p>Mass-Based vs. Molar-Based vs. Volueme-Based</p> <ul> <li>Definitions and when to use each method</li> <li>Examples and comparative analysis</li> </ul> </li> <li><p>Kappa Value Parameterization</p> <ul> <li>Theory behind kappa values</li> <li>Practical exercises on calculating water activity</li> </ul> </li> </ol>"},{"location":"Tutorials/Particle_Phase/Functional/Activity_Functions/#mass-arrays","title":"Mass Arrays\u00b6","text":"<p>First we'll need to create some mass concentration arrays to use in our examples. We will use a 2-component and 3-component system for demonstration purposes.</p> <p>In each the first component is water and the second component is a solute. The mass fractions of the solute will be varied to demonstrate the different mixing rules.</p>"},{"location":"Tutorials/Particle_Phase/Functional/Activity_Functions/#molar-based-mixing","title":"Molar-Based Mixing\u00b6","text":"<p>The ideal in this context refers to all the activity coefficients being equal to 1. This is the simplest case and is often used as a reference point for more complex models. In this case, then we are just mixing based on molar fractions.</p>"},{"location":"Tutorials/Particle_Phase/Functional/Activity_Functions/#volume-based-mixing","title":"Volume-Based Mixing\u00b6","text":"<p>In this next example, we will use volume-based mixing. This is common for use with liquid mixtures, where the volume of the solution is the sum of the volumes of the components. This is a simple way to mix solutions, but it is not always accurate.</p>"},{"location":"Tutorials/Particle_Phase/Functional/Activity_Functions/#mass-based-mixing","title":"Mass-Based Mixing\u00b6","text":"<p>In this example, we will use mass-based mixing. This is the simplest, as our mass fractions are directly proportional to the mass of the components.</p>"},{"location":"Tutorials/Particle_Phase/Functional/Activity_Functions/#kappa-activity","title":"Kappa-Activity\u00b6","text":"<p>The kappa value parameterization is a simple way to model non-ideal water interactions in solutions.</p>"},{"location":"Tutorials/Particle_Phase/Functional/Activity_Functions/#summary","title":"Summary\u00b6","text":"<p>By the end of this notebook, you should have a better understanding of mixing rules, mass-based vs. molar-based calculations, and the kappa value parameterization for predicting water activity in non-ideal solutions. You will also have learned how to apply these concepts to practical examples and visualize the results using plots.</p> <p>You saw how different mixing rules can be used to predict the properties of solutions and how they can affect the accuracy of the predictions. You also learned about the kappa value parameterization and how it can be used to model water activity in non-ideal solutions. These concepts are essential for condensation and phase equilibrium calculations when aerosol particles are present in the atmosphere.</p>"},{"location":"contribute/","title":"Contribute","text":"<p>Here we have summary and links to the different ways you can contribute to the project.</p>"},{"location":"contribute/#contents","title":"Contents","text":"<ul> <li>Code of Conduct</li> <li>Contributing Guidelines</li> <li>Style Guide (Google)</li> </ul>"},{"location":"contribute/CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"contribute/CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"contribute/CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or   advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"contribute/CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"contribute/CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"contribute/CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at . All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"contribute/CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"contribute/CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"contribute/CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"contribute/CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"contribute/CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"contribute/CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"contribute/CONTRIBUTING/","title":"Contributor Guidelines","text":"<p>First of all, thank you for considering contributing to this project! While we have specific guidelines below, we also encourage you to contribute to the best of your ability and not let these guidelines hinder your productivity and creativity. We are open to any contribution, and we are always looking for new ways to improve the project. We are also open to any feedback, however small or large, and in any area (from documentation to calculation to presentation).</p> <p>The cycle of contribution goes something like this:</p> <ol> <li> <p>See if there is an issue open that you can help with. If there is not one, please open one.</p> </li> <li> <p>Create a personal fork of this repository; and in it, create a branch (from <code>uncscode:main</code>) with the <code>issue000</code> in the name of the branch (e.g. <code>username/issue000</code> or <code>issue000</code>), where <code>000</code> is the number of the issue from step 1.</p> </li> <li> <p>Set up an appropriate environment:</p> <ul> <li>an easy option is just to use the <code>.devcontainer</code> in root</li> <li>another option is to either <code>pip install</code> or <code>conda install</code> the packages required for development in <code>requirements.txt</code> in root.</li> </ul> </li> <li> <p>Write your code in the branch. This usually includes the following.</p> <p>a. Code to be implemented.</p> <p>b. Documentation associated with added code in a.</p> <p>c. Tests associated with added code in a.</p> <p>d. Ideally, you'd also add a Jupyter notebook to showcase your work (if applicable).</p> </li> <li> <p>Optionally, you can run standard linting and testing calls on your code locally to make sure it works as expected. This can be done in several ways, for example the <code>pylint</code>, <code>flake8</code>, and <code>pytest</code> calls below. These calls will be run once you submit your pull request.</p> </li> <li> <p>Submit a pull request to the <code>main</code> branch of this repository. Upon submission, standard automated tests will be run on your code.</p> </li> <li> <p>If you don't hear back from maintainers, feel free to mention one of us directly in the comments of the PR. Expect to have speedy feedback and help from us to finalize the PR.</p> </li> </ol> <pre><code>pylint $(find particula/ -name \"*.py\" | xargs)\n</code></pre> <pre><code>flake8 particula/ --count\n</code></pre> <pre><code>pytest particula/\n</code></pre> <p>More information about contributing to this project can be found below. We are excited and looking forward to your contribution!</p>"},{"location":"contribute/CONTRIBUTING/#github","title":"GitHub","text":"<p>We use GitHub to develop <code>particula</code> completely in the open. Our repository is available here: https://uncscode.github.io/particula/. There are several ways to use GitHub: through the command line via <code>git</code> and/or <code>gh</code>, through the web interface and/or the GitHub web editor, or through an IDE like PyCharm or a code editor like Visual Studio Code. In general, we recommend that you fork our repository, that you work with VS Code, and that submit a pull request based on an issue. If any of these sound unfamiliar or if you need help, please see more information below and feel free to contact us directly to discuss options. We look forward to getting you started and up to speed on this project with us!</p> <p>Links: https://docs.github.com/en/get-started</p>"},{"location":"contribute/CONTRIBUTING/#vs-code","title":"VS Code","text":"<p>Visual Studio Code is a free and open-source code editor for writing code and it has a rich ecosystem of extensions that allow you to write code in a variety of languages with a lot of helpful features and tools.</p> <p>Links: https://code.visualstudio.com/</p>"},{"location":"contribute/CONTRIBUTING/#devcontainer","title":"<code>.devcontainer</code>","text":"<p>In the root of our repository, we have a <code>.devcontainer</code> folder that contains the environment variables required for development. This is a convenient way to set up the environment for development. It requires Docker to be installed and running. And the first time it runs it may take a few minutes to install the Docker image (a minimal operating system with Python 3.9).</p> <p>Links: https://code.visualstudio.com/docs/remote/containers</p>"},{"location":"contribute/CONTRIBUTING/#python-code-style","title":"Python code style","text":"<p>We follow the Google's Python style guide. We encourage you to follow it too, but we also encourage you to contribute to the best of your ability and not let these guidelines hinder your productivity and creativity.</p> <p>Links: https://google.github.io/styleguide/pyguide.html</p>"},{"location":"contribute/CONTRIBUTING/#running-particula-locally","title":"Running <code>particula</code> locally","text":"<p>Once you are in the root directory, you will be able to import <code>particula</code> as a package/model and thus all documentation on website applies. You must be in the root directory.</p>"},{"location":"contribute/CONTRIBUTING/#writing-tests","title":"Writing tests","text":"<p>It is essential that every piece of code has an associated test. This is a good way to ensure that the code is working as intended. It also ensures that the code is not broken and that the code is not too complex. However small or big, a test is always required.</p>"},{"location":"contribute/CONTRIBUTING/#running-testinglinting-locally","title":"Running testing/linting locally","text":"<p>We use <code>pytest</code>, <code>pylint</code>, and <code>flake8</code> to run tests and linting. The command below can be run in the root directory like you'd run the package above.</p> <pre><code>pylint $(find particula/ -name \"*.py\" | xargs)\n</code></pre> <pre><code>flake8 particula/ --count\n</code></pre> <pre><code>pytest particula/\n</code></pre>"},{"location":"contribute/CONTRIBUTING/#building-particula-locally","title":"Building <code>particula</code> locally","text":"<p>To build <code>particula</code> locally, you must be in the root directory. You have two options, depending on your usage case.</p> <ol> <li>You can use <code>python -m build</code> to build the package wheels locally (note: you will need to install <code>build</code> too, via <code>pip install build</code>).</li> <li>You can build the conda recipe available at https://github.com/conda-forge/particula-feedstock either via <code>python build-locally.py</code> in the root of <code>particula-feedstock</code> or via <code>conda build recipe</code> (equivalently, but faster, <code>mamba build recipe</code>). For the latter, you will need to have <code>conda-build</code> installed (for <code>conda build</code> to work) or <code>boa</code> (for <code>mamba build</code> to work). In either case, you can install package with conda via, <code>conda install conda-build</code> or <code>mamba install boa</code>.</li> </ol> <p>Links: https://packaging.python.org/en/latest/tutorials/packaging-projects/ and https://docs.conda.io/projects/conda-build/en/latest/user-guide/index.html</p>"},{"location":"contribute/CONTRIBUTING/#documentation-writing","title":"Documentation writing","text":"<p>We prefer that the tutorials are written in the form of Jupyter notebooks after the package is released and published. A convenient option is using Google's Colaboratory to write the notebooks.</p> <p>Links: https://colab.research.google.com/</p>"},{"location":"contribute/CONTRIBUTING/#more-information","title":"More information","text":"<p>We will update this regularly with more information, but in the meanwhile, please feel free to contact us directly on GitHub.</p>"},{"location":"next/","title":"Next Outline","text":"<p>Next is the next iteration of the particula simulation model. It is a complete rewrite of the model, with a focus on improving the modularity and extensibility of the model. The goal is to make it easier to add new features and to make the model more flexible and easier to use.</p>"},{"location":"next/#particle-resolved","title":"Particle Resolved","text":"<ul> <li> Coagulation needs to be implemented</li> <li> check equilibrium for condensation and evaporation</li> </ul>"},{"location":"next/#continuous-particle-pdf-and-pmf","title":"Continuous Particle PDF and PMF","text":"<ul> <li> Bin Remapping after condensation and evaporation is needed, or dr/dt method</li> <li> Coagulation needs to be checked for PMF vs PDF handling</li> <li> ODE solver for both needs to be implemented</li> </ul>"},{"location":"next/#scavenging","title":"Scavenging","text":"<ul> <li> Scavenging needs to be implemented for Particle Resolved</li> </ul>"},{"location":"next/#activity-coefficients","title":"Activity Coefficients","text":"<ul> <li> BAT model needs added to activity coefficient calculation</li> </ul>"},{"location":"next/#guides-for-developers","title":"Guides for Developers","text":"<ul> <li> More focused reorganization of the code and examples.</li> </ul>"},{"location":"old-examples/","title":"Examples Outline","text":"<p>This is a collection of jupyter notebooks that demonstrate how to use the aspects of the <code>particula</code> library.</p>"},{"location":"old-examples/#table-of-contents","title":"Table of contents","text":"<ul> <li>Tour of Particula</li> <li>Distributions</li> </ul>"},{"location":"old-examples/distributions/","title":"Distributions Examples","text":"<p>This is a collection of jupyter notebooks that demonstrate how to use the aspects of the <code>particula</code> library.</p>"},{"location":"old-examples/distributions/#notebooks","title":"Notebooks","text":"<ul> <li>Ambient Aerosol Distributions</li> <li>Coagulation of Distribution</li> <li>Time Evolution of Distribution</li> <li>Statistics of Distribution</li> <li>Ion and Charge Distributions</li> </ul>"},{"location":"old-examples/distributions/notebooks/distribution_ambient/","title":"Distributions","text":"In\u00a0[\u00a0]: Copied! <pre>try:\n    import particula, matplotlib\nexcept ImportError:\n    print(\"Setting up computational environment...\")\n    %pip install -U particula -qqq\n    %pip install matplotlib -qqq\n\nfrom particula import particle, rates\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom particula.util.simple_solver import SimpleSolver\nfrom particula.util.coagulation_rate import CoagulationRate\nfrom particula.util.dimensionless_coagulation import full_coag\nfrom particula.util.input_handling import in_time\n</pre> try:     import particula, matplotlib except ImportError:     print(\"Setting up computational environment...\")     %pip install -U particula -qqq     %pip install matplotlib -qqq  from particula import particle, rates import numpy as np from matplotlib import pyplot as plt from particula.util.simple_solver import SimpleSolver from particula.util.coagulation_rate import CoagulationRate from particula.util.dimensionless_coagulation import full_coag from particula.util.input_handling import in_time In\u00a0[19]: Copied! <pre>ambient_dist = {\n    \"mode\": [100e-9, 2000e-9], # 100 nm and 2000 nm \n    \"nbins\": 250, # cut the bins down for speed\n    \"nparticles\": [1e7, 1e4], # 1e4 #\n    \"volume\": 1e-6, # per 1e-6 m^3 (or 1 cc)\n    \"gsigma\": [1.25,1.4], # relatively narrow\n    \"spacing\": \"logspace\", # bin spacing,\n}\n\nambient_dist = particle.Particle(**ambient_dist) \n\n#inital distribution coag kernel\ncoag_kernel = full_coag(radius=ambient_dist.particle_radius)\ntime_array = np.arange(0, 30*60, 1)\n\n#setup the inital state of the distribution\nproblem = {\n    \"distribution\": ambient_dist.particle_distribution(),\n    \"radius\": ambient_dist.particle_radius,\n    \"kernel\": coag_kernel,\n    \"tspan\": time_array\n}\n\nproblem2 = {\n    \"distribution\": ambient_dist.particle_distribution(),\n    \"radius\": ambient_dist.particle_radius,\n    \"kernel\": coag_kernel*10, # 10x increase to approximate soot\n    \"tspan\": time_array\n}\n\n\n#call the solver\nsolution = SimpleSolver(**problem).solution()\nsolution2 = SimpleSolver(**problem2).solution()\n</pre> ambient_dist = {     \"mode\": [100e-9, 2000e-9], # 100 nm and 2000 nm      \"nbins\": 250, # cut the bins down for speed     \"nparticles\": [1e7, 1e4], # 1e4 #     \"volume\": 1e-6, # per 1e-6 m^3 (or 1 cc)     \"gsigma\": [1.25,1.4], # relatively narrow     \"spacing\": \"logspace\", # bin spacing, }  ambient_dist = particle.Particle(**ambient_dist)   #inital distribution coag kernel coag_kernel = full_coag(radius=ambient_dist.particle_radius) time_array = np.arange(0, 30*60, 1)  #setup the inital state of the distribution problem = {     \"distribution\": ambient_dist.particle_distribution(),     \"radius\": ambient_dist.particle_radius,     \"kernel\": coag_kernel,     \"tspan\": time_array }  problem2 = {     \"distribution\": ambient_dist.particle_distribution(),     \"radius\": ambient_dist.particle_radius,     \"kernel\": coag_kernel*10, # 10x increase to approximate soot     \"tspan\": time_array }   #call the solver solution = SimpleSolver(**problem).solution() solution2 = SimpleSolver(**problem2).solution()    <p>So we ran the simulation, and lets plot a couple slices for each. Solution 2 is an 10x increase in the coagulation kernel, which is a rough approximation for the coagulation enhancement due to a chain-like soot structure over the base spherical particle model.</p> In\u00a0[26]: Copied! <pre>#plot\nfig, ax= plt.subplots(1,1,figsize=[10,10])\n\nradius = ambient_dist.particle_radius.to('nm').m\nax.loglog(radius, ambient_dist.particle_distribution().m, '-k', label='Inital')\nax.loglog(radius, solution.m[29,:], '--b', label='t=30 sec spheres')\nax.loglog(radius, solution.m[-1,:], '-.b', label='t=30 min spheres')\n\nax.loglog(radius, solution2.m[29,:], '--r', label='t=30 sec soot')\nax.loglog(radius, solution2.m[-1,:], '-.r', label='t=30 min soot')\n\n\nax.legend()\nax.set_ylim(bottom=1e11)\nax.set_xlim(left=40, right= 10000)\nax.set_ylabel(f\"Number, {ambient_dist.particle_distribution().u}\")\nax.set_xlabel(f\"Radius, {ambient_dist.particle_radius.u}\")\nax.grid(True, which='both', alpha=0.5)\n</pre> #plot fig, ax= plt.subplots(1,1,figsize=[10,10])  radius = ambient_dist.particle_radius.to('nm').m ax.loglog(radius, ambient_dist.particle_distribution().m, '-k', label='Inital') ax.loglog(radius, solution.m[29,:], '--b', label='t=30 sec spheres') ax.loglog(radius, solution.m[-1,:], '-.b', label='t=30 min spheres')  ax.loglog(radius, solution2.m[29,:], '--r', label='t=30 sec soot') ax.loglog(radius, solution2.m[-1,:], '-.r', label='t=30 min soot')   ax.legend() ax.set_ylim(bottom=1e11) ax.set_xlim(left=40, right= 10000) ax.set_ylabel(f\"Number, {ambient_dist.particle_distribution().u}\") ax.set_xlabel(f\"Radius, {ambient_dist.particle_radius.u}\") ax.grid(True, which='both', alpha=0.5) In\u00a0[21]: Copied! <pre>radius = ambient_dist.particle_radius.m\nradius_withunits= ambient_dist.particle_radius\nsplit = 600e-9 # fine to coarse cut off we are using.\n\nsplit_index = np.argmin(np.abs(radius-split))\nprint(split_index)\n\nfine_mode = np.zeros_like(time_array)\ncoarse_mode = np.zeros_like(time_array)\n\nfine_mode2 = np.zeros_like(time_array)\ncoarse_mode2 = np.zeros_like(time_array)\n\nfine_mode_vol = np.zeros_like(time_array)\ncoarse_mode_vol = np.zeros_like(time_array)\n\ndef pdf_total(radius, pdf_distribution):\n    return np.trapz(y=pdf_distribution, x=radius)\n\ndef pdf_volume_total(radius, pdf_distribution):\n    return np.trapz(y=pdf_distribution* 4/3 * np.pi * radius**3, x=radius)\n\nfor i, value in enumerate(time_array):\n  fine_mode[i] = pdf_total(radius[0:split_index], solution.m[i, 0:split_index] )\n  coarse_mode[i] = pdf_total(radius[split_index:-1], solution.m[i, split_index:-1] )\n  fine_mode2[i] = pdf_total(radius[0:split_index], solution2.m[i, 0:split_index] )\n  coarse_mode2[i] = pdf_total(radius[split_index:-1], solution2.m[i, split_index:-1] )\n\n  fine_mode_vol[i] = pdf_volume_total(radius_withunits[0:split_index], solution[i, 0:split_index] )\n  coarse_mode_vol[i] = pdf_volume_total(radius_withunits[split_index:-1], solution[i, split_index:-1] )\n\nfig, ax= plt.subplots(1,1,figsize=[10,10])\n\nax.semilogy(time_array, fine_mode, '-b', label='fine sphere')\nax.semilogy(time_array, coarse_mode, '--b', label='coarse sphere')\n\nax.semilogy(time_array, fine_mode2, '-r', label='fine soot')\nax.semilogy(time_array, coarse_mode2, '--r', label='coarse soot')\n\nax.legend()\nax.set_xlim(left=0)\nax.set_ylabel(f\"number, #/m3 \")\nax.set_xlabel(f\"time, \")\nax.grid(True, which='both', alpha=0.5)\n\nfig.savefig('coagulation_number.png')\nfig.savefig('coagulation_number.pdf')\n</pre> radius = ambient_dist.particle_radius.m radius_withunits= ambient_dist.particle_radius split = 600e-9 # fine to coarse cut off we are using.  split_index = np.argmin(np.abs(radius-split)) print(split_index)  fine_mode = np.zeros_like(time_array) coarse_mode = np.zeros_like(time_array)  fine_mode2 = np.zeros_like(time_array) coarse_mode2 = np.zeros_like(time_array)  fine_mode_vol = np.zeros_like(time_array) coarse_mode_vol = np.zeros_like(time_array)  def pdf_total(radius, pdf_distribution):     return np.trapz(y=pdf_distribution, x=radius)  def pdf_volume_total(radius, pdf_distribution):     return np.trapz(y=pdf_distribution* 4/3 * np.pi * radius**3, x=radius)  for i, value in enumerate(time_array):   fine_mode[i] = pdf_total(radius[0:split_index], solution.m[i, 0:split_index] )   coarse_mode[i] = pdf_total(radius[split_index:-1], solution.m[i, split_index:-1] )   fine_mode2[i] = pdf_total(radius[0:split_index], solution2.m[i, 0:split_index] )   coarse_mode2[i] = pdf_total(radius[split_index:-1], solution2.m[i, split_index:-1] )    fine_mode_vol[i] = pdf_volume_total(radius_withunits[0:split_index], solution[i, 0:split_index] )   coarse_mode_vol[i] = pdf_volume_total(radius_withunits[split_index:-1], solution[i, split_index:-1] )  fig, ax= plt.subplots(1,1,figsize=[10,10])  ax.semilogy(time_array, fine_mode, '-b', label='fine sphere') ax.semilogy(time_array, coarse_mode, '--b', label='coarse sphere')  ax.semilogy(time_array, fine_mode2, '-r', label='fine soot') ax.semilogy(time_array, coarse_mode2, '--r', label='coarse soot')  ax.legend() ax.set_xlim(left=0) ax.set_ylabel(f\"number, #/m3 \") ax.set_xlabel(f\"time, \") ax.grid(True, which='both', alpha=0.5)  fig.savefig('coagulation_number.png') fig.savefig('coagulation_number.pdf') <pre>128\n</pre>"},{"location":"old-examples/distributions/notebooks/distribution_ambient/#distributions","title":"Distributions\u00b6","text":"<p>Usually in the ambient air, there are at least two modes of aerosol particles. Fine mode (150 nm mode) generated from atmospheric chemistry and combustion emissions. Coarse mode (10 microns mode) generated from windblown dust, sea salt, or wildfire ash.</p> <p>So let's make a multi-modal distribution and propagate that forward in time.</p>"},{"location":"old-examples/distributions/notebooks/distribution_ambient/#combined-distributions","title":"combined distributions\u00b6","text":"<p>As we saw in the mulit-mode distribution call above, you can use keywards to get multiple distributions. Let's see how those fine and coarse mode distributions interact.</p>"},{"location":"old-examples/distributions/notebooks/distribution_ambient/#number-vs-time","title":"Number vs Time\u00b6","text":"<p>Now lets plot the integrated number vs time. We should see the fine mode decrease, and the coarse mode increase a little depending on how fast the coagulational growth is moving the distribution.</p>"},{"location":"old-examples/distributions/notebooks/distribution_ambient/#summary","title":"Summary\u00b6","text":"<p>So we covered how to make a distribution, and how to progress a distribution forward in time with coagulation. This is just one of the three key processes (nucleation, condensation, and coagulation) happening to particles in the atmosphere; all of which can be simulated with <code>Particula</code>!</p>"},{"location":"old-examples/distributions/notebooks/distribution_coagulation/","title":"Distribution coagulation","text":"In\u00a0[\u00a0]: Copied! <pre>try:\n    import particula, matplotlib\nexcept ImportError:\n    print(\"Setting up computational environment...\")\n    %pip install -U particula -qqq\n    %pip install matplotlib -qqq\n\n\nfrom particula import particle, rates\nimport numpy as np\nfrom matplotlib import pyplot as plt\n</pre> try:     import particula, matplotlib except ImportError:     print(\"Setting up computational environment...\")     %pip install -U particula -qqq     %pip install matplotlib -qqq   from particula import particle, rates import numpy as np from matplotlib import pyplot as plt In\u00a0[\u00a0]: Copied! <pre>coarse_mode = {\n    \"mode\": 2000e-9, # 200 nm median\n    \"nbins\": 1000, # 1000 bins\n    \"nparticles\": 1e5, # 1e4 #\n    \"volume\": 1e-6, # per 1e-6 m^3 (or 1 cc)\n    \"gsigma\": 1.4, # relatively narrow\n    \"spacing\": \"linspace\", # bin spacing, \n}\n</pre> coarse_mode = {     \"mode\": 2000e-9, # 200 nm median     \"nbins\": 1000, # 1000 bins     \"nparticles\": 1e5, # 1e4 #     \"volume\": 1e-6, # per 1e-6 m^3 (or 1 cc)     \"gsigma\": 1.4, # relatively narrow     \"spacing\": \"linspace\", # bin spacing,  } In\u00a0[12]: Copied! <pre>coarse_mode_dist = particle.Particle(**coarse_mode)\ncoarse_coag_loss = rates.Rates(particle=coarse_mode_dist).coagulation_loss()\ncoarse_coag_gain = rates.Rates(particle=coarse_mode_dist).coagulation_gain()\n</pre> coarse_mode_dist = particle.Particle(**coarse_mode) coarse_coag_loss = rates.Rates(particle=coarse_mode_dist).coagulation_loss() coarse_coag_gain = rates.Rates(particle=coarse_mode_dist).coagulation_gain() <p>Then plotting the results, we see that smaller particles are lost and larger particles gain number</p> In\u00a0[13]: Copied! <pre>fig, ax = plt.subplots(1, 1, figsize=[9, 6])\n\n# (2*(peak of original distribution)**3)**(1/3)\n\nax.semilogx(coarse_mode_dist.particle_radius.m, -coarse_coag_loss.m, '-r', label='particles Lost')\nax.semilogx(coarse_mode_dist.particle_radius.m, coarse_coag_gain.m, '-b', label='particles Gained')\nax.semilogx(coarse_mode_dist.particle_radius.m, coarse_coag_gain.m-coarse_coag_loss.m, '--k', label= 'Net change')\nax.legend()\nax.set_xlabel(f\"radius, {coarse_mode_dist.particle_radius.u}\")\nax.set_ylabel(f\"coagulation rates, {coarse_coag_gain.u}\")\nax.grid(True, alpha=0.5)\n</pre> fig, ax = plt.subplots(1, 1, figsize=[9, 6])  # (2*(peak of original distribution)**3)**(1/3)  ax.semilogx(coarse_mode_dist.particle_radius.m, -coarse_coag_loss.m, '-r', label='particles Lost') ax.semilogx(coarse_mode_dist.particle_radius.m, coarse_coag_gain.m, '-b', label='particles Gained') ax.semilogx(coarse_mode_dist.particle_radius.m, coarse_coag_gain.m-coarse_coag_loss.m, '--k', label= 'Net change') ax.legend() ax.set_xlabel(f\"radius, {coarse_mode_dist.particle_radius.u}\") ax.set_ylabel(f\"coagulation rates, {coarse_coag_gain.u}\") ax.grid(True, alpha=0.5)"},{"location":"old-examples/distributions/notebooks/distribution_coagulation/#distribution-coagulation","title":"Distribution coagulation\u00b6","text":"<p>Now with particle number distribution we can calculated the coagulation rate, both the loss and gain in particle number. Let's import the classes from the previous tutorial and make a new coarse distribution.</p>"},{"location":"old-examples/distributions/notebooks/distribution_evolution/","title":"Distribution evolution","text":"In\u00a0[14]: Copied! <pre>try:\n    import particula, matplotlib\nexcept ImportError:\n    print(\"Setting up computational environment...\")\n    %pip install -U particula -qqq\n    %pip install matplotlib -qqq\n\n\nfrom particula import particle, rates\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom particula.util.coagulation_rate import CoagulationRate\nfrom particula.util.dimensionless_coagulation import full_coag\nfrom particula.util.input_handling import in_time\n</pre> try:     import particula, matplotlib except ImportError:     print(\"Setting up computational environment...\")     %pip install -U particula -qqq     %pip install matplotlib -qqq   from particula import particle, rates import numpy as np from matplotlib import pyplot as plt from particula.util.coagulation_rate import CoagulationRate from particula.util.dimensionless_coagulation import full_coag from particula.util.input_handling import in_time <p>We can do this in a simple way by using a for loop to march through the time steps.</p> In\u00a0[15]: Copied! <pre># Time steps\n\nsimple_dic_kwargs = {\n    \"mode\": 200e-9, # 200 nm median\n    \"nbins\": 500, # 1000 bins\n    \"nparticles\": 1e6, # 1e4 #\n    \"volume\": 1e-6, # per 1e-6 m^3 (or 1 cc)\n    \"gsigma\": 1.5, # relatively narrow\n}\nparticle_dist2 = particle.Particle(**simple_dic_kwargs) # pass the kwargs using ** prefix\n\n#inital distribution\np_distribution_0 = particle_dist2.particle_distribution()\np_radius = particle_dist2.particle_radius\ncoag_kernel = full_coag(radius=p_radius)\n\np_distribution_i = p_distribution_0\n\ntime_interval = in_time(10)\ntime_array = np.arange(0, 1000, time_interval.m)\n\ndistribution_time = np.zeros([len(time_array), len(p_distribution_0)])\n\nfor i, dpa in enumerate(time_array):\n\n    if i&gt;0:\n        # calculate coagulations\n        coag_gain_i = CoagulationRate(p_distribution_i, p_radius, coag_kernel).coag_gain()\n        coag_loss_i = CoagulationRate(p_distribution_i, p_radius, coag_kernel).coag_loss()\n\n        net_change = (coag_gain_i-coag_loss_i)*time_interval\n        p_distribution_i = p_distribution_i+net_change\n\n    distribution_time[i,:] = p_distribution_i.m\n</pre> # Time steps  simple_dic_kwargs = {     \"mode\": 200e-9, # 200 nm median     \"nbins\": 500, # 1000 bins     \"nparticles\": 1e6, # 1e4 #     \"volume\": 1e-6, # per 1e-6 m^3 (or 1 cc)     \"gsigma\": 1.5, # relatively narrow } particle_dist2 = particle.Particle(**simple_dic_kwargs) # pass the kwargs using ** prefix  #inital distribution p_distribution_0 = particle_dist2.particle_distribution() p_radius = particle_dist2.particle_radius coag_kernel = full_coag(radius=p_radius)  p_distribution_i = p_distribution_0  time_interval = in_time(10) time_array = np.arange(0, 1000, time_interval.m)  distribution_time = np.zeros([len(time_array), len(p_distribution_0)])  for i, dpa in enumerate(time_array):      if i&gt;0:         # calculate coagulations         coag_gain_i = CoagulationRate(p_distribution_i, p_radius, coag_kernel).coag_gain()         coag_loss_i = CoagulationRate(p_distribution_i, p_radius, coag_kernel).coag_loss()          net_change = (coag_gain_i-coag_loss_i)*time_interval         p_distribution_i = p_distribution_i+net_change      distribution_time[i,:] = p_distribution_i.m In\u00a0[22]: Copied! <pre>fig, ax = plt.subplots(1, 1, figsize=[9, 6])\n\nradius = p_radius.m\nax.semilogx(radius, p_distribution_0.m, '-b', label='Inital')\nax.semilogx(radius, distribution_time[49,:], '--', label='t=50')\nax.semilogx(radius, distribution_time[-1,:], '-r', label='t=end')\n\nax.legend()\nax.set_ylabel(f\"Number, {particle_dist2.particle_distribution().u}\")\nax.set_xlabel(f\"Radius, {particle_dist2.particle_radius.u}\")\nax.grid(True, alpha=0.5)\n</pre> fig, ax = plt.subplots(1, 1, figsize=[9, 6])  radius = p_radius.m ax.semilogx(radius, p_distribution_0.m, '-b', label='Inital') ax.semilogx(radius, distribution_time[49,:], '--', label='t=50') ax.semilogx(radius, distribution_time[-1,:], '-r', label='t=end')  ax.legend() ax.set_ylabel(f\"Number, {particle_dist2.particle_distribution().u}\") ax.set_xlabel(f\"Radius, {particle_dist2.particle_radius.u}\") ax.grid(True, alpha=0.5) In\u00a0[17]: Copied! <pre>from particula.util.simple_solver import SimpleSolver\n</pre> from particula.util.simple_solver import SimpleSolver <p>Then let us run the same dynamic problem again</p> In\u00a0[18]: Copied! <pre>simple_dic_kwargs = {\n    \"mode\": 200e-9, # 200 nm median\n    \"nbins\": 500, # 1000 bins\n    \"nparticles\": 1e6, # 1e4 #\n    \"volume\": 1e-6, # per 1e-6 m^3 (or 1 cc)\n    \"gsigma\": 1.5, # relatively narrow\n}\nparticle_dist2 = particle.Particle(**simple_dic_kwargs) # pass the kwargs using ** prefix\n\n#inital distribution coag kernel\ncoag_kernel = full_coag(radius=particle_dist2.particle_radius)\ntime_array = np.arange(0, 1000, 10)\n\n#setup the inital state of the distribution\nproblem = {\n    \"distribution\": particle_dist2.particle_distribution(),\n    \"radius\": particle_dist2.particle_radius,\n    \"kernel\": coag_kernel,\n    \"tspan\": time_array\n}\n\n#call the solver\nsolution = SimpleSolver(**problem).solution()\n\n#plot\nfig, ax = plt.subplots(1, 1, figsize=[9, 6])\n\nradius = p_radius.m\nax.semilogx(radius, particle_dist2.particle_distribution().m, '-b', label='Inital')\nax.semilogx(radius, solution.m[49,:], '--', label='t=50')\nax.semilogx(radius, solution.m[-1,:], '-r', label='t=end')\n\nax.legend()\nax.set_ylabel(f\"Number, {particle_dist2.particle_distribution().u}\")\nax.set_xlabel(f\"Radius, {particle_dist2.particle_radius.u}\")\nax.grid(True, alpha=0.5)\n</pre> simple_dic_kwargs = {     \"mode\": 200e-9, # 200 nm median     \"nbins\": 500, # 1000 bins     \"nparticles\": 1e6, # 1e4 #     \"volume\": 1e-6, # per 1e-6 m^3 (or 1 cc)     \"gsigma\": 1.5, # relatively narrow } particle_dist2 = particle.Particle(**simple_dic_kwargs) # pass the kwargs using ** prefix  #inital distribution coag kernel coag_kernel = full_coag(radius=particle_dist2.particle_radius) time_array = np.arange(0, 1000, 10)  #setup the inital state of the distribution problem = {     \"distribution\": particle_dist2.particle_distribution(),     \"radius\": particle_dist2.particle_radius,     \"kernel\": coag_kernel,     \"tspan\": time_array }  #call the solver solution = SimpleSolver(**problem).solution()  #plot fig, ax = plt.subplots(1, 1, figsize=[9, 6])  radius = p_radius.m ax.semilogx(radius, particle_dist2.particle_distribution().m, '-b', label='Inital') ax.semilogx(radius, solution.m[49,:], '--', label='t=50') ax.semilogx(radius, solution.m[-1,:], '-r', label='t=end')  ax.legend() ax.set_ylabel(f\"Number, {particle_dist2.particle_distribution().u}\") ax.set_xlabel(f\"Radius, {particle_dist2.particle_radius.u}\") ax.grid(True, alpha=0.5)"},{"location":"old-examples/distributions/notebooks/distribution_evolution/#distribution-evolution","title":"Distribution evolution\u00b6","text":"<p>Now that we can make a distribution and calculate coagulation rates, let's move that forward in time.</p>"},{"location":"old-examples/distributions/notebooks/distribution_evolution/#for-loop-graph","title":"For loop Graph\u00b6","text":""},{"location":"old-examples/distributions/notebooks/distribution_evolution/#ode-solver","title":"ODE solver\u00b6","text":"<p>Instead of prescribing the time steps, which can make the problem solution unstable, let's let the code handle that with an ODE solver.</p> <p>Lets import that solver class</p>"},{"location":"old-examples/distributions/notebooks/distribution_evolution/#summary-on-stepping","title":"summary on stepping\u00b6","text":"<p>As we walked through, using the ODE solver is quite a nice way to get to the answer, without figuring out what time-step you might need.</p>"},{"location":"old-examples/distributions/notebooks/distribution_statistics/","title":"Distribution statistics","text":"In\u00a0[2]: Copied! <pre>try:\n    import particula, matplotlib\nexcept ImportError:\n    print(\"Setting up computational environment...\")\n    %pip install -U particula -qqq\n    %pip install matplotlib -qqq\n\n\nfrom particula import particle, rates\nimport numpy as np\nfrom matplotlib import pyplot as plt\n</pre> try:     import particula, matplotlib except ImportError:     print(\"Setting up computational environment...\")     %pip install -U particula -qqq     %pip install matplotlib -qqq   from particula import particle, rates import numpy as np from matplotlib import pyplot as plt In\u00a0[3]: Copied! <pre>default_distribution = particle.Particle()\n\nprint(\"Radii: \")\nprint(default_distribution.particle_radius[:10])\n</pre> default_distribution = particle.Particle()  print(\"Radii: \") print(default_distribution.particle_radius[:10]) <pre>Radii\n</pre> Out[3]: Magnitude<pre>[4.1972292396604054e-08 4.216876899517281e-08 4.236524559374157e-08 4.256172219231033e-08 4.275819879087909e-08 4.295467538944785e-08 4.315115198801661e-08 4.3347628586585377e-08 4.3544105185154136e-08 4.3740581783722896e-08]</pre>Unitsmeter <p>At every radius listed in <code>.particle_radius</code> is a probability of the particles at that radius. Thus, we have probability distribution function (PDF) of particles.</p> In\u00a0[4]: Copied! <pre>print(\"Particles PDF given radii: \")\nprint(default_distribution.particle_distribution()[:10])\n</pre> print(\"Particles PDF given radii: \") print(default_distribution.particle_distribution()[:10]) <pre>Particles PFD given radii.\n</pre> Out[4]: Magnitude<pre>[2200235960693703.8 2375247794883328.5 2562153632216260.0 2761608050637125.5 2974291484346663.0 3200910665710347.5 3442199044624819.5 3698917183754246.5 3971853128059254.0 4261822747056273.0]</pre>Units1/meter<sup>4</sup> In\u00a0[5]: Copied! <pre>fig, ax = plt.subplots(1, 2, figsize=[14, 6])\n\n#linear scale\nax[0].plot(default_distribution.particle_radius.m, default_distribution.particle_distribution().m)\n\nax[0].set_ylabel(f\"Number, {default_distribution.particle_distribution().u}\")\nax[0].set_xlabel(f\"Radius, {default_distribution.particle_radius.u}\")\nax[0].grid(True, alpha=0.5)\n\n#log x\nax[1].semilogx(default_distribution.particle_radius.m, default_distribution.particle_distribution().m)\n\nax[1].set_ylabel(f\"Number, {default_distribution.particle_distribution().u}\")\nax[1].set_xlabel(f\"Radius, {default_distribution.particle_radius.u}\")\nax[1].grid(True, alpha=0.5)\n</pre> fig, ax = plt.subplots(1, 2, figsize=[14, 6])  #linear scale ax[0].plot(default_distribution.particle_radius.m, default_distribution.particle_distribution().m)  ax[0].set_ylabel(f\"Number, {default_distribution.particle_distribution().u}\") ax[0].set_xlabel(f\"Radius, {default_distribution.particle_radius.u}\") ax[0].grid(True, alpha=0.5)  #log x ax[1].semilogx(default_distribution.particle_radius.m, default_distribution.particle_distribution().m)  ax[1].set_ylabel(f\"Number, {default_distribution.particle_distribution().u}\") ax[1].set_xlabel(f\"Radius, {default_distribution.particle_radius.u}\") ax[1].grid(True, alpha=0.5)  In\u00a0[6]: Copied! <pre>def pdf_total(radius, pdf_distribution):\n    return np.trapz(y=pdf_distribution, x=radius)\n\ndef pdf_volume_total(radius, pdf_distribution):\n    return np.trapz(y=pdf_distribution* 4/3 * np.pi * radius**3, x=radius)\n\nprint(f'Total number of the PDF, {pdf_total(default_distribution.particle_radius, default_distribution.particle_distribution())}')\n\nprint(f'Total volume of the PDF, {pdf_volume_total(default_distribution.particle_radius, default_distribution.particle_distribution())}')\n</pre> def pdf_total(radius, pdf_distribution):     return np.trapz(y=pdf_distribution, x=radius)  def pdf_volume_total(radius, pdf_distribution):     return np.trapz(y=pdf_distribution* 4/3 * np.pi * radius**3, x=radius)  print(f'Total number of the PDF, {pdf_total(default_distribution.particle_radius, default_distribution.particle_distribution())}')  print(f'Total volume of the PDF, {pdf_volume_total(default_distribution.particle_radius, default_distribution.particle_distribution())}') <pre>Total number of the PDF, 99989997132.11078 / meter ** 3\nTotal volume of the PDF, 5.237475060187453e-10 dimensionless\n</pre> <ul> <li>The integral area of the particle PDF is the total number of the distribution, $0.99\\times 10^{12}$ m $^{-3}$.</li> <li>Converting to volume PDF, the integral is the total volume of the particle distribution, $5\\times 10^{-10}$.</li> </ul> <p>That was using defaults, but the defaults might not work for your case so you can change the distribution properties using keyword arguments.</p> <p>Note the line spacing is how the bin widths are spaced, for numerical efficiently in the coagulation calculation <code>linspace</code> is preferred over <code>logspace</code>.</p> <p>For a complete list of the <code>kwargs</code> you can look at the XXX document.</p> In\u00a0[7]: Copied! <pre># around here, just define a kwargs\n\nfine_mode = {\n    \"mode\": 150e-9, # 200 nm median\n    \"nbins\": 1000, # 1000 bins\n    \"nparticles\": 1e8, # 1e4 #\n    \"volume\": 1e-6, # per 1e-6 m^3 (or 1 cc)\n    \"gsigma\": 1.25, # relatively narrow\n    \"spacing\": \"linspace\", # bin spacing, \n}\n\ncoarse_mode = {\n    \"mode\": 2000e-9, # 200 nm median\n    \"nbins\": 1000, # 1000 bins\n    \"nparticles\": 1e5, # 1e4 #\n    \"volume\": 1e-6, # per 1e-6 m^3 (or 1 cc)\n    \"gsigma\": 1.4, # relatively narrow\n    \"spacing\": \"linspace\", # bin spacing, \n}\n\nmulti_mode = {\n    \"mode\": [5000e-9, 50e-9, 300e-9], # 200 nm median\n    \"nbins\": 1000, # 1000 bins\n    \"nparticles\": [1e6,1e9,1e7], # 1e4 #\n    \"volume\": 1e-6, # per 1e-6 m^3 (or 1 cc)\n    \"gsigma\": [1.5,1.2,1.5], # relatively narrow\n    \"spacing\": \"logspace\", # bin spacing, \n}\n</pre> # around here, just define a kwargs  fine_mode = {     \"mode\": 150e-9, # 200 nm median     \"nbins\": 1000, # 1000 bins     \"nparticles\": 1e8, # 1e4 #     \"volume\": 1e-6, # per 1e-6 m^3 (or 1 cc)     \"gsigma\": 1.25, # relatively narrow     \"spacing\": \"linspace\", # bin spacing,  }  coarse_mode = {     \"mode\": 2000e-9, # 200 nm median     \"nbins\": 1000, # 1000 bins     \"nparticles\": 1e5, # 1e4 #     \"volume\": 1e-6, # per 1e-6 m^3 (or 1 cc)     \"gsigma\": 1.4, # relatively narrow     \"spacing\": \"linspace\", # bin spacing,  }  multi_mode = {     \"mode\": [5000e-9, 50e-9, 300e-9], # 200 nm median     \"nbins\": 1000, # 1000 bins     \"nparticles\": [1e6,1e9,1e7], # 1e4 #     \"volume\": 1e-6, # per 1e-6 m^3 (or 1 cc)     \"gsigma\": [1.5,1.2,1.5], # relatively narrow     \"spacing\": \"logspace\", # bin spacing,  }  In\u00a0[8]: Copied! <pre>fine_mode_dist = particle.Particle(**fine_mode) # pass the kwargs using ** prefix\ncoarse_mode_dist = particle.Particle(**coarse_mode) \nmulti_mode = particle.Particle(**multi_mode)\n</pre> fine_mode_dist = particle.Particle(**fine_mode) # pass the kwargs using ** prefix coarse_mode_dist = particle.Particle(**coarse_mode)  multi_mode = particle.Particle(**multi_mode)  In\u00a0[9]: Copied! <pre>print(f'Total number of the PDF, {pdf_total(fine_mode_dist.particle_radius, fine_mode_dist.particle_distribution())}')\n\nprint(f'Total volume of the PDF, {pdf_volume_total(fine_mode_dist.particle_radius, fine_mode_dist.particle_distribution())}')\nprint(f'Total volume of the PDF, {pdf_volume_total(coarse_mode_dist.particle_radius, coarse_mode_dist.particle_distribution())}')\nprint(f'Total volume of the PDF, {pdf_volume_total(multi_mode.particle_radius, multi_mode.particle_distribution())}')\n</pre> print(f'Total number of the PDF, {pdf_total(fine_mode_dist.particle_radius, fine_mode_dist.particle_distribution())}')  print(f'Total volume of the PDF, {pdf_volume_total(fine_mode_dist.particle_radius, fine_mode_dist.particle_distribution())}') print(f'Total volume of the PDF, {pdf_volume_total(coarse_mode_dist.particle_radius, coarse_mode_dist.particle_distribution())}') print(f'Total volume of the PDF, {pdf_volume_total(multi_mode.particle_radius, multi_mode.particle_distribution())}') <pre>Total number of the PDF, 99989997132110.78 / meter ** 3\nTotal volume of the PDF, 1.7676478328132657e-06 dimensionless\nTotal volume of the PDF, 5.566386043732607e-06 dimensionless\nTotal volume of the PDF, 0.0003653651719983997 dimensionless\n</pre> <p>Let's see what we just made.</p> In\u00a0[10]: Copied! <pre>fig, ax = plt.subplots(1, 2, figsize=[14, 6])\n\nax[0].plot(fine_mode_dist.particle_radius.m, fine_mode_dist.particle_distribution().m)\nax[0].plot(coarse_mode_dist.particle_radius.m, coarse_mode_dist.particle_distribution().m)\n\nax[0].set_ylabel(f\"Number, {fine_mode_dist.particle_distribution().u}\")\nax[0].set_xlabel(f\"Radius, {fine_mode_dist.particle_radius.u}\")\nax[0].grid(True, alpha=0.5)\n\nax[1].loglog(fine_mode_dist.particle_radius.m, fine_mode_dist.particle_distribution().m)\nax[1].loglog(coarse_mode_dist.particle_radius.m, coarse_mode_dist.particle_distribution().m)\n\nax[1].set_ylabel(f\"Number, {coarse_mode_dist.particle_distribution().u}\")\nax[1].set_xlabel(f\"Radius, {coarse_mode_dist.particle_radius.u}\")\nax[1].grid(True, alpha=0.5)\n\n\nfig, ax= plt.subplots(1, 2, figsize=[14, 6])\n\nax[0].plot(multi_mode.particle_radius.m, multi_mode.particle_distribution().m)\n\nax[0].set_ylabel(f\"Number, {multi_mode.particle_distribution().u}\")\nax[0].set_xlabel(f\"Radius, {multi_mode.particle_radius.u}\")\nax[0].grid(True, alpha=0.5)\n\nax[1].loglog(multi_mode.particle_radius.m, multi_mode.particle_distribution().m)\n\nax[1].set_ylabel(f\"Number, {multi_mode.particle_distribution().u}\")\nax[1].set_xlabel(f\"Radius, {multi_mode.particle_radius.u}\")\nax[1].grid(True, alpha=0.5)\n</pre> fig, ax = plt.subplots(1, 2, figsize=[14, 6])  ax[0].plot(fine_mode_dist.particle_radius.m, fine_mode_dist.particle_distribution().m) ax[0].plot(coarse_mode_dist.particle_radius.m, coarse_mode_dist.particle_distribution().m)  ax[0].set_ylabel(f\"Number, {fine_mode_dist.particle_distribution().u}\") ax[0].set_xlabel(f\"Radius, {fine_mode_dist.particle_radius.u}\") ax[0].grid(True, alpha=0.5)  ax[1].loglog(fine_mode_dist.particle_radius.m, fine_mode_dist.particle_distribution().m) ax[1].loglog(coarse_mode_dist.particle_radius.m, coarse_mode_dist.particle_distribution().m)  ax[1].set_ylabel(f\"Number, {coarse_mode_dist.particle_distribution().u}\") ax[1].set_xlabel(f\"Radius, {coarse_mode_dist.particle_radius.u}\") ax[1].grid(True, alpha=0.5)   fig, ax= plt.subplots(1, 2, figsize=[14, 6])  ax[0].plot(multi_mode.particle_radius.m, multi_mode.particle_distribution().m)  ax[0].set_ylabel(f\"Number, {multi_mode.particle_distribution().u}\") ax[0].set_xlabel(f\"Radius, {multi_mode.particle_radius.u}\") ax[0].grid(True, alpha=0.5)  ax[1].loglog(multi_mode.particle_radius.m, multi_mode.particle_distribution().m)  ax[1].set_ylabel(f\"Number, {multi_mode.particle_distribution().u}\") ax[1].set_xlabel(f\"Radius, {multi_mode.particle_radius.u}\") ax[1].grid(True, alpha=0.5)"},{"location":"old-examples/distributions/notebooks/distribution_statistics/#distribution-statistics","title":"Distribution statistics\u00b6","text":"<p>We are going to look at <code>Particle</code> class for this notebook to generate particle distributions.</p> <p>So let's get those imported along with numpy and <code>matplotlib</code> for plotting.</p>"},{"location":"old-examples/distributions/notebooks/distribution_statistics/#particle","title":"<code>Particle</code>\u00b6","text":"<p>Let's just call this and see what we get.</p>"},{"location":"old-examples/distributions/notebooks/distribution_statistics/#plot-the-particle-pdf","title":"Plot the particle PDF\u00b6","text":"<p>Let's see what this particle PDF looks like now.</p> <p>(Note using <code>.m</code> returns just the magnitude and drops the units.)</p>"},{"location":"old-examples/distributions/notebooks/distribution_statistics/#summary-statistics-of-a-particle-pdf","title":"Summary statistics of a particle PDF\u00b6","text":"<p>As the keen-eyed reader may have noticed, this is not a typical PDF and the maximunm is very large ($1.75*10^{18}$). Lets define some diagnostic functions and see what we get for the integral area.</p>"},{"location":"old-examples/distributions/notebooks/ionparticle_coagulation/","title":"Ion\u2013particle coagulation","text":"In\u00a0[1]: Copied! <pre>try:\n    import particula, matplotlib\nexcept ImportError:\n    print(\"Setting up computational environment...\")\n    %pip install -U particula -qqq\n    %pip install matplotlib -qqq\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom particula import particle, u\nfrom particula.util.lf2013_coagulation import lf2013_coag_full\n</pre> try:     import particula, matplotlib except ImportError:     print(\"Setting up computational environment...\")     %pip install -U particula -qqq     %pip install matplotlib -qqq  import numpy as np from matplotlib import pyplot as plt from particula import particle, u from particula.util.lf2013_coagulation import lf2013_coag_full In\u00a0[3]: Copied! <pre>approx = [\"hardsphere\", \"gk2008\", \"gh2012\", \"dy2007\", \"cg2019\"]\nfor i in range(len(approx)):\n    shared_dict = {\n        \"temperature\": 278,\n        \"coagulation_approximation\": approx[i]\n    }\n    positive_particles = [\n        particle.Particle(\n            **shared_dict,\n            particle_radius=3e-9,\n            particle_charge=i,\n            particle_density=1700,\n        ) for i in range(1, 10)\n    ]\n    negative_ion = particle.Particle(\n        **shared_dict,\n        particle_radius=0.45e-9,\n        particle_charge=-1,\n        particle_density=1860,\n    )\n    coags = [\n        negative_ion.coagulation(particle)\n        for particle in positive_particles\n    ]\n    coags_ccps_mags = [\n        coags[index].to(\"cc/s\").m\n        for index in range(0, 9)\n    ]\n    plt.semilogy(range(1,10), np.array(coags_ccps_mags).squeeze(), label=approx[i]);\n   \n\n\nret = np.nan_to_num(lf2013_coag_full(\n        ion_type=\"air\",\n        particle_type=\"conductive\",\n        temperature_val=298.15,\n        pressure_val=101325,\n        charge_vals=np.arange(1, 10),\n        radius_vals=3e-9,)[0], 0)  # [0] returns negative, [1] returns positive ions\nplt.semilogy(range(1,10),  np.array(ret*1e6).squeeze(), label=\"lf2013\");\nplt.ylim([1e-7, 1e-4]); plt.ylabel(\"Attachment coefficient, cc/s\"); plt.legend(); plt.xlabel(\"# charges\");\n</pre> approx = [\"hardsphere\", \"gk2008\", \"gh2012\", \"dy2007\", \"cg2019\"] for i in range(len(approx)):     shared_dict = {         \"temperature\": 278,         \"coagulation_approximation\": approx[i]     }     positive_particles = [         particle.Particle(             **shared_dict,             particle_radius=3e-9,             particle_charge=i,             particle_density=1700,         ) for i in range(1, 10)     ]     negative_ion = particle.Particle(         **shared_dict,         particle_radius=0.45e-9,         particle_charge=-1,         particle_density=1860,     )     coags = [         negative_ion.coagulation(particle)         for particle in positive_particles     ]     coags_ccps_mags = [         coags[index].to(\"cc/s\").m         for index in range(0, 9)     ]     plt.semilogy(range(1,10), np.array(coags_ccps_mags).squeeze(), label=approx[i]);       ret = np.nan_to_num(lf2013_coag_full(         ion_type=\"air\",         particle_type=\"conductive\",         temperature_val=298.15,         pressure_val=101325,         charge_vals=np.arange(1, 10),         radius_vals=3e-9,)[0], 0)  # [0] returns negative, [1] returns positive ions plt.semilogy(range(1,10),  np.array(ret*1e6).squeeze(), label=\"lf2013\"); plt.ylim([1e-7, 1e-4]); plt.ylabel(\"Attachment coefficient, cc/s\"); plt.legend(); plt.xlabel(\"# charges\");"},{"location":"old-examples/distributions/notebooks/ionparticle_coagulation/#ionparticle-coagulation","title":"Ion\u2013particle coagulation\u00b6","text":"<p>The problem here: positive particles (1 to 9 charges) of radius 3 nm colliding with a negative ion of radius 0.45 nm.</p> <p>Several coagulation approximations:</p> <ul> <li>hard shpere</li> <li>gh2012: https://journals.aps.org/pre/abstract/10.1103/PhysRevE.85.026410</li> <li>gk2008: https://journals.aps.org/pre/abstract/10.1103/PhysRevE.78.046402</li> <li>dy2007: https://aip.scitation.org/doi/10.1063/1.2713719</li> <li>cg2019: https://www.tandfonline.com/doi/suppl/10.1080/02786826.2019.1614522</li> <li>lf2013: https://www.tandfonline.com/doi/full/10.1080/02786826.2013.783684</li> </ul>"},{"location":"old-examples/tour-%28old%29/","title":"Particula Tour","text":"<p>This is a tour of the <code>particula</code> library. The tour is designed to give you a brief overview of the library and its capabilities.</p>"},{"location":"old-examples/tour-%28old%29/#notebooks","title":"Notebooks","text":""},{"location":"old-examples/tour-%28old%29/part-tour/","title":"Particula tour","text":"In\u00a0[1]: Copied! <pre>try:\n    import particula, matplotlib\nexcept ImportError:\n    print(\"Setting up computational environment...\")\n    %pip install -U particula -qqq\n    %pip install matplotlib -qqq\n\nfrom particula.particle import Particle\nfrom particula.rates import Rates\nfrom matplotlib import pyplot as plt\nimport numpy as np\n</pre> try:     import particula, matplotlib except ImportError:     print(\"Setting up computational environment...\")     %pip install -U particula -qqq     %pip install matplotlib -qqq  from particula.particle import Particle from particula.rates import Rates from matplotlib import pyplot as plt import numpy as np In\u00a0[2]: Copied! <pre>deets = {\n    \"mode\": [10e-9, 70e-9],\n    \"gsigma\": [1.6, 2.0],\n    \"nbins\": 4000,\n    \"particle_number\": [17/20, 3/20],\n}\npart_dist = Particle(**deets)\nr = Rates(particle=part_dist, lazy=False)\n</pre> deets = {     \"mode\": [10e-9, 70e-9],     \"gsigma\": [1.6, 2.0],     \"nbins\": 4000,     \"particle_number\": [17/20, 3/20], } part_dist = Particle(**deets) r = Rates(particle=part_dist, lazy=False) <p>We define a simple plot utility to plot some of the properties of this distribution.</p> In\u00a0[3]: Copied! <pre>def plot_some(x, y, grid=\"semilogx\", title=None, label=None):\n    \"\"\" plot y vs x with grid, providing title and label \"\"\"\n    if grid == \"loglog\":\n        plt.loglog(x.m, y.m, label=label)\n    else:\n        plt.semilogx(x.m, y.m, label=label);\n    if label is not None:\n        plt.legend()\n    plt.title(title)\n    plt.xlabel(f\"{x.u}\"); plt.ylabel(f\"{y.u}\");\n</pre> def plot_some(x, y, grid=\"semilogx\", title=None, label=None):     \"\"\" plot y vs x with grid, providing title and label \"\"\"     if grid == \"loglog\":         plt.loglog(x.m, y.m, label=label)     else:         plt.semilogx(x.m, y.m, label=label);     if label is not None:         plt.legend()     plt.title(title)     plt.xlabel(f\"{x.u}\"); plt.ylabel(f\"{y.u}\"); In\u00a0[4]: Copied! <pre>plot_some(\n    x=part_dist.particle_radius,\n    y=part_dist.particle_distribution(),\n    title=\"Particle distribution density\",\n)\n</pre> plot_some(     x=part_dist.particle_radius,     y=part_dist.particle_distribution(),     title=\"Particle distribution density\", ) In\u00a0[5]: Copied! <pre>plot_some(\n    x=part_dist.particle_radius,\n    y=part_dist.coagulation(),\n    title=\"Particle coagulation kernel\",\n    grid=\"loglog\"\n)\n</pre> plot_some(     x=part_dist.particle_radius,     y=part_dist.coagulation(),     title=\"Particle coagulation kernel\",     grid=\"loglog\" ) In\u00a0[6]: Copied! <pre>plot_some(\n    x=part_dist.particle_radius,\n    y=-r.coagulation_loss(),\n    title=\"Particle coagulation loss rate\",\n)\n</pre> plot_some(     x=part_dist.particle_radius,     y=-r.coagulation_loss(),     title=\"Particle coagulation loss rate\", ) In\u00a0[7]: Copied! <pre>plot_some(\n    x=part_dist.particle_radius,\n    y=r.coagulation_gain(),\n    title=\"Particle coagulation gain rate\",\n)\n</pre> plot_some(     x=part_dist.particle_radius,     y=r.coagulation_gain(),     title=\"Particle coagulation gain rate\", ) In\u00a0[8]: Copied! <pre>plot_some(\n    x=part_dist.particle_radius,\n    y=r.coagulation_rate(),\n    title=\"Particle coagulation net rate\",\n)\n</pre> plot_some(     x=part_dist.particle_radius,     y=r.coagulation_rate(),     title=\"Particle coagulation net rate\", ) In\u00a0[9]: Copied! <pre>plot_some(\n    x=part_dist.particle_radius,\n    y=r.condensation_growth_speed(),\n    title=\"Particle condensation growth speed\",\n)\n</pre> plot_some(     x=part_dist.particle_radius,     y=r.condensation_growth_speed(),     title=\"Particle condensation growth speed\", ) In\u00a0[10]: Copied! <pre>plot_some(\n    x=part_dist.particle_radius,\n    y=r.condensation_growth_rate(),\n    title=\"Particle condensation growth rate\",\n)\n</pre> plot_some(     x=part_dist.particle_radius,     y=r.condensation_growth_rate(),     title=\"Particle condensation growth rate\", ) In\u00a0[11]: Copied! <pre>plot_some(\n    x=part_dist.particle_radius,\n    y=r.condensation_growth_rate()*part_dist.particle_radius**3,\n    title=\"Particle condensation growth rate (volume)\",\n)\n</pre> plot_some(     x=part_dist.particle_radius,     y=r.condensation_growth_rate()*part_dist.particle_radius**3,     title=\"Particle condensation growth rate (volume)\", ) In\u00a0[12]: Copied! <pre>plot_some(\n    x=part_dist.particle_radius,\n    y=r.coagulation_rate()*part_dist.particle_radius**3,\n    title=\"Particle coagulation net rate (volume)\",\n    label=f\"Integral: {np.trapz(r.coagulation_rate()*part_dist.particle_radius**3, part_dist.particle_radius)}\"\n)\n</pre> plot_some(     x=part_dist.particle_radius,     y=r.coagulation_rate()*part_dist.particle_radius**3,     title=\"Particle coagulation net rate (volume)\",     label=f\"Integral: {np.trapz(r.coagulation_rate()*part_dist.particle_radius**3, part_dist.particle_radius)}\" ) In\u00a0[13]: Copied! <pre>from particula.dynamics import Solver\ndeets = {\n    \"mode\": [10e-9, 70e-9],\n    \"gsigma\": [1.6, 2.0],\n    \"nbins\": 2000,\n    \"particle_number\": [17/20, 3/20],\n}\npart_dist = Particle(**deets)\nr = Rates(particle=part_dist, lazy=True)\ntime_span = [0, 60]\ns = Solver(particle=part_dist, time_span=time_span)\nsols = s.solution()\nplt.semilogx(part_dist.particle_radius.m, sols[0].m, label=f\"Initial at {time_span[0]} seconds\")\nplt.semilogx(part_dist.particle_radius.m, sols[-1].m, label=f\"Final after {time_span[-1]} seconds\")\nplt.xlabel(f\"{part_dist.particle_radius.u}\")\nplt.ylabel(f\"{sols[0].u}\")\nplt.title(\"The evolution of the size distribution\")\nplt.legend();\n</pre> from particula.dynamics import Solver deets = {     \"mode\": [10e-9, 70e-9],     \"gsigma\": [1.6, 2.0],     \"nbins\": 2000,     \"particle_number\": [17/20, 3/20], } part_dist = Particle(**deets) r = Rates(particle=part_dist, lazy=True) time_span = [0, 60] s = Solver(particle=part_dist, time_span=time_span) sols = s.solution() plt.semilogx(part_dist.particle_radius.m, sols[0].m, label=f\"Initial at {time_span[0]} seconds\") plt.semilogx(part_dist.particle_radius.m, sols[-1].m, label=f\"Final after {time_span[-1]} seconds\") plt.xlabel(f\"{part_dist.particle_radius.u}\") plt.ylabel(f\"{sols[0].u}\") plt.title(\"The evolution of the size distribution\") plt.legend(); In\u00a0[14]: Copied! <pre>plt.semilogx(\n    part_dist.particle_radius.m,\n    sols[0].m*part_dist.particle_radius.m**3,\n    label=f\"Initial at {time_span[0]} seconds\"\n)\nplt.semilogx(\n    part_dist.particle_radius.m,\n    sols[-1].m*part_dist.particle_radius.m**3,\n    label=f\"Final after {time_span[-1]} seconds\"\n)\nplt.legend()\nplt.xlabel(f\"{part_dist.particle_radius.u}\")\nplt.ylabel(f\"{sols[0].u*part_dist.particle_radius.u**3}\")\nplt.title(\"The evolution of the size distribution (volume)\")\nplt.xlim([1e-7, 5e-7]); plt.ylim([35e-5, 37e-5]);\n</pre> plt.semilogx(     part_dist.particle_radius.m,     sols[0].m*part_dist.particle_radius.m**3,     label=f\"Initial at {time_span[0]} seconds\" ) plt.semilogx(     part_dist.particle_radius.m,     sols[-1].m*part_dist.particle_radius.m**3,     label=f\"Final after {time_span[-1]} seconds\" ) plt.legend() plt.xlabel(f\"{part_dist.particle_radius.u}\") plt.ylabel(f\"{sols[0].u*part_dist.particle_radius.u**3}\") plt.title(\"The evolution of the size distribution (volume)\") plt.xlim([1e-7, 5e-7]); plt.ylim([35e-5, 37e-5]);"},{"location":"old-examples/tour-%28old%29/part-tour/#particula-tour","title":"Particula tour\u00b6","text":"<p>We have designed <code>particula</code> around object-oriented programming principles where physics entities inherit from each other.</p> <ol> <li>It all starts with an <code>Environment</code> object (class) where temperature, pressure, and other derived properties are defined. For now, the two main derived properties are the dynamic viscosity and mean free path.</li> <li>Then, the <code>Vapor</code> object inherits from <code>Environment</code> and adds its own properties, mainly vapor properties like radius and density, but also derived properties like the driving force of condensation.</li> <li>The most involved object <code>Particle</code> builds on <code>Vapor</code> (and thus <code>Environment</code>). It is split into steps to isolate different components (e.g. making a distribution, making particle instances, calculating condensation, and calculating coagulation are all split into different objects that build on each other). In <code>Particle</code>, the idea is to form a fully equipped particle distribution, whose properties are readily available and calculated.</li> <li>Up to <code>Particle</code>, there is no sense of a time dimension. To add one, we create the <code>Rates</code> object who takes as input the <code>Particle</code> object, thus explicitly allowing dynamics-specific calculations, or \"rates\".</li> <li>Finally, a dynamic <code>Solver</code> object builds on <code>Rates</code> and propagates the <code>Particle</code> object in time.</li> </ol>"},{"location":"old-examples/tour-%28old%29/part-tour/#setup","title":"Setup\u00b6","text":"<p>Let's first get the needed packages and set up our computational environment.</p>"},{"location":"old-examples/tour-%28old%29/part-tour/#defining-a-distribution","title":"Defining a distribution\u00b6","text":"<p>Defining a distribution in <code>particula</code> is easy! Simply import the <code>Particle</code> class and pass some keyword arguments to it. Here we interested in a bimodal particle distribution, with different modes and different geometric standard deviations (<code>gsigma</code>) and different amplitude (<code>particle_number</code>). While at it, we might as well calculate rates and disabling the <code>lazy</code> execution so that we do not recalculate the rates at every call.</p>"},{"location":"old-examples/tour-%28old%29/part-tour/#particle-number-concentration-density","title":"Particle number concentration density\u00b6","text":"<p>One way to think about this is to integrate the curve, that yields exactly 1e5 /cc which is the total number concentration. Try it! (Copy the code block below and execute it after or before the next cell.)</p> <pre>np.trapz(part_dist.particle_distribution(), part_dist.particle_radius)\n</pre>"},{"location":"old-examples/tour-%28old%29/part-tour/#the-coagulation-kernel","title":"The coagulation kernel\u00b6","text":""},{"location":"old-examples/tour-%28old%29/part-tour/#the-coagulation-loss-rate","title":"The coagulation loss rate\u00b6","text":""},{"location":"old-examples/tour-%28old%29/part-tour/#the-coagulation-gain-rate","title":"The coagulation gain rate\u00b6","text":""},{"location":"old-examples/tour-%28old%29/part-tour/#the-coagulation-net-rate","title":"The coagulation net rate\u00b6","text":""},{"location":"old-examples/tour-%28old%29/part-tour/#the-condensation-growth-speed","title":"The condensation growth speed\u00b6","text":""},{"location":"old-examples/tour-%28old%29/part-tour/#the-condensation-growth-rate","title":"The condensation growth rate\u00b6","text":""},{"location":"old-examples/tour-%28old%29/part-tour/#the-condensation-growth-rate-volume-wise","title":"The condensation growth rate (volume-wise)\u00b6","text":""},{"location":"old-examples/tour-%28old%29/part-tour/#the-coagulation-net-rate-volume-wise","title":"The coagulation net rate (volume-wise)\u00b6","text":"<p>Note the integration yields a small number, meaning the mass is conserved!</p>"},{"location":"old-examples/tour-%28old%29/part-tour/#a-solver","title":"A solver\u00b6","text":"<p>If you are adventurous, you can even propagate the define distribution in time! We use a rather simple solver here, but it still takes time as it has to recalculate all the rates at every time step. We reduce the <code>nbins</code> to make it slightly faster, but it may not even run on a super tiny (free) machine.</p>"},{"location":"old-examples/tour-%28old%29/Documentation/particle/","title":"The Classes","text":"<p>The <code>ParticleDistribution</code> inherits from the <code>Vapor</code> class, with the following added attributes and methods:</p> In\u00a0[4]: Copied! <pre>from particula.particle import ParticleDistribution\nPDcutoff1 = ParticleDistribution()\nPDcutoff2 = ParticleDistribution(\n    cutoff=.99,\n)\n\nprint(\"Starting radius from 99.99% cutoff is \", PDcutoff1.pre_radius().min())\nprint(\"Starting radius from 99% cutoff is \", PDcutoff2.pre_radius().min())\n</pre> from particula.particle import ParticleDistribution PDcutoff1 = ParticleDistribution() PDcutoff2 = ParticleDistribution(     cutoff=.99, )  print(\"Starting radius from 99.99% cutoff is \", PDcutoff1.pre_radius().min()) print(\"Starting radius from 99% cutoff is \", PDcutoff2.pre_radius().min()) <pre>resulting radius from 99.99% cutoff is  4.1972292396604054e-08 meter\nresulting radius from 99% cutoff is  5.628288472608393e-08 meter\n</pre> In\u00a0[6]: Copied! <pre>from particula.particle import ParticleDistribution\nPDspacing1 = ParticleDistribution()\nPDspacing2 = ParticleDistribution(\n    spacing=\"logspace\",\n)\n\nprint(\"First few radii from linspace spacing are \", PDspacing1.pre_radius()[:6])\nprint(\"First few radii from logspace spacing are \", PDspacing2.pre_radius()[:6])\n</pre> from particula.particle import ParticleDistribution PDspacing1 = ParticleDistribution() PDspacing2 = ParticleDistribution(     spacing=\"logspace\", )  print(\"First few radii from linspace spacing are \", PDspacing1.pre_radius()[:6]) print(\"First few radii from logspace spacing are \", PDspacing2.pre_radius()[:6]) <pre>First few radii from linspace spacing are  [4.1972292396604054e-08 4.216876899517281e-08 4.236524559374157e-08 4.256172219231033e-08 4.275819879087909e-08 4.295467538944785e-08] meter\nFirst few radii from logspace spacing are  [4.1972292396604034e-08 4.204530615154216e-08 4.211844691904267e-08 4.2191714920053024e-08 4.2265110375904696e-08 4.2338633508314515e-08] meter\n</pre> In\u00a0[10]: Copied! <pre>print(\"The units of the distribution (density units): \", PDspacing1.pre_distribution().u)\n</pre> print(\"The units of the distribution (density units): \", PDspacing1.pre_distribution().u) <pre>The units of the distribution (density units):  1 / meter ** 4\n</pre> <p>The <code>ParticleInstances</code> inherits from the <code>ParticleDistribution</code> class, with the following added attributes and methods:</p> In\u00a0[16]: Copied! <pre>from particula.particle import ParticleInstances\nPD_dist = ParticleInstances()\nPD_disc = ParticleInstances(\n    particle_radius=[1e-9, 2e-9],\n    particle_number=[1, 2]\n)\n\nprint(\"The units of the 'continuous' distribution (density units): \", PD_dist.particle_distribution().u)\nprint(\"The units of the 'discrete' distribution (density units): \", PD_disc.particle_distribution().u)\nprint(\"First few points of continuous: \", PD_dist.particle_distribution()[:2])\nprint(\"First few points of discrete: \", PD_disc.particle_distribution()[:2])\n</pre> from particula.particle import ParticleInstances PD_dist = ParticleInstances() PD_disc = ParticleInstances(     particle_radius=[1e-9, 2e-9],     particle_number=[1, 2] )  print(\"The units of the 'continuous' distribution (density units): \", PD_dist.particle_distribution().u) print(\"The units of the 'discrete' distribution (density units): \", PD_disc.particle_distribution().u) print(\"First few points of continuous: \", PD_dist.particle_distribution()[:2]) print(\"First few points of discrete: \", PD_disc.particle_distribution()[:2]) <pre>The units of the 'continuous' distribution (density units):  1 / meter ** 4\nThe units of the 'discrete' distribution (density units):  1 / meter ** 4\nFirst few points of continuous:  [2200235960693703.8 2375247794883328.5] / meter ** 4\nFirst few points of discrete:  [999999999999999.9 999999999999999.9] / meter ** 4\n</pre> In\u00a0[18]: Copied! <pre>print(\"Particle mass: \", PD_disc.particle_mass())\nprint(\"Friction factor: \", PD_disc.friction_factor())\n</pre> print(\"Particle mass: \", PD_disc.particle_mass()) print(\"Friction factor: \", PD_disc.friction_factor()) <pre>Particle mass:  [4.188790204786392e-24 3.3510321638291136e-23] kilogram\nFriction factor:  [3.127639189424173e-15 1.2446393807134826e-14] kilogram / second\n</pre> <p>The <code>Particle</code> inherits from the <code>ParticleInstances</code> class, with the following added attributes and methods:</p> In\u00a0[22]: Copied! <pre>from particula.particle import Particle\n\ntwo_particles = Particle(\n    particle_radius=[1e-9, 2e-9],\n    particle_number=[1, 1]\n)\n\nanother_particle = Particle(particle_radius=1e-8)\n</pre> from particula.particle import Particle  two_particles = Particle(     particle_radius=[1e-9, 2e-9],     particle_number=[1, 1] )  another_particle = Particle(particle_radius=1e-8) In\u00a0[24]: Copied! <pre>two_particles.coagulation()\n</pre> two_particles.coagulation() Out[24]: Magnitude<pre>[[8.835482748391875e-16 1.4836836108384949e-15] [1.4836836108384949e-15 1.235668665276733e-15]]</pre>Unitsmeter<sup>3</sup>/second In\u00a0[25]: Copied! <pre>another_particle.coagulation()\n</pre> another_particle.coagulation() Out[25]: Magnitude<pre>[[2.3065250186958553e-15]]</pre>Unitsmeter<sup>3</sup>/second In\u00a0[27]: Copied! <pre>another_particle.coagulation(another_particle)\n</pre> another_particle.coagulation(another_particle) Out[27]: Magnitude<pre>[[2.3065250186958553e-15]]</pre>Unitsmeter<sup>3</sup>/second In\u00a0[26]: Copied! <pre>two_particles.coagulation(another_particle)\n</pre> two_particles.coagulation(another_particle) Out[26]: Magnitude<pre>[[1.8143554043998508e-14] [7.479664416578196e-15]]</pre>Unitsmeter<sup>3</sup>/second"},{"location":"old-examples/tour-%28old%29/Documentation/particle/#the-particle-classes","title":"The <code>Particle</code> Classes\u00b6","text":"<p>The <code>Particle</code> class is the base class for all particles, whether introduced discretely one by one or as a distribution. In reality, the <code>Particle</code> class is based on two intermediate classes: <code>ParticleDistribution</code> and <code>ParticleInstances</code> to instantiate particle distributions and particles directly, respectively.</p>"},{"location":"old-examples/tour-%28old%29/Documentation/particle/#particledistribution-attributes","title":"<code>ParticleDistribution</code> attributes\u00b6","text":"<p>| attribute    | unit        | default value | ---------    | ----        | ------------- | <code>spacing</code>    |             | <code>\"linspace\"</code> | <code>nbins</code>      |             | <code>1e3</code> | <code>nparticles</code> |             | <code>1e5</code> | <code>volume</code>     | / m^3       | <code>1e-6</code> | <code>cutoff</code>     |             | <code>0.9999</code> | <code>gsigma</code>     |             | <code>1.25</code> | <code>mode</code>       | m           | <code>1e-7</code> | <code>disttype</code>   |             | <code>\"lognormal\"</code></p>"},{"location":"old-examples/tour-%28old%29/Documentation/particle/#particledistribution-methods","title":"<code>ParticleDistribution</code> methods\u00b6","text":""},{"location":"old-examples/tour-%28old%29/Documentation/particle/#particledistributionpre_radius","title":"<code>ParticleDistribution.pre_radius()</code>\u00b6","text":"<p>The <code>pre_radius</code> method uses the attributes <code>cutoff</code>, <code>gsigma</code>, and <code>mode</code> to determine the starting and ending radii according to the utility <code>cutoff_radius.cut_rad</code>. Here, <code>cutoff</code> refers to the fraction cutoff of the distribution (e.g. <code>cutoff=0.9999</code> means taking only 99.99% of the lognormal distribution). Moreover, <code>gsigma</code> and <code>mode</code> are the lognormal parameters of the distribution, referring to the geometric standard deviation and mode (geometric mean) respectively. We use the <code>scipy.stats.lognorm</code> to construct the distribution in the <code>pre_discretize</code> method below.</p> <ul> <li><code>particula.util.cutoff_radius</code></li> </ul> <p>Then, the <code>spacing</code> is used to create a vector of radii with <code>nbins</code> entries. The <code>spacing</code> attribute is a <code>string</code> type and for now, it can only be <code>\"linspace\"</code> or <code>\"logspace\"</code>: using the <code>numpy.linspace</code> or <code>numpy.logspace</code> functions, respectively, to construct the vector.</p> <p>Finally, the <code>pre_radius</code> method returns a radius vector with units of meter.</p>"},{"location":"old-examples/tour-%28old%29/Documentation/particle/#particledistributionpre_discretize","title":"<code>ParticleDistribution.pre_discretize()</code>\u00b6","text":"<p>The <code>pre_discretize</code> method uses the result of the <code>pre_radius()</code> method above, <code>disttype</code>, <code>gsigma</code>, and <code>mode</code> attributes to produce a probability density function distribution based on the <code>scipy.stats.lognorm</code> (lognormal) function. This is done via the <code>distribution_discretization</code> utility.</p> <ul> <li><code>particula.util.distribution_discretization</code></li> </ul>"},{"location":"old-examples/tour-%28old%29/Documentation/particle/#particledistributionpre_distribution","title":"<code>ParticleDistribution.pre_distribution()</code>\u00b6","text":"<p>The <code>pre_distribution</code> method simply constructs the distribution multiplying the product of <code>pre_discretize()</code> by <code>nparticles</code> and dividing by <code>volume</code>.</p>"},{"location":"old-examples/tour-%28old%29/Documentation/particle/#particleinstances-attributes","title":"<code>ParticleInstances</code> attributes\u00b6","text":"<p>| attribute         | unit        | default value | ---------         | ----        | ------------- | <code>particle_radius</code> | m           | <code>None</code> or <code>ParticleDistribution.pre_radius()</code> | <code>particle_number</code> |             | <code>1</code> or <code>ParticleDistribution.nparticles</code> | <code>particle_density</code>| kg / m^3    | <code>1e3</code> | <code>shape_factor</code>    |             | <code>1</code> | <code>volume_void</code>     |             | <code>0</code> | <code>particle_charge</code> |             | <code>0</code></p> <p>We note that the <code>particle_radius</code> attribute defaults to <code>ParticleDistribution.pre_radius()</code> if it is not given explicitly. Therefore, one could either provide a one or more radii via <code>particle_radius</code> or provide the parameters for a distribution as described above. The <code>particle_number</code> attribute defaults to <code>ParticleDistribution.nparticles</code> if the <code>particle_radius</code> attribute is not given explicitly; otherwise, it is set to <code>1</code> by default, but the user could provide a different value, for example, <code>particle_radius=[1e-9, 2e-9]</code> coupled with <code>particle_number=[1, 2]</code> would mean one particle of radius 1e-9 and two particles of radius 2e-9.</p> <p>In any event, the attributes here have higher precedence than the attributes in <code>ParticleDistribution</code>. Below, we reaffirm the <code>particle_distribution</code> as well.</p>"},{"location":"old-examples/tour-%28old%29/Documentation/particle/#particleinstances-methods","title":"<code>ParticleInstances</code> methods\u00b6","text":""},{"location":"old-examples/tour-%28old%29/Documentation/particle/#particleinstancesparticle_distribution","title":"<code>ParticleInstances.particle_distribution()</code>\u00b6","text":"<p>The <code>particle_distribution</code> method either returns the <code>ParticleDistribution.pre_distribution()</code> if the <code>particle_radius</code> attribute is not given explicitly, or it constructs the distribution dividing <code>particle_number</code> by <code>particle_radius</code> and dividing by <code>volume</code>.</p> <p>Note: the idea of distribution density necessitates normalizing by the variable (in our case, it is the radius) and here we divide by radius to get the unit of 1 / m^3 / m (i.e. number concentration density).</p>"},{"location":"old-examples/tour-%28old%29/Documentation/particle/#particleinstancesparticle_mass","title":"<code>ParticleInstances.particle_mass()</code>\u00b6","text":"<p>The <code>particle_mass</code> method returns the mass of the particle by using the <code>particle_radius</code>, <code>particle_density</code>, <code>shape_factor</code>, and <code>volume_void</code> attributes.</p> <ul> <li><code>particula.util.particle_mass</code></li> </ul>"},{"location":"old-examples/tour-%28old%29/Documentation/particle/#particleinstancesknudsen_number","title":"<code>ParticleInstances.knudsen_number()</code>\u00b6","text":"<p>The <code>knudsen_number</code> method returns the knudsen number of the particle by using the <code>particle_radius</code> attribute as well as the <code>mean_free_path()</code> method.</p> <ul> <li><code>knudsen_number</code></li> </ul>"},{"location":"old-examples/tour-%28old%29/Documentation/particle/#particleinstancesslip_correction_factor","title":"<code>ParticleInstances.slip_correction_factor()</code>\u00b6","text":"<p>The <code>slip_correction_factor</code> method returns the slip correction factor of the particle by using the <code>particle_radius</code> attribute as well as the <code>knudsen_number()</code> method.</p> <ul> <li><code>particula.util.slip_correction</code></li> </ul>"},{"location":"old-examples/tour-%28old%29/Documentation/particle/#particleinstancesfriction_factor","title":"<code>ParticleInstances.friction_factor()</code>\u00b6","text":"<p>The <code>friction_factor</code> method returns the friction factor of the particle by using the <code>particle_radius</code> attribute as well as the <code>dynamic_viscosity()</code> and <code>slip_correction_factor()</code> methods.</p> <ul> <li><code>particula.util.friction_factor</code></li> </ul>"},{"location":"old-examples/tour-%28old%29/Documentation/particle/#the-particle-attributes","title":"The <code>Particle</code> attributes\u00b6","text":"<p>| attribute                   | unit               | default value | ---------                   | ----               | ------------- | <code>elementary_charge_value</code>   | C                  | <code>constants.ELEMENTARY_CHARGE_VALUE</code> | <code>electric_permittivity</code>     | F / m              | <code>constants.ELECTRIC_PERMITTIVITY</code> | <code>boltzmann_constant</code>        | kg * m^2 / K / s^2 | <code>constants.BOLTZMANN_CONSTANT</code> | <code>coagulation_approximation</code> |                    | <code>\"hardsphere\"</code></p>"},{"location":"old-examples/tour-%28old%29/Documentation/particle/#the-particle-methods","title":"The <code>Particle</code> methods\u00b6","text":"<p>The following methods are available for the <code>Particle</code> class:</p> <ul> <li><code>Particle._coag_prep()</code></li> <li><code>Particle.reduced_mass()</code></li> <li><code>Particle.reduced_friction_factor()</code></li> <li><code>Particle.coulomb_potential_ratio()</code></li> <li><code>Particle.coulomb_enhancement_kinetic_limit()</code></li> <li><code>Particle.coulomb_enhancement_continuum_limit()</code></li> <li><code>Particle.diffusive_knudsen_number()</code></li> <li><code>Particle.dimensionless_coagulation()</code></li> <li><code>Particle.coagulation()</code></li> </ul> <p>They all rely on one underlying utility: the class <code>DimensionlessCoagulation</code> from <code>dimensionless_coagulation</code>, which is documented in the <code>particula.util.dimensionless_coagulation</code> notebook.</p> <p>All these added methods rely on previously defined attributes and methods to construct particle--particle interaction (e.g. coagulation). Thus, each method takes an input argument <code>particle</code> which is an instance of the <code>Particle</code> class. If not explicitly provided, the <code>particle</code> argument defaults to <code>self</code> (itself).</p>"},{"location":"old-examples/tour-%28old%29/Documentation/vapor/","title":"The Class","text":"<p>The <code>Vapor</code> class links the <code>Environment</code> class with the <code>Particle</code> class by defining condensing vapor that are precursors to particles. The <code>Vapor</code> class is defined in <code>particula/vapor.py</code>. It inherits everything from the <code>Environment</code> class, including attributes and methods. It can be imported as,</p> In\u00a0[1]: Copied! <pre>from particula.vapor import Vapor\n</pre> from particula.vapor import Vapor <p>and then it can be initiated with (some of) the <code>Environment</code> attributes as well as the following additional attributes:</p> In\u00a0[3]: Copied! <pre>from particula import u\nfrom particula.vapor import Vapor\n\nVapOne = Vapor(temperature=300) \nprint(\"temperature is \", VapOne.temperature) # will print 300 K\nprint(\"pressure is \", VapOne.pressure) # will print 101325 Pa (kg/m/s^2)\nprint(\"vapor radius is \", VapOne.vapor_radius)  # will print 1.6 nm\n</pre> from particula import u from particula.vapor import Vapor  VapOne = Vapor(temperature=300)  print(\"temperature is \", VapOne.temperature) # will print 300 K print(\"pressure is \", VapOne.pressure) # will print 101325 Pa (kg/m/s^2) print(\"vapor radius is \", VapOne.vapor_radius)  # will print 1.6 nm <pre>temperature is  300 kelvin\npressure is  101325 kilogram / meter / second ** 2\nvapor radius is  1.6e-09 meter\n</pre>"},{"location":"old-examples/tour-%28old%29/Documentation/vapor/#the-vapor-class","title":"The <code>Vapor</code> Class\u00b6","text":""},{"location":"old-examples/tour-%28old%29/Documentation/vapor/#vapor-attributes","title":"<code>Vapor</code> attributes\u00b6","text":"<p>| attribute             | unit     | default | ---------             | ----     | ------- | <code>vapor_radius</code>        | m        | <code>1.6e-9</code> | <code>vapor_density</code>       | kg / m^3 | <code>1400</code> | <code>vapor_concentration</code> | kg / m^3 | <code>0.025e-9</code> | <code>vapor_attachment</code>    |          | <code>1</code> | <code>vapor_molec_wt</code>      | kg / mol | <code>0.2</code></p> <p>For example, <code>Vapor(vapor_radius=1e-9)</code> initiates the class with vapor radius of 1 nm with all other default attributes. Additionally, <code>Vapor(vapor_radius=1e-9, temperature=290)</code> will initiate the class with 290 K and 1 nm, in addition to all other attributes. Above, <code>vapor_radius</code> and <code>vapor_density</code> refer to the radius of the condensing vapor and its density, respectively. The <code>vapor_concentration</code> attribute defines the driving force of condensation (defined below). The <code>vapor_attachment</code> coefficient is the sticking coefficient between a vapor and a particle and it is dimensionless; <code>vapor_molec_wt</code> is the molecular weight of the condensing vapor.</p> <p>It is possible to provide multiple vapors with multiple properties.</p>"},{"location":"old-examples/tour-%28old%29/Documentation/vapor/#vapor-methods","title":"<code>Vapor</code> methods\u00b6","text":"<p>We currently only have one method in the <code>Vapor</code> class.</p>"},{"location":"old-examples/tour-%28old%29/Documentation/vapor/#vapordriving_force","title":"<code>Vapor.driving_force()</code>\u00b6","text":"<p>For now, <code>Vapor.driving_force()</code> is equal to <code>Vapor.vapor_concentration</code>. In reality, the relationship is more complicated, but since we likely do not measure the gas concentration directly, we can estimate it as such and correct it later.</p>"}]}